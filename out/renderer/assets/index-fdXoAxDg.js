var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var require_index_001 = __commonJS({
  "assets/index-fdXoAxDg.js"(exports, module) {
    function _mergeNamespaces(n2, m2) {
      for (var i = 0; i < m2.length; i++) {
        const e2 = m2[i];
        if (typeof e2 !== "string" && !Array.isArray(e2)) {
          for (const k2 in e2) {
            if (k2 !== "default" && !(k2 in n2)) {
              const d2 = Object.getOwnPropertyDescriptor(e2, k2);
              if (d2) {
                Object.defineProperty(n2, k2, d2.get ? d2 : {
                  enumerable: true,
                  get: () => e2[k2]
                });
              }
            }
          }
        }
      }
      return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
    }
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs(x2) {
      return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
    }
    var jsxRuntime = { exports: {} };
    var reactJsxRuntime_production_min = {};
    var react = { exports: {} };
    var react_production_min = {};
    /**
     * @license React
     * react.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var l$3 = Symbol.for("react.element"), n$3 = Symbol.for("react.portal"), p$3 = Symbol.for("react.fragment"), q$2 = Symbol.for("react.strict_mode"), r$1 = Symbol.for("react.profiler"), t$2 = Symbol.for("react.provider"), u$1 = Symbol.for("react.context"), v$2 = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z$2 = Symbol.iterator;
    function A$1(a) {
      if (null === a || "object" !== typeof a)
        return null;
      a = z$2 && a[z$2] || a["@@iterator"];
      return "function" === typeof a ? a : null;
    }
    var B$1 = { isMounted: function() {
      return false;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } }, C$1 = Object.assign, D$1 = {};
    function E$1(a, b2, e2) {
      this.props = a;
      this.context = b2;
      this.refs = D$1;
      this.updater = e2 || B$1;
    }
    E$1.prototype.isReactComponent = {};
    E$1.prototype.setState = function(a, b2) {
      if ("object" !== typeof a && "function" !== typeof a && null != a)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, a, b2, "setState");
    };
    E$1.prototype.forceUpdate = function(a) {
      this.updater.enqueueForceUpdate(this, a, "forceUpdate");
    };
    function F() {
    }
    F.prototype = E$1.prototype;
    function G$1(a, b2, e2) {
      this.props = a;
      this.context = b2;
      this.refs = D$1;
      this.updater = e2 || B$1;
    }
    var H$1 = G$1.prototype = new F();
    H$1.constructor = G$1;
    C$1(H$1, E$1.prototype);
    H$1.isPureReactComponent = true;
    var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
    function M$1(a, b2, e2) {
      var d2, c2 = {}, k2 = null, h2 = null;
      if (null != b2)
        for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
          J.call(b2, d2) && !L$1.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
      var g2 = arguments.length - 2;
      if (1 === g2)
        c2.children = e2;
      else if (1 < g2) {
        for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
          f2[m2] = arguments[m2 + 2];
        c2.children = f2;
      }
      if (a && a.defaultProps)
        for (d2 in g2 = a.defaultProps, g2)
          void 0 === c2[d2] && (c2[d2] = g2[d2]);
      return { $$typeof: l$3, type: a, key: k2, ref: h2, props: c2, _owner: K$1.current };
    }
    function N$1(a, b2) {
      return { $$typeof: l$3, type: a.type, key: b2, ref: a.ref, props: a.props, _owner: a._owner };
    }
    function O$1(a) {
      return "object" === typeof a && null !== a && a.$$typeof === l$3;
    }
    function escape(a) {
      var b2 = { "=": "=0", ":": "=2" };
      return "$" + a.replace(/[=:]/g, function(a2) {
        return b2[a2];
      });
    }
    var P$1 = /\/+/g;
    function Q$1(a, b2) {
      return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b2.toString(36);
    }
    function R$1(a, b2, e2, d2, c2) {
      var k2 = typeof a;
      if ("undefined" === k2 || "boolean" === k2)
        a = null;
      var h2 = false;
      if (null === a)
        h2 = true;
      else
        switch (k2) {
          case "string":
          case "number":
            h2 = true;
            break;
          case "object":
            switch (a.$$typeof) {
              case l$3:
              case n$3:
                h2 = true;
            }
        }
      if (h2)
        return h2 = a, c2 = c2(h2), a = "" === d2 ? "." + Q$1(h2, 0) : d2, I$1(c2) ? (e2 = "", null != a && (e2 = a.replace(P$1, "$&/") + "/"), R$1(c2, b2, e2, "", function(a2) {
          return a2;
        })) : null != c2 && (O$1(c2) && (c2 = N$1(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$1, "$&/") + "/") + a)), b2.push(c2)), 1;
      h2 = 0;
      d2 = "" === d2 ? "." : d2 + ":";
      if (I$1(a))
        for (var g2 = 0; g2 < a.length; g2++) {
          k2 = a[g2];
          var f2 = d2 + Q$1(k2, g2);
          h2 += R$1(k2, b2, e2, f2, c2);
        }
      else if (f2 = A$1(a), "function" === typeof f2)
        for (a = f2.call(a), g2 = 0; !(k2 = a.next()).done; )
          k2 = k2.value, f2 = d2 + Q$1(k2, g2++), h2 += R$1(k2, b2, e2, f2, c2);
      else if ("object" === k2)
        throw b2 = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
      return h2;
    }
    function S$1(a, b2, e2) {
      if (null == a)
        return a;
      var d2 = [], c2 = 0;
      R$1(a, d2, "", "", function(a2) {
        return b2.call(e2, a2, c2++);
      });
      return d2;
    }
    function T$1(a) {
      if (-1 === a._status) {
        var b2 = a._result;
        b2 = b2();
        b2.then(function(b3) {
          if (0 === a._status || -1 === a._status)
            a._status = 1, a._result = b3;
        }, function(b3) {
          if (0 === a._status || -1 === a._status)
            a._status = 2, a._result = b3;
        });
        -1 === a._status && (a._status = 0, a._result = b2);
      }
      if (1 === a._status)
        return a._result.default;
      throw a._result;
    }
    var U$1 = { current: null }, V$1 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
    react_production_min.Children = { map: S$1, forEach: function(a, b2, e2) {
      S$1(a, function() {
        b2.apply(this, arguments);
      }, e2);
    }, count: function(a) {
      var b2 = 0;
      S$1(a, function() {
        b2++;
      });
      return b2;
    }, toArray: function(a) {
      return S$1(a, function(a2) {
        return a2;
      }) || [];
    }, only: function(a) {
      if (!O$1(a))
        throw Error("React.Children.only expected to receive a single React element child.");
      return a;
    } };
    react_production_min.Component = E$1;
    react_production_min.Fragment = p$3;
    react_production_min.Profiler = r$1;
    react_production_min.PureComponent = G$1;
    react_production_min.StrictMode = q$2;
    react_production_min.Suspense = w;
    react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
    react_production_min.cloneElement = function(a, b2, e2) {
      if (null === a || void 0 === a)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
      var d2 = C$1({}, a.props), c2 = a.key, k2 = a.ref, h2 = a._owner;
      if (null != b2) {
        void 0 !== b2.ref && (k2 = b2.ref, h2 = K$1.current);
        void 0 !== b2.key && (c2 = "" + b2.key);
        if (a.type && a.type.defaultProps)
          var g2 = a.type.defaultProps;
        for (f2 in b2)
          J.call(b2, f2) && !L$1.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
      }
      var f2 = arguments.length - 2;
      if (1 === f2)
        d2.children = e2;
      else if (1 < f2) {
        g2 = Array(f2);
        for (var m2 = 0; m2 < f2; m2++)
          g2[m2] = arguments[m2 + 2];
        d2.children = g2;
      }
      return { $$typeof: l$3, type: a.type, key: c2, ref: k2, props: d2, _owner: h2 };
    };
    react_production_min.createContext = function(a) {
      a = { $$typeof: u$1, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
      a.Provider = { $$typeof: t$2, _context: a };
      return a.Consumer = a;
    };
    react_production_min.createElement = M$1;
    react_production_min.createFactory = function(a) {
      var b2 = M$1.bind(null, a);
      b2.type = a;
      return b2;
    };
    react_production_min.createRef = function() {
      return { current: null };
    };
    react_production_min.forwardRef = function(a) {
      return { $$typeof: v$2, render: a };
    };
    react_production_min.isValidElement = O$1;
    react_production_min.lazy = function(a) {
      return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T$1 };
    };
    react_production_min.memo = function(a, b2) {
      return { $$typeof: x, type: a, compare: void 0 === b2 ? null : b2 };
    };
    react_production_min.startTransition = function(a) {
      var b2 = V$1.transition;
      V$1.transition = {};
      try {
        a();
      } finally {
        V$1.transition = b2;
      }
    };
    react_production_min.unstable_act = function() {
      throw Error("act(...) is not supported in production builds of React.");
    };
    react_production_min.useCallback = function(a, b2) {
      return U$1.current.useCallback(a, b2);
    };
    react_production_min.useContext = function(a) {
      return U$1.current.useContext(a);
    };
    react_production_min.useDebugValue = function() {
    };
    react_production_min.useDeferredValue = function(a) {
      return U$1.current.useDeferredValue(a);
    };
    react_production_min.useEffect = function(a, b2) {
      return U$1.current.useEffect(a, b2);
    };
    react_production_min.useId = function() {
      return U$1.current.useId();
    };
    react_production_min.useImperativeHandle = function(a, b2, e2) {
      return U$1.current.useImperativeHandle(a, b2, e2);
    };
    react_production_min.useInsertionEffect = function(a, b2) {
      return U$1.current.useInsertionEffect(a, b2);
    };
    react_production_min.useLayoutEffect = function(a, b2) {
      return U$1.current.useLayoutEffect(a, b2);
    };
    react_production_min.useMemo = function(a, b2) {
      return U$1.current.useMemo(a, b2);
    };
    react_production_min.useReducer = function(a, b2, e2) {
      return U$1.current.useReducer(a, b2, e2);
    };
    react_production_min.useRef = function(a) {
      return U$1.current.useRef(a);
    };
    react_production_min.useState = function(a) {
      return U$1.current.useState(a);
    };
    react_production_min.useSyncExternalStore = function(a, b2, e2) {
      return U$1.current.useSyncExternalStore(a, b2, e2);
    };
    react_production_min.useTransition = function() {
      return U$1.current.useTransition();
    };
    react_production_min.version = "18.2.0";
    {
      react.exports = react_production_min;
    }
    var reactExports = react.exports;
    const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
    const React$1 = /* @__PURE__ */ _mergeNamespaces({
      __proto__: null,
      default: React
    }, [reactExports]);
    /**
     * @license React
     * react-jsx-runtime.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var f$1 = reactExports, k$1 = Symbol.for("react.element"), l$2 = Symbol.for("react.fragment"), m$2 = Object.prototype.hasOwnProperty, n$2 = f$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$2 = { key: true, ref: true, __self: true, __source: true };
    function q$1(c2, a, g2) {
      var b2, d2 = {}, e2 = null, h2 = null;
      void 0 !== g2 && (e2 = "" + g2);
      void 0 !== a.key && (e2 = "" + a.key);
      void 0 !== a.ref && (h2 = a.ref);
      for (b2 in a)
        m$2.call(a, b2) && !p$2.hasOwnProperty(b2) && (d2[b2] = a[b2]);
      if (c2 && c2.defaultProps)
        for (b2 in a = c2.defaultProps, a)
          void 0 === d2[b2] && (d2[b2] = a[b2]);
      return { $$typeof: k$1, type: c2, key: e2, ref: h2, props: d2, _owner: n$2.current };
    }
    reactJsxRuntime_production_min.Fragment = l$2;
    reactJsxRuntime_production_min.jsx = q$1;
    reactJsxRuntime_production_min.jsxs = q$1;
    {
      jsxRuntime.exports = reactJsxRuntime_production_min;
    }
    var jsxRuntimeExports = jsxRuntime.exports;
    var client = {};
    var reactDom = { exports: {} };
    var reactDom_production_min = {};
    var scheduler = { exports: {} };
    var scheduler_production_min = {};
    /**
     * @license React
     * scheduler.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    (function(exports2) {
      function f2(a, b2) {
        var c2 = a.length;
        a.push(b2);
        a:
          for (; 0 < c2; ) {
            var d2 = c2 - 1 >>> 1, e2 = a[d2];
            if (0 < g2(e2, b2))
              a[d2] = b2, a[c2] = e2, c2 = d2;
            else
              break a;
          }
      }
      function h2(a) {
        return 0 === a.length ? null : a[0];
      }
      function k2(a) {
        if (0 === a.length)
          return null;
        var b2 = a[0], c2 = a.pop();
        if (c2 !== b2) {
          a[0] = c2;
          a:
            for (var d2 = 0, e2 = a.length, w2 = e2 >>> 1; d2 < w2; ) {
              var m2 = 2 * (d2 + 1) - 1, C2 = a[m2], n2 = m2 + 1, x2 = a[n2];
              if (0 > g2(C2, c2))
                n2 < e2 && 0 > g2(x2, C2) ? (a[d2] = x2, a[n2] = c2, d2 = n2) : (a[d2] = C2, a[m2] = c2, d2 = m2);
              else if (n2 < e2 && 0 > g2(x2, c2))
                a[d2] = x2, a[n2] = c2, d2 = n2;
              else
                break a;
            }
        }
        return b2;
      }
      function g2(a, b2) {
        var c2 = a.sortIndex - b2.sortIndex;
        return 0 !== c2 ? c2 : a.id - b2.id;
      }
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var l2 = performance;
        exports2.unstable_now = function() {
          return l2.now();
        };
      } else {
        var p2 = Date, q2 = p2.now();
        exports2.unstable_now = function() {
          return p2.now() - q2;
        };
      }
      var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
      "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function G2(a) {
        for (var b2 = h2(t2); null !== b2; ) {
          if (null === b2.callback)
            k2(t2);
          else if (b2.startTime <= a)
            k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
          else
            break;
          b2 = h2(t2);
        }
      }
      function H2(a) {
        B2 = false;
        G2(a);
        if (!A2)
          if (null !== h2(r2))
            A2 = true, I2(J2);
          else {
            var b2 = h2(t2);
            null !== b2 && K2(H2, b2.startTime - a);
          }
      }
      function J2(a, b2) {
        A2 = false;
        B2 && (B2 = false, E2(L2), L2 = -1);
        z2 = true;
        var c2 = y2;
        try {
          G2(b2);
          for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a && !M2()); ) {
            var d2 = v2.callback;
            if ("function" === typeof d2) {
              v2.callback = null;
              y2 = v2.priorityLevel;
              var e2 = d2(v2.expirationTime <= b2);
              b2 = exports2.unstable_now();
              "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
              G2(b2);
            } else
              k2(r2);
            v2 = h2(r2);
          }
          if (null !== v2)
            var w2 = true;
          else {
            var m2 = h2(t2);
            null !== m2 && K2(H2, m2.startTime - b2);
            w2 = false;
          }
          return w2;
        } finally {
          v2 = null, y2 = c2, z2 = false;
        }
      }
      var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
      function M2() {
        return exports2.unstable_now() - Q2 < P2 ? false : true;
      }
      function R2() {
        if (null !== O2) {
          var a = exports2.unstable_now();
          Q2 = a;
          var b2 = true;
          try {
            b2 = O2(true, a);
          } finally {
            b2 ? S2() : (N2 = false, O2 = null);
          }
        } else
          N2 = false;
      }
      var S2;
      if ("function" === typeof F2)
        S2 = function() {
          F2(R2);
        };
      else if ("undefined" !== typeof MessageChannel) {
        var T2 = new MessageChannel(), U2 = T2.port2;
        T2.port1.onmessage = R2;
        S2 = function() {
          U2.postMessage(null);
        };
      } else
        S2 = function() {
          D2(R2, 0);
        };
      function I2(a) {
        O2 = a;
        N2 || (N2 = true, S2());
      }
      function K2(a, b2) {
        L2 = D2(function() {
          a(exports2.unstable_now());
        }, b2);
      }
      exports2.unstable_IdlePriority = 5;
      exports2.unstable_ImmediatePriority = 1;
      exports2.unstable_LowPriority = 4;
      exports2.unstable_NormalPriority = 3;
      exports2.unstable_Profiling = null;
      exports2.unstable_UserBlockingPriority = 2;
      exports2.unstable_cancelCallback = function(a) {
        a.callback = null;
      };
      exports2.unstable_continueExecution = function() {
        A2 || z2 || (A2 = true, I2(J2));
      };
      exports2.unstable_forceFrameRate = function(a) {
        0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a ? Math.floor(1e3 / a) : 5;
      };
      exports2.unstable_getCurrentPriorityLevel = function() {
        return y2;
      };
      exports2.unstable_getFirstCallbackNode = function() {
        return h2(r2);
      };
      exports2.unstable_next = function(a) {
        switch (y2) {
          case 1:
          case 2:
          case 3:
            var b2 = 3;
            break;
          default:
            b2 = y2;
        }
        var c2 = y2;
        y2 = b2;
        try {
          return a();
        } finally {
          y2 = c2;
        }
      };
      exports2.unstable_pauseExecution = function() {
      };
      exports2.unstable_requestPaint = function() {
      };
      exports2.unstable_runWithPriority = function(a, b2) {
        switch (a) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            a = 3;
        }
        var c2 = y2;
        y2 = a;
        try {
          return b2();
        } finally {
          y2 = c2;
        }
      };
      exports2.unstable_scheduleCallback = function(a, b2, c2) {
        var d2 = exports2.unstable_now();
        "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
        switch (a) {
          case 1:
            var e2 = -1;
            break;
          case 2:
            e2 = 250;
            break;
          case 5:
            e2 = 1073741823;
            break;
          case 4:
            e2 = 1e4;
            break;
          default:
            e2 = 5e3;
        }
        e2 = c2 + e2;
        a = { id: u2++, callback: b2, priorityLevel: a, startTime: c2, expirationTime: e2, sortIndex: -1 };
        c2 > d2 ? (a.sortIndex = c2, f2(t2, a), null === h2(r2) && a === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a.sortIndex = e2, f2(r2, a), A2 || z2 || (A2 = true, I2(J2)));
        return a;
      };
      exports2.unstable_shouldYield = M2;
      exports2.unstable_wrapCallback = function(a) {
        var b2 = y2;
        return function() {
          var c2 = y2;
          y2 = b2;
          try {
            return a.apply(this, arguments);
          } finally {
            y2 = c2;
          }
        };
      };
    })(scheduler_production_min);
    {
      scheduler.exports = scheduler_production_min;
    }
    var schedulerExports = scheduler.exports;
    /**
     * @license React
     * react-dom.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var aa = reactExports, ca = schedulerExports;
    function p$1(a) {
      for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c2 = 1; c2 < arguments.length; c2++)
        b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
      return "Minified React error #" + a + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var da = /* @__PURE__ */ new Set(), ea = {};
    function fa(a, b2) {
      ha(a, b2);
      ha(a + "Capture", b2);
    }
    function ha(a, b2) {
      ea[a] = b2;
      for (a = 0; a < b2.length; a++)
        da.add(b2[a]);
    }
    var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
    function oa(a) {
      if (ja.call(ma, a))
        return true;
      if (ja.call(la, a))
        return false;
      if (ka.test(a))
        return ma[a] = true;
      la[a] = true;
      return false;
    }
    function pa(a, b2, c2, d2) {
      if (null !== c2 && 0 === c2.type)
        return false;
      switch (typeof b2) {
        case "function":
        case "symbol":
          return true;
        case "boolean":
          if (d2)
            return false;
          if (null !== c2)
            return !c2.acceptsBooleans;
          a = a.toLowerCase().slice(0, 5);
          return "data-" !== a && "aria-" !== a;
        default:
          return false;
      }
    }
    function qa(a, b2, c2, d2) {
      if (null === b2 || "undefined" === typeof b2 || pa(a, b2, c2, d2))
        return true;
      if (d2)
        return false;
      if (null !== c2)
        switch (c2.type) {
          case 3:
            return !b2;
          case 4:
            return false === b2;
          case 5:
            return isNaN(b2);
          case 6:
            return isNaN(b2) || 1 > b2;
        }
      return false;
    }
    function v$1(a, b2, c2, d2, e2, f2, g2) {
      this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
      this.attributeName = d2;
      this.attributeNamespace = e2;
      this.mustUseProperty = c2;
      this.propertyName = a;
      this.type = b2;
      this.sanitizeURL = f2;
      this.removeEmptyString = g2;
    }
    var z$1 = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
      z$1[a] = new v$1(a, 0, false, a, null, false, false);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
      var b2 = a[0];
      z$1[b2] = new v$1(b2, 1, false, a[1], null, false, false);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
      z$1[a] = new v$1(a, 2, false, a.toLowerCase(), null, false, false);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
      z$1[a] = new v$1(a, 2, false, a, null, false, false);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
      z$1[a] = new v$1(a, 3, false, a.toLowerCase(), null, false, false);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a) {
      z$1[a] = new v$1(a, 3, true, a, null, false, false);
    });
    ["capture", "download"].forEach(function(a) {
      z$1[a] = new v$1(a, 4, false, a, null, false, false);
    });
    ["cols", "rows", "size", "span"].forEach(function(a) {
      z$1[a] = new v$1(a, 6, false, a, null, false, false);
    });
    ["rowSpan", "start"].forEach(function(a) {
      z$1[a] = new v$1(a, 5, false, a.toLowerCase(), null, false, false);
    });
    var ra = /[\-:]([a-z])/g;
    function sa(a) {
      return a[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
      var b2 = a.replace(
        ra,
        sa
      );
      z$1[b2] = new v$1(b2, 1, false, a, null, false, false);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
      var b2 = a.replace(ra, sa);
      z$1[b2] = new v$1(b2, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
      var b2 = a.replace(ra, sa);
      z$1[b2] = new v$1(b2, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a) {
      z$1[a] = new v$1(a, 1, false, a.toLowerCase(), null, false, false);
    });
    z$1.xlinkHref = new v$1("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
    ["src", "href", "action", "formAction"].forEach(function(a) {
      z$1[a] = new v$1(a, 1, false, a.toLowerCase(), null, true, true);
    });
    function ta(a, b2, c2, d2) {
      var e2 = z$1.hasOwnProperty(b2) ? z$1[b2] : null;
      if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
        qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a.removeAttribute(b2) : a.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a.setAttributeNS(d2, b2, c2) : a.setAttribute(b2, c2)));
    }
    var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
    var Ia = Symbol.for("react.offscreen");
    var Ja = Symbol.iterator;
    function Ka(a) {
      if (null === a || "object" !== typeof a)
        return null;
      a = Ja && a[Ja] || a["@@iterator"];
      return "function" === typeof a ? a : null;
    }
    var A = Object.assign, La;
    function Ma(a) {
      if (void 0 === La)
        try {
          throw Error();
        } catch (c2) {
          var b2 = c2.stack.trim().match(/\n( *(at )?)/);
          La = b2 && b2[1] || "";
        }
      return "\n" + La + a;
    }
    var Na = false;
    function Oa(a, b2) {
      if (!a || Na)
        return "";
      Na = true;
      var c2 = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (b2)
          if (b2 = function() {
            throw Error();
          }, Object.defineProperty(b2.prototype, "props", { set: function() {
            throw Error();
          } }), "object" === typeof Reflect && Reflect.construct) {
            try {
              Reflect.construct(b2, []);
            } catch (l2) {
              var d2 = l2;
            }
            Reflect.construct(a, [], b2);
          } else {
            try {
              b2.call();
            } catch (l2) {
              d2 = l2;
            }
            a.call(b2.prototype);
          }
        else {
          try {
            throw Error();
          } catch (l2) {
            d2 = l2;
          }
          a();
        }
      } catch (l2) {
        if (l2 && d2 && "string" === typeof l2.stack) {
          for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
            h2--;
          for (; 1 <= g2 && 0 <= h2; g2--, h2--)
            if (e2[g2] !== f2[h2]) {
              if (1 !== g2 || 1 !== h2) {
                do
                  if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                    var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                    a.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a.displayName));
                    return k2;
                  }
                while (1 <= g2 && 0 <= h2);
              }
              break;
            }
        }
      } finally {
        Na = false, Error.prepareStackTrace = c2;
      }
      return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
    }
    function Pa(a) {
      switch (a.tag) {
        case 5:
          return Ma(a.type);
        case 16:
          return Ma("Lazy");
        case 13:
          return Ma("Suspense");
        case 19:
          return Ma("SuspenseList");
        case 0:
        case 2:
        case 15:
          return a = Oa(a.type, false), a;
        case 11:
          return a = Oa(a.type.render, false), a;
        case 1:
          return a = Oa(a.type, true), a;
        default:
          return "";
      }
    }
    function Qa(a) {
      if (null == a)
        return null;
      if ("function" === typeof a)
        return a.displayName || a.name || null;
      if ("string" === typeof a)
        return a;
      switch (a) {
        case ya:
          return "Fragment";
        case wa:
          return "Portal";
        case Aa:
          return "Profiler";
        case za:
          return "StrictMode";
        case Ea:
          return "Suspense";
        case Fa:
          return "SuspenseList";
      }
      if ("object" === typeof a)
        switch (a.$$typeof) {
          case Ca:
            return (a.displayName || "Context") + ".Consumer";
          case Ba:
            return (a._context.displayName || "Context") + ".Provider";
          case Da:
            var b2 = a.render;
            a = a.displayName;
            a || (a = b2.displayName || b2.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
            return a;
          case Ga:
            return b2 = a.displayName || null, null !== b2 ? b2 : Qa(a.type) || "Memo";
          case Ha:
            b2 = a._payload;
            a = a._init;
            try {
              return Qa(a(b2));
            } catch (c2) {
            }
        }
      return null;
    }
    function Ra(a) {
      var b2 = a.type;
      switch (a.tag) {
        case 24:
          return "Cache";
        case 9:
          return (b2.displayName || "Context") + ".Consumer";
        case 10:
          return (b2._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return a = b2.render, a = a.displayName || a.name || "", b2.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return b2;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return Qa(b2);
        case 8:
          return b2 === za ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if ("function" === typeof b2)
            return b2.displayName || b2.name || null;
          if ("string" === typeof b2)
            return b2;
      }
      return null;
    }
    function Sa(a) {
      switch (typeof a) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return a;
        case "object":
          return a;
        default:
          return "";
      }
    }
    function Ta(a) {
      var b2 = a.type;
      return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
    }
    function Ua(a) {
      var b2 = Ta(a) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a.constructor.prototype, b2), d2 = "" + a[b2];
      if (!a.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
        var e2 = c2.get, f2 = c2.set;
        Object.defineProperty(a, b2, { configurable: true, get: function() {
          return e2.call(this);
        }, set: function(a2) {
          d2 = "" + a2;
          f2.call(this, a2);
        } });
        Object.defineProperty(a, b2, { enumerable: c2.enumerable });
        return { getValue: function() {
          return d2;
        }, setValue: function(a2) {
          d2 = "" + a2;
        }, stopTracking: function() {
          a._valueTracker = null;
          delete a[b2];
        } };
      }
    }
    function Va(a) {
      a._valueTracker || (a._valueTracker = Ua(a));
    }
    function Wa(a) {
      if (!a)
        return false;
      var b2 = a._valueTracker;
      if (!b2)
        return true;
      var c2 = b2.getValue();
      var d2 = "";
      a && (d2 = Ta(a) ? a.checked ? "true" : "false" : a.value);
      a = d2;
      return a !== c2 ? (b2.setValue(a), true) : false;
    }
    function Xa(a) {
      a = a || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof a)
        return null;
      try {
        return a.activeElement || a.body;
      } catch (b2) {
        return a.body;
      }
    }
    function Ya(a, b2) {
      var c2 = b2.checked;
      return A({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a._wrapperState.initialChecked });
    }
    function Za(a, b2) {
      var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
      c2 = Sa(null != b2.value ? b2.value : c2);
      a._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
    }
    function ab(a, b2) {
      b2 = b2.checked;
      null != b2 && ta(a, "checked", b2, false);
    }
    function bb(a, b2) {
      ab(a, b2);
      var c2 = Sa(b2.value), d2 = b2.type;
      if (null != c2)
        if ("number" === d2) {
          if (0 === c2 && "" === a.value || a.value != c2)
            a.value = "" + c2;
        } else
          a.value !== "" + c2 && (a.value = "" + c2);
      else if ("submit" === d2 || "reset" === d2) {
        a.removeAttribute("value");
        return;
      }
      b2.hasOwnProperty("value") ? cb(a, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a, b2.type, Sa(b2.defaultValue));
      null == b2.checked && null != b2.defaultChecked && (a.defaultChecked = !!b2.defaultChecked);
    }
    function db(a, b2, c2) {
      if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
        var d2 = b2.type;
        if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
          return;
        b2 = "" + a._wrapperState.initialValue;
        c2 || b2 === a.value || (a.value = b2);
        a.defaultValue = b2;
      }
      c2 = a.name;
      "" !== c2 && (a.name = "");
      a.defaultChecked = !!a._wrapperState.initialChecked;
      "" !== c2 && (a.name = c2);
    }
    function cb(a, b2, c2) {
      if ("number" !== b2 || Xa(a.ownerDocument) !== a)
        null == c2 ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c2 && (a.defaultValue = "" + c2);
    }
    var eb = Array.isArray;
    function fb(a, b2, c2, d2) {
      a = a.options;
      if (b2) {
        b2 = {};
        for (var e2 = 0; e2 < c2.length; e2++)
          b2["$" + c2[e2]] = true;
        for (c2 = 0; c2 < a.length; c2++)
          e2 = b2.hasOwnProperty("$" + a[c2].value), a[c2].selected !== e2 && (a[c2].selected = e2), e2 && d2 && (a[c2].defaultSelected = true);
      } else {
        c2 = "" + Sa(c2);
        b2 = null;
        for (e2 = 0; e2 < a.length; e2++) {
          if (a[e2].value === c2) {
            a[e2].selected = true;
            d2 && (a[e2].defaultSelected = true);
            return;
          }
          null !== b2 || a[e2].disabled || (b2 = a[e2]);
        }
        null !== b2 && (b2.selected = true);
      }
    }
    function gb(a, b2) {
      if (null != b2.dangerouslySetInnerHTML)
        throw Error(p$1(91));
      return A({}, b2, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
    }
    function hb(a, b2) {
      var c2 = b2.value;
      if (null == c2) {
        c2 = b2.children;
        b2 = b2.defaultValue;
        if (null != c2) {
          if (null != b2)
            throw Error(p$1(92));
          if (eb(c2)) {
            if (1 < c2.length)
              throw Error(p$1(93));
            c2 = c2[0];
          }
          b2 = c2;
        }
        null == b2 && (b2 = "");
        c2 = b2;
      }
      a._wrapperState = { initialValue: Sa(c2) };
    }
    function ib(a, b2) {
      var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
      null != c2 && (c2 = "" + c2, c2 !== a.value && (a.value = c2), null == b2.defaultValue && a.defaultValue !== c2 && (a.defaultValue = c2));
      null != d2 && (a.defaultValue = "" + d2);
    }
    function jb(a) {
      var b2 = a.textContent;
      b2 === a._wrapperState.initialValue && "" !== b2 && null !== b2 && (a.value = b2);
    }
    function kb(a) {
      switch (a) {
        case "svg":
          return "http://www.w3.org/2000/svg";
        case "math":
          return "http://www.w3.org/1998/Math/MathML";
        default:
          return "http://www.w3.org/1999/xhtml";
      }
    }
    function lb(a, b2) {
      return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b2) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a;
    }
    var mb, nb = function(a) {
      return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
        MSApp.execUnsafeLocalFunction(function() {
          return a(b2, c2, d2, e2);
        });
      } : a;
    }(function(a, b2) {
      if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a)
        a.innerHTML = b2;
      else {
        mb = mb || document.createElement("div");
        mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
        for (b2 = mb.firstChild; a.firstChild; )
          a.removeChild(a.firstChild);
        for (; b2.firstChild; )
          a.appendChild(b2.firstChild);
      }
    });
    function ob(a, b2) {
      if (b2) {
        var c2 = a.firstChild;
        if (c2 && c2 === a.lastChild && 3 === c2.nodeType) {
          c2.nodeValue = b2;
          return;
        }
      }
      a.textContent = b2;
    }
    var pb = {
      animationIterationCount: true,
      aspectRatio: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    }, qb = ["Webkit", "ms", "Moz", "O"];
    Object.keys(pb).forEach(function(a) {
      qb.forEach(function(b2) {
        b2 = b2 + a.charAt(0).toUpperCase() + a.substring(1);
        pb[b2] = pb[a];
      });
    });
    function rb(a, b2, c2) {
      return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a) && pb[a] ? ("" + b2).trim() : b2 + "px";
    }
    function sb(a, b2) {
      a = a.style;
      for (var c2 in b2)
        if (b2.hasOwnProperty(c2)) {
          var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
          "float" === c2 && (c2 = "cssFloat");
          d2 ? a.setProperty(c2, e2) : a[c2] = e2;
        }
    }
    var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
    function ub(a, b2) {
      if (b2) {
        if (tb[a] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
          throw Error(p$1(137, a));
        if (null != b2.dangerouslySetInnerHTML) {
          if (null != b2.children)
            throw Error(p$1(60));
          if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
            throw Error(p$1(61));
        }
        if (null != b2.style && "object" !== typeof b2.style)
          throw Error(p$1(62));
      }
    }
    function vb(a, b2) {
      if (-1 === a.indexOf("-"))
        return "string" === typeof b2.is;
      switch (a) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    var wb = null;
    function xb(a) {
      a = a.target || a.srcElement || window;
      a.correspondingUseElement && (a = a.correspondingUseElement);
      return 3 === a.nodeType ? a.parentNode : a;
    }
    var yb = null, zb = null, Ab = null;
    function Bb(a) {
      if (a = Cb(a)) {
        if ("function" !== typeof yb)
          throw Error(p$1(280));
        var b2 = a.stateNode;
        b2 && (b2 = Db(b2), yb(a.stateNode, a.type, b2));
      }
    }
    function Eb(a) {
      zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
    }
    function Fb() {
      if (zb) {
        var a = zb, b2 = Ab;
        Ab = zb = null;
        Bb(a);
        if (b2)
          for (a = 0; a < b2.length; a++)
            Bb(b2[a]);
      }
    }
    function Gb(a, b2) {
      return a(b2);
    }
    function Hb() {
    }
    var Ib = false;
    function Jb(a, b2, c2) {
      if (Ib)
        return a(b2, c2);
      Ib = true;
      try {
        return Gb(a, b2, c2);
      } finally {
        if (Ib = false, null !== zb || null !== Ab)
          Hb(), Fb();
      }
    }
    function Kb(a, b2) {
      var c2 = a.stateNode;
      if (null === c2)
        return null;
      var d2 = Db(c2);
      if (null === d2)
        return null;
      c2 = d2[b2];
      a:
        switch (b2) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (d2 = !d2.disabled) || (a = a.type, d2 = !("button" === a || "input" === a || "select" === a || "textarea" === a));
            a = !d2;
            break a;
          default:
            a = false;
        }
      if (a)
        return null;
      if (c2 && "function" !== typeof c2)
        throw Error(p$1(231, b2, typeof c2));
      return c2;
    }
    var Lb = false;
    if (ia)
      try {
        var Mb = {};
        Object.defineProperty(Mb, "passive", { get: function() {
          Lb = true;
        } });
        window.addEventListener("test", Mb, Mb);
        window.removeEventListener("test", Mb, Mb);
      } catch (a) {
        Lb = false;
      }
    function Nb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
      var l2 = Array.prototype.slice.call(arguments, 3);
      try {
        b2.apply(c2, l2);
      } catch (m2) {
        this.onError(m2);
      }
    }
    var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
      Ob = true;
      Pb = a;
    } };
    function Tb(a, b2, c2, d2, e2, f2, g2, h2, k2) {
      Ob = false;
      Pb = null;
      Nb.apply(Sb, arguments);
    }
    function Ub(a, b2, c2, d2, e2, f2, g2, h2, k2) {
      Tb.apply(this, arguments);
      if (Ob) {
        if (Ob) {
          var l2 = Pb;
          Ob = false;
          Pb = null;
        } else
          throw Error(p$1(198));
        Qb || (Qb = true, Rb = l2);
      }
    }
    function Vb(a) {
      var b2 = a, c2 = a;
      if (a.alternate)
        for (; b2.return; )
          b2 = b2.return;
      else {
        a = b2;
        do
          b2 = a, 0 !== (b2.flags & 4098) && (c2 = b2.return), a = b2.return;
        while (a);
      }
      return 3 === b2.tag ? c2 : null;
    }
    function Wb(a) {
      if (13 === a.tag) {
        var b2 = a.memoizedState;
        null === b2 && (a = a.alternate, null !== a && (b2 = a.memoizedState));
        if (null !== b2)
          return b2.dehydrated;
      }
      return null;
    }
    function Xb(a) {
      if (Vb(a) !== a)
        throw Error(p$1(188));
    }
    function Yb(a) {
      var b2 = a.alternate;
      if (!b2) {
        b2 = Vb(a);
        if (null === b2)
          throw Error(p$1(188));
        return b2 !== a ? null : a;
      }
      for (var c2 = a, d2 = b2; ; ) {
        var e2 = c2.return;
        if (null === e2)
          break;
        var f2 = e2.alternate;
        if (null === f2) {
          d2 = e2.return;
          if (null !== d2) {
            c2 = d2;
            continue;
          }
          break;
        }
        if (e2.child === f2.child) {
          for (f2 = e2.child; f2; ) {
            if (f2 === c2)
              return Xb(e2), a;
            if (f2 === d2)
              return Xb(e2), b2;
            f2 = f2.sibling;
          }
          throw Error(p$1(188));
        }
        if (c2.return !== d2.return)
          c2 = e2, d2 = f2;
        else {
          for (var g2 = false, h2 = e2.child; h2; ) {
            if (h2 === c2) {
              g2 = true;
              c2 = e2;
              d2 = f2;
              break;
            }
            if (h2 === d2) {
              g2 = true;
              d2 = e2;
              c2 = f2;
              break;
            }
            h2 = h2.sibling;
          }
          if (!g2) {
            for (h2 = f2.child; h2; ) {
              if (h2 === c2) {
                g2 = true;
                c2 = f2;
                d2 = e2;
                break;
              }
              if (h2 === d2) {
                g2 = true;
                d2 = f2;
                c2 = e2;
                break;
              }
              h2 = h2.sibling;
            }
            if (!g2)
              throw Error(p$1(189));
          }
        }
        if (c2.alternate !== d2)
          throw Error(p$1(190));
      }
      if (3 !== c2.tag)
        throw Error(p$1(188));
      return c2.stateNode.current === c2 ? a : b2;
    }
    function Zb(a) {
      a = Yb(a);
      return null !== a ? $b(a) : null;
    }
    function $b(a) {
      if (5 === a.tag || 6 === a.tag)
        return a;
      for (a = a.child; null !== a; ) {
        var b2 = $b(a);
        if (null !== b2)
          return b2;
        a = a.sibling;
      }
      return null;
    }
    var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
    function mc(a) {
      if (lc && "function" === typeof lc.onCommitFiberRoot)
        try {
          lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
        } catch (b2) {
        }
    }
    var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
    function nc(a) {
      a >>>= 0;
      return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
    }
    var rc = 64, sc = 4194304;
    function tc(a) {
      switch (a & -a) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return a & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return a & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return a;
      }
    }
    function uc(a, b2) {
      var c2 = a.pendingLanes;
      if (0 === c2)
        return 0;
      var d2 = 0, e2 = a.suspendedLanes, f2 = a.pingedLanes, g2 = c2 & 268435455;
      if (0 !== g2) {
        var h2 = g2 & ~e2;
        0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
      } else
        g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
      if (0 === d2)
        return 0;
      if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
        return b2;
      0 !== (d2 & 4) && (d2 |= c2 & 16);
      b2 = a.entangledLanes;
      if (0 !== b2)
        for (a = a.entanglements, b2 &= d2; 0 < b2; )
          c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a[c2], b2 &= ~e2;
      return d2;
    }
    function vc(a, b2) {
      switch (a) {
        case 1:
        case 2:
        case 4:
          return b2 + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return b2 + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function wc(a, b2) {
      for (var c2 = a.suspendedLanes, d2 = a.pingedLanes, e2 = a.expirationTimes, f2 = a.pendingLanes; 0 < f2; ) {
        var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
        if (-1 === k2) {
          if (0 === (h2 & c2) || 0 !== (h2 & d2))
            e2[g2] = vc(h2, b2);
        } else
          k2 <= b2 && (a.expiredLanes |= h2);
        f2 &= ~h2;
      }
    }
    function xc(a) {
      a = a.pendingLanes & -1073741825;
      return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
    }
    function yc() {
      var a = rc;
      rc <<= 1;
      0 === (rc & 4194240) && (rc = 64);
      return a;
    }
    function zc(a) {
      for (var b2 = [], c2 = 0; 31 > c2; c2++)
        b2.push(a);
      return b2;
    }
    function Ac(a, b2, c2) {
      a.pendingLanes |= b2;
      536870912 !== b2 && (a.suspendedLanes = 0, a.pingedLanes = 0);
      a = a.eventTimes;
      b2 = 31 - oc(b2);
      a[b2] = c2;
    }
    function Bc(a, b2) {
      var c2 = a.pendingLanes & ~b2;
      a.pendingLanes = b2;
      a.suspendedLanes = 0;
      a.pingedLanes = 0;
      a.expiredLanes &= b2;
      a.mutableReadLanes &= b2;
      a.entangledLanes &= b2;
      b2 = a.entanglements;
      var d2 = a.eventTimes;
      for (a = a.expirationTimes; 0 < c2; ) {
        var e2 = 31 - oc(c2), f2 = 1 << e2;
        b2[e2] = 0;
        d2[e2] = -1;
        a[e2] = -1;
        c2 &= ~f2;
      }
    }
    function Cc(a, b2) {
      var c2 = a.entangledLanes |= b2;
      for (a = a.entanglements; c2; ) {
        var d2 = 31 - oc(c2), e2 = 1 << d2;
        e2 & b2 | a[d2] & b2 && (a[d2] |= b2);
        c2 &= ~e2;
      }
    }
    var C = 0;
    function Dc(a) {
      a &= -a;
      return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
    }
    var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function Sc(a, b2) {
      switch (a) {
        case "focusin":
        case "focusout":
          Lc = null;
          break;
        case "dragenter":
        case "dragleave":
          Mc = null;
          break;
        case "mouseover":
        case "mouseout":
          Nc = null;
          break;
        case "pointerover":
        case "pointerout":
          Oc.delete(b2.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          Pc.delete(b2.pointerId);
      }
    }
    function Tc(a, b2, c2, d2, e2, f2) {
      if (null === a || a.nativeEvent !== f2)
        return a = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a;
      a.eventSystemFlags |= d2;
      b2 = a.targetContainers;
      null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
      return a;
    }
    function Uc(a, b2, c2, d2, e2) {
      switch (b2) {
        case "focusin":
          return Lc = Tc(Lc, a, b2, c2, d2, e2), true;
        case "dragenter":
          return Mc = Tc(Mc, a, b2, c2, d2, e2), true;
        case "mouseover":
          return Nc = Tc(Nc, a, b2, c2, d2, e2), true;
        case "pointerover":
          var f2 = e2.pointerId;
          Oc.set(f2, Tc(Oc.get(f2) || null, a, b2, c2, d2, e2));
          return true;
        case "gotpointercapture":
          return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a, b2, c2, d2, e2)), true;
      }
      return false;
    }
    function Vc(a) {
      var b2 = Wc(a.target);
      if (null !== b2) {
        var c2 = Vb(b2);
        if (null !== c2) {
          if (b2 = c2.tag, 13 === b2) {
            if (b2 = Wb(c2), null !== b2) {
              a.blockedOn = b2;
              Ic(a.priority, function() {
                Gc(c2);
              });
              return;
            }
          } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
            a.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
            return;
          }
        }
      }
      a.blockedOn = null;
    }
    function Xc(a) {
      if (null !== a.blockedOn)
        return false;
      for (var b2 = a.targetContainers; 0 < b2.length; ) {
        var c2 = Yc(a.domEventName, a.eventSystemFlags, b2[0], a.nativeEvent);
        if (null === c2) {
          c2 = a.nativeEvent;
          var d2 = new c2.constructor(c2.type, c2);
          wb = d2;
          c2.target.dispatchEvent(d2);
          wb = null;
        } else
          return b2 = Cb(c2), null !== b2 && Fc(b2), a.blockedOn = c2, false;
        b2.shift();
      }
      return true;
    }
    function Zc(a, b2, c2) {
      Xc(a) && c2.delete(b2);
    }
    function $c() {
      Jc = false;
      null !== Lc && Xc(Lc) && (Lc = null);
      null !== Mc && Xc(Mc) && (Mc = null);
      null !== Nc && Xc(Nc) && (Nc = null);
      Oc.forEach(Zc);
      Pc.forEach(Zc);
    }
    function ad(a, b2) {
      a.blockedOn === b2 && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
    }
    function bd(a) {
      function b2(b3) {
        return ad(b3, a);
      }
      if (0 < Kc.length) {
        ad(Kc[0], a);
        for (var c2 = 1; c2 < Kc.length; c2++) {
          var d2 = Kc[c2];
          d2.blockedOn === a && (d2.blockedOn = null);
        }
      }
      null !== Lc && ad(Lc, a);
      null !== Mc && ad(Mc, a);
      null !== Nc && ad(Nc, a);
      Oc.forEach(b2);
      Pc.forEach(b2);
      for (c2 = 0; c2 < Qc.length; c2++)
        d2 = Qc[c2], d2.blockedOn === a && (d2.blockedOn = null);
      for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
        Vc(c2), null === c2.blockedOn && Qc.shift();
    }
    var cd = ua.ReactCurrentBatchConfig, dd = true;
    function ed(a, b2, c2, d2) {
      var e2 = C, f2 = cd.transition;
      cd.transition = null;
      try {
        C = 1, fd(a, b2, c2, d2);
      } finally {
        C = e2, cd.transition = f2;
      }
    }
    function gd(a, b2, c2, d2) {
      var e2 = C, f2 = cd.transition;
      cd.transition = null;
      try {
        C = 4, fd(a, b2, c2, d2);
      } finally {
        C = e2, cd.transition = f2;
      }
    }
    function fd(a, b2, c2, d2) {
      if (dd) {
        var e2 = Yc(a, b2, c2, d2);
        if (null === e2)
          hd(a, b2, d2, id, c2), Sc(a, d2);
        else if (Uc(e2, a, b2, c2, d2))
          d2.stopPropagation();
        else if (Sc(a, d2), b2 & 4 && -1 < Rc.indexOf(a)) {
          for (; null !== e2; ) {
            var f2 = Cb(e2);
            null !== f2 && Ec(f2);
            f2 = Yc(a, b2, c2, d2);
            null === f2 && hd(a, b2, d2, id, c2);
            if (f2 === e2)
              break;
            e2 = f2;
          }
          null !== e2 && d2.stopPropagation();
        } else
          hd(a, b2, d2, null, c2);
      }
    }
    var id = null;
    function Yc(a, b2, c2, d2) {
      id = null;
      a = xb(d2);
      a = Wc(a);
      if (null !== a)
        if (b2 = Vb(a), null === b2)
          a = null;
        else if (c2 = b2.tag, 13 === c2) {
          a = Wb(b2);
          if (null !== a)
            return a;
          a = null;
        } else if (3 === c2) {
          if (b2.stateNode.current.memoizedState.isDehydrated)
            return 3 === b2.tag ? b2.stateNode.containerInfo : null;
          a = null;
        } else
          b2 !== a && (a = null);
      id = a;
      return null;
    }
    function jd(a) {
      switch (a) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 4;
        case "message":
          switch (ec()) {
            case fc:
              return 1;
            case gc:
              return 4;
            case hc:
            case ic:
              return 16;
            case jc:
              return 536870912;
            default:
              return 16;
          }
        default:
          return 16;
      }
    }
    var kd = null, ld = null, md = null;
    function nd() {
      if (md)
        return md;
      var a, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
      for (a = 0; a < c2 && b2[a] === e2[a]; a++)
        ;
      var g2 = c2 - a;
      for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
        ;
      return md = e2.slice(a, 1 < d2 ? 1 - d2 : void 0);
    }
    function od(a) {
      var b2 = a.keyCode;
      "charCode" in a ? (a = a.charCode, 0 === a && 13 === b2 && (a = 13)) : a = b2;
      10 === a && (a = 13);
      return 32 <= a || 13 === a ? a : 0;
    }
    function pd() {
      return true;
    }
    function qd() {
      return false;
    }
    function rd(a) {
      function b2(b3, d2, e2, f2, g2) {
        this._reactName = b3;
        this._targetInst = e2;
        this.type = d2;
        this.nativeEvent = f2;
        this.target = g2;
        this.currentTarget = null;
        for (var c2 in a)
          a.hasOwnProperty(c2) && (b3 = a[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
        this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
        this.isPropagationStopped = qd;
        return this;
      }
      A(b2.prototype, { preventDefault: function() {
        this.defaultPrevented = true;
        var a2 = this.nativeEvent;
        a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
      }, stopPropagation: function() {
        var a2 = this.nativeEvent;
        a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
      }, persist: function() {
      }, isPersistent: pd });
      return b2;
    }
    var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
      return a.timeStamp || Date.now();
    }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
      return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
    }, movementX: function(a) {
      if ("movementX" in a)
        return a.movementX;
      a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
      return wd;
    }, movementY: function(a) {
      return "movementY" in a ? a.movementY : xd;
    } }), Bd = rd(Ad), Cd = A({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A({}, sd, { clipboardData: function(a) {
      return "clipboardData" in a ? a.clipboardData : window.clipboardData;
    } }), Jd = rd(Id), Kd = A({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Nd = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
    function Pd(a) {
      var b2 = this.nativeEvent;
      return b2.getModifierState ? b2.getModifierState(a) : (a = Od[a]) ? !!b2[a] : false;
    }
    function zd() {
      return Pd;
    }
    var Qd = A({}, ud, { key: function(a) {
      if (a.key) {
        var b2 = Md[a.key] || a.key;
        if ("Unidentified" !== b2)
          return b2;
      }
      return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
    }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
      return "keypress" === a.type ? od(a) : 0;
    }, keyCode: function(a) {
      return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    }, which: function(a) {
      return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    } }), Rd = rd(Qd), Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A({}, Ad, {
      deltaX: function(a) {
        return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
      },
      deltaY: function(a) {
        return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
    ia && "documentMode" in document && (be = document.documentMode);
    var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
    function ge(a, b2) {
      switch (a) {
        case "keyup":
          return -1 !== $d.indexOf(b2.keyCode);
        case "keydown":
          return 229 !== b2.keyCode;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function he(a) {
      a = a.detail;
      return "object" === typeof a && "data" in a ? a.data : null;
    }
    var ie = false;
    function je(a, b2) {
      switch (a) {
        case "compositionend":
          return he(b2);
        case "keypress":
          if (32 !== b2.which)
            return null;
          fe = true;
          return ee;
        case "textInput":
          return a = b2.data, a === ee && fe ? null : a;
        default:
          return null;
      }
    }
    function ke(a, b2) {
      if (ie)
        return "compositionend" === a || !ae && ge(a, b2) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
      switch (a) {
        case "paste":
          return null;
        case "keypress":
          if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
            if (b2.char && 1 < b2.char.length)
              return b2.char;
            if (b2.which)
              return String.fromCharCode(b2.which);
          }
          return null;
        case "compositionend":
          return de && "ko" !== b2.locale ? null : b2.data;
        default:
          return null;
      }
    }
    var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
    function me(a) {
      var b2 = a && a.nodeName && a.nodeName.toLowerCase();
      return "input" === b2 ? !!le[a.type] : "textarea" === b2 ? true : false;
    }
    function ne(a, b2, c2, d2) {
      Eb(d2);
      b2 = oe(b2, "onChange");
      0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a.push({ event: c2, listeners: b2 }));
    }
    var pe = null, qe = null;
    function re(a) {
      se(a, 0);
    }
    function te(a) {
      var b2 = ue(a);
      if (Wa(b2))
        return a;
    }
    function ve(a, b2) {
      if ("change" === a)
        return b2;
    }
    var we = false;
    if (ia) {
      var xe;
      if (ia) {
        var ye = "oninput" in document;
        if (!ye) {
          var ze = document.createElement("div");
          ze.setAttribute("oninput", "return;");
          ye = "function" === typeof ze.oninput;
        }
        xe = ye;
      } else
        xe = false;
      we = xe && (!document.documentMode || 9 < document.documentMode);
    }
    function Ae() {
      pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
    }
    function Be(a) {
      if ("value" === a.propertyName && te(qe)) {
        var b2 = [];
        ne(b2, qe, a, xb(a));
        Jb(re, b2);
      }
    }
    function Ce(a, b2, c2) {
      "focusin" === a ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
    }
    function De(a) {
      if ("selectionchange" === a || "keyup" === a || "keydown" === a)
        return te(qe);
    }
    function Ee(a, b2) {
      if ("click" === a)
        return te(b2);
    }
    function Fe(a, b2) {
      if ("input" === a || "change" === a)
        return te(b2);
    }
    function Ge(a, b2) {
      return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
    }
    var He = "function" === typeof Object.is ? Object.is : Ge;
    function Ie(a, b2) {
      if (He(a, b2))
        return true;
      if ("object" !== typeof a || null === a || "object" !== typeof b2 || null === b2)
        return false;
      var c2 = Object.keys(a), d2 = Object.keys(b2);
      if (c2.length !== d2.length)
        return false;
      for (d2 = 0; d2 < c2.length; d2++) {
        var e2 = c2[d2];
        if (!ja.call(b2, e2) || !He(a[e2], b2[e2]))
          return false;
      }
      return true;
    }
    function Je(a) {
      for (; a && a.firstChild; )
        a = a.firstChild;
      return a;
    }
    function Ke(a, b2) {
      var c2 = Je(a);
      a = 0;
      for (var d2; c2; ) {
        if (3 === c2.nodeType) {
          d2 = a + c2.textContent.length;
          if (a <= b2 && d2 >= b2)
            return { node: c2, offset: b2 - a };
          a = d2;
        }
        a: {
          for (; c2; ) {
            if (c2.nextSibling) {
              c2 = c2.nextSibling;
              break a;
            }
            c2 = c2.parentNode;
          }
          c2 = void 0;
        }
        c2 = Je(c2);
      }
    }
    function Le(a, b2) {
      return a && b2 ? a === b2 ? true : a && 3 === a.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a, b2.parentNode) : "contains" in a ? a.contains(b2) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b2) & 16) : false : false;
    }
    function Me() {
      for (var a = window, b2 = Xa(); b2 instanceof a.HTMLIFrameElement; ) {
        try {
          var c2 = "string" === typeof b2.contentWindow.location.href;
        } catch (d2) {
          c2 = false;
        }
        if (c2)
          a = b2.contentWindow;
        else
          break;
        b2 = Xa(a.document);
      }
      return b2;
    }
    function Ne(a) {
      var b2 = a && a.nodeName && a.nodeName.toLowerCase();
      return b2 && ("input" === b2 && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b2 || "true" === a.contentEditable);
    }
    function Oe(a) {
      var b2 = Me(), c2 = a.focusedElem, d2 = a.selectionRange;
      if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
        if (null !== d2 && Ne(c2)) {
          if (b2 = d2.start, a = d2.end, void 0 === a && (a = b2), "selectionStart" in c2)
            c2.selectionStart = b2, c2.selectionEnd = Math.min(a, c2.value.length);
          else if (a = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a.getSelection) {
            a = a.getSelection();
            var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
            d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
            !a.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
            e2 = Ke(c2, f2);
            var g2 = Ke(
              c2,
              d2
            );
            e2 && g2 && (1 !== a.rangeCount || a.anchorNode !== e2.node || a.anchorOffset !== e2.offset || a.focusNode !== g2.node || a.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a.removeAllRanges(), f2 > d2 ? (a.addRange(b2), a.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a.addRange(b2)));
          }
        }
        b2 = [];
        for (a = c2; a = a.parentNode; )
          1 === a.nodeType && b2.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
        "function" === typeof c2.focus && c2.focus();
        for (c2 = 0; c2 < b2.length; c2++)
          a = b2[c2], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
      }
    }
    var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
    function Ue(a, b2, c2) {
      var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
      Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a.push({ event: b2, listeners: d2 }), b2.target = Qe)));
    }
    function Ve(a, b2) {
      var c2 = {};
      c2[a.toLowerCase()] = b2.toLowerCase();
      c2["Webkit" + a] = "webkit" + b2;
      c2["Moz" + a] = "moz" + b2;
      return c2;
    }
    var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
    ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
    function Ze(a) {
      if (Xe[a])
        return Xe[a];
      if (!We[a])
        return a;
      var b2 = We[a], c2;
      for (c2 in b2)
        if (b2.hasOwnProperty(c2) && c2 in Ye)
          return Xe[a] = b2[c2];
      return a;
    }
    var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    function ff(a, b2) {
      df.set(a, b2);
      fa(b2, [a]);
    }
    for (var gf = 0; gf < ef.length; gf++) {
      var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
      ff(jf, "on" + kf);
    }
    ff($e, "onAnimationEnd");
    ff(af, "onAnimationIteration");
    ff(bf, "onAnimationStart");
    ff("dblclick", "onDoubleClick");
    ff("focusin", "onFocus");
    ff("focusout", "onBlur");
    ff(cf, "onTransitionEnd");
    ha("onMouseEnter", ["mouseout", "mouseover"]);
    ha("onMouseLeave", ["mouseout", "mouseover"]);
    ha("onPointerEnter", ["pointerout", "pointerover"]);
    ha("onPointerLeave", ["pointerout", "pointerover"]);
    fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
    fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
    function nf(a, b2, c2) {
      var d2 = a.type || "unknown-event";
      a.currentTarget = c2;
      Ub(d2, b2, void 0, a);
      a.currentTarget = null;
    }
    function se(a, b2) {
      b2 = 0 !== (b2 & 4);
      for (var c2 = 0; c2 < a.length; c2++) {
        var d2 = a[c2], e2 = d2.event;
        d2 = d2.listeners;
        a: {
          var f2 = void 0;
          if (b2)
            for (var g2 = d2.length - 1; 0 <= g2; g2--) {
              var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
              h2 = h2.listener;
              if (k2 !== f2 && e2.isPropagationStopped())
                break a;
              nf(e2, h2, l2);
              f2 = k2;
            }
          else
            for (g2 = 0; g2 < d2.length; g2++) {
              h2 = d2[g2];
              k2 = h2.instance;
              l2 = h2.currentTarget;
              h2 = h2.listener;
              if (k2 !== f2 && e2.isPropagationStopped())
                break a;
              nf(e2, h2, l2);
              f2 = k2;
            }
        }
      }
      if (Qb)
        throw a = Rb, Qb = false, Rb = null, a;
    }
    function D(a, b2) {
      var c2 = b2[of];
      void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
      var d2 = a + "__bubble";
      c2.has(d2) || (pf(b2, a, 2, false), c2.add(d2));
    }
    function qf(a, b2, c2) {
      var d2 = 0;
      b2 && (d2 |= 4);
      pf(c2, a, d2, b2);
    }
    var rf = "_reactListening" + Math.random().toString(36).slice(2);
    function sf(a) {
      if (!a[rf]) {
        a[rf] = true;
        da.forEach(function(b3) {
          "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a), qf(b3, true, a));
        });
        var b2 = 9 === a.nodeType ? a : a.ownerDocument;
        null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
      }
    }
    function pf(a, b2, c2, d2) {
      switch (jd(b2)) {
        case 1:
          var e2 = ed;
          break;
        case 4:
          e2 = gd;
          break;
        default:
          e2 = fd;
      }
      c2 = e2.bind(null, b2, c2, a);
      e2 = void 0;
      !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
      d2 ? void 0 !== e2 ? a.addEventListener(b2, c2, { capture: true, passive: e2 }) : a.addEventListener(b2, c2, true) : void 0 !== e2 ? a.addEventListener(b2, c2, { passive: e2 }) : a.addEventListener(b2, c2, false);
    }
    function hd(a, b2, c2, d2, e2) {
      var f2 = d2;
      if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
        a:
          for (; ; ) {
            if (null === d2)
              return;
            var g2 = d2.tag;
            if (3 === g2 || 4 === g2) {
              var h2 = d2.stateNode.containerInfo;
              if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
                break;
              if (4 === g2)
                for (g2 = d2.return; null !== g2; ) {
                  var k2 = g2.tag;
                  if (3 === k2 || 4 === k2) {
                    if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                      return;
                  }
                  g2 = g2.return;
                }
              for (; null !== h2; ) {
                g2 = Wc(h2);
                if (null === g2)
                  return;
                k2 = g2.tag;
                if (5 === k2 || 6 === k2) {
                  d2 = f2 = g2;
                  continue a;
                }
                h2 = h2.parentNode;
              }
            }
            d2 = d2.return;
          }
      Jb(function() {
        var d3 = f2, e3 = xb(c2), g3 = [];
        a: {
          var h3 = df.get(a);
          if (void 0 !== h3) {
            var k3 = td, n2 = a;
            switch (a) {
              case "keypress":
                if (0 === od(c2))
                  break a;
              case "keydown":
              case "keyup":
                k3 = Rd;
                break;
              case "focusin":
                n2 = "focus";
                k3 = Fd;
                break;
              case "focusout":
                n2 = "blur";
                k3 = Fd;
                break;
              case "beforeblur":
              case "afterblur":
                k3 = Fd;
                break;
              case "click":
                if (2 === c2.button)
                  break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                k3 = Bd;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                k3 = Dd;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                k3 = Vd;
                break;
              case $e:
              case af:
              case bf:
                k3 = Hd;
                break;
              case cf:
                k3 = Xd;
                break;
              case "scroll":
                k3 = vd;
                break;
              case "wheel":
                k3 = Zd;
                break;
              case "copy":
              case "cut":
              case "paste":
                k3 = Jd;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                k3 = Td;
            }
            var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
            t2 = [];
            for (var w2 = d3, u2; null !== w2; ) {
              u2 = w2;
              var F2 = u2.stateNode;
              5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
              if (J2)
                break;
              w2 = w2.return;
            }
            0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
          }
        }
        if (0 === (b2 & 7)) {
          a: {
            h3 = "mouseover" === a || "pointerover" === a;
            k3 = "mouseout" === a || "pointerout" === a;
            if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
              break a;
            if (k3 || h3) {
              h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
              if (k3) {
                if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
                  n2 = null;
              } else
                k3 = null, n2 = d3;
              if (k3 !== n2) {
                t2 = Bd;
                F2 = "onMouseLeave";
                x2 = "onMouseEnter";
                w2 = "mouse";
                if ("pointerout" === a || "pointerover" === a)
                  t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
                J2 = null == k3 ? h3 : ue(k3);
                u2 = null == n2 ? h3 : ue(n2);
                h3 = new t2(F2, w2 + "leave", k3, c2, e3);
                h3.target = J2;
                h3.relatedTarget = u2;
                F2 = null;
                Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
                J2 = F2;
                if (k3 && n2)
                  b: {
                    t2 = k3;
                    x2 = n2;
                    w2 = 0;
                    for (u2 = t2; u2; u2 = vf(u2))
                      w2++;
                    u2 = 0;
                    for (F2 = x2; F2; F2 = vf(F2))
                      u2++;
                    for (; 0 < w2 - u2; )
                      t2 = vf(t2), w2--;
                    for (; 0 < u2 - w2; )
                      x2 = vf(x2), u2--;
                    for (; w2--; ) {
                      if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                        break b;
                      t2 = vf(t2);
                      x2 = vf(x2);
                    }
                    t2 = null;
                  }
                else
                  t2 = null;
                null !== k3 && wf(g3, h3, k3, t2, false);
                null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
              }
            }
          }
          a: {
            h3 = d3 ? ue(d3) : window;
            k3 = h3.nodeName && h3.nodeName.toLowerCase();
            if ("select" === k3 || "input" === k3 && "file" === h3.type)
              var na = ve;
            else if (me(h3))
              if (we)
                na = Fe;
              else {
                na = De;
                var xa = Ce;
              }
            else
              (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
            if (na && (na = na(a, d3))) {
              ne(g3, na, c2, e3);
              break a;
            }
            xa && xa(a, h3, d3);
            "focusout" === a && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
          }
          xa = d3 ? ue(d3) : window;
          switch (a) {
            case "focusin":
              if (me(xa) || "true" === xa.contentEditable)
                Qe = xa, Re = d3, Se = null;
              break;
            case "focusout":
              Se = Re = Qe = null;
              break;
            case "mousedown":
              Te = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              Te = false;
              Ue(g3, c2, e3);
              break;
            case "selectionchange":
              if (Pe)
                break;
            case "keydown":
            case "keyup":
              Ue(g3, c2, e3);
          }
          var $a;
          if (ae)
            b: {
              switch (a) {
                case "compositionstart":
                  var ba = "onCompositionStart";
                  break b;
                case "compositionend":
                  ba = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  ba = "onCompositionUpdate";
                  break b;
              }
              ba = void 0;
            }
          else
            ie ? ge(a, c2) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c2.keyCode && (ba = "onCompositionStart");
          ba && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
          if ($a = ce ? je(a, c2) : ke(a, c2))
            d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
        }
        se(g3, b2);
      });
    }
    function tf(a, b2, c2) {
      return { instance: a, listener: b2, currentTarget: c2 };
    }
    function oe(a, b2) {
      for (var c2 = b2 + "Capture", d2 = []; null !== a; ) {
        var e2 = a, f2 = e2.stateNode;
        5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a, c2), null != f2 && d2.unshift(tf(a, f2, e2)), f2 = Kb(a, b2), null != f2 && d2.push(tf(a, f2, e2)));
        a = a.return;
      }
      return d2;
    }
    function vf(a) {
      if (null === a)
        return null;
      do
        a = a.return;
      while (a && 5 !== a.tag);
      return a ? a : null;
    }
    function wf(a, b2, c2, d2, e2) {
      for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
        var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
        if (null !== k2 && k2 === d2)
          break;
        5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
        c2 = c2.return;
      }
      0 !== g2.length && a.push({ event: b2, listeners: g2 });
    }
    var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
    function zf(a) {
      return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
    }
    function Af(a, b2, c2) {
      b2 = zf(b2);
      if (zf(a) !== b2 && c2)
        throw Error(p$1(425));
    }
    function Bf() {
    }
    var Cf = null, Df = null;
    function Ef(a, b2) {
      return "textarea" === a || "noscript" === a || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
    }
    var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
      return Hf.resolve(null).then(a).catch(If);
    } : Ff;
    function If(a) {
      setTimeout(function() {
        throw a;
      });
    }
    function Kf(a, b2) {
      var c2 = b2, d2 = 0;
      do {
        var e2 = c2.nextSibling;
        a.removeChild(c2);
        if (e2 && 8 === e2.nodeType)
          if (c2 = e2.data, "/$" === c2) {
            if (0 === d2) {
              a.removeChild(e2);
              bd(b2);
              return;
            }
            d2--;
          } else
            "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
        c2 = e2;
      } while (c2);
      bd(b2);
    }
    function Lf(a) {
      for (; null != a; a = a.nextSibling) {
        var b2 = a.nodeType;
        if (1 === b2 || 3 === b2)
          break;
        if (8 === b2) {
          b2 = a.data;
          if ("$" === b2 || "$!" === b2 || "$?" === b2)
            break;
          if ("/$" === b2)
            return null;
        }
      }
      return a;
    }
    function Mf(a) {
      a = a.previousSibling;
      for (var b2 = 0; a; ) {
        if (8 === a.nodeType) {
          var c2 = a.data;
          if ("$" === c2 || "$!" === c2 || "$?" === c2) {
            if (0 === b2)
              return a;
            b2--;
          } else
            "/$" === c2 && b2++;
        }
        a = a.previousSibling;
      }
      return null;
    }
    var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
    function Wc(a) {
      var b2 = a[Of];
      if (b2)
        return b2;
      for (var c2 = a.parentNode; c2; ) {
        if (b2 = c2[uf] || c2[Of]) {
          c2 = b2.alternate;
          if (null !== b2.child || null !== c2 && null !== c2.child)
            for (a = Mf(a); null !== a; ) {
              if (c2 = a[Of])
                return c2;
              a = Mf(a);
            }
          return b2;
        }
        a = c2;
        c2 = a.parentNode;
      }
      return null;
    }
    function Cb(a) {
      a = a[Of] || a[uf];
      return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
    }
    function ue(a) {
      if (5 === a.tag || 6 === a.tag)
        return a.stateNode;
      throw Error(p$1(33));
    }
    function Db(a) {
      return a[Pf] || null;
    }
    var Sf = [], Tf = -1;
    function Uf(a) {
      return { current: a };
    }
    function E(a) {
      0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
    }
    function G(a, b2) {
      Tf++;
      Sf[Tf] = a.current;
      a.current = b2;
    }
    var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
    function Yf(a, b2) {
      var c2 = a.type.contextTypes;
      if (!c2)
        return Vf;
      var d2 = a.stateNode;
      if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
        return d2.__reactInternalMemoizedMaskedChildContext;
      var e2 = {}, f2;
      for (f2 in c2)
        e2[f2] = b2[f2];
      d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b2, a.__reactInternalMemoizedMaskedChildContext = e2);
      return e2;
    }
    function Zf(a) {
      a = a.childContextTypes;
      return null !== a && void 0 !== a;
    }
    function $f() {
      E(Wf);
      E(H);
    }
    function ag(a, b2, c2) {
      if (H.current !== Vf)
        throw Error(p$1(168));
      G(H, b2);
      G(Wf, c2);
    }
    function bg(a, b2, c2) {
      var d2 = a.stateNode;
      b2 = b2.childContextTypes;
      if ("function" !== typeof d2.getChildContext)
        return c2;
      d2 = d2.getChildContext();
      for (var e2 in d2)
        if (!(e2 in b2))
          throw Error(p$1(108, Ra(a) || "Unknown", e2));
      return A({}, c2, d2);
    }
    function cg(a) {
      a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
      Xf = H.current;
      G(H, a);
      G(Wf, Wf.current);
      return true;
    }
    function dg(a, b2, c2) {
      var d2 = a.stateNode;
      if (!d2)
        throw Error(p$1(169));
      c2 ? (a = bg(a, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
      G(Wf, c2);
    }
    var eg = null, fg = false, gg = false;
    function hg(a) {
      null === eg ? eg = [a] : eg.push(a);
    }
    function ig(a) {
      fg = true;
      hg(a);
    }
    function jg() {
      if (!gg && null !== eg) {
        gg = true;
        var a = 0, b2 = C;
        try {
          var c2 = eg;
          for (C = 1; a < c2.length; a++) {
            var d2 = c2[a];
            do
              d2 = d2(true);
            while (null !== d2);
          }
          eg = null;
          fg = false;
        } catch (e2) {
          throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e2;
        } finally {
          C = b2, gg = false;
        }
      }
      return null;
    }
    var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
    function tg(a, b2) {
      kg[lg++] = ng;
      kg[lg++] = mg;
      mg = a;
      ng = b2;
    }
    function ug(a, b2, c2) {
      og[pg++] = rg;
      og[pg++] = sg;
      og[pg++] = qg;
      qg = a;
      var d2 = rg;
      a = sg;
      var e2 = 32 - oc(d2) - 1;
      d2 &= ~(1 << e2);
      c2 += 1;
      var f2 = 32 - oc(b2) + e2;
      if (30 < f2) {
        var g2 = e2 - e2 % 5;
        f2 = (d2 & (1 << g2) - 1).toString(32);
        d2 >>= g2;
        e2 -= g2;
        rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
        sg = f2 + a;
      } else
        rg = 1 << f2 | c2 << e2 | d2, sg = a;
    }
    function vg(a) {
      null !== a.return && (tg(a, 1), ug(a, 1, 0));
    }
    function wg(a) {
      for (; a === mg; )
        mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
      for (; a === qg; )
        qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
    }
    var xg = null, yg = null, I = false, zg = null;
    function Ag(a, b2) {
      var c2 = Bg(5, null, null, 0);
      c2.elementType = "DELETED";
      c2.stateNode = b2;
      c2.return = a;
      b2 = a.deletions;
      null === b2 ? (a.deletions = [c2], a.flags |= 16) : b2.push(c2);
    }
    function Cg(a, b2) {
      switch (a.tag) {
        case 5:
          var c2 = a.type;
          b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
          return null !== b2 ? (a.stateNode = b2, xg = a, yg = Lf(b2.firstChild), true) : false;
        case 6:
          return b2 = "" === a.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a.stateNode = b2, xg = a, yg = null, true) : false;
        case 13:
          return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a, a.child = c2, xg = a, yg = null, true) : false;
        default:
          return false;
      }
    }
    function Dg(a) {
      return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
    }
    function Eg(a) {
      if (I) {
        var b2 = yg;
        if (b2) {
          var c2 = b2;
          if (!Cg(a, b2)) {
            if (Dg(a))
              throw Error(p$1(418));
            b2 = Lf(c2.nextSibling);
            var d2 = xg;
            b2 && Cg(a, b2) ? Ag(d2, c2) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
          }
        } else {
          if (Dg(a))
            throw Error(p$1(418));
          a.flags = a.flags & -4097 | 2;
          I = false;
          xg = a;
        }
      }
    }
    function Fg(a) {
      for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; )
        a = a.return;
      xg = a;
    }
    function Gg(a) {
      if (a !== xg)
        return false;
      if (!I)
        return Fg(a), I = true, false;
      var b2;
      (b2 = 3 !== a.tag) && !(b2 = 5 !== a.tag) && (b2 = a.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a.type, a.memoizedProps));
      if (b2 && (b2 = yg)) {
        if (Dg(a))
          throw Hg(), Error(p$1(418));
        for (; b2; )
          Ag(a, b2), b2 = Lf(b2.nextSibling);
      }
      Fg(a);
      if (13 === a.tag) {
        a = a.memoizedState;
        a = null !== a ? a.dehydrated : null;
        if (!a)
          throw Error(p$1(317));
        a: {
          a = a.nextSibling;
          for (b2 = 0; a; ) {
            if (8 === a.nodeType) {
              var c2 = a.data;
              if ("/$" === c2) {
                if (0 === b2) {
                  yg = Lf(a.nextSibling);
                  break a;
                }
                b2--;
              } else
                "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
            }
            a = a.nextSibling;
          }
          yg = null;
        }
      } else
        yg = xg ? Lf(a.stateNode.nextSibling) : null;
      return true;
    }
    function Hg() {
      for (var a = yg; a; )
        a = Lf(a.nextSibling);
    }
    function Ig() {
      yg = xg = null;
      I = false;
    }
    function Jg(a) {
      null === zg ? zg = [a] : zg.push(a);
    }
    var Kg = ua.ReactCurrentBatchConfig;
    function Lg(a, b2) {
      if (a && a.defaultProps) {
        b2 = A({}, b2);
        a = a.defaultProps;
        for (var c2 in a)
          void 0 === b2[c2] && (b2[c2] = a[c2]);
        return b2;
      }
      return b2;
    }
    var Mg = Uf(null), Ng = null, Og = null, Pg = null;
    function Qg() {
      Pg = Og = Ng = null;
    }
    function Rg(a) {
      var b2 = Mg.current;
      E(Mg);
      a._currentValue = b2;
    }
    function Sg(a, b2, c2) {
      for (; null !== a; ) {
        var d2 = a.alternate;
        (a.childLanes & b2) !== b2 ? (a.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
        if (a === c2)
          break;
        a = a.return;
      }
    }
    function Tg(a, b2) {
      Ng = a;
      Pg = Og = null;
      a = a.dependencies;
      null !== a && null !== a.firstContext && (0 !== (a.lanes & b2) && (Ug = true), a.firstContext = null);
    }
    function Vg(a) {
      var b2 = a._currentValue;
      if (Pg !== a)
        if (a = { context: a, memoizedValue: b2, next: null }, null === Og) {
          if (null === Ng)
            throw Error(p$1(308));
          Og = a;
          Ng.dependencies = { lanes: 0, firstContext: a };
        } else
          Og = Og.next = a;
      return b2;
    }
    var Wg = null;
    function Xg(a) {
      null === Wg ? Wg = [a] : Wg.push(a);
    }
    function Yg(a, b2, c2, d2) {
      var e2 = b2.interleaved;
      null === e2 ? (c2.next = c2, Xg(b2)) : (c2.next = e2.next, e2.next = c2);
      b2.interleaved = c2;
      return Zg(a, d2);
    }
    function Zg(a, b2) {
      a.lanes |= b2;
      var c2 = a.alternate;
      null !== c2 && (c2.lanes |= b2);
      c2 = a;
      for (a = a.return; null !== a; )
        a.childLanes |= b2, c2 = a.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a, a = a.return;
      return 3 === c2.tag ? c2.stateNode : null;
    }
    var $g = false;
    function ah(a) {
      a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    function bh(a, b2) {
      a = a.updateQueue;
      b2.updateQueue === a && (b2.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
    }
    function ch(a, b2) {
      return { eventTime: a, lane: b2, tag: 0, payload: null, callback: null, next: null };
    }
    function dh(a, b2, c2) {
      var d2 = a.updateQueue;
      if (null === d2)
        return null;
      d2 = d2.shared;
      if (0 !== (K & 2)) {
        var e2 = d2.pending;
        null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
        d2.pending = b2;
        return Zg(a, c2);
      }
      e2 = d2.interleaved;
      null === e2 ? (b2.next = b2, Xg(d2)) : (b2.next = e2.next, e2.next = b2);
      d2.interleaved = b2;
      return Zg(a, c2);
    }
    function eh(a, b2, c2) {
      b2 = b2.updateQueue;
      if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
        var d2 = b2.lanes;
        d2 &= a.pendingLanes;
        c2 |= d2;
        b2.lanes = c2;
        Cc(a, c2);
      }
    }
    function fh(a, b2) {
      var c2 = a.updateQueue, d2 = a.alternate;
      if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
        var e2 = null, f2 = null;
        c2 = c2.firstBaseUpdate;
        if (null !== c2) {
          do {
            var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
            null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
            c2 = c2.next;
          } while (null !== c2);
          null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
        } else
          e2 = f2 = b2;
        c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
        a.updateQueue = c2;
        return;
      }
      a = c2.lastBaseUpdate;
      null === a ? c2.firstBaseUpdate = b2 : a.next = b2;
      c2.lastBaseUpdate = b2;
    }
    function gh(a, b2, c2, d2) {
      var e2 = a.updateQueue;
      $g = false;
      var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
      if (null !== h2) {
        e2.shared.pending = null;
        var k2 = h2, l2 = k2.next;
        k2.next = null;
        null === g2 ? f2 = l2 : g2.next = l2;
        g2 = k2;
        var m2 = a.alternate;
        null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
      }
      if (null !== f2) {
        var q2 = e2.baseState;
        g2 = 0;
        m2 = l2 = k2 = null;
        h2 = f2;
        do {
          var r2 = h2.lane, y2 = h2.eventTime;
          if ((d2 & r2) === r2) {
            null !== m2 && (m2 = m2.next = {
              eventTime: y2,
              lane: 0,
              tag: h2.tag,
              payload: h2.payload,
              callback: h2.callback,
              next: null
            });
            a: {
              var n2 = a, t2 = h2;
              r2 = b2;
              y2 = c2;
              switch (t2.tag) {
                case 1:
                  n2 = t2.payload;
                  if ("function" === typeof n2) {
                    q2 = n2.call(y2, q2, r2);
                    break a;
                  }
                  q2 = n2;
                  break a;
                case 3:
                  n2.flags = n2.flags & -65537 | 128;
                case 0:
                  n2 = t2.payload;
                  r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
                  if (null === r2 || void 0 === r2)
                    break a;
                  q2 = A({}, q2, r2);
                  break a;
                case 2:
                  $g = true;
              }
            }
            null !== h2.callback && 0 !== h2.lane && (a.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
          } else
            y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
          h2 = h2.next;
          if (null === h2)
            if (h2 = e2.shared.pending, null === h2)
              break;
            else
              r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
        } while (1);
        null === m2 && (k2 = q2);
        e2.baseState = k2;
        e2.firstBaseUpdate = l2;
        e2.lastBaseUpdate = m2;
        b2 = e2.shared.interleaved;
        if (null !== b2) {
          e2 = b2;
          do
            g2 |= e2.lane, e2 = e2.next;
          while (e2 !== b2);
        } else
          null === f2 && (e2.shared.lanes = 0);
        hh |= g2;
        a.lanes = g2;
        a.memoizedState = q2;
      }
    }
    function ih(a, b2, c2) {
      a = b2.effects;
      b2.effects = null;
      if (null !== a)
        for (b2 = 0; b2 < a.length; b2++) {
          var d2 = a[b2], e2 = d2.callback;
          if (null !== e2) {
            d2.callback = null;
            d2 = c2;
            if ("function" !== typeof e2)
              throw Error(p$1(191, e2));
            e2.call(d2);
          }
        }
    }
    var jh = new aa.Component().refs;
    function kh(a, b2, c2, d2) {
      b2 = a.memoizedState;
      c2 = c2(d2, b2);
      c2 = null === c2 || void 0 === c2 ? b2 : A({}, b2, c2);
      a.memoizedState = c2;
      0 === a.lanes && (a.updateQueue.baseState = c2);
    }
    var nh = { isMounted: function(a) {
      return (a = a._reactInternals) ? Vb(a) === a : false;
    }, enqueueSetState: function(a, b2, c2) {
      a = a._reactInternals;
      var d2 = L(), e2 = lh(a), f2 = ch(d2, e2);
      f2.payload = b2;
      void 0 !== c2 && null !== c2 && (f2.callback = c2);
      b2 = dh(a, f2, e2);
      null !== b2 && (mh(b2, a, e2, d2), eh(b2, a, e2));
    }, enqueueReplaceState: function(a, b2, c2) {
      a = a._reactInternals;
      var d2 = L(), e2 = lh(a), f2 = ch(d2, e2);
      f2.tag = 1;
      f2.payload = b2;
      void 0 !== c2 && null !== c2 && (f2.callback = c2);
      b2 = dh(a, f2, e2);
      null !== b2 && (mh(b2, a, e2, d2), eh(b2, a, e2));
    }, enqueueForceUpdate: function(a, b2) {
      a = a._reactInternals;
      var c2 = L(), d2 = lh(a), e2 = ch(c2, d2);
      e2.tag = 2;
      void 0 !== b2 && null !== b2 && (e2.callback = b2);
      b2 = dh(a, e2, d2);
      null !== b2 && (mh(b2, a, d2, c2), eh(b2, a, d2));
    } };
    function oh(a, b2, c2, d2, e2, f2, g2) {
      a = a.stateNode;
      return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c2, d2) || !Ie(e2, f2) : true;
    }
    function ph(a, b2, c2) {
      var d2 = false, e2 = Vf;
      var f2 = b2.contextType;
      "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e2 = Zf(b2) ? Xf : H.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a, e2) : Vf);
      b2 = new b2(c2, f2);
      a.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
      b2.updater = nh;
      a.stateNode = b2;
      b2._reactInternals = a;
      d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e2, a.__reactInternalMemoizedMaskedChildContext = f2);
      return b2;
    }
    function qh(a, b2, c2, d2) {
      a = b2.state;
      "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
      "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
      b2.state !== a && nh.enqueueReplaceState(b2, b2.state, null);
    }
    function rh(a, b2, c2, d2) {
      var e2 = a.stateNode;
      e2.props = c2;
      e2.state = a.memoizedState;
      e2.refs = jh;
      ah(a);
      var f2 = b2.contextType;
      "object" === typeof f2 && null !== f2 ? e2.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H.current, e2.context = Yf(a, f2));
      e2.state = a.memoizedState;
      f2 = b2.getDerivedStateFromProps;
      "function" === typeof f2 && (kh(a, b2, f2, c2), e2.state = a.memoizedState);
      "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a, c2, e2, d2), e2.state = a.memoizedState);
      "function" === typeof e2.componentDidMount && (a.flags |= 4194308);
    }
    function sh(a, b2, c2) {
      a = c2.ref;
      if (null !== a && "function" !== typeof a && "object" !== typeof a) {
        if (c2._owner) {
          c2 = c2._owner;
          if (c2) {
            if (1 !== c2.tag)
              throw Error(p$1(309));
            var d2 = c2.stateNode;
          }
          if (!d2)
            throw Error(p$1(147, a));
          var e2 = d2, f2 = "" + a;
          if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
            return b2.ref;
          b2 = function(a2) {
            var b3 = e2.refs;
            b3 === jh && (b3 = e2.refs = {});
            null === a2 ? delete b3[f2] : b3[f2] = a2;
          };
          b2._stringRef = f2;
          return b2;
        }
        if ("string" !== typeof a)
          throw Error(p$1(284));
        if (!c2._owner)
          throw Error(p$1(290, a));
      }
      return a;
    }
    function th(a, b2) {
      a = Object.prototype.toString.call(b2);
      throw Error(p$1(31, "[object Object]" === a ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a));
    }
    function uh(a) {
      var b2 = a._init;
      return b2(a._payload);
    }
    function vh(a) {
      function b2(b3, c3) {
        if (a) {
          var d3 = b3.deletions;
          null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
        }
      }
      function c2(c3, d3) {
        if (!a)
          return null;
        for (; null !== d3; )
          b2(c3, d3), d3 = d3.sibling;
        return null;
      }
      function d2(a2, b3) {
        for (a2 = /* @__PURE__ */ new Map(); null !== b3; )
          null !== b3.key ? a2.set(b3.key, b3) : a2.set(b3.index, b3), b3 = b3.sibling;
        return a2;
      }
      function e2(a2, b3) {
        a2 = wh(a2, b3);
        a2.index = 0;
        a2.sibling = null;
        return a2;
      }
      function f2(b3, c3, d3) {
        b3.index = d3;
        if (!a)
          return b3.flags |= 1048576, c3;
        d3 = b3.alternate;
        if (null !== d3)
          return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
        b3.flags |= 2;
        return c3;
      }
      function g2(b3) {
        a && null === b3.alternate && (b3.flags |= 2);
        return b3;
      }
      function h2(a2, b3, c3, d3) {
        if (null === b3 || 6 !== b3.tag)
          return b3 = xh(c3, a2.mode, d3), b3.return = a2, b3;
        b3 = e2(b3, c3);
        b3.return = a2;
        return b3;
      }
      function k2(a2, b3, c3, d3) {
        var f3 = c3.type;
        if (f3 === ya)
          return m2(a2, b3, c3.props.children, d3, c3.key);
        if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b3.type))
          return d3 = e2(b3, c3.props), d3.ref = sh(a2, b3, c3), d3.return = a2, d3;
        d3 = yh(c3.type, c3.key, c3.props, null, a2.mode, d3);
        d3.ref = sh(a2, b3, c3);
        d3.return = a2;
        return d3;
      }
      function l2(a2, b3, c3, d3) {
        if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
          return b3 = zh(c3, a2.mode, d3), b3.return = a2, b3;
        b3 = e2(b3, c3.children || []);
        b3.return = a2;
        return b3;
      }
      function m2(a2, b3, c3, d3, f3) {
        if (null === b3 || 7 !== b3.tag)
          return b3 = Ah(c3, a2.mode, d3, f3), b3.return = a2, b3;
        b3 = e2(b3, c3);
        b3.return = a2;
        return b3;
      }
      function q2(a2, b3, c3) {
        if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
          return b3 = xh("" + b3, a2.mode, c3), b3.return = a2, b3;
        if ("object" === typeof b3 && null !== b3) {
          switch (b3.$$typeof) {
            case va:
              return c3 = yh(b3.type, b3.key, b3.props, null, a2.mode, c3), c3.ref = sh(a2, null, b3), c3.return = a2, c3;
            case wa:
              return b3 = zh(b3, a2.mode, c3), b3.return = a2, b3;
            case Ha:
              var d3 = b3._init;
              return q2(a2, d3(b3._payload), c3);
          }
          if (eb(b3) || Ka(b3))
            return b3 = Ah(b3, a2.mode, c3, null), b3.return = a2, b3;
          th(a2, b3);
        }
        return null;
      }
      function r2(a2, b3, c3, d3) {
        var e3 = null !== b3 ? b3.key : null;
        if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
          return null !== e3 ? null : h2(a2, b3, "" + c3, d3);
        if ("object" === typeof c3 && null !== c3) {
          switch (c3.$$typeof) {
            case va:
              return c3.key === e3 ? k2(a2, b3, c3, d3) : null;
            case wa:
              return c3.key === e3 ? l2(a2, b3, c3, d3) : null;
            case Ha:
              return e3 = c3._init, r2(
                a2,
                b3,
                e3(c3._payload),
                d3
              );
          }
          if (eb(c3) || Ka(c3))
            return null !== e3 ? null : m2(a2, b3, c3, d3, null);
          th(a2, c3);
        }
        return null;
      }
      function y2(a2, b3, c3, d3, e3) {
        if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
          return a2 = a2.get(c3) || null, h2(b3, a2, "" + d3, e3);
        if ("object" === typeof d3 && null !== d3) {
          switch (d3.$$typeof) {
            case va:
              return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a2, d3, e3);
            case wa:
              return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a2, d3, e3);
            case Ha:
              var f3 = d3._init;
              return y2(a2, b3, c3, f3(d3._payload), e3);
          }
          if (eb(d3) || Ka(d3))
            return a2 = a2.get(c3) || null, m2(b3, a2, d3, e3, null);
          th(b3, d3);
        }
        return null;
      }
      function n2(e3, g3, h3, k3) {
        for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
          u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
          var n3 = r2(e3, u2, h3[w2], k3);
          if (null === n3) {
            null === u2 && (u2 = x2);
            break;
          }
          a && u2 && null === n3.alternate && b2(e3, u2);
          g3 = f2(n3, g3, w2);
          null === m3 ? l3 = n3 : m3.sibling = n3;
          m3 = n3;
          u2 = x2;
        }
        if (w2 === h3.length)
          return c2(e3, u2), I && tg(e3, w2), l3;
        if (null === u2) {
          for (; w2 < h3.length; w2++)
            u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
          I && tg(e3, w2);
          return l3;
        }
        for (u2 = d2(e3, u2); w2 < h3.length; w2++)
          x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
        a && u2.forEach(function(a2) {
          return b2(e3, a2);
        });
        I && tg(e3, w2);
        return l3;
      }
      function t2(e3, g3, h3, k3) {
        var l3 = Ka(h3);
        if ("function" !== typeof l3)
          throw Error(p$1(150));
        h3 = l3.call(h3);
        if (null == h3)
          throw Error(p$1(151));
        for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
          m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
          var t3 = r2(e3, m3, n3.value, k3);
          if (null === t3) {
            null === m3 && (m3 = x2);
            break;
          }
          a && m3 && null === t3.alternate && b2(e3, m3);
          g3 = f2(t3, g3, w2);
          null === u2 ? l3 = t3 : u2.sibling = t3;
          u2 = t3;
          m3 = x2;
        }
        if (n3.done)
          return c2(
            e3,
            m3
          ), I && tg(e3, w2), l3;
        if (null === m3) {
          for (; !n3.done; w2++, n3 = h3.next())
            n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
          I && tg(e3, w2);
          return l3;
        }
        for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next())
          n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
        a && m3.forEach(function(a2) {
          return b2(e3, a2);
        });
        I && tg(e3, w2);
        return l3;
      }
      function J2(a2, d3, f3, h3) {
        "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
        if ("object" === typeof f3 && null !== f3) {
          switch (f3.$$typeof) {
            case va:
              a: {
                for (var k3 = f3.key, l3 = d3; null !== l3; ) {
                  if (l3.key === k3) {
                    k3 = f3.type;
                    if (k3 === ya) {
                      if (7 === l3.tag) {
                        c2(a2, l3.sibling);
                        d3 = e2(l3, f3.props.children);
                        d3.return = a2;
                        a2 = d3;
                        break a;
                      }
                    } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l3.type) {
                      c2(a2, l3.sibling);
                      d3 = e2(l3, f3.props);
                      d3.ref = sh(a2, l3, f3);
                      d3.return = a2;
                      a2 = d3;
                      break a;
                    }
                    c2(a2, l3);
                    break;
                  } else
                    b2(a2, l3);
                  l3 = l3.sibling;
                }
                f3.type === ya ? (d3 = Ah(f3.props.children, a2.mode, h3, f3.key), d3.return = a2, a2 = d3) : (h3 = yh(f3.type, f3.key, f3.props, null, a2.mode, h3), h3.ref = sh(a2, d3, f3), h3.return = a2, a2 = h3);
              }
              return g2(a2);
            case wa:
              a: {
                for (l3 = f3.key; null !== d3; ) {
                  if (d3.key === l3)
                    if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                      c2(a2, d3.sibling);
                      d3 = e2(d3, f3.children || []);
                      d3.return = a2;
                      a2 = d3;
                      break a;
                    } else {
                      c2(a2, d3);
                      break;
                    }
                  else
                    b2(a2, d3);
                  d3 = d3.sibling;
                }
                d3 = zh(f3, a2.mode, h3);
                d3.return = a2;
                a2 = d3;
              }
              return g2(a2);
            case Ha:
              return l3 = f3._init, J2(a2, d3, l3(f3._payload), h3);
          }
          if (eb(f3))
            return n2(a2, d3, f3, h3);
          if (Ka(f3))
            return t2(a2, d3, f3, h3);
          th(a2, f3);
        }
        return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a2, d3.sibling), d3 = e2(d3, f3), d3.return = a2, a2 = d3) : (c2(a2, d3), d3 = xh(f3, a2.mode, h3), d3.return = a2, a2 = d3), g2(a2)) : c2(a2, d3);
      }
      return J2;
    }
    var Bh = vh(true), Ch = vh(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
    function Hh(a) {
      if (a === Dh)
        throw Error(p$1(174));
      return a;
    }
    function Ih(a, b2) {
      G(Gh, b2);
      G(Fh, a);
      G(Eh, Dh);
      a = b2.nodeType;
      switch (a) {
        case 9:
        case 11:
          b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
          break;
        default:
          a = 8 === a ? b2.parentNode : b2, b2 = a.namespaceURI || null, a = a.tagName, b2 = lb(b2, a);
      }
      E(Eh);
      G(Eh, b2);
    }
    function Jh() {
      E(Eh);
      E(Fh);
      E(Gh);
    }
    function Kh(a) {
      Hh(Gh.current);
      var b2 = Hh(Eh.current);
      var c2 = lb(b2, a.type);
      b2 !== c2 && (G(Fh, a), G(Eh, c2));
    }
    function Lh(a) {
      Fh.current === a && (E(Eh), E(Fh));
    }
    var M = Uf(0);
    function Mh(a) {
      for (var b2 = a; null !== b2; ) {
        if (13 === b2.tag) {
          var c2 = b2.memoizedState;
          if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
            return b2;
        } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
          if (0 !== (b2.flags & 128))
            return b2;
        } else if (null !== b2.child) {
          b2.child.return = b2;
          b2 = b2.child;
          continue;
        }
        if (b2 === a)
          break;
        for (; null === b2.sibling; ) {
          if (null === b2.return || b2.return === a)
            return null;
          b2 = b2.return;
        }
        b2.sibling.return = b2.return;
        b2 = b2.sibling;
      }
      return null;
    }
    var Nh = [];
    function Oh() {
      for (var a = 0; a < Nh.length; a++)
        Nh[a]._workInProgressVersionPrimary = null;
      Nh.length = 0;
    }
    var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N = null, O = null, P = null, Sh = false, Th = false, Uh = 0, Vh = 0;
    function Q() {
      throw Error(p$1(321));
    }
    function Wh(a, b2) {
      if (null === b2)
        return false;
      for (var c2 = 0; c2 < b2.length && c2 < a.length; c2++)
        if (!He(a[c2], b2[c2]))
          return false;
      return true;
    }
    function Xh(a, b2, c2, d2, e2, f2) {
      Rh = f2;
      N = b2;
      b2.memoizedState = null;
      b2.updateQueue = null;
      b2.lanes = 0;
      Ph.current = null === a || null === a.memoizedState ? Yh : Zh;
      a = c2(d2, e2);
      if (Th) {
        f2 = 0;
        do {
          Th = false;
          Uh = 0;
          if (25 <= f2)
            throw Error(p$1(301));
          f2 += 1;
          P = O = null;
          b2.updateQueue = null;
          Ph.current = $h;
          a = c2(d2, e2);
        } while (Th);
      }
      Ph.current = ai;
      b2 = null !== O && null !== O.next;
      Rh = 0;
      P = O = N = null;
      Sh = false;
      if (b2)
        throw Error(p$1(300));
      return a;
    }
    function bi() {
      var a = 0 !== Uh;
      Uh = 0;
      return a;
    }
    function ci() {
      var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      null === P ? N.memoizedState = P = a : P = P.next = a;
      return P;
    }
    function di() {
      if (null === O) {
        var a = N.alternate;
        a = null !== a ? a.memoizedState : null;
      } else
        a = O.next;
      var b2 = null === P ? N.memoizedState : P.next;
      if (null !== b2)
        P = b2, O = a;
      else {
        if (null === a)
          throw Error(p$1(310));
        O = a;
        a = { memoizedState: O.memoizedState, baseState: O.baseState, baseQueue: O.baseQueue, queue: O.queue, next: null };
        null === P ? N.memoizedState = P = a : P = P.next = a;
      }
      return P;
    }
    function ei(a, b2) {
      return "function" === typeof b2 ? b2(a) : b2;
    }
    function fi(a) {
      var b2 = di(), c2 = b2.queue;
      if (null === c2)
        throw Error(p$1(311));
      c2.lastRenderedReducer = a;
      var d2 = O, e2 = d2.baseQueue, f2 = c2.pending;
      if (null !== f2) {
        if (null !== e2) {
          var g2 = e2.next;
          e2.next = f2.next;
          f2.next = g2;
        }
        d2.baseQueue = e2 = f2;
        c2.pending = null;
      }
      if (null !== e2) {
        f2 = e2.next;
        d2 = d2.baseState;
        var h2 = g2 = null, k2 = null, l2 = f2;
        do {
          var m2 = l2.lane;
          if ((Rh & m2) === m2)
            null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a(d2, l2.action);
          else {
            var q2 = {
              lane: m2,
              action: l2.action,
              hasEagerState: l2.hasEagerState,
              eagerState: l2.eagerState,
              next: null
            };
            null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
            N.lanes |= m2;
            hh |= m2;
          }
          l2 = l2.next;
        } while (null !== l2 && l2 !== f2);
        null === k2 ? g2 = d2 : k2.next = h2;
        He(d2, b2.memoizedState) || (Ug = true);
        b2.memoizedState = d2;
        b2.baseState = g2;
        b2.baseQueue = k2;
        c2.lastRenderedState = d2;
      }
      a = c2.interleaved;
      if (null !== a) {
        e2 = a;
        do
          f2 = e2.lane, N.lanes |= f2, hh |= f2, e2 = e2.next;
        while (e2 !== a);
      } else
        null === e2 && (c2.lanes = 0);
      return [b2.memoizedState, c2.dispatch];
    }
    function gi(a) {
      var b2 = di(), c2 = b2.queue;
      if (null === c2)
        throw Error(p$1(311));
      c2.lastRenderedReducer = a;
      var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
      if (null !== e2) {
        c2.pending = null;
        var g2 = e2 = e2.next;
        do
          f2 = a(f2, g2.action), g2 = g2.next;
        while (g2 !== e2);
        He(f2, b2.memoizedState) || (Ug = true);
        b2.memoizedState = f2;
        null === b2.baseQueue && (b2.baseState = f2);
        c2.lastRenderedState = f2;
      }
      return [f2, d2];
    }
    function hi() {
    }
    function ii(a, b2) {
      var c2 = N, d2 = di(), e2 = b2(), f2 = !He(d2.memoizedState, e2);
      f2 && (d2.memoizedState = e2, Ug = true);
      d2 = d2.queue;
      ji(ki.bind(null, c2, d2, a), [a]);
      if (d2.getSnapshot !== b2 || f2 || null !== P && P.memoizedState.tag & 1) {
        c2.flags |= 2048;
        li(9, mi.bind(null, c2, d2, e2, b2), void 0, null);
        if (null === R)
          throw Error(p$1(349));
        0 !== (Rh & 30) || ni(c2, b2, e2);
      }
      return e2;
    }
    function ni(a, b2, c2) {
      a.flags |= 16384;
      a = { getSnapshot: b2, value: c2 };
      b2 = N.updateQueue;
      null === b2 ? (b2 = { lastEffect: null, stores: null }, N.updateQueue = b2, b2.stores = [a]) : (c2 = b2.stores, null === c2 ? b2.stores = [a] : c2.push(a));
    }
    function mi(a, b2, c2, d2) {
      b2.value = c2;
      b2.getSnapshot = d2;
      oi(b2) && pi(a);
    }
    function ki(a, b2, c2) {
      return c2(function() {
        oi(b2) && pi(a);
      });
    }
    function oi(a) {
      var b2 = a.getSnapshot;
      a = a.value;
      try {
        var c2 = b2();
        return !He(a, c2);
      } catch (d2) {
        return true;
      }
    }
    function pi(a) {
      var b2 = Zg(a, 1);
      null !== b2 && mh(b2, a, 1, -1);
    }
    function qi(a) {
      var b2 = ci();
      "function" === typeof a && (a = a());
      b2.memoizedState = b2.baseState = a;
      a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a };
      b2.queue = a;
      a = a.dispatch = ri.bind(null, N, a);
      return [b2.memoizedState, a];
    }
    function li(a, b2, c2, d2) {
      a = { tag: a, create: b2, destroy: c2, deps: d2, next: null };
      b2 = N.updateQueue;
      null === b2 ? (b2 = { lastEffect: null, stores: null }, N.updateQueue = b2, b2.lastEffect = a.next = a) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a.next = a : (d2 = c2.next, c2.next = a, a.next = d2, b2.lastEffect = a));
      return a;
    }
    function si() {
      return di().memoizedState;
    }
    function ti(a, b2, c2, d2) {
      var e2 = ci();
      N.flags |= a;
      e2.memoizedState = li(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
    }
    function ui(a, b2, c2, d2) {
      var e2 = di();
      d2 = void 0 === d2 ? null : d2;
      var f2 = void 0;
      if (null !== O) {
        var g2 = O.memoizedState;
        f2 = g2.destroy;
        if (null !== d2 && Wh(d2, g2.deps)) {
          e2.memoizedState = li(b2, c2, f2, d2);
          return;
        }
      }
      N.flags |= a;
      e2.memoizedState = li(1 | b2, c2, f2, d2);
    }
    function vi(a, b2) {
      return ti(8390656, 8, a, b2);
    }
    function ji(a, b2) {
      return ui(2048, 8, a, b2);
    }
    function wi(a, b2) {
      return ui(4, 2, a, b2);
    }
    function xi(a, b2) {
      return ui(4, 4, a, b2);
    }
    function yi(a, b2) {
      if ("function" === typeof b2)
        return a = a(), b2(a), function() {
          b2(null);
        };
      if (null !== b2 && void 0 !== b2)
        return a = a(), b2.current = a, function() {
          b2.current = null;
        };
    }
    function zi(a, b2, c2) {
      c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
      return ui(4, 4, yi.bind(null, b2, a), c2);
    }
    function Ai() {
    }
    function Bi(a, b2) {
      var c2 = di();
      b2 = void 0 === b2 ? null : b2;
      var d2 = c2.memoizedState;
      if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
        return d2[0];
      c2.memoizedState = [a, b2];
      return a;
    }
    function Ci(a, b2) {
      var c2 = di();
      b2 = void 0 === b2 ? null : b2;
      var d2 = c2.memoizedState;
      if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
        return d2[0];
      a = a();
      c2.memoizedState = [a, b2];
      return a;
    }
    function Di(a, b2, c2) {
      if (0 === (Rh & 21))
        return a.baseState && (a.baseState = false, Ug = true), a.memoizedState = c2;
      He(c2, b2) || (c2 = yc(), N.lanes |= c2, hh |= c2, a.baseState = true);
      return b2;
    }
    function Ei(a, b2) {
      var c2 = C;
      C = 0 !== c2 && 4 > c2 ? c2 : 4;
      a(true);
      var d2 = Qh.transition;
      Qh.transition = {};
      try {
        a(false), b2();
      } finally {
        C = c2, Qh.transition = d2;
      }
    }
    function Fi() {
      return di().memoizedState;
    }
    function Gi(a, b2, c2) {
      var d2 = lh(a);
      c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
      if (Hi(a))
        Ii(b2, c2);
      else if (c2 = Yg(a, b2, c2, d2), null !== c2) {
        var e2 = L();
        mh(c2, a, d2, e2);
        Ji(c2, b2, d2);
      }
    }
    function ri(a, b2, c2) {
      var d2 = lh(a), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
      if (Hi(a))
        Ii(b2, e2);
      else {
        var f2 = a.alternate;
        if (0 === a.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
          try {
            var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
            e2.hasEagerState = true;
            e2.eagerState = h2;
            if (He(h2, g2)) {
              var k2 = b2.interleaved;
              null === k2 ? (e2.next = e2, Xg(b2)) : (e2.next = k2.next, k2.next = e2);
              b2.interleaved = e2;
              return;
            }
          } catch (l2) {
          } finally {
          }
        c2 = Yg(a, b2, e2, d2);
        null !== c2 && (e2 = L(), mh(c2, a, d2, e2), Ji(c2, b2, d2));
      }
    }
    function Hi(a) {
      var b2 = a.alternate;
      return a === N || null !== b2 && b2 === N;
    }
    function Ii(a, b2) {
      Th = Sh = true;
      var c2 = a.pending;
      null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
      a.pending = b2;
    }
    function Ji(a, b2, c2) {
      if (0 !== (c2 & 4194240)) {
        var d2 = b2.lanes;
        d2 &= a.pendingLanes;
        c2 |= d2;
        b2.lanes = c2;
        Cc(a, c2);
      }
    }
    var ai = { readContext: Vg, useCallback: Q, useContext: Q, useEffect: Q, useImperativeHandle: Q, useInsertionEffect: Q, useLayoutEffect: Q, useMemo: Q, useReducer: Q, useRef: Q, useState: Q, useDebugValue: Q, useDeferredValue: Q, useTransition: Q, useMutableSource: Q, useSyncExternalStore: Q, useId: Q, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a, b2) {
      ci().memoizedState = [a, void 0 === b2 ? null : b2];
      return a;
    }, useContext: Vg, useEffect: vi, useImperativeHandle: function(a, b2, c2) {
      c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
      return ti(
        4194308,
        4,
        yi.bind(null, b2, a),
        c2
      );
    }, useLayoutEffect: function(a, b2) {
      return ti(4194308, 4, a, b2);
    }, useInsertionEffect: function(a, b2) {
      return ti(4, 2, a, b2);
    }, useMemo: function(a, b2) {
      var c2 = ci();
      b2 = void 0 === b2 ? null : b2;
      a = a();
      c2.memoizedState = [a, b2];
      return a;
    }, useReducer: function(a, b2, c2) {
      var d2 = ci();
      b2 = void 0 !== c2 ? c2(b2) : b2;
      d2.memoizedState = d2.baseState = b2;
      a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b2 };
      d2.queue = a;
      a = a.dispatch = Gi.bind(null, N, a);
      return [d2.memoizedState, a];
    }, useRef: function(a) {
      var b2 = ci();
      a = { current: a };
      return b2.memoizedState = a;
    }, useState: qi, useDebugValue: Ai, useDeferredValue: function(a) {
      return ci().memoizedState = a;
    }, useTransition: function() {
      var a = qi(false), b2 = a[0];
      a = Ei.bind(null, a[1]);
      ci().memoizedState = a;
      return [b2, a];
    }, useMutableSource: function() {
    }, useSyncExternalStore: function(a, b2, c2) {
      var d2 = N, e2 = ci();
      if (I) {
        if (void 0 === c2)
          throw Error(p$1(407));
        c2 = c2();
      } else {
        c2 = b2();
        if (null === R)
          throw Error(p$1(349));
        0 !== (Rh & 30) || ni(d2, b2, c2);
      }
      e2.memoizedState = c2;
      var f2 = { value: c2, getSnapshot: b2 };
      e2.queue = f2;
      vi(ki.bind(
        null,
        d2,
        f2,
        a
      ), [a]);
      d2.flags |= 2048;
      li(9, mi.bind(null, d2, f2, c2, b2), void 0, null);
      return c2;
    }, useId: function() {
      var a = ci(), b2 = R.identifierPrefix;
      if (I) {
        var c2 = sg;
        var d2 = rg;
        c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
        b2 = ":" + b2 + "R" + c2;
        c2 = Uh++;
        0 < c2 && (b2 += "H" + c2.toString(32));
        b2 += ":";
      } else
        c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
      return a.memoizedState = b2;
    }, unstable_isNewReconciler: false }, Zh = {
      readContext: Vg,
      useCallback: Bi,
      useContext: Vg,
      useEffect: ji,
      useImperativeHandle: zi,
      useInsertionEffect: wi,
      useLayoutEffect: xi,
      useMemo: Ci,
      useReducer: fi,
      useRef: si,
      useState: function() {
        return fi(ei);
      },
      useDebugValue: Ai,
      useDeferredValue: function(a) {
        var b2 = di();
        return Di(b2, O.memoizedState, a);
      },
      useTransition: function() {
        var a = fi(ei)[0], b2 = di().memoizedState;
        return [a, b2];
      },
      useMutableSource: hi,
      useSyncExternalStore: ii,
      useId: Fi,
      unstable_isNewReconciler: false
    }, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
      return gi(ei);
    }, useDebugValue: Ai, useDeferredValue: function(a) {
      var b2 = di();
      return null === O ? b2.memoizedState = a : Di(b2, O.memoizedState, a);
    }, useTransition: function() {
      var a = gi(ei)[0], b2 = di().memoizedState;
      return [a, b2];
    }, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
    function Ki(a, b2) {
      try {
        var c2 = "", d2 = b2;
        do
          c2 += Pa(d2), d2 = d2.return;
        while (d2);
        var e2 = c2;
      } catch (f2) {
        e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
      }
      return { value: a, source: b2, stack: e2, digest: null };
    }
    function Li(a, b2, c2) {
      return { value: a, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
    }
    function Mi(a, b2) {
      try {
        console.error(b2.value);
      } catch (c2) {
        setTimeout(function() {
          throw c2;
        });
      }
    }
    var Ni = "function" === typeof WeakMap ? WeakMap : Map;
    function Oi(a, b2, c2) {
      c2 = ch(-1, c2);
      c2.tag = 3;
      c2.payload = { element: null };
      var d2 = b2.value;
      c2.callback = function() {
        Pi || (Pi = true, Qi = d2);
        Mi(a, b2);
      };
      return c2;
    }
    function Ri(a, b2, c2) {
      c2 = ch(-1, c2);
      c2.tag = 3;
      var d2 = a.type.getDerivedStateFromError;
      if ("function" === typeof d2) {
        var e2 = b2.value;
        c2.payload = function() {
          return d2(e2);
        };
        c2.callback = function() {
          Mi(a, b2);
        };
      }
      var f2 = a.stateNode;
      null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
        Mi(a, b2);
        "function" !== typeof d2 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
        var c3 = b2.stack;
        this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
      });
      return c2;
    }
    function Ti(a, b2, c2) {
      var d2 = a.pingCache;
      if (null === d2) {
        d2 = a.pingCache = new Ni();
        var e2 = /* @__PURE__ */ new Set();
        d2.set(b2, e2);
      } else
        e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
      e2.has(c2) || (e2.add(c2), a = Ui.bind(null, a, b2, c2), b2.then(a, a));
    }
    function Vi(a) {
      do {
        var b2;
        if (b2 = 13 === a.tag)
          b2 = a.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
        if (b2)
          return a;
        a = a.return;
      } while (null !== a);
      return null;
    }
    function Wi(a, b2, c2, d2, e2) {
      if (0 === (a.mode & 1))
        return a === b2 ? a.flags |= 65536 : (a.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a;
      a.flags |= 65536;
      a.lanes = e2;
      return a;
    }
    var Xi = ua.ReactCurrentOwner, Ug = false;
    function Yi(a, b2, c2, d2) {
      b2.child = null === a ? Ch(b2, null, c2, d2) : Bh(b2, a.child, c2, d2);
    }
    function Zi(a, b2, c2, d2, e2) {
      c2 = c2.render;
      var f2 = b2.ref;
      Tg(b2, e2);
      d2 = Xh(a, b2, c2, d2, f2, e2);
      c2 = bi();
      if (null !== a && !Ug)
        return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, $i(a, b2, e2);
      I && c2 && vg(b2);
      b2.flags |= 1;
      Yi(a, b2, d2, e2);
      return b2.child;
    }
    function aj(a, b2, c2, d2, e2) {
      if (null === a) {
        var f2 = c2.type;
        if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
          return b2.tag = 15, b2.type = f2, cj(a, b2, f2, d2, e2);
        a = yh(c2.type, null, d2, b2, b2.mode, e2);
        a.ref = b2.ref;
        a.return = b2;
        return b2.child = a;
      }
      f2 = a.child;
      if (0 === (a.lanes & e2)) {
        var g2 = f2.memoizedProps;
        c2 = c2.compare;
        c2 = null !== c2 ? c2 : Ie;
        if (c2(g2, d2) && a.ref === b2.ref)
          return $i(a, b2, e2);
      }
      b2.flags |= 1;
      a = wh(f2, d2);
      a.ref = b2.ref;
      a.return = b2;
      return b2.child = a;
    }
    function cj(a, b2, c2, d2, e2) {
      if (null !== a) {
        var f2 = a.memoizedProps;
        if (Ie(f2, d2) && a.ref === b2.ref)
          if (Ug = false, b2.pendingProps = d2 = f2, 0 !== (a.lanes & e2))
            0 !== (a.flags & 131072) && (Ug = true);
          else
            return b2.lanes = a.lanes, $i(a, b2, e2);
      }
      return dj(a, b2, c2, d2, e2);
    }
    function ej(a, b2, c2) {
      var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a ? a.memoizedState : null;
      if ("hidden" === d2.mode)
        if (0 === (b2.mode & 1))
          b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(fj, gj), gj |= c2;
        else {
          if (0 === (c2 & 1073741824))
            return a = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b2.updateQueue = null, G(fj, gj), gj |= a, null;
          b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
          d2 = null !== f2 ? f2.baseLanes : c2;
          G(fj, gj);
          gj |= d2;
        }
      else
        null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G(fj, gj), gj |= d2;
      Yi(a, b2, e2, c2);
      return b2.child;
    }
    function hj(a, b2) {
      var c2 = b2.ref;
      if (null === a && null !== c2 || null !== a && a.ref !== c2)
        b2.flags |= 512, b2.flags |= 2097152;
    }
    function dj(a, b2, c2, d2, e2) {
      var f2 = Zf(c2) ? Xf : H.current;
      f2 = Yf(b2, f2);
      Tg(b2, e2);
      c2 = Xh(a, b2, c2, d2, f2, e2);
      d2 = bi();
      if (null !== a && !Ug)
        return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, $i(a, b2, e2);
      I && d2 && vg(b2);
      b2.flags |= 1;
      Yi(a, b2, c2, e2);
      return b2.child;
    }
    function ij(a, b2, c2, d2, e2) {
      if (Zf(c2)) {
        var f2 = true;
        cg(b2);
      } else
        f2 = false;
      Tg(b2, e2);
      if (null === b2.stateNode)
        jj(a, b2), ph(b2, c2, d2), rh(b2, c2, d2, e2), d2 = true;
      else if (null === a) {
        var g2 = b2.stateNode, h2 = b2.memoizedProps;
        g2.props = h2;
        var k2 = g2.context, l2 = c2.contextType;
        "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H.current, l2 = Yf(b2, l2));
        var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
        q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && qh(b2, g2, d2, l2);
        $g = false;
        var r2 = b2.memoizedState;
        g2.state = r2;
        gh(b2, d2, g2, e2);
        k2 = b2.memoizedState;
        h2 !== d2 || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
      } else {
        g2 = b2.stateNode;
        bh(a, b2);
        h2 = b2.memoizedProps;
        l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
        g2.props = l2;
        q2 = b2.pendingProps;
        r2 = g2.context;
        k2 = c2.contextType;
        "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c2) ? Xf : H.current, k2 = Yf(b2, k2));
        var y2 = c2.getDerivedStateFromProps;
        (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b2, g2, d2, k2);
        $g = false;
        r2 = b2.memoizedState;
        g2.state = r2;
        gh(b2, d2, g2, e2);
        var n2 = b2.memoizedState;
        h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), d2 = false);
      }
      return kj(a, b2, c2, d2, f2, e2);
    }
    function kj(a, b2, c2, d2, e2, f2) {
      hj(a, b2);
      var g2 = 0 !== (b2.flags & 128);
      if (!d2 && !g2)
        return e2 && dg(b2, c2, false), $i(a, b2, f2);
      d2 = b2.stateNode;
      Xi.current = b2;
      var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
      b2.flags |= 1;
      null !== a && g2 ? (b2.child = Bh(b2, a.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi(a, b2, h2, f2);
      b2.memoizedState = d2.state;
      e2 && dg(b2, c2, true);
      return b2.child;
    }
    function lj(a) {
      var b2 = a.stateNode;
      b2.pendingContext ? ag(a, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a, b2.context, false);
      Ih(a, b2.containerInfo);
    }
    function mj(a, b2, c2, d2, e2) {
      Ig();
      Jg(e2);
      b2.flags |= 256;
      Yi(a, b2, c2, d2);
      return b2.child;
    }
    var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
    function oj(a) {
      return { baseLanes: a, cachePool: null, transitions: null };
    }
    function pj(a, b2, c2) {
      var d2 = b2.pendingProps, e2 = M.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
      (h2 = g2) || (h2 = null !== a && null === a.memoizedState ? false : 0 !== (e2 & 2));
      if (h2)
        f2 = true, b2.flags &= -129;
      else if (null === a || null !== a.memoizedState)
        e2 |= 1;
      G(M, e2 & 1);
      if (null === a) {
        Eg(b2);
        a = b2.memoizedState;
        if (null !== a && (a = a.dehydrated, null !== a))
          return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
        g2 = d2.children;
        a = d2.fallback;
        return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d2, 0, null), a = Ah(a, d2, c2, null), f2.return = b2, a.return = b2, f2.sibling = a, b2.child = f2, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a) : rj(b2, g2);
      }
      e2 = a.memoizedState;
      if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
        return sj(a, b2, g2, d2, h2, e2, c2);
      if (f2) {
        f2 = d2.fallback;
        g2 = b2.mode;
        e2 = a.child;
        h2 = e2.sibling;
        var k2 = { mode: "hidden", children: d2.children };
        0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = wh(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
        null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g2, c2, null), f2.flags |= 2);
        f2.return = b2;
        d2.return = b2;
        d2.sibling = f2;
        b2.child = d2;
        d2 = f2;
        f2 = b2.child;
        g2 = a.child.memoizedState;
        g2 = null === g2 ? oj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
        f2.memoizedState = g2;
        f2.childLanes = a.childLanes & ~c2;
        b2.memoizedState = nj;
        return d2;
      }
      f2 = a.child;
      a = f2.sibling;
      d2 = wh(f2, { mode: "visible", children: d2.children });
      0 === (b2.mode & 1) && (d2.lanes = c2);
      d2.return = b2;
      d2.sibling = null;
      null !== a && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a], b2.flags |= 16) : c2.push(a));
      b2.child = d2;
      b2.memoizedState = null;
      return d2;
    }
    function rj(a, b2) {
      b2 = qj({ mode: "visible", children: b2 }, a.mode, 0, null);
      b2.return = a;
      return a.child = b2;
    }
    function tj(a, b2, c2, d2) {
      null !== d2 && Jg(d2);
      Bh(b2, a.child, null, c2);
      a = rj(b2, b2.pendingProps.children);
      a.flags |= 2;
      b2.memoizedState = null;
      return a;
    }
    function sj(a, b2, c2, d2, e2, f2, g2) {
      if (c2) {
        if (b2.flags & 256)
          return b2.flags &= -257, d2 = Li(Error(p$1(422))), tj(a, b2, g2, d2);
        if (null !== b2.memoizedState)
          return b2.child = a.child, b2.flags |= 128, null;
        f2 = d2.fallback;
        e2 = b2.mode;
        d2 = qj({ mode: "visible", children: d2.children }, e2, 0, null);
        f2 = Ah(f2, e2, g2, null);
        f2.flags |= 2;
        d2.return = b2;
        f2.return = b2;
        d2.sibling = f2;
        b2.child = d2;
        0 !== (b2.mode & 1) && Bh(b2, a.child, null, g2);
        b2.child.memoizedState = oj(g2);
        b2.memoizedState = nj;
        return f2;
      }
      if (0 === (b2.mode & 1))
        return tj(a, b2, g2, null);
      if ("$!" === e2.data) {
        d2 = e2.nextSibling && e2.nextSibling.dataset;
        if (d2)
          var h2 = d2.dgst;
        d2 = h2;
        f2 = Error(p$1(419));
        d2 = Li(f2, d2, void 0);
        return tj(a, b2, g2, d2);
      }
      h2 = 0 !== (g2 & a.childLanes);
      if (Ug || h2) {
        d2 = R;
        if (null !== d2) {
          switch (g2 & -g2) {
            case 4:
              e2 = 2;
              break;
            case 16:
              e2 = 8;
              break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              e2 = 32;
              break;
            case 536870912:
              e2 = 268435456;
              break;
            default:
              e2 = 0;
          }
          e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
          0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, Zg(a, e2), mh(d2, a, e2, -1));
        }
        uj();
        d2 = Li(Error(p$1(421)));
        return tj(a, b2, g2, d2);
      }
      if ("$?" === e2.data)
        return b2.flags |= 128, b2.child = a.child, b2 = vj.bind(null, a), e2._reactRetry = b2, null;
      a = f2.treeContext;
      yg = Lf(e2.nextSibling);
      xg = b2;
      I = true;
      zg = null;
      null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b2);
      b2 = rj(b2, d2.children);
      b2.flags |= 4096;
      return b2;
    }
    function wj(a, b2, c2) {
      a.lanes |= b2;
      var d2 = a.alternate;
      null !== d2 && (d2.lanes |= b2);
      Sg(a.return, b2, c2);
    }
    function xj(a, b2, c2, d2, e2) {
      var f2 = a.memoizedState;
      null === f2 ? a.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
    }
    function yj(a, b2, c2) {
      var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
      Yi(a, b2, d2.children, c2);
      d2 = M.current;
      if (0 !== (d2 & 2))
        d2 = d2 & 1 | 2, b2.flags |= 128;
      else {
        if (null !== a && 0 !== (a.flags & 128))
          a:
            for (a = b2.child; null !== a; ) {
              if (13 === a.tag)
                null !== a.memoizedState && wj(a, c2, b2);
              else if (19 === a.tag)
                wj(a, c2, b2);
              else if (null !== a.child) {
                a.child.return = a;
                a = a.child;
                continue;
              }
              if (a === b2)
                break a;
              for (; null === a.sibling; ) {
                if (null === a.return || a.return === b2)
                  break a;
                a = a.return;
              }
              a.sibling.return = a.return;
              a = a.sibling;
            }
        d2 &= 1;
      }
      G(M, d2);
      if (0 === (b2.mode & 1))
        b2.memoizedState = null;
      else
        switch (e2) {
          case "forwards":
            c2 = b2.child;
            for (e2 = null; null !== c2; )
              a = c2.alternate, null !== a && null === Mh(a) && (e2 = c2), c2 = c2.sibling;
            c2 = e2;
            null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
            xj(b2, false, e2, c2, f2);
            break;
          case "backwards":
            c2 = null;
            e2 = b2.child;
            for (b2.child = null; null !== e2; ) {
              a = e2.alternate;
              if (null !== a && null === Mh(a)) {
                b2.child = e2;
                break;
              }
              a = e2.sibling;
              e2.sibling = c2;
              c2 = e2;
              e2 = a;
            }
            xj(b2, true, c2, null, f2);
            break;
          case "together":
            xj(b2, false, null, null, void 0);
            break;
          default:
            b2.memoizedState = null;
        }
      return b2.child;
    }
    function jj(a, b2) {
      0 === (b2.mode & 1) && null !== a && (a.alternate = null, b2.alternate = null, b2.flags |= 2);
    }
    function $i(a, b2, c2) {
      null !== a && (b2.dependencies = a.dependencies);
      hh |= b2.lanes;
      if (0 === (c2 & b2.childLanes))
        return null;
      if (null !== a && b2.child !== a.child)
        throw Error(p$1(153));
      if (null !== b2.child) {
        a = b2.child;
        c2 = wh(a, a.pendingProps);
        b2.child = c2;
        for (c2.return = b2; null !== a.sibling; )
          a = a.sibling, c2 = c2.sibling = wh(a, a.pendingProps), c2.return = b2;
        c2.sibling = null;
      }
      return b2.child;
    }
    function zj(a, b2, c2) {
      switch (b2.tag) {
        case 3:
          lj(b2);
          Ig();
          break;
        case 5:
          Kh(b2);
          break;
        case 1:
          Zf(b2.type) && cg(b2);
          break;
        case 4:
          Ih(b2, b2.stateNode.containerInfo);
          break;
        case 10:
          var d2 = b2.type._context, e2 = b2.memoizedProps.value;
          G(Mg, d2._currentValue);
          d2._currentValue = e2;
          break;
        case 13:
          d2 = b2.memoizedState;
          if (null !== d2) {
            if (null !== d2.dehydrated)
              return G(M, M.current & 1), b2.flags |= 128, null;
            if (0 !== (c2 & b2.child.childLanes))
              return pj(a, b2, c2);
            G(M, M.current & 1);
            a = $i(a, b2, c2);
            return null !== a ? a.sibling : null;
          }
          G(M, M.current & 1);
          break;
        case 19:
          d2 = 0 !== (c2 & b2.childLanes);
          if (0 !== (a.flags & 128)) {
            if (d2)
              return yj(a, b2, c2);
            b2.flags |= 128;
          }
          e2 = b2.memoizedState;
          null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
          G(M, M.current);
          if (d2)
            break;
          else
            return null;
        case 22:
        case 23:
          return b2.lanes = 0, ej(a, b2, c2);
      }
      return $i(a, b2, c2);
    }
    var Aj, Bj, Cj, Dj;
    Aj = function(a, b2) {
      for (var c2 = b2.child; null !== c2; ) {
        if (5 === c2.tag || 6 === c2.tag)
          a.appendChild(c2.stateNode);
        else if (4 !== c2.tag && null !== c2.child) {
          c2.child.return = c2;
          c2 = c2.child;
          continue;
        }
        if (c2 === b2)
          break;
        for (; null === c2.sibling; ) {
          if (null === c2.return || c2.return === b2)
            return;
          c2 = c2.return;
        }
        c2.sibling.return = c2.return;
        c2 = c2.sibling;
      }
    };
    Bj = function() {
    };
    Cj = function(a, b2, c2, d2) {
      var e2 = a.memoizedProps;
      if (e2 !== d2) {
        a = b2.stateNode;
        Hh(Eh.current);
        var f2 = null;
        switch (c2) {
          case "input":
            e2 = Ya(a, e2);
            d2 = Ya(a, d2);
            f2 = [];
            break;
          case "select":
            e2 = A({}, e2, { value: void 0 });
            d2 = A({}, d2, { value: void 0 });
            f2 = [];
            break;
          case "textarea":
            e2 = gb(a, e2);
            d2 = gb(a, d2);
            f2 = [];
            break;
          default:
            "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a.onclick = Bf);
        }
        ub(c2, d2);
        var g2;
        c2 = null;
        for (l2 in e2)
          if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
            if ("style" === l2) {
              var h2 = e2[l2];
              for (g2 in h2)
                h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
            } else
              "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
        for (l2 in d2) {
          var k2 = d2[l2];
          h2 = null != e2 ? e2[l2] : void 0;
          if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
            if ("style" === l2)
              if (h2) {
                for (g2 in h2)
                  !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
                for (g2 in k2)
                  k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
              } else
                c2 || (f2 || (f2 = []), f2.push(
                  l2,
                  c2
                )), c2 = k2;
            else
              "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D("scroll", a), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
        }
        c2 && (f2 = f2 || []).push("style", c2);
        var l2 = f2;
        if (b2.updateQueue = l2)
          b2.flags |= 4;
      }
    };
    Dj = function(a, b2, c2, d2) {
      c2 !== d2 && (b2.flags |= 4);
    };
    function Ej(a, b2) {
      if (!I)
        switch (a.tailMode) {
          case "hidden":
            b2 = a.tail;
            for (var c2 = null; null !== b2; )
              null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
            null === c2 ? a.tail = null : c2.sibling = null;
            break;
          case "collapsed":
            c2 = a.tail;
            for (var d2 = null; null !== c2; )
              null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
            null === d2 ? b2 || null === a.tail ? a.tail = null : a.tail.sibling = null : d2.sibling = null;
        }
    }
    function S(a) {
      var b2 = null !== a.alternate && a.alternate.child === a.child, c2 = 0, d2 = 0;
      if (b2)
        for (var e2 = a.child; null !== e2; )
          c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a, e2 = e2.sibling;
      else
        for (e2 = a.child; null !== e2; )
          c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a, e2 = e2.sibling;
      a.subtreeFlags |= d2;
      a.childLanes = c2;
      return b2;
    }
    function Fj(a, b2, c2) {
      var d2 = b2.pendingProps;
      wg(b2);
      switch (b2.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return S(b2), null;
        case 1:
          return Zf(b2.type) && $f(), S(b2), null;
        case 3:
          d2 = b2.stateNode;
          Jh();
          E(Wf);
          E(H);
          Oh();
          d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
          if (null === a || null === a.child)
            Gg(b2) ? b2.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
          Bj(a, b2);
          S(b2);
          return null;
        case 5:
          Lh(b2);
          var e2 = Hh(Gh.current);
          c2 = b2.type;
          if (null !== a && null != b2.stateNode)
            Cj(a, b2, c2, d2, e2), a.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
          else {
            if (!d2) {
              if (null === b2.stateNode)
                throw Error(p$1(166));
              S(b2);
              return null;
            }
            a = Hh(Eh.current);
            if (Gg(b2)) {
              d2 = b2.stateNode;
              c2 = b2.type;
              var f2 = b2.memoizedProps;
              d2[Of] = b2;
              d2[Pf] = f2;
              a = 0 !== (b2.mode & 1);
              switch (c2) {
                case "dialog":
                  D("cancel", d2);
                  D("close", d2);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", d2);
                  break;
                case "video":
                case "audio":
                  for (e2 = 0; e2 < lf.length; e2++)
                    D(lf[e2], d2);
                  break;
                case "source":
                  D("error", d2);
                  break;
                case "img":
                case "image":
                case "link":
                  D(
                    "error",
                    d2
                  );
                  D("load", d2);
                  break;
                case "details":
                  D("toggle", d2);
                  break;
                case "input":
                  Za(d2, f2);
                  D("invalid", d2);
                  break;
                case "select":
                  d2._wrapperState = { wasMultiple: !!f2.multiple };
                  D("invalid", d2);
                  break;
                case "textarea":
                  hb(d2, f2), D("invalid", d2);
              }
              ub(c2, f2);
              e2 = null;
              for (var g2 in f2)
                if (f2.hasOwnProperty(g2)) {
                  var h2 = f2[g2];
                  "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                    d2.textContent,
                    h2,
                    a
                  ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D("scroll", d2);
                }
              switch (c2) {
                case "input":
                  Va(d2);
                  db(d2, f2, true);
                  break;
                case "textarea":
                  Va(d2);
                  jb(d2);
                  break;
                case "select":
                case "option":
                  break;
                default:
                  "function" === typeof f2.onClick && (d2.onclick = Bf);
              }
              d2 = e2;
              b2.updateQueue = d2;
              null !== d2 && (b2.flags |= 4);
            } else {
              g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
              "http://www.w3.org/1999/xhtml" === a && (a = kb(c2));
              "http://www.w3.org/1999/xhtml" === a ? "script" === c2 ? (a = g2.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d2.is ? a = g2.createElement(c2, { is: d2.is }) : (a = g2.createElement(c2), "select" === c2 && (g2 = a, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a = g2.createElementNS(a, c2);
              a[Of] = b2;
              a[Pf] = d2;
              Aj(a, b2, false, false);
              b2.stateNode = a;
              a: {
                g2 = vb(c2, d2);
                switch (c2) {
                  case "dialog":
                    D("cancel", a);
                    D("close", a);
                    e2 = d2;
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D("load", a);
                    e2 = d2;
                    break;
                  case "video":
                  case "audio":
                    for (e2 = 0; e2 < lf.length; e2++)
                      D(lf[e2], a);
                    e2 = d2;
                    break;
                  case "source":
                    D("error", a);
                    e2 = d2;
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D(
                      "error",
                      a
                    );
                    D("load", a);
                    e2 = d2;
                    break;
                  case "details":
                    D("toggle", a);
                    e2 = d2;
                    break;
                  case "input":
                    Za(a, d2);
                    e2 = Ya(a, d2);
                    D("invalid", a);
                    break;
                  case "option":
                    e2 = d2;
                    break;
                  case "select":
                    a._wrapperState = { wasMultiple: !!d2.multiple };
                    e2 = A({}, d2, { value: void 0 });
                    D("invalid", a);
                    break;
                  case "textarea":
                    hb(a, d2);
                    e2 = gb(a, d2);
                    D("invalid", a);
                    break;
                  default:
                    e2 = d2;
                }
                ub(c2, e2);
                h2 = e2;
                for (f2 in h2)
                  if (h2.hasOwnProperty(f2)) {
                    var k2 = h2[f2];
                    "style" === f2 ? sb(a, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a, k2) : "number" === typeof k2 && ob(a, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D("scroll", a) : null != k2 && ta(a, f2, k2, g2));
                  }
                switch (c2) {
                  case "input":
                    Va(a);
                    db(a, d2, false);
                    break;
                  case "textarea":
                    Va(a);
                    jb(a);
                    break;
                  case "option":
                    null != d2.value && a.setAttribute("value", "" + Sa(d2.value));
                    break;
                  case "select":
                    a.multiple = !!d2.multiple;
                    f2 = d2.value;
                    null != f2 ? fb(a, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                      a,
                      !!d2.multiple,
                      d2.defaultValue,
                      true
                    );
                    break;
                  default:
                    "function" === typeof e2.onClick && (a.onclick = Bf);
                }
                switch (c2) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    d2 = !!d2.autoFocus;
                    break a;
                  case "img":
                    d2 = true;
                    break a;
                  default:
                    d2 = false;
                }
              }
              d2 && (b2.flags |= 4);
            }
            null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
          }
          S(b2);
          return null;
        case 6:
          if (a && null != b2.stateNode)
            Dj(a, b2, a.memoizedProps, d2);
          else {
            if ("string" !== typeof d2 && null === b2.stateNode)
              throw Error(p$1(166));
            c2 = Hh(Gh.current);
            Hh(Eh.current);
            if (Gg(b2)) {
              d2 = b2.stateNode;
              c2 = b2.memoizedProps;
              d2[Of] = b2;
              if (f2 = d2.nodeValue !== c2) {
                if (a = xg, null !== a)
                  switch (a.tag) {
                    case 3:
                      Af(d2.nodeValue, c2, 0 !== (a.mode & 1));
                      break;
                    case 5:
                      true !== a.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a.mode & 1));
                  }
              }
              f2 && (b2.flags |= 4);
            } else
              d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
          }
          S(b2);
          return null;
        case 13:
          E(M);
          d2 = b2.memoizedState;
          if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
            if (I && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
              Hg(), Ig(), b2.flags |= 98560, f2 = false;
            else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
              if (null === a) {
                if (!f2)
                  throw Error(p$1(318));
                f2 = b2.memoizedState;
                f2 = null !== f2 ? f2.dehydrated : null;
                if (!f2)
                  throw Error(p$1(317));
                f2[Of] = b2;
              } else
                Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
              S(b2);
              f2 = false;
            } else
              null !== zg && (Gj(zg), zg = null), f2 = true;
            if (!f2)
              return b2.flags & 65536 ? b2 : null;
          }
          if (0 !== (b2.flags & 128))
            return b2.lanes = c2, b2;
          d2 = null !== d2;
          d2 !== (null !== a && null !== a.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a || 0 !== (M.current & 1) ? 0 === T && (T = 3) : uj()));
          null !== b2.updateQueue && (b2.flags |= 4);
          S(b2);
          return null;
        case 4:
          return Jh(), Bj(a, b2), null === a && sf(b2.stateNode.containerInfo), S(b2), null;
        case 10:
          return Rg(b2.type._context), S(b2), null;
        case 17:
          return Zf(b2.type) && $f(), S(b2), null;
        case 19:
          E(M);
          f2 = b2.memoizedState;
          if (null === f2)
            return S(b2), null;
          d2 = 0 !== (b2.flags & 128);
          g2 = f2.rendering;
          if (null === g2)
            if (d2)
              Ej(f2, false);
            else {
              if (0 !== T || null !== a && 0 !== (a.flags & 128))
                for (a = b2.child; null !== a; ) {
                  g2 = Mh(a);
                  if (null !== g2) {
                    b2.flags |= 128;
                    Ej(f2, false);
                    d2 = g2.updateQueue;
                    null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                    b2.subtreeFlags = 0;
                    d2 = c2;
                    for (c2 = b2.child; null !== c2; )
                      f2 = c2, a = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a = g2.dependencies, f2.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c2 = c2.sibling;
                    G(M, M.current & 1 | 2);
                    return b2.child;
                  }
                  a = a.sibling;
                }
              null !== f2.tail && B() > Hj && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
            }
          else {
            if (!d2)
              if (a = Mh(g2), null !== a) {
                if (b2.flags |= 128, d2 = true, c2 = a.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I)
                  return S(b2), null;
              } else
                2 * B() - f2.renderingStartTime > Hj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
            f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
          }
          if (null !== f2.tail)
            return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B(), b2.sibling = null, c2 = M.current, G(M, d2 ? c2 & 1 | 2 : c2 & 1), b2;
          S(b2);
          return null;
        case 22:
        case 23:
          return Ij(), d2 = null !== b2.memoizedState, null !== a && null !== a.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S(b2), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(p$1(156, b2.tag));
    }
    function Jj(a, b2) {
      wg(b2);
      switch (b2.tag) {
        case 1:
          return Zf(b2.type) && $f(), a = b2.flags, a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
        case 3:
          return Jh(), E(Wf), E(H), Oh(), a = b2.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b2.flags = a & -65537 | 128, b2) : null;
        case 5:
          return Lh(b2), null;
        case 13:
          E(M);
          a = b2.memoizedState;
          if (null !== a && null !== a.dehydrated) {
            if (null === b2.alternate)
              throw Error(p$1(340));
            Ig();
          }
          a = b2.flags;
          return a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
        case 19:
          return E(M), null;
        case 4:
          return Jh(), null;
        case 10:
          return Rg(b2.type._context), null;
        case 22:
        case 23:
          return Ij(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var Kj = false, U = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
    function Mj(a, b2) {
      var c2 = a.ref;
      if (null !== c2)
        if ("function" === typeof c2)
          try {
            c2(null);
          } catch (d2) {
            W(a, b2, d2);
          }
        else
          c2.current = null;
    }
    function Nj(a, b2, c2) {
      try {
        c2();
      } catch (d2) {
        W(a, b2, d2);
      }
    }
    var Oj = false;
    function Pj(a, b2) {
      Cf = dd;
      a = Me();
      if (Ne(a)) {
        if ("selectionStart" in a)
          var c2 = { start: a.selectionStart, end: a.selectionEnd };
        else
          a: {
            c2 = (c2 = a.ownerDocument) && c2.defaultView || window;
            var d2 = c2.getSelection && c2.getSelection();
            if (d2 && 0 !== d2.rangeCount) {
              c2 = d2.anchorNode;
              var e2 = d2.anchorOffset, f2 = d2.focusNode;
              d2 = d2.focusOffset;
              try {
                c2.nodeType, f2.nodeType;
              } catch (F2) {
                c2 = null;
                break a;
              }
              var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a, r2 = null;
              b:
                for (; ; ) {
                  for (var y2; ; ) {
                    q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
                    q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
                    3 === q2.nodeType && (g2 += q2.nodeValue.length);
                    if (null === (y2 = q2.firstChild))
                      break;
                    r2 = q2;
                    q2 = y2;
                  }
                  for (; ; ) {
                    if (q2 === a)
                      break b;
                    r2 === c2 && ++l2 === e2 && (h2 = g2);
                    r2 === f2 && ++m2 === d2 && (k2 = g2);
                    if (null !== (y2 = q2.nextSibling))
                      break;
                    q2 = r2;
                    r2 = q2.parentNode;
                  }
                  q2 = y2;
                }
              c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
            } else
              c2 = null;
          }
        c2 = c2 || { start: 0, end: 0 };
      } else
        c2 = null;
      Df = { focusedElem: a, selectionRange: c2 };
      dd = false;
      for (V = b2; null !== V; )
        if (b2 = V, a = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a)
          a.return = b2, V = a;
        else
          for (; null !== V; ) {
            b2 = V;
            try {
              var n2 = b2.alternate;
              if (0 !== (b2.flags & 1024))
                switch (b2.tag) {
                  case 0:
                  case 11:
                  case 15:
                    break;
                  case 1:
                    if (null !== n2) {
                      var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Lg(b2.type, t2), J2);
                      x2.__reactInternalSnapshotBeforeUpdate = w2;
                    }
                    break;
                  case 3:
                    var u2 = b2.stateNode.containerInfo;
                    1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                    break;
                  case 5:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    throw Error(p$1(163));
                }
            } catch (F2) {
              W(b2, b2.return, F2);
            }
            a = b2.sibling;
            if (null !== a) {
              a.return = b2.return;
              V = a;
              break;
            }
            V = b2.return;
          }
      n2 = Oj;
      Oj = false;
      return n2;
    }
    function Qj(a, b2, c2) {
      var d2 = b2.updateQueue;
      d2 = null !== d2 ? d2.lastEffect : null;
      if (null !== d2) {
        var e2 = d2 = d2.next;
        do {
          if ((e2.tag & a) === a) {
            var f2 = e2.destroy;
            e2.destroy = void 0;
            void 0 !== f2 && Nj(b2, c2, f2);
          }
          e2 = e2.next;
        } while (e2 !== d2);
      }
    }
    function Rj(a, b2) {
      b2 = b2.updateQueue;
      b2 = null !== b2 ? b2.lastEffect : null;
      if (null !== b2) {
        var c2 = b2 = b2.next;
        do {
          if ((c2.tag & a) === a) {
            var d2 = c2.create;
            c2.destroy = d2();
          }
          c2 = c2.next;
        } while (c2 !== b2);
      }
    }
    function Sj(a) {
      var b2 = a.ref;
      if (null !== b2) {
        var c2 = a.stateNode;
        switch (a.tag) {
          case 5:
            a = c2;
            break;
          default:
            a = c2;
        }
        "function" === typeof b2 ? b2(a) : b2.current = a;
      }
    }
    function Tj(a) {
      var b2 = a.alternate;
      null !== b2 && (a.alternate = null, Tj(b2));
      a.child = null;
      a.deletions = null;
      a.sibling = null;
      5 === a.tag && (b2 = a.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
      a.stateNode = null;
      a.return = null;
      a.dependencies = null;
      a.memoizedProps = null;
      a.memoizedState = null;
      a.pendingProps = null;
      a.stateNode = null;
      a.updateQueue = null;
    }
    function Uj(a) {
      return 5 === a.tag || 3 === a.tag || 4 === a.tag;
    }
    function Vj(a) {
      a:
        for (; ; ) {
          for (; null === a.sibling; ) {
            if (null === a.return || Uj(a.return))
              return null;
            a = a.return;
          }
          a.sibling.return = a.return;
          for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
            if (a.flags & 2)
              continue a;
            if (null === a.child || 4 === a.tag)
              continue a;
            else
              a.child.return = a, a = a.child;
          }
          if (!(a.flags & 2))
            return a.stateNode;
        }
    }
    function Wj(a, b2, c2) {
      var d2 = a.tag;
      if (5 === d2 || 6 === d2)
        a = a.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a, b2) : c2.insertBefore(a, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a, c2)) : (b2 = c2, b2.appendChild(a)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
      else if (4 !== d2 && (a = a.child, null !== a))
        for (Wj(a, b2, c2), a = a.sibling; null !== a; )
          Wj(a, b2, c2), a = a.sibling;
    }
    function Xj(a, b2, c2) {
      var d2 = a.tag;
      if (5 === d2 || 6 === d2)
        a = a.stateNode, b2 ? c2.insertBefore(a, b2) : c2.appendChild(a);
      else if (4 !== d2 && (a = a.child, null !== a))
        for (Xj(a, b2, c2), a = a.sibling; null !== a; )
          Xj(a, b2, c2), a = a.sibling;
    }
    var X = null, Yj = false;
    function Zj(a, b2, c2) {
      for (c2 = c2.child; null !== c2; )
        ak(a, b2, c2), c2 = c2.sibling;
    }
    function ak(a, b2, c2) {
      if (lc && "function" === typeof lc.onCommitFiberUnmount)
        try {
          lc.onCommitFiberUnmount(kc, c2);
        } catch (h2) {
        }
      switch (c2.tag) {
        case 5:
          U || Mj(c2, b2);
        case 6:
          var d2 = X, e2 = Yj;
          X = null;
          Zj(a, b2, c2);
          X = d2;
          Yj = e2;
          null !== X && (Yj ? (a = X, c2 = c2.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c2) : a.removeChild(c2)) : X.removeChild(c2.stateNode));
          break;
        case 18:
          null !== X && (Yj ? (a = X, c2 = c2.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c2) : 1 === a.nodeType && Kf(a, c2), bd(a)) : Kf(X, c2.stateNode));
          break;
        case 4:
          d2 = X;
          e2 = Yj;
          X = c2.stateNode.containerInfo;
          Yj = true;
          Zj(a, b2, c2);
          X = d2;
          Yj = e2;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          if (!U && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
            e2 = d2 = d2.next;
            do {
              var f2 = e2, g2 = f2.destroy;
              f2 = f2.tag;
              void 0 !== g2 && (0 !== (f2 & 2) ? Nj(c2, b2, g2) : 0 !== (f2 & 4) && Nj(c2, b2, g2));
              e2 = e2.next;
            } while (e2 !== d2);
          }
          Zj(a, b2, c2);
          break;
        case 1:
          if (!U && (Mj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
            try {
              d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
            } catch (h2) {
              W(c2, b2, h2);
            }
          Zj(a, b2, c2);
          break;
        case 21:
          Zj(a, b2, c2);
          break;
        case 22:
          c2.mode & 1 ? (U = (d2 = U) || null !== c2.memoizedState, Zj(a, b2, c2), U = d2) : Zj(a, b2, c2);
          break;
        default:
          Zj(a, b2, c2);
      }
    }
    function bk(a) {
      var b2 = a.updateQueue;
      if (null !== b2) {
        a.updateQueue = null;
        var c2 = a.stateNode;
        null === c2 && (c2 = a.stateNode = new Lj());
        b2.forEach(function(b3) {
          var d2 = ck.bind(null, a, b3);
          c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
        });
      }
    }
    function dk(a, b2) {
      var c2 = b2.deletions;
      if (null !== c2)
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2];
          try {
            var f2 = a, g2 = b2, h2 = g2;
            a:
              for (; null !== h2; ) {
                switch (h2.tag) {
                  case 5:
                    X = h2.stateNode;
                    Yj = false;
                    break a;
                  case 3:
                    X = h2.stateNode.containerInfo;
                    Yj = true;
                    break a;
                  case 4:
                    X = h2.stateNode.containerInfo;
                    Yj = true;
                    break a;
                }
                h2 = h2.return;
              }
            if (null === X)
              throw Error(p$1(160));
            ak(f2, g2, e2);
            X = null;
            Yj = false;
            var k2 = e2.alternate;
            null !== k2 && (k2.return = null);
            e2.return = null;
          } catch (l2) {
            W(e2, b2, l2);
          }
        }
      if (b2.subtreeFlags & 12854)
        for (b2 = b2.child; null !== b2; )
          ek(b2, a), b2 = b2.sibling;
    }
    function ek(a, b2) {
      var c2 = a.alternate, d2 = a.flags;
      switch (a.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          dk(b2, a);
          fk(a);
          if (d2 & 4) {
            try {
              Qj(3, a, a.return), Rj(3, a);
            } catch (t2) {
              W(a, a.return, t2);
            }
            try {
              Qj(5, a, a.return);
            } catch (t2) {
              W(a, a.return, t2);
            }
          }
          break;
        case 1:
          dk(b2, a);
          fk(a);
          d2 & 512 && null !== c2 && Mj(c2, c2.return);
          break;
        case 5:
          dk(b2, a);
          fk(a);
          d2 & 512 && null !== c2 && Mj(c2, c2.return);
          if (a.flags & 32) {
            var e2 = a.stateNode;
            try {
              ob(e2, "");
            } catch (t2) {
              W(a, a.return, t2);
            }
          }
          if (d2 & 4 && (e2 = a.stateNode, null != e2)) {
            var f2 = a.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a.type, k2 = a.updateQueue;
            a.updateQueue = null;
            if (null !== k2)
              try {
                "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
                vb(h2, g2);
                var l2 = vb(h2, f2);
                for (g2 = 0; g2 < k2.length; g2 += 2) {
                  var m2 = k2[g2], q2 = k2[g2 + 1];
                  "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
                }
                switch (h2) {
                  case "input":
                    bb(e2, f2);
                    break;
                  case "textarea":
                    ib(e2, f2);
                    break;
                  case "select":
                    var r2 = e2._wrapperState.wasMultiple;
                    e2._wrapperState.wasMultiple = !!f2.multiple;
                    var y2 = f2.value;
                    null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                      e2,
                      !!f2.multiple,
                      f2.defaultValue,
                      true
                    ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
                }
                e2[Pf] = f2;
              } catch (t2) {
                W(a, a.return, t2);
              }
          }
          break;
        case 6:
          dk(b2, a);
          fk(a);
          if (d2 & 4) {
            if (null === a.stateNode)
              throw Error(p$1(162));
            e2 = a.stateNode;
            f2 = a.memoizedProps;
            try {
              e2.nodeValue = f2;
            } catch (t2) {
              W(a, a.return, t2);
            }
          }
          break;
        case 3:
          dk(b2, a);
          fk(a);
          if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
            try {
              bd(b2.containerInfo);
            } catch (t2) {
              W(a, a.return, t2);
            }
          break;
        case 4:
          dk(b2, a);
          fk(a);
          break;
        case 13:
          dk(b2, a);
          fk(a);
          e2 = a.child;
          e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B()));
          d2 & 4 && bk(a);
          break;
        case 22:
          m2 = null !== c2 && null !== c2.memoizedState;
          a.mode & 1 ? (U = (l2 = U) || m2, dk(b2, a), U = l2) : dk(b2, a);
          fk(a);
          if (d2 & 8192) {
            l2 = null !== a.memoizedState;
            if ((a.stateNode.isHidden = l2) && !m2 && 0 !== (a.mode & 1))
              for (V = a, m2 = a.child; null !== m2; ) {
                for (q2 = V = m2; null !== V; ) {
                  r2 = V;
                  y2 = r2.child;
                  switch (r2.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                      Qj(4, r2, r2.return);
                      break;
                    case 1:
                      Mj(r2, r2.return);
                      var n2 = r2.stateNode;
                      if ("function" === typeof n2.componentWillUnmount) {
                        d2 = r2;
                        c2 = r2.return;
                        try {
                          b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                        } catch (t2) {
                          W(d2, c2, t2);
                        }
                      }
                      break;
                    case 5:
                      Mj(r2, r2.return);
                      break;
                    case 22:
                      if (null !== r2.memoizedState) {
                        hk(q2);
                        continue;
                      }
                  }
                  null !== y2 ? (y2.return = r2, V = y2) : hk(q2);
                }
                m2 = m2.sibling;
              }
            a:
              for (m2 = null, q2 = a; ; ) {
                if (5 === q2.tag) {
                  if (null === m2) {
                    m2 = q2;
                    try {
                      e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                    } catch (t2) {
                      W(a, a.return, t2);
                    }
                  }
                } else if (6 === q2.tag) {
                  if (null === m2)
                    try {
                      q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                    } catch (t2) {
                      W(a, a.return, t2);
                    }
                } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a) && null !== q2.child) {
                  q2.child.return = q2;
                  q2 = q2.child;
                  continue;
                }
                if (q2 === a)
                  break a;
                for (; null === q2.sibling; ) {
                  if (null === q2.return || q2.return === a)
                    break a;
                  m2 === q2 && (m2 = null);
                  q2 = q2.return;
                }
                m2 === q2 && (m2 = null);
                q2.sibling.return = q2.return;
                q2 = q2.sibling;
              }
          }
          break;
        case 19:
          dk(b2, a);
          fk(a);
          d2 & 4 && bk(a);
          break;
        case 21:
          break;
        default:
          dk(
            b2,
            a
          ), fk(a);
      }
    }
    function fk(a) {
      var b2 = a.flags;
      if (b2 & 2) {
        try {
          a: {
            for (var c2 = a.return; null !== c2; ) {
              if (Uj(c2)) {
                var d2 = c2;
                break a;
              }
              c2 = c2.return;
            }
            throw Error(p$1(160));
          }
          switch (d2.tag) {
            case 5:
              var e2 = d2.stateNode;
              d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
              var f2 = Vj(a);
              Xj(a, f2, e2);
              break;
            case 3:
            case 4:
              var g2 = d2.stateNode.containerInfo, h2 = Vj(a);
              Wj(a, h2, g2);
              break;
            default:
              throw Error(p$1(161));
          }
        } catch (k2) {
          W(a, a.return, k2);
        }
        a.flags &= -3;
      }
      b2 & 4096 && (a.flags &= -4097);
    }
    function ik(a, b2, c2) {
      V = a;
      jk(a);
    }
    function jk(a, b2, c2) {
      for (var d2 = 0 !== (a.mode & 1); null !== V; ) {
        var e2 = V, f2 = e2.child;
        if (22 === e2.tag && d2) {
          var g2 = null !== e2.memoizedState || Kj;
          if (!g2) {
            var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U;
            h2 = Kj;
            var l2 = U;
            Kj = g2;
            if ((U = k2) && !l2)
              for (V = e2; null !== V; )
                g2 = V, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e2) : null !== k2 ? (k2.return = g2, V = k2) : kk(e2);
            for (; null !== f2; )
              V = f2, jk(f2), f2 = f2.sibling;
            V = e2;
            Kj = h2;
            U = l2;
          }
          lk(a);
        } else
          0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V = f2) : lk(a);
      }
    }
    function lk(a) {
      for (; null !== V; ) {
        var b2 = V;
        if (0 !== (b2.flags & 8772)) {
          var c2 = b2.alternate;
          try {
            if (0 !== (b2.flags & 8772))
              switch (b2.tag) {
                case 0:
                case 11:
                case 15:
                  U || Rj(5, b2);
                  break;
                case 1:
                  var d2 = b2.stateNode;
                  if (b2.flags & 4 && !U)
                    if (null === c2)
                      d2.componentDidMount();
                    else {
                      var e2 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                      d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                    }
                  var f2 = b2.updateQueue;
                  null !== f2 && ih(b2, f2, d2);
                  break;
                case 3:
                  var g2 = b2.updateQueue;
                  if (null !== g2) {
                    c2 = null;
                    if (null !== b2.child)
                      switch (b2.child.tag) {
                        case 5:
                          c2 = b2.child.stateNode;
                          break;
                        case 1:
                          c2 = b2.child.stateNode;
                      }
                    ih(b2, g2, c2);
                  }
                  break;
                case 5:
                  var h2 = b2.stateNode;
                  if (null === c2 && b2.flags & 4) {
                    c2 = h2;
                    var k2 = b2.memoizedProps;
                    switch (b2.type) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        k2.autoFocus && c2.focus();
                        break;
                      case "img":
                        k2.src && (c2.src = k2.src);
                    }
                  }
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (null === b2.memoizedState) {
                    var l2 = b2.alternate;
                    if (null !== l2) {
                      var m2 = l2.memoizedState;
                      if (null !== m2) {
                        var q2 = m2.dehydrated;
                        null !== q2 && bd(q2);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                case 25:
                  break;
                default:
                  throw Error(p$1(163));
              }
            U || b2.flags & 512 && Sj(b2);
          } catch (r2) {
            W(b2, b2.return, r2);
          }
        }
        if (b2 === a) {
          V = null;
          break;
        }
        c2 = b2.sibling;
        if (null !== c2) {
          c2.return = b2.return;
          V = c2;
          break;
        }
        V = b2.return;
      }
    }
    function hk(a) {
      for (; null !== V; ) {
        var b2 = V;
        if (b2 === a) {
          V = null;
          break;
        }
        var c2 = b2.sibling;
        if (null !== c2) {
          c2.return = b2.return;
          V = c2;
          break;
        }
        V = b2.return;
      }
    }
    function kk(a) {
      for (; null !== V; ) {
        var b2 = V;
        try {
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              var c2 = b2.return;
              try {
                Rj(4, b2);
              } catch (k2) {
                W(b2, c2, k2);
              }
              break;
            case 1:
              var d2 = b2.stateNode;
              if ("function" === typeof d2.componentDidMount) {
                var e2 = b2.return;
                try {
                  d2.componentDidMount();
                } catch (k2) {
                  W(b2, e2, k2);
                }
              }
              var f2 = b2.return;
              try {
                Sj(b2);
              } catch (k2) {
                W(b2, f2, k2);
              }
              break;
            case 5:
              var g2 = b2.return;
              try {
                Sj(b2);
              } catch (k2) {
                W(b2, g2, k2);
              }
          }
        } catch (k2) {
          W(b2, b2.return, k2);
        }
        if (b2 === a) {
          V = null;
          break;
        }
        var h2 = b2.sibling;
        if (null !== h2) {
          h2.return = b2.return;
          V = h2;
          break;
        }
        V = b2.return;
      }
    }
    var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K = 0, R = null, Y = null, Z = 0, gj = 0, fj = Uf(0), T = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
    function L() {
      return 0 !== (K & 6) ? B() : -1 !== Bk ? Bk : Bk = B();
    }
    function lh(a) {
      if (0 === (a.mode & 1))
        return 1;
      if (0 !== (K & 2) && 0 !== Z)
        return Z & -Z;
      if (null !== Kg.transition)
        return 0 === Ck && (Ck = yc()), Ck;
      a = C;
      if (0 !== a)
        return a;
      a = window.event;
      a = void 0 === a ? 16 : jd(a.type);
      return a;
    }
    function mh(a, b2, c2, d2) {
      if (50 < zk)
        throw zk = 0, Ak = null, Error(p$1(185));
      Ac(a, c2, d2);
      if (0 === (K & 2) || a !== R)
        a === R && (0 === (K & 2) && (rk |= c2), 4 === T && Dk(a, Z)), Ek(a, d2), 1 === c2 && 0 === K && 0 === (b2.mode & 1) && (Hj = B() + 500, fg && jg());
    }
    function Ek(a, b2) {
      var c2 = a.callbackNode;
      wc(a, b2);
      var d2 = uc(a, a === R ? Z : 0);
      if (0 === d2)
        null !== c2 && bc(c2), a.callbackNode = null, a.callbackPriority = 0;
      else if (b2 = d2 & -d2, a.callbackPriority !== b2) {
        null != c2 && bc(c2);
        if (1 === b2)
          0 === a.tag ? ig(Fk.bind(null, a)) : hg(Fk.bind(null, a)), Jf(function() {
            0 === (K & 6) && jg();
          }), c2 = null;
        else {
          switch (Dc(d2)) {
            case 1:
              c2 = fc;
              break;
            case 4:
              c2 = gc;
              break;
            case 16:
              c2 = hc;
              break;
            case 536870912:
              c2 = jc;
              break;
            default:
              c2 = hc;
          }
          c2 = Gk(c2, Hk.bind(null, a));
        }
        a.callbackPriority = b2;
        a.callbackNode = c2;
      }
    }
    function Hk(a, b2) {
      Bk = -1;
      Ck = 0;
      if (0 !== (K & 6))
        throw Error(p$1(327));
      var c2 = a.callbackNode;
      if (Ik() && a.callbackNode !== c2)
        return null;
      var d2 = uc(a, a === R ? Z : 0);
      if (0 === d2)
        return null;
      if (0 !== (d2 & 30) || 0 !== (d2 & a.expiredLanes) || b2)
        b2 = Jk(a, d2);
      else {
        b2 = d2;
        var e2 = K;
        K |= 2;
        var f2 = Kk();
        if (R !== a || Z !== b2)
          vk = null, Hj = B() + 500, Lk(a, b2);
        do
          try {
            Mk();
            break;
          } catch (h2) {
            Nk(a, h2);
          }
        while (1);
        Qg();
        nk.current = f2;
        K = e2;
        null !== Y ? b2 = 0 : (R = null, Z = 0, b2 = T);
      }
      if (0 !== b2) {
        2 === b2 && (e2 = xc(a), 0 !== e2 && (d2 = e2, b2 = Ok(a, e2)));
        if (1 === b2)
          throw c2 = qk, Lk(a, 0), Dk(a, d2), Ek(a, B()), c2;
        if (6 === b2)
          Dk(a, d2);
        else {
          e2 = a.current.alternate;
          if (0 === (d2 & 30) && !Pk(e2) && (b2 = Jk(a, d2), 2 === b2 && (f2 = xc(a), 0 !== f2 && (d2 = f2, b2 = Ok(a, f2))), 1 === b2))
            throw c2 = qk, Lk(a, 0), Dk(a, d2), Ek(a, B()), c2;
          a.finishedWork = e2;
          a.finishedLanes = d2;
          switch (b2) {
            case 0:
            case 1:
              throw Error(p$1(345));
            case 2:
              Qk(a, uk, vk);
              break;
            case 3:
              Dk(a, d2);
              if ((d2 & 130023424) === d2 && (b2 = gk + 500 - B(), 10 < b2)) {
                if (0 !== uc(a, 0))
                  break;
                e2 = a.suspendedLanes;
                if ((e2 & d2) !== d2) {
                  L();
                  a.pingedLanes |= a.suspendedLanes & e2;
                  break;
                }
                a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), b2);
                break;
              }
              Qk(a, uk, vk);
              break;
            case 4:
              Dk(a, d2);
              if ((d2 & 4194240) === d2)
                break;
              b2 = a.eventTimes;
              for (e2 = -1; 0 < d2; ) {
                var g2 = 31 - oc(d2);
                f2 = 1 << g2;
                g2 = b2[g2];
                g2 > e2 && (e2 = g2);
                d2 &= ~f2;
              }
              d2 = e2;
              d2 = B() - d2;
              d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
              if (10 < d2) {
                a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), d2);
                break;
              }
              Qk(a, uk, vk);
              break;
            case 5:
              Qk(a, uk, vk);
              break;
            default:
              throw Error(p$1(329));
          }
        }
      }
      Ek(a, B());
      return a.callbackNode === c2 ? Hk.bind(null, a) : null;
    }
    function Ok(a, b2) {
      var c2 = tk;
      a.current.memoizedState.isDehydrated && (Lk(a, b2).flags |= 256);
      a = Jk(a, b2);
      2 !== a && (b2 = uk, uk = c2, null !== b2 && Gj(b2));
      return a;
    }
    function Gj(a) {
      null === uk ? uk = a : uk.push.apply(uk, a);
    }
    function Pk(a) {
      for (var b2 = a; ; ) {
        if (b2.flags & 16384) {
          var c2 = b2.updateQueue;
          if (null !== c2 && (c2 = c2.stores, null !== c2))
            for (var d2 = 0; d2 < c2.length; d2++) {
              var e2 = c2[d2], f2 = e2.getSnapshot;
              e2 = e2.value;
              try {
                if (!He(f2(), e2))
                  return false;
              } catch (g2) {
                return false;
              }
            }
        }
        c2 = b2.child;
        if (b2.subtreeFlags & 16384 && null !== c2)
          c2.return = b2, b2 = c2;
        else {
          if (b2 === a)
            break;
          for (; null === b2.sibling; ) {
            if (null === b2.return || b2.return === a)
              return true;
            b2 = b2.return;
          }
          b2.sibling.return = b2.return;
          b2 = b2.sibling;
        }
      }
      return true;
    }
    function Dk(a, b2) {
      b2 &= ~sk;
      b2 &= ~rk;
      a.suspendedLanes |= b2;
      a.pingedLanes &= ~b2;
      for (a = a.expirationTimes; 0 < b2; ) {
        var c2 = 31 - oc(b2), d2 = 1 << c2;
        a[c2] = -1;
        b2 &= ~d2;
      }
    }
    function Fk(a) {
      if (0 !== (K & 6))
        throw Error(p$1(327));
      Ik();
      var b2 = uc(a, 0);
      if (0 === (b2 & 1))
        return Ek(a, B()), null;
      var c2 = Jk(a, b2);
      if (0 !== a.tag && 2 === c2) {
        var d2 = xc(a);
        0 !== d2 && (b2 = d2, c2 = Ok(a, d2));
      }
      if (1 === c2)
        throw c2 = qk, Lk(a, 0), Dk(a, b2), Ek(a, B()), c2;
      if (6 === c2)
        throw Error(p$1(345));
      a.finishedWork = a.current.alternate;
      a.finishedLanes = b2;
      Qk(a, uk, vk);
      Ek(a, B());
      return null;
    }
    function Rk(a, b2) {
      var c2 = K;
      K |= 1;
      try {
        return a(b2);
      } finally {
        K = c2, 0 === K && (Hj = B() + 500, fg && jg());
      }
    }
    function Sk(a) {
      null !== xk && 0 === xk.tag && 0 === (K & 6) && Ik();
      var b2 = K;
      K |= 1;
      var c2 = pk.transition, d2 = C;
      try {
        if (pk.transition = null, C = 1, a)
          return a();
      } finally {
        C = d2, pk.transition = c2, K = b2, 0 === (K & 6) && jg();
      }
    }
    function Ij() {
      gj = fj.current;
      E(fj);
    }
    function Lk(a, b2) {
      a.finishedWork = null;
      a.finishedLanes = 0;
      var c2 = a.timeoutHandle;
      -1 !== c2 && (a.timeoutHandle = -1, Gf(c2));
      if (null !== Y)
        for (c2 = Y.return; null !== c2; ) {
          var d2 = c2;
          wg(d2);
          switch (d2.tag) {
            case 1:
              d2 = d2.type.childContextTypes;
              null !== d2 && void 0 !== d2 && $f();
              break;
            case 3:
              Jh();
              E(Wf);
              E(H);
              Oh();
              break;
            case 5:
              Lh(d2);
              break;
            case 4:
              Jh();
              break;
            case 13:
              E(M);
              break;
            case 19:
              E(M);
              break;
            case 10:
              Rg(d2.type._context);
              break;
            case 22:
            case 23:
              Ij();
          }
          c2 = c2.return;
        }
      R = a;
      Y = a = wh(a.current, null);
      Z = gj = b2;
      T = 0;
      qk = null;
      sk = rk = hh = 0;
      uk = tk = null;
      if (null !== Wg) {
        for (b2 = 0; b2 < Wg.length; b2++)
          if (c2 = Wg[b2], d2 = c2.interleaved, null !== d2) {
            c2.interleaved = null;
            var e2 = d2.next, f2 = c2.pending;
            if (null !== f2) {
              var g2 = f2.next;
              f2.next = e2;
              d2.next = g2;
            }
            c2.pending = d2;
          }
        Wg = null;
      }
      return a;
    }
    function Nk(a, b2) {
      do {
        var c2 = Y;
        try {
          Qg();
          Ph.current = ai;
          if (Sh) {
            for (var d2 = N.memoizedState; null !== d2; ) {
              var e2 = d2.queue;
              null !== e2 && (e2.pending = null);
              d2 = d2.next;
            }
            Sh = false;
          }
          Rh = 0;
          P = O = N = null;
          Th = false;
          Uh = 0;
          ok.current = null;
          if (null === c2 || null === c2.return) {
            T = 1;
            qk = b2;
            Y = null;
            break;
          }
          a: {
            var f2 = a, g2 = c2.return, h2 = c2, k2 = b2;
            b2 = Z;
            h2.flags |= 32768;
            if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
              var l2 = k2, m2 = h2, q2 = m2.tag;
              if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
                var r2 = m2.alternate;
                r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
              }
              var y2 = Vi(g2);
              if (null !== y2) {
                y2.flags &= -257;
                Wi(y2, g2, h2, f2, b2);
                y2.mode & 1 && Ti(f2, l2, b2);
                b2 = y2;
                k2 = l2;
                var n2 = b2.updateQueue;
                if (null === n2) {
                  var t2 = /* @__PURE__ */ new Set();
                  t2.add(k2);
                  b2.updateQueue = t2;
                } else
                  n2.add(k2);
                break a;
              } else {
                if (0 === (b2 & 1)) {
                  Ti(f2, l2, b2);
                  uj();
                  break a;
                }
                k2 = Error(p$1(426));
              }
            } else if (I && h2.mode & 1) {
              var J2 = Vi(g2);
              if (null !== J2) {
                0 === (J2.flags & 65536) && (J2.flags |= 256);
                Wi(J2, g2, h2, f2, b2);
                Jg(Ki(k2, h2));
                break a;
              }
            }
            f2 = k2 = Ki(k2, h2);
            4 !== T && (T = 2);
            null === tk ? tk = [f2] : tk.push(f2);
            f2 = g2;
            do {
              switch (f2.tag) {
                case 3:
                  f2.flags |= 65536;
                  b2 &= -b2;
                  f2.lanes |= b2;
                  var x2 = Oi(f2, k2, b2);
                  fh(f2, x2);
                  break a;
                case 1:
                  h2 = k2;
                  var w2 = f2.type, u2 = f2.stateNode;
                  if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si || !Si.has(u2)))) {
                    f2.flags |= 65536;
                    b2 &= -b2;
                    f2.lanes |= b2;
                    var F2 = Ri(f2, h2, b2);
                    fh(f2, F2);
                    break a;
                  }
              }
              f2 = f2.return;
            } while (null !== f2);
          }
          Tk(c2);
        } catch (na) {
          b2 = na;
          Y === c2 && null !== c2 && (Y = c2 = c2.return);
          continue;
        }
        break;
      } while (1);
    }
    function Kk() {
      var a = nk.current;
      nk.current = ai;
      return null === a ? ai : a;
    }
    function uj() {
      if (0 === T || 3 === T || 2 === T)
        T = 4;
      null === R || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R, Z);
    }
    function Jk(a, b2) {
      var c2 = K;
      K |= 2;
      var d2 = Kk();
      if (R !== a || Z !== b2)
        vk = null, Lk(a, b2);
      do
        try {
          Uk();
          break;
        } catch (e2) {
          Nk(a, e2);
        }
      while (1);
      Qg();
      K = c2;
      nk.current = d2;
      if (null !== Y)
        throw Error(p$1(261));
      R = null;
      Z = 0;
      return T;
    }
    function Uk() {
      for (; null !== Y; )
        Vk(Y);
    }
    function Mk() {
      for (; null !== Y && !cc(); )
        Vk(Y);
    }
    function Vk(a) {
      var b2 = Wk(a.alternate, a, gj);
      a.memoizedProps = a.pendingProps;
      null === b2 ? Tk(a) : Y = b2;
      ok.current = null;
    }
    function Tk(a) {
      var b2 = a;
      do {
        var c2 = b2.alternate;
        a = b2.return;
        if (0 === (b2.flags & 32768)) {
          if (c2 = Fj(c2, b2, gj), null !== c2) {
            Y = c2;
            return;
          }
        } else {
          c2 = Jj(c2, b2);
          if (null !== c2) {
            c2.flags &= 32767;
            Y = c2;
            return;
          }
          if (null !== a)
            a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
          else {
            T = 6;
            Y = null;
            return;
          }
        }
        b2 = b2.sibling;
        if (null !== b2) {
          Y = b2;
          return;
        }
        Y = b2 = a;
      } while (null !== b2);
      0 === T && (T = 5);
    }
    function Qk(a, b2, c2) {
      var d2 = C, e2 = pk.transition;
      try {
        pk.transition = null, C = 1, Xk(a, b2, c2, d2);
      } finally {
        pk.transition = e2, C = d2;
      }
      return null;
    }
    function Xk(a, b2, c2, d2) {
      do
        Ik();
      while (null !== xk);
      if (0 !== (K & 6))
        throw Error(p$1(327));
      c2 = a.finishedWork;
      var e2 = a.finishedLanes;
      if (null === c2)
        return null;
      a.finishedWork = null;
      a.finishedLanes = 0;
      if (c2 === a.current)
        throw Error(p$1(177));
      a.callbackNode = null;
      a.callbackPriority = 0;
      var f2 = c2.lanes | c2.childLanes;
      Bc(a, f2);
      a === R && (Y = R = null, Z = 0);
      0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
        Ik();
        return null;
      }));
      f2 = 0 !== (c2.flags & 15990);
      if (0 !== (c2.subtreeFlags & 15990) || f2) {
        f2 = pk.transition;
        pk.transition = null;
        var g2 = C;
        C = 1;
        var h2 = K;
        K |= 4;
        ok.current = null;
        Pj(a, c2);
        ek(c2, a);
        Oe(Df);
        dd = !!Cf;
        Df = Cf = null;
        a.current = c2;
        ik(c2);
        dc();
        K = h2;
        C = g2;
        pk.transition = f2;
      } else
        a.current = c2;
      wk && (wk = false, xk = a, yk = e2);
      f2 = a.pendingLanes;
      0 === f2 && (Si = null);
      mc(c2.stateNode);
      Ek(a, B());
      if (null !== b2)
        for (d2 = a.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
          e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
      if (Pi)
        throw Pi = false, a = Qi, Qi = null, a;
      0 !== (yk & 1) && 0 !== a.tag && Ik();
      f2 = a.pendingLanes;
      0 !== (f2 & 1) ? a === Ak ? zk++ : (zk = 0, Ak = a) : zk = 0;
      jg();
      return null;
    }
    function Ik() {
      if (null !== xk) {
        var a = Dc(yk), b2 = pk.transition, c2 = C;
        try {
          pk.transition = null;
          C = 16 > a ? 16 : a;
          if (null === xk)
            var d2 = false;
          else {
            a = xk;
            xk = null;
            yk = 0;
            if (0 !== (K & 6))
              throw Error(p$1(331));
            var e2 = K;
            K |= 4;
            for (V = a.current; null !== V; ) {
              var f2 = V, g2 = f2.child;
              if (0 !== (V.flags & 16)) {
                var h2 = f2.deletions;
                if (null !== h2) {
                  for (var k2 = 0; k2 < h2.length; k2++) {
                    var l2 = h2[k2];
                    for (V = l2; null !== V; ) {
                      var m2 = V;
                      switch (m2.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Qj(8, m2, f2);
                      }
                      var q2 = m2.child;
                      if (null !== q2)
                        q2.return = m2, V = q2;
                      else
                        for (; null !== V; ) {
                          m2 = V;
                          var r2 = m2.sibling, y2 = m2.return;
                          Tj(m2);
                          if (m2 === l2) {
                            V = null;
                            break;
                          }
                          if (null !== r2) {
                            r2.return = y2;
                            V = r2;
                            break;
                          }
                          V = y2;
                        }
                    }
                  }
                  var n2 = f2.alternate;
                  if (null !== n2) {
                    var t2 = n2.child;
                    if (null !== t2) {
                      n2.child = null;
                      do {
                        var J2 = t2.sibling;
                        t2.sibling = null;
                        t2 = J2;
                      } while (null !== t2);
                    }
                  }
                  V = f2;
                }
              }
              if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
                g2.return = f2, V = g2;
              else
                b:
                  for (; null !== V; ) {
                    f2 = V;
                    if (0 !== (f2.flags & 2048))
                      switch (f2.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Qj(9, f2, f2.return);
                      }
                    var x2 = f2.sibling;
                    if (null !== x2) {
                      x2.return = f2.return;
                      V = x2;
                      break b;
                    }
                    V = f2.return;
                  }
            }
            var w2 = a.current;
            for (V = w2; null !== V; ) {
              g2 = V;
              var u2 = g2.child;
              if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
                u2.return = g2, V = u2;
              else
                b:
                  for (g2 = w2; null !== V; ) {
                    h2 = V;
                    if (0 !== (h2.flags & 2048))
                      try {
                        switch (h2.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Rj(9, h2);
                        }
                      } catch (na) {
                        W(h2, h2.return, na);
                      }
                    if (h2 === g2) {
                      V = null;
                      break b;
                    }
                    var F2 = h2.sibling;
                    if (null !== F2) {
                      F2.return = h2.return;
                      V = F2;
                      break b;
                    }
                    V = h2.return;
                  }
            }
            K = e2;
            jg();
            if (lc && "function" === typeof lc.onPostCommitFiberRoot)
              try {
                lc.onPostCommitFiberRoot(kc, a);
              } catch (na) {
              }
            d2 = true;
          }
          return d2;
        } finally {
          C = c2, pk.transition = b2;
        }
      }
      return false;
    }
    function Yk(a, b2, c2) {
      b2 = Ki(c2, b2);
      b2 = Oi(a, b2, 1);
      a = dh(a, b2, 1);
      b2 = L();
      null !== a && (Ac(a, 1, b2), Ek(a, b2));
    }
    function W(a, b2, c2) {
      if (3 === a.tag)
        Yk(a, a, c2);
      else
        for (; null !== b2; ) {
          if (3 === b2.tag) {
            Yk(b2, a, c2);
            break;
          } else if (1 === b2.tag) {
            var d2 = b2.stateNode;
            if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si || !Si.has(d2))) {
              a = Ki(c2, a);
              a = Ri(b2, a, 1);
              b2 = dh(b2, a, 1);
              a = L();
              null !== b2 && (Ac(b2, 1, a), Ek(b2, a));
              break;
            }
          }
          b2 = b2.return;
        }
    }
    function Ui(a, b2, c2) {
      var d2 = a.pingCache;
      null !== d2 && d2.delete(b2);
      b2 = L();
      a.pingedLanes |= a.suspendedLanes & c2;
      R === a && (Z & c2) === c2 && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - gk ? Lk(a, 0) : sk |= c2);
      Ek(a, b2);
    }
    function Zk(a, b2) {
      0 === b2 && (0 === (a.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
      var c2 = L();
      a = Zg(a, b2);
      null !== a && (Ac(a, b2, c2), Ek(a, c2));
    }
    function vj(a) {
      var b2 = a.memoizedState, c2 = 0;
      null !== b2 && (c2 = b2.retryLane);
      Zk(a, c2);
    }
    function ck(a, b2) {
      var c2 = 0;
      switch (a.tag) {
        case 13:
          var d2 = a.stateNode;
          var e2 = a.memoizedState;
          null !== e2 && (c2 = e2.retryLane);
          break;
        case 19:
          d2 = a.stateNode;
          break;
        default:
          throw Error(p$1(314));
      }
      null !== d2 && d2.delete(b2);
      Zk(a, c2);
    }
    var Wk;
    Wk = function(a, b2, c2) {
      if (null !== a)
        if (a.memoizedProps !== b2.pendingProps || Wf.current)
          Ug = true;
        else {
          if (0 === (a.lanes & c2) && 0 === (b2.flags & 128))
            return Ug = false, zj(a, b2, c2);
          Ug = 0 !== (a.flags & 131072) ? true : false;
        }
      else
        Ug = false, I && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
      b2.lanes = 0;
      switch (b2.tag) {
        case 2:
          var d2 = b2.type;
          jj(a, b2);
          a = b2.pendingProps;
          var e2 = Yf(b2, H.current);
          Tg(b2, c2);
          e2 = Xh(null, b2, d2, a, e2, c2);
          var f2 = bi();
          b2.flags |= 1;
          "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b2), e2.updater = nh, b2.stateNode = e2, e2._reactInternals = b2, rh(b2, d2, a, c2), b2 = kj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I && f2 && vg(b2), Yi(null, b2, e2, c2), b2 = b2.child);
          return b2;
        case 16:
          d2 = b2.elementType;
          a: {
            jj(a, b2);
            a = b2.pendingProps;
            e2 = d2._init;
            d2 = e2(d2._payload);
            b2.type = d2;
            e2 = b2.tag = $k(d2);
            a = Lg(d2, a);
            switch (e2) {
              case 0:
                b2 = dj(null, b2, d2, a, c2);
                break a;
              case 1:
                b2 = ij(null, b2, d2, a, c2);
                break a;
              case 11:
                b2 = Zi(null, b2, d2, a, c2);
                break a;
              case 14:
                b2 = aj(null, b2, d2, Lg(d2.type, a), c2);
                break a;
            }
            throw Error(p$1(
              306,
              d2,
              ""
            ));
          }
          return b2;
        case 0:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), dj(a, b2, d2, e2, c2);
        case 1:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), ij(a, b2, d2, e2, c2);
        case 3:
          a: {
            lj(b2);
            if (null === a)
              throw Error(p$1(387));
            d2 = b2.pendingProps;
            f2 = b2.memoizedState;
            e2 = f2.element;
            bh(a, b2);
            gh(b2, d2, null, c2);
            var g2 = b2.memoizedState;
            d2 = g2.element;
            if (f2.isDehydrated)
              if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
                e2 = Ki(Error(p$1(423)), b2);
                b2 = mj(a, b2, d2, c2, e2);
                break a;
              } else if (d2 !== e2) {
                e2 = Ki(Error(p$1(424)), b2);
                b2 = mj(a, b2, d2, c2, e2);
                break a;
              } else
                for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I = true, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; )
                  c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
            else {
              Ig();
              if (d2 === e2) {
                b2 = $i(a, b2, c2);
                break a;
              }
              Yi(a, b2, d2, c2);
            }
            b2 = b2.child;
          }
          return b2;
        case 5:
          return Kh(b2), null === a && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a ? a.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), hj(a, b2), Yi(a, b2, g2, c2), b2.child;
        case 6:
          return null === a && Eg(b2), null;
        case 13:
          return pj(a, b2, c2);
        case 4:
          return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a ? b2.child = Bh(b2, null, d2, c2) : Yi(a, b2, d2, c2), b2.child;
        case 11:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), Zi(a, b2, d2, e2, c2);
        case 7:
          return Yi(a, b2, b2.pendingProps, c2), b2.child;
        case 8:
          return Yi(a, b2, b2.pendingProps.children, c2), b2.child;
        case 12:
          return Yi(a, b2, b2.pendingProps.children, c2), b2.child;
        case 10:
          a: {
            d2 = b2.type._context;
            e2 = b2.pendingProps;
            f2 = b2.memoizedProps;
            g2 = e2.value;
            G(Mg, d2._currentValue);
            d2._currentValue = g2;
            if (null !== f2)
              if (He(f2.value, g2)) {
                if (f2.children === e2.children && !Wf.current) {
                  b2 = $i(a, b2, c2);
                  break a;
                }
              } else
                for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
                  var h2 = f2.dependencies;
                  if (null !== h2) {
                    g2 = f2.child;
                    for (var k2 = h2.firstContext; null !== k2; ) {
                      if (k2.context === d2) {
                        if (1 === f2.tag) {
                          k2 = ch(-1, c2 & -c2);
                          k2.tag = 2;
                          var l2 = f2.updateQueue;
                          if (null !== l2) {
                            l2 = l2.shared;
                            var m2 = l2.pending;
                            null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                            l2.pending = k2;
                          }
                        }
                        f2.lanes |= c2;
                        k2 = f2.alternate;
                        null !== k2 && (k2.lanes |= c2);
                        Sg(
                          f2.return,
                          c2,
                          b2
                        );
                        h2.lanes |= c2;
                        break;
                      }
                      k2 = k2.next;
                    }
                  } else if (10 === f2.tag)
                    g2 = f2.type === b2.type ? null : f2.child;
                  else if (18 === f2.tag) {
                    g2 = f2.return;
                    if (null === g2)
                      throw Error(p$1(341));
                    g2.lanes |= c2;
                    h2 = g2.alternate;
                    null !== h2 && (h2.lanes |= c2);
                    Sg(g2, c2, b2);
                    g2 = f2.sibling;
                  } else
                    g2 = f2.child;
                  if (null !== g2)
                    g2.return = f2;
                  else
                    for (g2 = f2; null !== g2; ) {
                      if (g2 === b2) {
                        g2 = null;
                        break;
                      }
                      f2 = g2.sibling;
                      if (null !== f2) {
                        f2.return = g2.return;
                        g2 = f2;
                        break;
                      }
                      g2 = g2.return;
                    }
                  f2 = g2;
                }
            Yi(a, b2, e2.children, c2);
            b2 = b2.child;
          }
          return b2;
        case 9:
          return e2 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e2 = Vg(e2), d2 = d2(e2), b2.flags |= 1, Yi(a, b2, d2, c2), b2.child;
        case 14:
          return d2 = b2.type, e2 = Lg(d2, b2.pendingProps), e2 = Lg(d2.type, e2), aj(a, b2, d2, e2, c2);
        case 15:
          return cj(a, b2, b2.type, b2.pendingProps, c2);
        case 17:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), jj(a, b2), b2.tag = 1, Zf(d2) ? (a = true, cg(b2)) : a = false, Tg(b2, c2), ph(b2, d2, e2), rh(b2, d2, e2, c2), kj(null, b2, d2, true, a, c2);
        case 19:
          return yj(a, b2, c2);
        case 22:
          return ej(a, b2, c2);
      }
      throw Error(p$1(156, b2.tag));
    };
    function Gk(a, b2) {
      return ac(a, b2);
    }
    function al(a, b2, c2, d2) {
      this.tag = a;
      this.key = c2;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.ref = null;
      this.pendingProps = b2;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = d2;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    function Bg(a, b2, c2, d2) {
      return new al(a, b2, c2, d2);
    }
    function bj(a) {
      a = a.prototype;
      return !(!a || !a.isReactComponent);
    }
    function $k(a) {
      if ("function" === typeof a)
        return bj(a) ? 1 : 0;
      if (void 0 !== a && null !== a) {
        a = a.$$typeof;
        if (a === Da)
          return 11;
        if (a === Ga)
          return 14;
      }
      return 2;
    }
    function wh(a, b2) {
      var c2 = a.alternate;
      null === c2 ? (c2 = Bg(a.tag, b2, a.key, a.mode), c2.elementType = a.elementType, c2.type = a.type, c2.stateNode = a.stateNode, c2.alternate = a, a.alternate = c2) : (c2.pendingProps = b2, c2.type = a.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
      c2.flags = a.flags & 14680064;
      c2.childLanes = a.childLanes;
      c2.lanes = a.lanes;
      c2.child = a.child;
      c2.memoizedProps = a.memoizedProps;
      c2.memoizedState = a.memoizedState;
      c2.updateQueue = a.updateQueue;
      b2 = a.dependencies;
      c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
      c2.sibling = a.sibling;
      c2.index = a.index;
      c2.ref = a.ref;
      return c2;
    }
    function yh(a, b2, c2, d2, e2, f2) {
      var g2 = 2;
      d2 = a;
      if ("function" === typeof a)
        bj(a) && (g2 = 1);
      else if ("string" === typeof a)
        g2 = 5;
      else
        a:
          switch (a) {
            case ya:
              return Ah(c2.children, e2, f2, b2);
            case za:
              g2 = 8;
              e2 |= 8;
              break;
            case Aa:
              return a = Bg(12, c2, b2, e2 | 2), a.elementType = Aa, a.lanes = f2, a;
            case Ea:
              return a = Bg(13, c2, b2, e2), a.elementType = Ea, a.lanes = f2, a;
            case Fa:
              return a = Bg(19, c2, b2, e2), a.elementType = Fa, a.lanes = f2, a;
            case Ia:
              return qj(c2, e2, f2, b2);
            default:
              if ("object" === typeof a && null !== a)
                switch (a.$$typeof) {
                  case Ba:
                    g2 = 10;
                    break a;
                  case Ca:
                    g2 = 9;
                    break a;
                  case Da:
                    g2 = 11;
                    break a;
                  case Ga:
                    g2 = 14;
                    break a;
                  case Ha:
                    g2 = 16;
                    d2 = null;
                    break a;
                }
              throw Error(p$1(130, null == a ? a : typeof a, ""));
          }
      b2 = Bg(g2, c2, b2, e2);
      b2.elementType = a;
      b2.type = d2;
      b2.lanes = f2;
      return b2;
    }
    function Ah(a, b2, c2, d2) {
      a = Bg(7, a, d2, b2);
      a.lanes = c2;
      return a;
    }
    function qj(a, b2, c2, d2) {
      a = Bg(22, a, d2, b2);
      a.elementType = Ia;
      a.lanes = c2;
      a.stateNode = { isHidden: false };
      return a;
    }
    function xh(a, b2, c2) {
      a = Bg(6, a, null, b2);
      a.lanes = c2;
      return a;
    }
    function zh(a, b2, c2) {
      b2 = Bg(4, null !== a.children ? a.children : [], a.key, b2);
      b2.lanes = c2;
      b2.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
      return b2;
    }
    function bl(a, b2, c2, d2, e2) {
      this.tag = b2;
      this.containerInfo = a;
      this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = -1;
      this.callbackNode = this.pendingContext = this.context = null;
      this.callbackPriority = 0;
      this.eventTimes = zc(0);
      this.expirationTimes = zc(-1);
      this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = zc(0);
      this.identifierPrefix = d2;
      this.onRecoverableError = e2;
      this.mutableSourceEagerHydrationData = null;
    }
    function cl(a, b2, c2, d2, e2, f2, g2, h2, k2) {
      a = new bl(a, b2, c2, h2, k2);
      1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
      f2 = Bg(3, null, null, b2);
      a.current = f2;
      f2.stateNode = a;
      f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
      ah(f2);
      return a;
    }
    function dl(a, b2, c2) {
      var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a, containerInfo: b2, implementation: c2 };
    }
    function el(a) {
      if (!a)
        return Vf;
      a = a._reactInternals;
      a: {
        if (Vb(a) !== a || 1 !== a.tag)
          throw Error(p$1(170));
        var b2 = a;
        do {
          switch (b2.tag) {
            case 3:
              b2 = b2.stateNode.context;
              break a;
            case 1:
              if (Zf(b2.type)) {
                b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
                break a;
              }
          }
          b2 = b2.return;
        } while (null !== b2);
        throw Error(p$1(171));
      }
      if (1 === a.tag) {
        var c2 = a.type;
        if (Zf(c2))
          return bg(a, c2, b2);
      }
      return b2;
    }
    function fl(a, b2, c2, d2, e2, f2, g2, h2, k2) {
      a = cl(c2, d2, true, a, e2, f2, g2, h2, k2);
      a.context = el(null);
      c2 = a.current;
      d2 = L();
      e2 = lh(c2);
      f2 = ch(d2, e2);
      f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
      dh(c2, f2, e2);
      a.current.lanes = e2;
      Ac(a, e2, d2);
      Ek(a, d2);
      return a;
    }
    function gl(a, b2, c2, d2) {
      var e2 = b2.current, f2 = L(), g2 = lh(e2);
      c2 = el(c2);
      null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
      b2 = ch(f2, g2);
      b2.payload = { element: a };
      d2 = void 0 === d2 ? null : d2;
      null !== d2 && (b2.callback = d2);
      a = dh(e2, b2, g2);
      null !== a && (mh(a, e2, g2, f2), eh(a, e2, g2));
      return g2;
    }
    function hl(a) {
      a = a.current;
      if (!a.child)
        return null;
      switch (a.child.tag) {
        case 5:
          return a.child.stateNode;
        default:
          return a.child.stateNode;
      }
    }
    function il(a, b2) {
      a = a.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        var c2 = a.retryLane;
        a.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
      }
    }
    function jl(a, b2) {
      il(a, b2);
      (a = a.alternate) && il(a, b2);
    }
    function kl() {
      return null;
    }
    var ll = "function" === typeof reportError ? reportError : function(a) {
      console.error(a);
    };
    function ml(a) {
      this._internalRoot = a;
    }
    nl.prototype.render = ml.prototype.render = function(a) {
      var b2 = this._internalRoot;
      if (null === b2)
        throw Error(p$1(409));
      gl(a, b2, null, null);
    };
    nl.prototype.unmount = ml.prototype.unmount = function() {
      var a = this._internalRoot;
      if (null !== a) {
        this._internalRoot = null;
        var b2 = a.containerInfo;
        Sk(function() {
          gl(null, a, null, null);
        });
        b2[uf] = null;
      }
    };
    function nl(a) {
      this._internalRoot = a;
    }
    nl.prototype.unstable_scheduleHydration = function(a) {
      if (a) {
        var b2 = Hc();
        a = { blockedOn: null, target: a, priority: b2 };
        for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
          ;
        Qc.splice(c2, 0, a);
        0 === c2 && Vc(a);
      }
    };
    function ol(a) {
      return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
    }
    function pl(a) {
      return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
    }
    function ql() {
    }
    function rl(a, b2, c2, d2, e2) {
      if (e2) {
        if ("function" === typeof d2) {
          var f2 = d2;
          d2 = function() {
            var a2 = hl(g2);
            f2.call(a2);
          };
        }
        var g2 = fl(b2, d2, a, 0, null, false, false, "", ql);
        a._reactRootContainer = g2;
        a[uf] = g2.current;
        sf(8 === a.nodeType ? a.parentNode : a);
        Sk();
        return g2;
      }
      for (; e2 = a.lastChild; )
        a.removeChild(e2);
      if ("function" === typeof d2) {
        var h2 = d2;
        d2 = function() {
          var a2 = hl(k2);
          h2.call(a2);
        };
      }
      var k2 = cl(a, 0, false, null, null, false, false, "", ql);
      a._reactRootContainer = k2;
      a[uf] = k2.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      Sk(function() {
        gl(b2, k2, c2, d2);
      });
      return k2;
    }
    function sl(a, b2, c2, d2, e2) {
      var f2 = c2._reactRootContainer;
      if (f2) {
        var g2 = f2;
        if ("function" === typeof e2) {
          var h2 = e2;
          e2 = function() {
            var a2 = hl(g2);
            h2.call(a2);
          };
        }
        gl(b2, g2, a, e2);
      } else
        g2 = rl(c2, b2, a, e2, d2);
      return hl(g2);
    }
    Ec = function(a) {
      switch (a.tag) {
        case 3:
          var b2 = a.stateNode;
          if (b2.current.memoizedState.isDehydrated) {
            var c2 = tc(b2.pendingLanes);
            0 !== c2 && (Cc(b2, c2 | 1), Ek(b2, B()), 0 === (K & 6) && (Hj = B() + 500, jg()));
          }
          break;
        case 13:
          Sk(function() {
            var b3 = Zg(a, 1);
            if (null !== b3) {
              var c3 = L();
              mh(b3, a, 1, c3);
            }
          }), jl(a, 1);
      }
    };
    Fc = function(a) {
      if (13 === a.tag) {
        var b2 = Zg(a, 134217728);
        if (null !== b2) {
          var c2 = L();
          mh(b2, a, 134217728, c2);
        }
        jl(a, 134217728);
      }
    };
    Gc = function(a) {
      if (13 === a.tag) {
        var b2 = lh(a), c2 = Zg(a, b2);
        if (null !== c2) {
          var d2 = L();
          mh(c2, a, b2, d2);
        }
        jl(a, b2);
      }
    };
    Hc = function() {
      return C;
    };
    Ic = function(a, b2) {
      var c2 = C;
      try {
        return C = a, b2();
      } finally {
        C = c2;
      }
    };
    yb = function(a, b2, c2) {
      switch (b2) {
        case "input":
          bb(a, c2);
          b2 = c2.name;
          if ("radio" === c2.type && null != b2) {
            for (c2 = a; c2.parentNode; )
              c2 = c2.parentNode;
            c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
            for (b2 = 0; b2 < c2.length; b2++) {
              var d2 = c2[b2];
              if (d2 !== a && d2.form === a.form) {
                var e2 = Db(d2);
                if (!e2)
                  throw Error(p$1(90));
                Wa(d2);
                bb(d2, e2);
              }
            }
          }
          break;
        case "textarea":
          ib(a, c2);
          break;
        case "select":
          b2 = c2.value, null != b2 && fb(a, !!c2.multiple, b2, false);
      }
    };
    Gb = Rk;
    Hb = Sk;
    var tl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
    var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
      a = Zb(a);
      return null === a ? null : a.stateNode;
    }, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
      var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!wl.isDisabled && wl.supportsFiber)
        try {
          kc = wl.inject(vl), lc = wl;
        } catch (a) {
        }
    }
    reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
    reactDom_production_min.createPortal = function(a, b2) {
      var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!ol(b2))
        throw Error(p$1(200));
      return dl(a, b2, null, c2);
    };
    reactDom_production_min.createRoot = function(a, b2) {
      if (!ol(a))
        throw Error(p$1(299));
      var c2 = false, d2 = "", e2 = ll;
      null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
      b2 = cl(a, 1, false, null, null, c2, false, d2, e2);
      a[uf] = b2.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      return new ml(b2);
    };
    reactDom_production_min.findDOMNode = function(a) {
      if (null == a)
        return null;
      if (1 === a.nodeType)
        return a;
      var b2 = a._reactInternals;
      if (void 0 === b2) {
        if ("function" === typeof a.render)
          throw Error(p$1(188));
        a = Object.keys(a).join(",");
        throw Error(p$1(268, a));
      }
      a = Zb(b2);
      a = null === a ? null : a.stateNode;
      return a;
    };
    reactDom_production_min.flushSync = function(a) {
      return Sk(a);
    };
    reactDom_production_min.hydrate = function(a, b2, c2) {
      if (!pl(b2))
        throw Error(p$1(200));
      return sl(null, a, b2, true, c2);
    };
    reactDom_production_min.hydrateRoot = function(a, b2, c2) {
      if (!ol(a))
        throw Error(p$1(405));
      var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = ll;
      null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
      b2 = fl(b2, null, a, 1, null != c2 ? c2 : null, e2, false, f2, g2);
      a[uf] = b2.current;
      sf(a);
      if (d2)
        for (a = 0; a < d2.length; a++)
          c2 = d2[a], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
            c2,
            e2
          );
      return new nl(b2);
    };
    reactDom_production_min.render = function(a, b2, c2) {
      if (!pl(b2))
        throw Error(p$1(200));
      return sl(null, a, b2, false, c2);
    };
    reactDom_production_min.unmountComponentAtNode = function(a) {
      if (!pl(a))
        throw Error(p$1(40));
      return a._reactRootContainer ? (Sk(function() {
        sl(null, null, a, false, function() {
          a._reactRootContainer = null;
          a[uf] = null;
        });
      }), true) : false;
    };
    reactDom_production_min.unstable_batchedUpdates = Rk;
    reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b2, c2, d2) {
      if (!pl(c2))
        throw Error(p$1(200));
      if (null == a || void 0 === a._reactInternals)
        throw Error(p$1(38));
      return sl(a, b2, c2, false, d2);
    };
    reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
    function checkDCE() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
        return;
      }
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err) {
        console.error(err);
      }
    }
    {
      checkDCE();
      reactDom.exports = reactDom_production_min;
    }
    var reactDomExports = reactDom.exports;
    const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
    const ReactDOM$1 = /* @__PURE__ */ _mergeNamespaces({
      __proto__: null,
      default: ReactDOM
    }, [reactDomExports]);
    var m$1 = reactDomExports;
    {
      client.createRoot = m$1.createRoot;
      client.hydrateRoot = m$1.hydrateRoot;
    }
    /**
     * @remix-run/router v1.14.0
     *
     * Copyright (c) Remix Software Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    function _extends$3() {
      _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$3.apply(this, arguments);
    }
    var Action;
    (function(Action2) {
      Action2["Pop"] = "POP";
      Action2["Push"] = "PUSH";
      Action2["Replace"] = "REPLACE";
    })(Action || (Action = {}));
    const PopStateEventType = "popstate";
    function createBrowserHistory(options) {
      if (options === void 0) {
        options = {};
      }
      function createBrowserLocation(window2, globalHistory) {
        let {
          pathname,
          search,
          hash
        } = window2.location;
        return createLocation(
          "",
          {
            pathname,
            search,
            hash
          },
          // state defaults to `null` because `window.history.state` does
          globalHistory.state && globalHistory.state.usr || null,
          globalHistory.state && globalHistory.state.key || "default"
        );
      }
      function createBrowserHref(window2, to2) {
        return typeof to2 === "string" ? to2 : createPath(to2);
      }
      return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
    }
    function invariant(value, message) {
      if (value === false || value === null || typeof value === "undefined") {
        throw new Error(message);
      }
    }
    function warning$3(cond, message) {
      if (!cond) {
        if (typeof console !== "undefined")
          console.warn(message);
        try {
          throw new Error(message);
        } catch (e2) {
        }
      }
    }
    function createKey() {
      return Math.random().toString(36).substr(2, 8);
    }
    function getHistoryState(location2, index2) {
      return {
        usr: location2.state,
        key: location2.key,
        idx: index2
      };
    }
    function createLocation(current, to2, state, key) {
      if (state === void 0) {
        state = null;
      }
      let location2 = _extends$3({
        pathname: typeof current === "string" ? current : current.pathname,
        search: "",
        hash: ""
      }, typeof to2 === "string" ? parsePath(to2) : to2, {
        state,
        // TODO: This could be cleaned up.  push/replace should probably just take
        // full Locations now and avoid the need to run through this flow at all
        // But that's a pretty big refactor to the current test suite so going to
        // keep as is for the time being and just let any incoming keys take precedence
        key: to2 && to2.key || key || createKey()
      });
      return location2;
    }
    function createPath(_ref) {
      let {
        pathname = "/",
        search = "",
        hash = ""
      } = _ref;
      if (search && search !== "?")
        pathname += search.charAt(0) === "?" ? search : "?" + search;
      if (hash && hash !== "#")
        pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
      return pathname;
    }
    function parsePath(path) {
      let parsedPath = {};
      if (path) {
        let hashIndex = path.indexOf("#");
        if (hashIndex >= 0) {
          parsedPath.hash = path.substr(hashIndex);
          path = path.substr(0, hashIndex);
        }
        let searchIndex = path.indexOf("?");
        if (searchIndex >= 0) {
          parsedPath.search = path.substr(searchIndex);
          path = path.substr(0, searchIndex);
        }
        if (path) {
          parsedPath.pathname = path;
        }
      }
      return parsedPath;
    }
    function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
      if (options === void 0) {
        options = {};
      }
      let {
        window: window2 = document.defaultView,
        v5Compat = false
      } = options;
      let globalHistory = window2.history;
      let action = Action.Pop;
      let listener = null;
      let index2 = getIndex();
      if (index2 == null) {
        index2 = 0;
        globalHistory.replaceState(_extends$3({}, globalHistory.state, {
          idx: index2
        }), "");
      }
      function getIndex() {
        let state = globalHistory.state || {
          idx: null
        };
        return state.idx;
      }
      function handlePop() {
        action = Action.Pop;
        let nextIndex = getIndex();
        let delta = nextIndex == null ? null : nextIndex - index2;
        index2 = nextIndex;
        if (listener) {
          listener({
            action,
            location: history.location,
            delta
          });
        }
      }
      function push(to2, state) {
        action = Action.Push;
        let location2 = createLocation(history.location, to2, state);
        if (validateLocation)
          validateLocation(location2, to2);
        index2 = getIndex() + 1;
        let historyState = getHistoryState(location2, index2);
        let url = history.createHref(location2);
        try {
          globalHistory.pushState(historyState, "", url);
        } catch (error) {
          if (error instanceof DOMException && error.name === "DataCloneError") {
            throw error;
          }
          window2.location.assign(url);
        }
        if (v5Compat && listener) {
          listener({
            action,
            location: history.location,
            delta: 1
          });
        }
      }
      function replace2(to2, state) {
        action = Action.Replace;
        let location2 = createLocation(history.location, to2, state);
        if (validateLocation)
          validateLocation(location2, to2);
        index2 = getIndex();
        let historyState = getHistoryState(location2, index2);
        let url = history.createHref(location2);
        globalHistory.replaceState(historyState, "", url);
        if (v5Compat && listener) {
          listener({
            action,
            location: history.location,
            delta: 0
          });
        }
      }
      function createURL(to2) {
        let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
        let href = typeof to2 === "string" ? to2 : createPath(to2);
        invariant(base, "No window.location.(origin|href) available to create URL for href: " + href);
        return new URL(href, base);
      }
      let history = {
        get action() {
          return action;
        },
        get location() {
          return getLocation(window2, globalHistory);
        },
        listen(fn) {
          if (listener) {
            throw new Error("A history only accepts one active listener");
          }
          window2.addEventListener(PopStateEventType, handlePop);
          listener = fn;
          return () => {
            window2.removeEventListener(PopStateEventType, handlePop);
            listener = null;
          };
        },
        createHref(to2) {
          return createHref(window2, to2);
        },
        createURL,
        encodeLocation(to2) {
          let url = createURL(to2);
          return {
            pathname: url.pathname,
            search: url.search,
            hash: url.hash
          };
        },
        push,
        replace: replace2,
        go(n2) {
          return globalHistory.go(n2);
        }
      };
      return history;
    }
    var ResultType;
    (function(ResultType2) {
      ResultType2["data"] = "data";
      ResultType2["deferred"] = "deferred";
      ResultType2["redirect"] = "redirect";
      ResultType2["error"] = "error";
    })(ResultType || (ResultType = {}));
    function matchRoutes(routes, locationArg, basename) {
      if (basename === void 0) {
        basename = "/";
      }
      let location2 = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
      let pathname = stripBasename(location2.pathname || "/", basename);
      if (pathname == null) {
        return null;
      }
      let branches = flattenRoutes(routes);
      rankRouteBranches(branches);
      let matches = null;
      for (let i = 0; matches == null && i < branches.length; ++i) {
        matches = matchRouteBranch(
          branches[i],
          // Incoming pathnames are generally encoded from either window.location
          // or from router.navigate, but we want to match against the unencoded
          // paths in the route definitions.  Memory router locations won't be
          // encoded here but there also shouldn't be anything to decode so this
          // should be a safe operation.  This avoids needing matchRoutes to be
          // history-aware.
          safelyDecodeURI(pathname)
        );
      }
      return matches;
    }
    function flattenRoutes(routes, branches, parentsMeta, parentPath) {
      if (branches === void 0) {
        branches = [];
      }
      if (parentsMeta === void 0) {
        parentsMeta = [];
      }
      if (parentPath === void 0) {
        parentPath = "";
      }
      let flattenRoute = (route, index2, relativePath) => {
        let meta = {
          relativePath: relativePath === void 0 ? route.path || "" : relativePath,
          caseSensitive: route.caseSensitive === true,
          childrenIndex: index2,
          route
        };
        if (meta.relativePath.startsWith("/")) {
          invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
          meta.relativePath = meta.relativePath.slice(parentPath.length);
        }
        let path = joinPaths([parentPath, meta.relativePath]);
        let routesMeta = parentsMeta.concat(meta);
        if (route.children && route.children.length > 0) {
          invariant(
            // Our types know better, but runtime JS may not!
            // @ts-expect-error
            route.index !== true,
            "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
          );
          flattenRoutes(route.children, branches, routesMeta, path);
        }
        if (route.path == null && !route.index) {
          return;
        }
        branches.push({
          path,
          score: computeScore(path, route.index),
          routesMeta
        });
      };
      routes.forEach((route, index2) => {
        var _route$path;
        if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
          flattenRoute(route, index2);
        } else {
          for (let exploded of explodeOptionalSegments(route.path)) {
            flattenRoute(route, index2, exploded);
          }
        }
      });
      return branches;
    }
    function explodeOptionalSegments(path) {
      let segments = path.split("/");
      if (segments.length === 0)
        return [];
      let [first, ...rest] = segments;
      let isOptional = first.endsWith("?");
      let required = first.replace(/\?$/, "");
      if (rest.length === 0) {
        return isOptional ? [required, ""] : [required];
      }
      let restExploded = explodeOptionalSegments(rest.join("/"));
      let result = [];
      result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/")));
      if (isOptional) {
        result.push(...restExploded);
      }
      return result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
    }
    function rankRouteBranches(branches) {
      branches.sort((a, b2) => a.score !== b2.score ? b2.score - a.score : compareIndexes(a.routesMeta.map((meta) => meta.childrenIndex), b2.routesMeta.map((meta) => meta.childrenIndex)));
    }
    const paramRe = /^:\w+$/;
    const dynamicSegmentValue = 3;
    const indexRouteValue = 2;
    const emptySegmentValue = 1;
    const staticSegmentValue = 10;
    const splatPenalty = -2;
    const isSplat = (s) => s === "*";
    function computeScore(path, index2) {
      let segments = path.split("/");
      let initialScore = segments.length;
      if (segments.some(isSplat)) {
        initialScore += splatPenalty;
      }
      if (index2) {
        initialScore += indexRouteValue;
      }
      return segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
    }
    function compareIndexes(a, b2) {
      let siblings = a.length === b2.length && a.slice(0, -1).every((n2, i) => n2 === b2[i]);
      return siblings ? (
        // If two routes are siblings, we should try to match the earlier sibling
        // first. This allows people to have fine-grained control over the matching
        // behavior by simply putting routes with identical paths in the order they
        // want them tried.
        a[a.length - 1] - b2[b2.length - 1]
      ) : (
        // Otherwise, it doesn't really make sense to rank non-siblings by index,
        // so they sort equally.
        0
      );
    }
    function matchRouteBranch(branch, pathname) {
      let {
        routesMeta
      } = branch;
      let matchedParams = {};
      let matchedPathname = "/";
      let matches = [];
      for (let i = 0; i < routesMeta.length; ++i) {
        let meta = routesMeta[i];
        let end = i === routesMeta.length - 1;
        let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
        let match5 = matchPath({
          path: meta.relativePath,
          caseSensitive: meta.caseSensitive,
          end
        }, remainingPathname);
        if (!match5)
          return null;
        Object.assign(matchedParams, match5.params);
        let route = meta.route;
        matches.push({
          // TODO: Can this as be avoided?
          params: matchedParams,
          pathname: joinPaths([matchedPathname, match5.pathname]),
          pathnameBase: normalizePathname(joinPaths([matchedPathname, match5.pathnameBase])),
          route
        });
        if (match5.pathnameBase !== "/") {
          matchedPathname = joinPaths([matchedPathname, match5.pathnameBase]);
        }
      }
      return matches;
    }
    function matchPath(pattern, pathname) {
      if (typeof pattern === "string") {
        pattern = {
          path: pattern,
          caseSensitive: false,
          end: true
        };
      }
      let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
      let match5 = pathname.match(matcher);
      if (!match5)
        return null;
      let matchedPathname = match5[0];
      let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
      let captureGroups = match5.slice(1);
      let params = compiledParams.reduce((memo, _ref, index2) => {
        let {
          paramName,
          isOptional
        } = _ref;
        if (paramName === "*") {
          let splatValue = captureGroups[index2] || "";
          pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
        }
        const value = captureGroups[index2];
        if (isOptional && !value) {
          memo[paramName] = void 0;
        } else {
          memo[paramName] = safelyDecodeURIComponent(value || "", paramName);
        }
        return memo;
      }, {});
      return {
        params,
        pathname: matchedPathname,
        pathnameBase,
        pattern
      };
    }
    function compilePath(path, caseSensitive, end) {
      if (caseSensitive === void 0) {
        caseSensitive = false;
      }
      if (end === void 0) {
        end = true;
      }
      warning$3(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
      let params = [];
      let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:(\w+)(\?)?/g, (_, paramName, isOptional) => {
        params.push({
          paramName,
          isOptional: isOptional != null
        });
        return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
      });
      if (path.endsWith("*")) {
        params.push({
          paramName: "*"
        });
        regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
      } else if (end) {
        regexpSource += "\\/*$";
      } else if (path !== "" && path !== "/") {
        regexpSource += "(?:(?=\\/|$))";
      } else
        ;
      let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
      return [matcher, params];
    }
    function safelyDecodeURI(value) {
      try {
        return decodeURI(value);
      } catch (error) {
        warning$3(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ")."));
        return value;
      }
    }
    function safelyDecodeURIComponent(value, paramName) {
      try {
        return decodeURIComponent(value);
      } catch (error) {
        warning$3(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ")."));
        return value;
      }
    }
    function stripBasename(pathname, basename) {
      if (basename === "/")
        return pathname;
      if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
        return null;
      }
      let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
      let nextChar = pathname.charAt(startIndex);
      if (nextChar && nextChar !== "/") {
        return null;
      }
      return pathname.slice(startIndex) || "/";
    }
    function resolvePath(to2, fromPathname) {
      if (fromPathname === void 0) {
        fromPathname = "/";
      }
      let {
        pathname: toPathname,
        search = "",
        hash = ""
      } = typeof to2 === "string" ? parsePath(to2) : to2;
      let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
      return {
        pathname,
        search: normalizeSearch(search),
        hash: normalizeHash(hash)
      };
    }
    function resolvePathname(relativePath, fromPathname) {
      let segments = fromPathname.replace(/\/+$/, "").split("/");
      let relativeSegments = relativePath.split("/");
      relativeSegments.forEach((segment) => {
        if (segment === "..") {
          if (segments.length > 1)
            segments.pop();
        } else if (segment !== ".") {
          segments.push(segment);
        }
      });
      return segments.length > 1 ? segments.join("/") : "/";
    }
    function getInvalidPathError(char2, field, dest, path) {
      return "Cannot include a '" + char2 + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
    }
    function getPathContributingMatches(matches) {
      return matches.filter((match5, index2) => index2 === 0 || match5.route.path && match5.route.path.length > 0);
    }
    function getResolveToMatches(matches, v7_relativeSplatPath) {
      let pathMatches = getPathContributingMatches(matches);
      if (v7_relativeSplatPath) {
        return pathMatches.map((match5, idx) => idx === matches.length - 1 ? match5.pathname : match5.pathnameBase);
      }
      return pathMatches.map((match5) => match5.pathnameBase);
    }
    function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
      if (isPathRelative === void 0) {
        isPathRelative = false;
      }
      let to2;
      if (typeof toArg === "string") {
        to2 = parsePath(toArg);
      } else {
        to2 = _extends$3({}, toArg);
        invariant(!to2.pathname || !to2.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to2));
        invariant(!to2.pathname || !to2.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to2));
        invariant(!to2.search || !to2.search.includes("#"), getInvalidPathError("#", "search", "hash", to2));
      }
      let isEmptyPath = toArg === "" || to2.pathname === "";
      let toPathname = isEmptyPath ? "/" : to2.pathname;
      let from2;
      if (toPathname == null) {
        from2 = locationPathname;
      } else if (isPathRelative) {
        let fromSegments = routePathnames.length === 0 ? [] : routePathnames[routePathnames.length - 1].replace(/^\//, "").split("/");
        if (toPathname.startsWith("..")) {
          let toSegments = toPathname.split("/");
          while (toSegments[0] === "..") {
            toSegments.shift();
            fromSegments.pop();
          }
          to2.pathname = toSegments.join("/");
        }
        from2 = "/" + fromSegments.join("/");
      } else {
        let routePathnameIndex = routePathnames.length - 1;
        if (toPathname.startsWith("..")) {
          let toSegments = toPathname.split("/");
          while (toSegments[0] === "..") {
            toSegments.shift();
            routePathnameIndex -= 1;
          }
          to2.pathname = toSegments.join("/");
        }
        from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
      }
      let path = resolvePath(to2, from2);
      let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
      let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
      if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
        path.pathname += "/";
      }
      return path;
    }
    const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
    const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
    const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
    const normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
    function isRouteErrorResponse(error) {
      return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
    }
    const validMutationMethodsArr = ["post", "put", "patch", "delete"];
    new Set(validMutationMethodsArr);
    const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
    new Set(validRequestMethodsArr);
    /**
     * React Router v6.21.0
     *
     * Copyright (c) Remix Software Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    function _extends$2() {
      _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$2.apply(this, arguments);
    }
    const DataRouterContext = /* @__PURE__ */ reactExports.createContext(null);
    const DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null);
    const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
    const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
    const RouteContext = /* @__PURE__ */ reactExports.createContext({
      outlet: null,
      matches: [],
      isDataRoute: false
    });
    const RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
    function useInRouterContext() {
      return reactExports.useContext(LocationContext) != null;
    }
    function useLocation() {
      !useInRouterContext() ? invariant(false) : void 0;
      return reactExports.useContext(LocationContext).location;
    }
    function useIsomorphicLayoutEffect$1(cb2) {
      let isStatic = reactExports.useContext(NavigationContext).static;
      if (!isStatic) {
        reactExports.useLayoutEffect(cb2);
      }
    }
    function useNavigate() {
      let {
        isDataRoute
      } = reactExports.useContext(RouteContext);
      return isDataRoute ? useNavigateStable() : useNavigateUnstable();
    }
    function useNavigateUnstable() {
      !useInRouterContext() ? invariant(false) : void 0;
      let dataRouterContext = reactExports.useContext(DataRouterContext);
      let {
        basename,
        future,
        navigator: navigator2
      } = reactExports.useContext(NavigationContext);
      let {
        matches
      } = reactExports.useContext(RouteContext);
      let {
        pathname: locationPathname
      } = useLocation();
      let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));
      let activeRef = reactExports.useRef(false);
      useIsomorphicLayoutEffect$1(() => {
        activeRef.current = true;
      });
      let navigate = reactExports.useCallback(function(to2, options) {
        if (options === void 0) {
          options = {};
        }
        if (!activeRef.current)
          return;
        if (typeof to2 === "number") {
          navigator2.go(to2);
          return;
        }
        let path = resolveTo(to2, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
        if (dataRouterContext == null && basename !== "/") {
          path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
        }
        (!!options.replace ? navigator2.replace : navigator2.push)(path, options.state, options);
      }, [basename, navigator2, routePathnamesJson, locationPathname, dataRouterContext]);
      return navigate;
    }
    const OutletContext = /* @__PURE__ */ reactExports.createContext(null);
    function useOutlet(context) {
      let outlet = reactExports.useContext(RouteContext).outlet;
      if (outlet) {
        return /* @__PURE__ */ reactExports.createElement(OutletContext.Provider, {
          value: context
        }, outlet);
      }
      return outlet;
    }
    function useParams() {
      let {
        matches
      } = reactExports.useContext(RouteContext);
      let routeMatch = matches[matches.length - 1];
      return routeMatch ? routeMatch.params : {};
    }
    function useRoutes(routes, locationArg) {
      return useRoutesImpl(routes, locationArg);
    }
    function useRoutesImpl(routes, locationArg, dataRouterState, future) {
      !useInRouterContext() ? invariant(false) : void 0;
      let {
        navigator: navigator2
      } = reactExports.useContext(NavigationContext);
      let {
        matches: parentMatches
      } = reactExports.useContext(RouteContext);
      let routeMatch = parentMatches[parentMatches.length - 1];
      let parentParams = routeMatch ? routeMatch.params : {};
      routeMatch ? routeMatch.pathname : "/";
      let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
      routeMatch && routeMatch.route;
      let locationFromContext = useLocation();
      let location2;
      if (locationArg) {
        var _parsedLocationArg$pa;
        let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
        !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant(false) : void 0;
        location2 = parsedLocationArg;
      } else {
        location2 = locationFromContext;
      }
      let pathname = location2.pathname || "/";
      let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
      let matches = matchRoutes(routes, {
        pathname: remainingPathname
      });
      let renderedMatches = _renderMatches(matches && matches.map((match5) => Object.assign({}, match5, {
        params: Object.assign({}, parentParams, match5.params),
        pathname: joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes
          navigator2.encodeLocation ? navigator2.encodeLocation(match5.pathname).pathname : match5.pathname
        ]),
        pathnameBase: match5.pathnameBase === "/" ? parentPathnameBase : joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes
          navigator2.encodeLocation ? navigator2.encodeLocation(match5.pathnameBase).pathname : match5.pathnameBase
        ])
      })), parentMatches, dataRouterState, future);
      if (locationArg && renderedMatches) {
        return /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
          value: {
            location: _extends$2({
              pathname: "/",
              search: "",
              hash: "",
              state: null,
              key: "default"
            }, location2),
            navigationType: Action.Pop
          }
        }, renderedMatches);
      }
      return renderedMatches;
    }
    function DefaultErrorComponent() {
      let error = useRouteError();
      let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
      let stack = error instanceof Error ? error.stack : null;
      let lightgrey = "rgba(200,200,200, 0.5)";
      let preStyles = {
        padding: "0.5rem",
        backgroundColor: lightgrey
      };
      let devInfo = null;
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
        style: {
          fontStyle: "italic"
        }
      }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
        style: preStyles
      }, stack) : null, devInfo);
    }
    const defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
    class RenderErrorBoundary extends reactExports.Component {
      constructor(props) {
        super(props);
        this.state = {
          location: props.location,
          revalidation: props.revalidation,
          error: props.error
        };
      }
      static getDerivedStateFromError(error) {
        return {
          error
        };
      }
      static getDerivedStateFromProps(props, state) {
        if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
          return {
            error: props.error,
            location: props.location,
            revalidation: props.revalidation
          };
        }
        return {
          error: props.error !== void 0 ? props.error : state.error,
          location: state.location,
          revalidation: props.revalidation || state.revalidation
        };
      }
      componentDidCatch(error, errorInfo) {
        console.error("React Router caught the following error during render", error, errorInfo);
      }
      render() {
        return this.state.error !== void 0 ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
          value: this.props.routeContext
        }, /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
          value: this.state.error,
          children: this.props.component
        })) : this.props.children;
      }
    }
    function RenderedRoute(_ref) {
      let {
        routeContext,
        match: match5,
        children
      } = _ref;
      let dataRouterContext = reactExports.useContext(DataRouterContext);
      if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match5.route.errorElement || match5.route.ErrorBoundary)) {
        dataRouterContext.staticContext._deepestRenderedBoundaryId = match5.route.id;
      }
      return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
        value: routeContext
      }, children);
    }
    function _renderMatches(matches, parentMatches, dataRouterState, future) {
      var _dataRouterState2;
      if (parentMatches === void 0) {
        parentMatches = [];
      }
      if (dataRouterState === void 0) {
        dataRouterState = null;
      }
      if (future === void 0) {
        future = null;
      }
      if (matches == null) {
        var _dataRouterState;
        if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {
          matches = dataRouterState.matches;
        } else {
          return null;
        }
      }
      let renderedMatches = matches;
      let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;
      if (errors != null) {
        let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors == null ? void 0 : errors[m2.route.id]));
        !(errorIndex >= 0) ? invariant(false) : void 0;
        renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
      }
      let renderFallback = false;
      let fallbackIndex = -1;
      if (dataRouterState && future && future.v7_partialHydration) {
        for (let i = 0; i < renderedMatches.length; i++) {
          let match5 = renderedMatches[i];
          if (match5.route.HydrateFallback || match5.route.hydrateFallbackElement) {
            fallbackIndex = i;
          }
          if (match5.route.loader && match5.route.id && dataRouterState.loaderData[match5.route.id] === void 0 && (!dataRouterState.errors || dataRouterState.errors[match5.route.id] === void 0)) {
            renderFallback = true;
            if (fallbackIndex >= 0) {
              renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
            } else {
              renderedMatches = [renderedMatches[0]];
            }
            break;
          }
        }
      }
      return renderedMatches.reduceRight((outlet, match5, index2) => {
        let error;
        let shouldRenderHydrateFallback = false;
        let errorElement = null;
        let hydrateFallbackElement = null;
        if (dataRouterState) {
          error = errors && match5.route.id ? errors[match5.route.id] : void 0;
          errorElement = match5.route.errorElement || defaultErrorElement;
          if (renderFallback) {
            if (fallbackIndex < 0 && index2 === 0) {
              warningOnce$1("route-fallback", false);
              shouldRenderHydrateFallback = true;
              hydrateFallbackElement = null;
            } else if (fallbackIndex === index2) {
              shouldRenderHydrateFallback = true;
              hydrateFallbackElement = match5.route.hydrateFallbackElement || null;
            }
          }
        }
        let matches2 = parentMatches.concat(renderedMatches.slice(0, index2 + 1));
        let getChildren = () => {
          let children;
          if (error) {
            children = errorElement;
          } else if (shouldRenderHydrateFallback) {
            children = hydrateFallbackElement;
          } else if (match5.route.Component) {
            children = /* @__PURE__ */ reactExports.createElement(match5.route.Component, null);
          } else if (match5.route.element) {
            children = match5.route.element;
          } else {
            children = outlet;
          }
          return /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
            match: match5,
            routeContext: {
              outlet,
              matches: matches2,
              isDataRoute: dataRouterState != null
            },
            children
          });
        };
        return dataRouterState && (match5.route.ErrorBoundary || match5.route.errorElement || index2 === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
          location: dataRouterState.location,
          revalidation: dataRouterState.revalidation,
          component: errorElement,
          error,
          children: getChildren(),
          routeContext: {
            outlet: null,
            matches: matches2,
            isDataRoute: true
          }
        }) : getChildren();
      }, null);
    }
    var DataRouterHook$1 = /* @__PURE__ */ function(DataRouterHook2) {
      DataRouterHook2["UseBlocker"] = "useBlocker";
      DataRouterHook2["UseRevalidator"] = "useRevalidator";
      DataRouterHook2["UseNavigateStable"] = "useNavigate";
      return DataRouterHook2;
    }(DataRouterHook$1 || {});
    var DataRouterStateHook$1 = /* @__PURE__ */ function(DataRouterStateHook2) {
      DataRouterStateHook2["UseBlocker"] = "useBlocker";
      DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
      DataRouterStateHook2["UseActionData"] = "useActionData";
      DataRouterStateHook2["UseRouteError"] = "useRouteError";
      DataRouterStateHook2["UseNavigation"] = "useNavigation";
      DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
      DataRouterStateHook2["UseMatches"] = "useMatches";
      DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
      DataRouterStateHook2["UseNavigateStable"] = "useNavigate";
      DataRouterStateHook2["UseRouteId"] = "useRouteId";
      return DataRouterStateHook2;
    }(DataRouterStateHook$1 || {});
    function useDataRouterContext(hookName) {
      let ctx = reactExports.useContext(DataRouterContext);
      !ctx ? invariant(false) : void 0;
      return ctx;
    }
    function useDataRouterState(hookName) {
      let state = reactExports.useContext(DataRouterStateContext);
      !state ? invariant(false) : void 0;
      return state;
    }
    function useRouteContext(hookName) {
      let route = reactExports.useContext(RouteContext);
      !route ? invariant(false) : void 0;
      return route;
    }
    function useCurrentRouteId(hookName) {
      let route = useRouteContext();
      let thisRoute = route.matches[route.matches.length - 1];
      !thisRoute.route.id ? invariant(false) : void 0;
      return thisRoute.route.id;
    }
    function useRouteError() {
      var _state$errors;
      let error = reactExports.useContext(RouteErrorContext);
      let state = useDataRouterState(DataRouterStateHook$1.UseRouteError);
      let routeId = useCurrentRouteId(DataRouterStateHook$1.UseRouteError);
      if (error !== void 0) {
        return error;
      }
      return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
    }
    function useNavigateStable() {
      let {
        router
      } = useDataRouterContext(DataRouterHook$1.UseNavigateStable);
      let id2 = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable);
      let activeRef = reactExports.useRef(false);
      useIsomorphicLayoutEffect$1(() => {
        activeRef.current = true;
      });
      let navigate = reactExports.useCallback(function(to2, options) {
        if (options === void 0) {
          options = {};
        }
        if (!activeRef.current)
          return;
        if (typeof to2 === "number") {
          router.navigate(to2);
        } else {
          router.navigate(to2, _extends$2({
            fromRouteId: id2
          }, options));
        }
      }, [router, id2]);
      return navigate;
    }
    const alreadyWarned = {};
    function warningOnce$1(key, cond, message) {
      if (!cond && !alreadyWarned[key]) {
        alreadyWarned[key] = true;
      }
    }
    function Outlet(props) {
      return useOutlet(props.context);
    }
    function Route(_props) {
      invariant(false);
    }
    function Router(_ref5) {
      let {
        basename: basenameProp = "/",
        children = null,
        location: locationProp,
        navigationType = Action.Pop,
        navigator: navigator2,
        static: staticProp = false,
        future
      } = _ref5;
      !!useInRouterContext() ? invariant(false) : void 0;
      let basename = basenameProp.replace(/^\/*/, "/");
      let navigationContext = reactExports.useMemo(() => ({
        basename,
        navigator: navigator2,
        static: staticProp,
        future: _extends$2({
          v7_relativeSplatPath: false
        }, future)
      }), [basename, future, navigator2, staticProp]);
      if (typeof locationProp === "string") {
        locationProp = parsePath(locationProp);
      }
      let {
        pathname = "/",
        search = "",
        hash = "",
        state = null,
        key = "default"
      } = locationProp;
      let locationContext = reactExports.useMemo(() => {
        let trailingPathname = stripBasename(pathname, basename);
        if (trailingPathname == null) {
          return null;
        }
        return {
          location: {
            pathname: trailingPathname,
            search,
            hash,
            state,
            key
          },
          navigationType
        };
      }, [basename, pathname, search, hash, state, key, navigationType]);
      if (locationContext == null) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
        value: navigationContext
      }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
        children,
        value: locationContext
      }));
    }
    function Routes(_ref6) {
      let {
        children,
        location: location2
      } = _ref6;
      return useRoutes(createRoutesFromChildren(children), location2);
    }
    new Promise(() => {
    });
    function createRoutesFromChildren(children, parentPath) {
      if (parentPath === void 0) {
        parentPath = [];
      }
      let routes = [];
      reactExports.Children.forEach(children, (element, index2) => {
        if (!/* @__PURE__ */ reactExports.isValidElement(element)) {
          return;
        }
        let treePath = [...parentPath, index2];
        if (element.type === reactExports.Fragment) {
          routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));
          return;
        }
        !(element.type === Route) ? invariant(false) : void 0;
        !(!element.props.index || !element.props.children) ? invariant(false) : void 0;
        let route = {
          id: element.props.id || treePath.join("-"),
          caseSensitive: element.props.caseSensitive,
          element: element.props.element,
          Component: element.props.Component,
          index: element.props.index,
          path: element.props.path,
          loader: element.props.loader,
          action: element.props.action,
          errorElement: element.props.errorElement,
          ErrorBoundary: element.props.ErrorBoundary,
          hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
          shouldRevalidate: element.props.shouldRevalidate,
          handle: element.props.handle,
          lazy: element.props.lazy
        };
        if (element.props.children) {
          route.children = createRoutesFromChildren(element.props.children, treePath);
        }
        routes.push(route);
      });
      return routes;
    }
    /**
     * React Router DOM v6.21.0
     *
     * Copyright (c) Remix Software Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    function createSearchParams(init) {
      if (init === void 0) {
        init = "";
      }
      return new URLSearchParams(typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {
        let value = init[key];
        return memo.concat(Array.isArray(value) ? value.map((v2) => [key, v2]) : [[key, value]]);
      }, []));
    }
    function getSearchParamsForLocation(locationSearch, defaultSearchParams) {
      let searchParams = createSearchParams(locationSearch);
      if (defaultSearchParams) {
        defaultSearchParams.forEach((_, key) => {
          if (!searchParams.has(key)) {
            defaultSearchParams.getAll(key).forEach((value) => {
              searchParams.append(key, value);
            });
          }
        });
      }
      return searchParams;
    }
    const START_TRANSITION = "startTransition";
    const startTransitionImpl = React$1[START_TRANSITION];
    function BrowserRouter(_ref4) {
      let {
        basename,
        children,
        future,
        window: window2
      } = _ref4;
      let historyRef = reactExports.useRef();
      if (historyRef.current == null) {
        historyRef.current = createBrowserHistory({
          window: window2,
          v5Compat: true
        });
      }
      let history = historyRef.current;
      let [state, setStateImpl] = reactExports.useState({
        action: history.action,
        location: history.location
      });
      let {
        v7_startTransition
      } = future || {};
      let setState = reactExports.useCallback((newState) => {
        v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
      }, [setStateImpl, v7_startTransition]);
      reactExports.useLayoutEffect(() => history.listen(setState), [history, setState]);
      return /* @__PURE__ */ reactExports.createElement(Router, {
        basename,
        children,
        location: state.location,
        navigationType: state.action,
        navigator: history,
        future
      });
    }
    var DataRouterHook;
    (function(DataRouterHook2) {
      DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
      DataRouterHook2["UseSubmit"] = "useSubmit";
      DataRouterHook2["UseSubmitFetcher"] = "useSubmitFetcher";
      DataRouterHook2["UseFetcher"] = "useFetcher";
      DataRouterHook2["useViewTransitionState"] = "useViewTransitionState";
    })(DataRouterHook || (DataRouterHook = {}));
    var DataRouterStateHook;
    (function(DataRouterStateHook2) {
      DataRouterStateHook2["UseFetcher"] = "useFetcher";
      DataRouterStateHook2["UseFetchers"] = "useFetchers";
      DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
    })(DataRouterStateHook || (DataRouterStateHook = {}));
    function useSearchParams(defaultInit) {
      let defaultSearchParamsRef = reactExports.useRef(createSearchParams(defaultInit));
      let hasSetSearchParamsRef = reactExports.useRef(false);
      let location2 = useLocation();
      let searchParams = reactExports.useMemo(() => (
        // Only merge in the defaults if we haven't yet called setSearchParams.
        // Once we call that we want those to take precedence, otherwise you can't
        // remove a param with setSearchParams({}) if it has an initial value
        getSearchParamsForLocation(location2.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current)
      ), [location2.search]);
      let navigate = useNavigate();
      let setSearchParams = reactExports.useCallback((nextInit, navigateOptions) => {
        const newSearchParams = createSearchParams(typeof nextInit === "function" ? nextInit(searchParams) : nextInit);
        hasSetSearchParamsRef.current = true;
        navigate("?" + newSearchParams, navigateOptions);
      }, [navigate, searchParams]);
      return [searchParams, setSearchParams];
    }
    var classnames = { exports: {} };
    /*!
    	Copyright (c) 2018 Jed Watson.
    	Licensed under the MIT License (MIT), see
    	http://jedwatson.github.io/classnames
    */
    (function(module2) {
      (function() {
        var hasOwn = {}.hasOwnProperty;
        function classNames2() {
          var classes = [];
          for (var i = 0; i < arguments.length; i++) {
            var arg = arguments[i];
            if (!arg)
              continue;
            var argType = typeof arg;
            if (argType === "string" || argType === "number") {
              classes.push(arg);
            } else if (Array.isArray(arg)) {
              if (arg.length) {
                var inner = classNames2.apply(null, arg);
                if (inner) {
                  classes.push(inner);
                }
              }
            } else if (argType === "object") {
              if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
                classes.push(arg.toString());
                continue;
              }
              for (var key in arg) {
                if (hasOwn.call(arg, key) && arg[key]) {
                  classes.push(key);
                }
              }
            }
          }
          return classes.join(" ");
        }
        if (module2.exports) {
          classNames2.default = classNames2;
          module2.exports = classNames2;
        } else {
          window.classNames = classNames2;
        }
      })();
    })(classnames);
    var classnamesExports = classnames.exports;
    const classNames = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
    function _extends$1() {
      _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$1.apply(this, arguments);
    }
    var reactIs = { exports: {} };
    var reactIs_production_min = {};
    /**
     * @license React
     * react-is.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var b = Symbol.for("react.element"), c = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e$2 = Symbol.for("react.strict_mode"), f = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h = Symbol.for("react.context"), k = Symbol.for("react.server_context"), l$1 = Symbol.for("react.forward_ref"), m = Symbol.for("react.suspense"), n$1 = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t$1 = Symbol.for("react.offscreen"), u;
    u = Symbol.for("react.module.reference");
    function v(a) {
      if ("object" === typeof a && null !== a) {
        var r2 = a.$$typeof;
        switch (r2) {
          case b:
            switch (a = a.type, a) {
              case d:
              case f:
              case e$2:
              case m:
              case n$1:
                return a;
              default:
                switch (a = a && a.$$typeof, a) {
                  case k:
                  case h:
                  case l$1:
                  case q:
                  case p:
                  case g:
                    return a;
                  default:
                    return r2;
                }
            }
          case c:
            return r2;
        }
      }
    }
    reactIs_production_min.ContextConsumer = h;
    reactIs_production_min.ContextProvider = g;
    reactIs_production_min.Element = b;
    reactIs_production_min.ForwardRef = l$1;
    reactIs_production_min.Fragment = d;
    reactIs_production_min.Lazy = q;
    reactIs_production_min.Memo = p;
    reactIs_production_min.Portal = c;
    reactIs_production_min.Profiler = f;
    reactIs_production_min.StrictMode = e$2;
    reactIs_production_min.Suspense = m;
    reactIs_production_min.SuspenseList = n$1;
    reactIs_production_min.isAsyncMode = function() {
      return false;
    };
    reactIs_production_min.isConcurrentMode = function() {
      return false;
    };
    reactIs_production_min.isContextConsumer = function(a) {
      return v(a) === h;
    };
    reactIs_production_min.isContextProvider = function(a) {
      return v(a) === g;
    };
    reactIs_production_min.isElement = function(a) {
      return "object" === typeof a && null !== a && a.$$typeof === b;
    };
    reactIs_production_min.isForwardRef = function(a) {
      return v(a) === l$1;
    };
    reactIs_production_min.isFragment = function(a) {
      return v(a) === d;
    };
    reactIs_production_min.isLazy = function(a) {
      return v(a) === q;
    };
    reactIs_production_min.isMemo = function(a) {
      return v(a) === p;
    };
    reactIs_production_min.isPortal = function(a) {
      return v(a) === c;
    };
    reactIs_production_min.isProfiler = function(a) {
      return v(a) === f;
    };
    reactIs_production_min.isStrictMode = function(a) {
      return v(a) === e$2;
    };
    reactIs_production_min.isSuspense = function(a) {
      return v(a) === m;
    };
    reactIs_production_min.isSuspenseList = function(a) {
      return v(a) === n$1;
    };
    reactIs_production_min.isValidElementType = function(a) {
      return "string" === typeof a || "function" === typeof a || a === d || a === f || a === e$2 || a === m || a === n$1 || a === t$1 || "object" === typeof a && null !== a && (a.$$typeof === q || a.$$typeof === p || a.$$typeof === g || a.$$typeof === h || a.$$typeof === l$1 || a.$$typeof === u || void 0 !== a.getModuleId) ? true : false;
    };
    reactIs_production_min.typeOf = v;
    {
      reactIs.exports = reactIs_production_min;
    }
    var reactIsExports = reactIs.exports;
    function toArray$a(children) {
      var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var ret = [];
      React.Children.forEach(children, function(child) {
        if ((child === void 0 || child === null) && !option.keepEmpty) {
          return;
        }
        if (Array.isArray(child)) {
          ret = ret.concat(toArray$a(child));
        } else if (reactIsExports.isFragment(child) && child.props) {
          ret = ret.concat(toArray$a(child.props.children, option));
        } else {
          ret.push(child);
        }
      });
      return ret;
    }
    var warned = {};
    var preMessage = function preMessage2(fn) {
    };
    function warning$2(valid, message) {
    }
    function note(valid, message) {
    }
    function resetWarned() {
      warned = {};
    }
    function call(method, valid, message) {
      if (!valid && !warned[message]) {
        method(false, message);
        warned[message] = true;
      }
    }
    function warningOnce(valid, message) {
      call(warning$2, valid, message);
    }
    function noteOnce(valid, message) {
      call(note, valid, message);
    }
    warningOnce.preMessage = preMessage;
    warningOnce.resetWarned = resetWarned;
    warningOnce.noteOnce = noteOnce;
    function _typeof(o2) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
        return typeof o3;
      } : function(o3) {
        return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
      }, _typeof(o2);
    }
    function toPrimitive(t2, r2) {
      if ("object" != _typeof(t2) || !t2)
        return t2;
      var e2 = t2[Symbol.toPrimitive];
      if (void 0 !== e2) {
        var i = e2.call(t2, r2 || "default");
        if ("object" != _typeof(i))
          return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    function toPropertyKey(t2) {
      var i = toPrimitive(t2, "string");
      return "symbol" == _typeof(i) ? i : String(i);
    }
    function _defineProperty(obj, key, value) {
      key = toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function ownKeys(e2, r2) {
      var t2 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var o2 = Object.getOwnPropertySymbols(e2);
        r2 && (o2 = o2.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
        })), t2.push.apply(t2, o2);
      }
      return t2;
    }
    function _objectSpread2(e2) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
          _defineProperty(e2, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e2;
    }
    function isDOM(node2) {
      return node2 instanceof HTMLElement || node2 instanceof SVGElement;
    }
    function findDOMNode(node2) {
      if (isDOM(node2)) {
        return node2;
      }
      if (node2 instanceof React.Component) {
        return ReactDOM.findDOMNode(node2);
      }
      return null;
    }
    function useMemo(getValue2, condition, shouldUpdate) {
      var cacheRef = reactExports.useRef({});
      if (!("value" in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
        cacheRef.current.value = getValue2();
        cacheRef.current.condition = condition;
      }
      return cacheRef.current.value;
    }
    function fillRef(ref, node2) {
      if (typeof ref === "function") {
        ref(node2);
      } else if (_typeof(ref) === "object" && ref && "current" in ref) {
        ref.current = node2;
      }
    }
    function composeRef() {
      for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
        refs[_key] = arguments[_key];
      }
      var refList = refs.filter(function(ref) {
        return ref;
      });
      if (refList.length <= 1) {
        return refList[0];
      }
      return function(node2) {
        refs.forEach(function(ref) {
          fillRef(ref, node2);
        });
      };
    }
    function useComposeRef() {
      for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        refs[_key2] = arguments[_key2];
      }
      return useMemo(function() {
        return composeRef.apply(void 0, refs);
      }, refs, function(prev2, next2) {
        return prev2.length !== next2.length || prev2.every(function(ref, i) {
          return ref !== next2[i];
        });
      });
    }
    function supportRef(nodeOrComponent) {
      var _type$prototype, _nodeOrComponent$prot;
      var type = reactIsExports.isMemo(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
      if (typeof type === "function" && !((_type$prototype = type.prototype) !== null && _type$prototype !== void 0 && _type$prototype.render)) {
        return false;
      }
      if (typeof nodeOrComponent === "function" && !((_nodeOrComponent$prot = nodeOrComponent.prototype) !== null && _nodeOrComponent$prot !== void 0 && _nodeOrComponent$prot.render)) {
        return false;
      }
      return true;
    }
    function supportNodeRef(node2) {
      if (!/* @__PURE__ */ reactExports.isValidElement(node2)) {
        return false;
      }
      if (reactIsExports.isFragment(node2)) {
        return false;
      }
      return supportRef(node2);
    }
    var CollectionContext = /* @__PURE__ */ reactExports.createContext(null);
    function Collection$2(_ref) {
      var children = _ref.children, onBatchResize = _ref.onBatchResize;
      var resizeIdRef = reactExports.useRef(0);
      var resizeInfosRef = reactExports.useRef([]);
      var onCollectionResize = reactExports.useContext(CollectionContext);
      var onResize2 = reactExports.useCallback(function(size, element, data) {
        resizeIdRef.current += 1;
        var currentId = resizeIdRef.current;
        resizeInfosRef.current.push({
          size,
          element,
          data
        });
        Promise.resolve().then(function() {
          if (currentId === resizeIdRef.current) {
            onBatchResize === null || onBatchResize === void 0 || onBatchResize(resizeInfosRef.current);
            resizeInfosRef.current = [];
          }
        });
        onCollectionResize === null || onCollectionResize === void 0 || onCollectionResize(size, element, data);
      }, [onBatchResize, onCollectionResize]);
      return /* @__PURE__ */ reactExports.createElement(CollectionContext.Provider, {
        value: onResize2
      }, children);
    }
    var MapShim = function() {
      if (typeof Map !== "undefined") {
        return Map;
      }
      function getIndex(arr, key) {
        var result = -1;
        arr.some(function(entry, index2) {
          if (entry[0] === key) {
            result = index2;
            return true;
          }
          return false;
        });
        return result;
      }
      return (
        /** @class */
        function() {
          function class_1() {
            this.__entries__ = [];
          }
          Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function() {
              return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
          });
          class_1.prototype.get = function(key) {
            var index2 = getIndex(this.__entries__, key);
            var entry = this.__entries__[index2];
            return entry && entry[1];
          };
          class_1.prototype.set = function(key, value) {
            var index2 = getIndex(this.__entries__, key);
            if (~index2) {
              this.__entries__[index2][1] = value;
            } else {
              this.__entries__.push([key, value]);
            }
          };
          class_1.prototype.delete = function(key) {
            var entries = this.__entries__;
            var index2 = getIndex(entries, key);
            if (~index2) {
              entries.splice(index2, 1);
            }
          };
          class_1.prototype.has = function(key) {
            return !!~getIndex(this.__entries__, key);
          };
          class_1.prototype.clear = function() {
            this.__entries__.splice(0);
          };
          class_1.prototype.forEach = function(callback, ctx) {
            if (ctx === void 0) {
              ctx = null;
            }
            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
              var entry = _a[_i];
              callback.call(ctx, entry[1], entry[0]);
            }
          };
          return class_1;
        }()
      );
    }();
    var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
    var global$1 = function() {
      if (typeof global !== "undefined" && global.Math === Math) {
        return global;
      }
      if (typeof self !== "undefined" && self.Math === Math) {
        return self;
      }
      if (typeof window !== "undefined" && window.Math === Math) {
        return window;
      }
      return Function("return this")();
    }();
    var requestAnimationFrame$1 = function() {
      if (typeof requestAnimationFrame === "function") {
        return requestAnimationFrame.bind(global$1);
      }
      return function(callback) {
        return setTimeout(function() {
          return callback(Date.now());
        }, 1e3 / 60);
      };
    }();
    var trailingTimeout = 2;
    function throttle$1(callback, delay) {
      var leadingCall = false, trailingCall = false, lastCallTime = 0;
      function resolvePending() {
        if (leadingCall) {
          leadingCall = false;
          callback();
        }
        if (trailingCall) {
          proxy();
        }
      }
      function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
      }
      function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
          if (timeStamp - lastCallTime < trailingTimeout) {
            return;
          }
          trailingCall = true;
        } else {
          leadingCall = true;
          trailingCall = false;
          setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
      }
      return proxy;
    }
    var REFRESH_DELAY = 20;
    var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
    var mutationObserverSupported = typeof MutationObserver !== "undefined";
    var ResizeObserverController = (
      /** @class */
      function() {
        function ResizeObserverController2() {
          this.connected_ = false;
          this.mutationEventsAdded_ = false;
          this.mutationsObserver_ = null;
          this.observers_ = [];
          this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
          this.refresh = throttle$1(this.refresh.bind(this), REFRESH_DELAY);
        }
        ResizeObserverController2.prototype.addObserver = function(observer) {
          if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
          }
          if (!this.connected_) {
            this.connect_();
          }
        };
        ResizeObserverController2.prototype.removeObserver = function(observer) {
          var observers2 = this.observers_;
          var index2 = observers2.indexOf(observer);
          if (~index2) {
            observers2.splice(index2, 1);
          }
          if (!observers2.length && this.connected_) {
            this.disconnect_();
          }
        };
        ResizeObserverController2.prototype.refresh = function() {
          var changesDetected = this.updateObservers_();
          if (changesDetected) {
            this.refresh();
          }
        };
        ResizeObserverController2.prototype.updateObservers_ = function() {
          var activeObservers = this.observers_.filter(function(observer) {
            return observer.gatherActive(), observer.hasActive();
          });
          activeObservers.forEach(function(observer) {
            return observer.broadcastActive();
          });
          return activeObservers.length > 0;
        };
        ResizeObserverController2.prototype.connect_ = function() {
          if (!isBrowser || this.connected_) {
            return;
          }
          document.addEventListener("transitionend", this.onTransitionEnd_);
          window.addEventListener("resize", this.refresh);
          if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
              attributes: true,
              childList: true,
              characterData: true,
              subtree: true
            });
          } else {
            document.addEventListener("DOMSubtreeModified", this.refresh);
            this.mutationEventsAdded_ = true;
          }
          this.connected_ = true;
        };
        ResizeObserverController2.prototype.disconnect_ = function() {
          if (!isBrowser || !this.connected_) {
            return;
          }
          document.removeEventListener("transitionend", this.onTransitionEnd_);
          window.removeEventListener("resize", this.refresh);
          if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
          }
          if (this.mutationEventsAdded_) {
            document.removeEventListener("DOMSubtreeModified", this.refresh);
          }
          this.mutationsObserver_ = null;
          this.mutationEventsAdded_ = false;
          this.connected_ = false;
        };
        ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
          var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
          var isReflowProperty = transitionKeys.some(function(key) {
            return !!~propertyName.indexOf(key);
          });
          if (isReflowProperty) {
            this.refresh();
          }
        };
        ResizeObserverController2.getInstance = function() {
          if (!this.instance_) {
            this.instance_ = new ResizeObserverController2();
          }
          return this.instance_;
        };
        ResizeObserverController2.instance_ = null;
        return ResizeObserverController2;
      }()
    );
    var defineConfigurable = function(target, props) {
      for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
          value: props[key],
          enumerable: false,
          writable: false,
          configurable: true
        });
      }
      return target;
    };
    var getWindowOf = function(target) {
      var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
      return ownerGlobal || global$1;
    };
    var emptyRect = createRectInit(0, 0, 0, 0);
    function toFloat(value) {
      return parseFloat(value) || 0;
    }
    function getBordersSize(styles) {
      var positions = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
      }
      return positions.reduce(function(size, position2) {
        var value = styles["border-" + position2 + "-width"];
        return size + toFloat(value);
      }, 0);
    }
    function getPaddings(styles) {
      var positions = ["top", "right", "bottom", "left"];
      var paddings = {};
      for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position2 = positions_1[_i];
        var value = styles["padding-" + position2];
        paddings[position2] = toFloat(value);
      }
      return paddings;
    }
    function getSVGContentRect(target) {
      var bbox = target.getBBox();
      return createRectInit(0, 0, bbox.width, bbox.height);
    }
    function getHTMLElementContentRect(target) {
      var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
      if (!clientWidth && !clientHeight) {
        return emptyRect;
      }
      var styles = getWindowOf(target).getComputedStyle(target);
      var paddings = getPaddings(styles);
      var horizPad = paddings.left + paddings.right;
      var vertPad = paddings.top + paddings.bottom;
      var width = toFloat(styles.width), height = toFloat(styles.height);
      if (styles.boxSizing === "border-box") {
        if (Math.round(width + horizPad) !== clientWidth) {
          width -= getBordersSize(styles, "left", "right") + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
          height -= getBordersSize(styles, "top", "bottom") + vertPad;
        }
      }
      if (!isDocumentElement(target)) {
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        if (Math.abs(vertScrollbar) !== 1) {
          width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
          height -= horizScrollbar;
        }
      }
      return createRectInit(paddings.left, paddings.top, width, height);
    }
    var isSVGGraphicsElement = function() {
      if (typeof SVGGraphicsElement !== "undefined") {
        return function(target) {
          return target instanceof getWindowOf(target).SVGGraphicsElement;
        };
      }
      return function(target) {
        return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
      };
    }();
    function isDocumentElement(target) {
      return target === getWindowOf(target).document.documentElement;
    }
    function getContentRect(target) {
      if (!isBrowser) {
        return emptyRect;
      }
      if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
      }
      return getHTMLElementContentRect(target);
    }
    function createReadOnlyRect(_a) {
      var x2 = _a.x, y2 = _a.y, width = _a.width, height = _a.height;
      var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
      var rect = Object.create(Constr.prototype);
      defineConfigurable(rect, {
        x: x2,
        y: y2,
        width,
        height,
        top: y2,
        right: x2 + width,
        bottom: height + y2,
        left: x2
      });
      return rect;
    }
    function createRectInit(x2, y2, width, height) {
      return { x: x2, y: y2, width, height };
    }
    var ResizeObservation = (
      /** @class */
      function() {
        function ResizeObservation2(target) {
          this.broadcastWidth = 0;
          this.broadcastHeight = 0;
          this.contentRect_ = createRectInit(0, 0, 0, 0);
          this.target = target;
        }
        ResizeObservation2.prototype.isActive = function() {
          var rect = getContentRect(this.target);
          this.contentRect_ = rect;
          return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
        };
        ResizeObservation2.prototype.broadcastRect = function() {
          var rect = this.contentRect_;
          this.broadcastWidth = rect.width;
          this.broadcastHeight = rect.height;
          return rect;
        };
        return ResizeObservation2;
      }()
    );
    var ResizeObserverEntry = (
      /** @class */
      /* @__PURE__ */ function() {
        function ResizeObserverEntry2(target, rectInit) {
          var contentRect = createReadOnlyRect(rectInit);
          defineConfigurable(this, { target, contentRect });
        }
        return ResizeObserverEntry2;
      }()
    );
    var ResizeObserverSPI = (
      /** @class */
      function() {
        function ResizeObserverSPI2(callback, controller, callbackCtx) {
          this.activeObservations_ = [];
          this.observations_ = new MapShim();
          if (typeof callback !== "function") {
            throw new TypeError("The callback provided as parameter 1 is not a function.");
          }
          this.callback_ = callback;
          this.controller_ = controller;
          this.callbackCtx_ = callbackCtx;
        }
        ResizeObserverSPI2.prototype.observe = function(target) {
          if (!arguments.length) {
            throw new TypeError("1 argument required, but only 0 present.");
          }
          if (typeof Element === "undefined" || !(Element instanceof Object)) {
            return;
          }
          if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
          }
          var observations = this.observations_;
          if (observations.has(target)) {
            return;
          }
          observations.set(target, new ResizeObservation(target));
          this.controller_.addObserver(this);
          this.controller_.refresh();
        };
        ResizeObserverSPI2.prototype.unobserve = function(target) {
          if (!arguments.length) {
            throw new TypeError("1 argument required, but only 0 present.");
          }
          if (typeof Element === "undefined" || !(Element instanceof Object)) {
            return;
          }
          if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
          }
          var observations = this.observations_;
          if (!observations.has(target)) {
            return;
          }
          observations.delete(target);
          if (!observations.size) {
            this.controller_.removeObserver(this);
          }
        };
        ResizeObserverSPI2.prototype.disconnect = function() {
          this.clearActive();
          this.observations_.clear();
          this.controller_.removeObserver(this);
        };
        ResizeObserverSPI2.prototype.gatherActive = function() {
          var _this = this;
          this.clearActive();
          this.observations_.forEach(function(observation) {
            if (observation.isActive()) {
              _this.activeObservations_.push(observation);
            }
          });
        };
        ResizeObserverSPI2.prototype.broadcastActive = function() {
          if (!this.hasActive()) {
            return;
          }
          var ctx = this.callbackCtx_;
          var entries = this.activeObservations_.map(function(observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
          });
          this.callback_.call(ctx, entries, ctx);
          this.clearActive();
        };
        ResizeObserverSPI2.prototype.clearActive = function() {
          this.activeObservations_.splice(0);
        };
        ResizeObserverSPI2.prototype.hasActive = function() {
          return this.activeObservations_.length > 0;
        };
        return ResizeObserverSPI2;
      }()
    );
    var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
    var ResizeObserver$2 = (
      /** @class */
      /* @__PURE__ */ function() {
        function ResizeObserver2(callback) {
          if (!(this instanceof ResizeObserver2)) {
            throw new TypeError("Cannot call a class as a function.");
          }
          if (!arguments.length) {
            throw new TypeError("1 argument required, but only 0 present.");
          }
          var controller = ResizeObserverController.getInstance();
          var observer = new ResizeObserverSPI(callback, controller, this);
          observers.set(this, observer);
        }
        return ResizeObserver2;
      }()
    );
    [
      "observe",
      "unobserve",
      "disconnect"
    ].forEach(function(method) {
      ResizeObserver$2.prototype[method] = function() {
        var _a;
        return (_a = observers.get(this))[method].apply(_a, arguments);
      };
    });
    var index$1 = function() {
      if (typeof global$1.ResizeObserver !== "undefined") {
        return global$1.ResizeObserver;
      }
      return ResizeObserver$2;
    }();
    var elementListeners = /* @__PURE__ */ new Map();
    function onResize(entities) {
      entities.forEach(function(entity) {
        var _elementListeners$get;
        var target = entity.target;
        (_elementListeners$get = elementListeners.get(target)) === null || _elementListeners$get === void 0 || _elementListeners$get.forEach(function(listener) {
          return listener(target);
        });
      });
    }
    var resizeObserver = new index$1(onResize);
    function observe(element, callback) {
      if (!elementListeners.has(element)) {
        elementListeners.set(element, /* @__PURE__ */ new Set());
        resizeObserver.observe(element);
      }
      elementListeners.get(element).add(callback);
    }
    function unobserve(element, callback) {
      if (elementListeners.has(element)) {
        elementListeners.get(element).delete(callback);
        if (!elementListeners.get(element).size) {
          resizeObserver.unobserve(element);
          elementListeners.delete(element);
        }
      }
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _setPrototypeOf$1(o2, p2) {
      _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf$1(o2, p2);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperty(subClass, "prototype", {
        writable: false
      });
      if (superClass)
        _setPrototypeOf$1(subClass, superClass);
    }
    function _getPrototypeOf$1(o2) {
      _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
        return o3.__proto__ || Object.getPrototypeOf(o3);
      };
      return _getPrototypeOf$1(o2);
    }
    function _isNativeReflectConstruct$1() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _possibleConstructorReturn(self2, call2) {
      if (call2 && (_typeof(call2) === "object" || typeof call2 === "function")) {
        return call2;
      } else if (call2 !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf$1(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf$1(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    var DomWrapper$1 = /* @__PURE__ */ function(_React$Component) {
      _inherits(DomWrapper2, _React$Component);
      var _super = _createSuper(DomWrapper2);
      function DomWrapper2() {
        _classCallCheck(this, DomWrapper2);
        return _super.apply(this, arguments);
      }
      _createClass(DomWrapper2, [{
        key: "render",
        value: function render2() {
          return this.props.children;
        }
      }]);
      return DomWrapper2;
    }(reactExports.Component);
    function SingleObserver(props, ref) {
      var children = props.children, disabled = props.disabled;
      var elementRef = reactExports.useRef(null);
      var wrapperRef = reactExports.useRef(null);
      var onCollectionResize = reactExports.useContext(CollectionContext);
      var isRenderProps = typeof children === "function";
      var mergedChildren = isRenderProps ? children(elementRef) : children;
      var sizeRef = reactExports.useRef({
        width: -1,
        height: -1,
        offsetWidth: -1,
        offsetHeight: -1
      });
      var canRef = !isRenderProps && /* @__PURE__ */ reactExports.isValidElement(mergedChildren) && supportRef(mergedChildren);
      var originRef = canRef ? mergedChildren.ref : null;
      var mergedRef = useComposeRef(originRef, elementRef);
      var getDom = function getDom2() {
        var _elementRef$current;
        return findDOMNode(elementRef.current) || // Support `nativeElement` format
        (elementRef.current && _typeof(elementRef.current) === "object" ? findDOMNode((_elementRef$current = elementRef.current) === null || _elementRef$current === void 0 ? void 0 : _elementRef$current.nativeElement) : null) || findDOMNode(wrapperRef.current);
      };
      reactExports.useImperativeHandle(ref, function() {
        return getDom();
      });
      var propsRef = reactExports.useRef(props);
      propsRef.current = props;
      var onInternalResize = reactExports.useCallback(function(target) {
        var _propsRef$current = propsRef.current, onResize2 = _propsRef$current.onResize, data = _propsRef$current.data;
        var _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height;
        var offsetWidth = target.offsetWidth, offsetHeight = target.offsetHeight;
        var fixedWidth = Math.floor(width);
        var fixedHeight = Math.floor(height);
        if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
          var size = {
            width: fixedWidth,
            height: fixedHeight,
            offsetWidth,
            offsetHeight
          };
          sizeRef.current = size;
          var mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;
          var mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;
          var sizeInfo = _objectSpread2(_objectSpread2({}, size), {}, {
            offsetWidth: mergedOffsetWidth,
            offsetHeight: mergedOffsetHeight
          });
          onCollectionResize === null || onCollectionResize === void 0 || onCollectionResize(sizeInfo, target, data);
          if (onResize2) {
            Promise.resolve().then(function() {
              onResize2(sizeInfo, target);
            });
          }
        }
      }, []);
      reactExports.useEffect(function() {
        var currentElement = getDom();
        if (currentElement && !disabled) {
          observe(currentElement, onInternalResize);
        }
        return function() {
          return unobserve(currentElement, onInternalResize);
        };
      }, [elementRef.current, disabled]);
      return /* @__PURE__ */ reactExports.createElement(DomWrapper$1, {
        ref: wrapperRef
      }, canRef ? /* @__PURE__ */ reactExports.cloneElement(mergedChildren, {
        ref: mergedRef
      }) : mergedChildren);
    }
    var RefSingleObserver = /* @__PURE__ */ reactExports.forwardRef(SingleObserver);
    var INTERNAL_PREFIX_KEY = "rc-observer-key";
    function ResizeObserver$1(props, ref) {
      var children = props.children;
      var childNodes = typeof children === "function" ? [children] : toArray$a(children);
      return childNodes.map(function(child, index2) {
        var key = (child === null || child === void 0 ? void 0 : child.key) || "".concat(INTERNAL_PREFIX_KEY, "-").concat(index2);
        return /* @__PURE__ */ reactExports.createElement(RefSingleObserver, _extends$1({}, props, {
          key,
          ref: index2 === 0 ? ref : void 0
        }), child);
      });
    }
    var RefResizeObserver = /* @__PURE__ */ reactExports.forwardRef(ResizeObserver$1);
    RefResizeObserver.Collection = Collection$2;
    function omit(obj, fields) {
      var clone2 = _objectSpread2({}, obj);
      if (Array.isArray(fields)) {
        fields.forEach(function(key) {
          delete clone2[key];
        });
      }
      return clone2;
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _unsupportedIterableToArray(o2, minLen) {
      if (!o2)
        return;
      if (typeof o2 === "string")
        return _arrayLikeToArray(o2, minLen);
      var n2 = Object.prototype.toString.call(o2).slice(8, -1);
      if (n2 === "Object" && o2.constructor)
        n2 = o2.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o2, minLen);
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    var raf = function raf2(callback) {
      return +setTimeout(callback, 16);
    };
    var caf = function caf2(num) {
      return clearTimeout(num);
    };
    if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
      raf = function raf3(callback) {
        return window.requestAnimationFrame(callback);
      };
      caf = function caf3(handle) {
        return window.cancelAnimationFrame(handle);
      };
    }
    var rafUUID = 0;
    var rafIds = /* @__PURE__ */ new Map();
    function cleanup(id2) {
      rafIds.delete(id2);
    }
    var wrapperRaf = function wrapperRaf2(callback) {
      var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      rafUUID += 1;
      var id2 = rafUUID;
      function callRef(leftTimes) {
        if (leftTimes === 0) {
          cleanup(id2);
          callback();
        } else {
          var realId = raf(function() {
            callRef(leftTimes - 1);
          });
          rafIds.set(id2, realId);
        }
      }
      callRef(times);
      return id2;
    };
    wrapperRaf.cancel = function(id2) {
      var realId = rafIds.get(id2);
      cleanup(id2);
      return caf(realId);
    };
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _iterableToArrayLimit(r2, l2) {
      var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
      if (null != t2) {
        var e2, n2, i, u2, a = [], f2 = true, o2 = false;
        try {
          if (i = (t2 = t2.call(r2)).next, 0 === l2) {
            if (Object(t2) !== t2)
              return;
            f2 = false;
          } else
            for (; !(f2 = (e2 = i.call(t2)).done) && (a.push(e2.value), a.length !== l2); f2 = true)
              ;
        } catch (r3) {
          o2 = true, n2 = r3;
        } finally {
          try {
            if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2))
              return;
          } finally {
            if (o2)
              throw n2;
          }
        }
        return a;
      }
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }
    function murmur2(str) {
      var h2 = 0;
      var k2, i = 0, len = str.length;
      for (; len >= 4; ++i, len -= 4) {
        k2 = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
        k2 = /* Math.imul(k, m): */
        (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
        k2 ^= /* k >>> r: */
        k2 >>> 24;
        h2 = /* Math.imul(k, m): */
        (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
        (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      switch (len) {
        case 3:
          h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
        case 2:
          h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
        case 1:
          h2 ^= str.charCodeAt(i) & 255;
          h2 = /* Math.imul(h, m): */
          (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      h2 ^= h2 >>> 13;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
    }
    function canUseDom() {
      return !!(typeof window !== "undefined" && window.document && window.document.createElement);
    }
    function contains(root, n2) {
      if (!root) {
        return false;
      }
      if (root.contains) {
        return root.contains(n2);
      }
      var node2 = n2;
      while (node2) {
        if (node2 === root) {
          return true;
        }
        node2 = node2.parentNode;
      }
      return false;
    }
    var APPEND_ORDER = "data-rc-order";
    var APPEND_PRIORITY = "data-rc-priority";
    var MARK_KEY = "rc-util-key";
    var containerCache = /* @__PURE__ */ new Map();
    function getMark() {
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark = _ref.mark;
      if (mark) {
        return mark.startsWith("data-") ? mark : "data-".concat(mark);
      }
      return MARK_KEY;
    }
    function getContainer(option) {
      if (option.attachTo) {
        return option.attachTo;
      }
      var head = document.querySelector("head");
      return head || document.body;
    }
    function getOrder(prepend) {
      if (prepend === "queue") {
        return "prependQueue";
      }
      return prepend ? "prepend" : "append";
    }
    function findStyles(container) {
      return Array.from((containerCache.get(container) || container).children).filter(function(node2) {
        return node2.tagName === "STYLE";
      });
    }
    function injectCSS(css) {
      var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!canUseDom()) {
        return null;
      }
      var csp = option.csp, prepend = option.prepend, _option$priority = option.priority, priority = _option$priority === void 0 ? 0 : _option$priority;
      var mergedOrder = getOrder(prepend);
      var isPrependQueue = mergedOrder === "prependQueue";
      var styleNode = document.createElement("style");
      styleNode.setAttribute(APPEND_ORDER, mergedOrder);
      if (isPrependQueue && priority) {
        styleNode.setAttribute(APPEND_PRIORITY, "".concat(priority));
      }
      if (csp !== null && csp !== void 0 && csp.nonce) {
        styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
      }
      styleNode.innerHTML = css;
      var container = getContainer(option);
      var firstChild = container.firstChild;
      if (prepend) {
        if (isPrependQueue) {
          var existStyle = findStyles(container).filter(function(node2) {
            if (!["prepend", "prependQueue"].includes(node2.getAttribute(APPEND_ORDER))) {
              return false;
            }
            var nodePriority = Number(node2.getAttribute(APPEND_PRIORITY) || 0);
            return priority >= nodePriority;
          });
          if (existStyle.length) {
            container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
            return styleNode;
          }
        }
        container.insertBefore(styleNode, firstChild);
      } else {
        container.appendChild(styleNode);
      }
      return styleNode;
    }
    function findExistNode(key) {
      var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var container = getContainer(option);
      return findStyles(container).find(function(node2) {
        return node2.getAttribute(getMark(option)) === key;
      });
    }
    function removeCSS(key) {
      var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var existNode = findExistNode(key, option);
      if (existNode) {
        var container = getContainer(option);
        container.removeChild(existNode);
      }
    }
    function syncRealContainer(container, option) {
      var cachedRealContainer = containerCache.get(container);
      if (!cachedRealContainer || !contains(document, cachedRealContainer)) {
        var placeholderStyle = injectCSS("", option);
        var parentNode = placeholderStyle.parentNode;
        containerCache.set(container, parentNode);
        container.removeChild(placeholderStyle);
      }
    }
    function updateCSS(css, key) {
      var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var container = getContainer(option);
      syncRealContainer(container, option);
      var existNode = findExistNode(key, option);
      if (existNode) {
        var _option$csp, _option$csp2;
        if ((_option$csp = option.csp) !== null && _option$csp !== void 0 && _option$csp.nonce && existNode.nonce !== ((_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce)) {
          var _option$csp3;
          existNode.nonce = (_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce;
        }
        if (existNode.innerHTML !== css) {
          existNode.innerHTML = css;
        }
        return existNode;
      }
      var newNode = injectCSS(css, option);
      newNode.setAttribute(getMark(option), key);
      return newNode;
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function isEqual$1(obj1, obj2) {
      var shallow = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var refSet = /* @__PURE__ */ new Set();
      function deepEqual(a, b2) {
        var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
        var circular = refSet.has(a);
        warningOnce(!circular, "Warning: There may be circular references");
        if (circular) {
          return false;
        }
        if (a === b2) {
          return true;
        }
        if (shallow && level > 1) {
          return false;
        }
        refSet.add(a);
        var newLevel = level + 1;
        if (Array.isArray(a)) {
          if (!Array.isArray(b2) || a.length !== b2.length) {
            return false;
          }
          for (var i = 0; i < a.length; i++) {
            if (!deepEqual(a[i], b2[i], newLevel)) {
              return false;
            }
          }
          return true;
        }
        if (a && b2 && _typeof(a) === "object" && _typeof(b2) === "object") {
          var keys2 = Object.keys(a);
          if (keys2.length !== Object.keys(b2).length) {
            return false;
          }
          return keys2.every(function(key) {
            return deepEqual(a[key], b2[key], newLevel);
          });
        }
        return false;
      }
      return deepEqual(obj1, obj2);
    }
    var SPLIT$1 = "%";
    var Entity = /* @__PURE__ */ function() {
      function Entity2(instanceId) {
        _classCallCheck(this, Entity2);
        _defineProperty(this, "instanceId", void 0);
        _defineProperty(this, "cache", /* @__PURE__ */ new Map());
        this.instanceId = instanceId;
      }
      _createClass(Entity2, [{
        key: "get",
        value: function get2(keys2) {
          return this.cache.get(keys2.join(SPLIT$1)) || null;
        }
      }, {
        key: "update",
        value: function update(keys2, valueFn) {
          var path = keys2.join(SPLIT$1);
          var prevValue = this.cache.get(path);
          var nextValue = valueFn(prevValue);
          if (nextValue === null) {
            this.cache.delete(path);
          } else {
            this.cache.set(path, nextValue);
          }
        }
      }]);
      return Entity2;
    }();
    var ATTR_TOKEN = "data-token-hash";
    var ATTR_MARK = "data-css-hash";
    var CSS_IN_JS_INSTANCE = "__cssinjs_instance__";
    function createCache() {
      var cssinjsInstanceId = Math.random().toString(12).slice(2);
      if (typeof document !== "undefined" && document.head && document.body) {
        var styles = document.body.querySelectorAll("style[".concat(ATTR_MARK, "]")) || [];
        var firstChild = document.head.firstChild;
        Array.from(styles).forEach(function(style2) {
          style2[CSS_IN_JS_INSTANCE] = style2[CSS_IN_JS_INSTANCE] || cssinjsInstanceId;
          if (style2[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
            document.head.insertBefore(style2, firstChild);
          }
        });
        var styleHash = {};
        Array.from(document.querySelectorAll("style[".concat(ATTR_MARK, "]"))).forEach(function(style2) {
          var hash = style2.getAttribute(ATTR_MARK);
          if (styleHash[hash]) {
            if (style2[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
              var _style$parentNode;
              (_style$parentNode = style2.parentNode) === null || _style$parentNode === void 0 || _style$parentNode.removeChild(style2);
            }
          } else {
            styleHash[hash] = true;
          }
        });
      }
      return new Entity(cssinjsInstanceId);
    }
    var StyleContext = /* @__PURE__ */ reactExports.createContext({
      hashPriority: "low",
      cache: createCache(),
      defaultCache: true
    });
    function sameDerivativeOption(left, right) {
      if (left.length !== right.length) {
        return false;
      }
      for (var i = 0; i < left.length; i++) {
        if (left[i] !== right[i]) {
          return false;
        }
      }
      return true;
    }
    var ThemeCache = /* @__PURE__ */ function() {
      function ThemeCache2() {
        _classCallCheck(this, ThemeCache2);
        _defineProperty(this, "cache", void 0);
        _defineProperty(this, "keys", void 0);
        _defineProperty(this, "cacheCallTimes", void 0);
        this.cache = /* @__PURE__ */ new Map();
        this.keys = [];
        this.cacheCallTimes = 0;
      }
      _createClass(ThemeCache2, [{
        key: "size",
        value: function size() {
          return this.keys.length;
        }
      }, {
        key: "internalGet",
        value: function internalGet(derivativeOption) {
          var _cache2, _cache3;
          var updateCallTimes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var cache = {
            map: this.cache
          };
          derivativeOption.forEach(function(derivative2) {
            if (!cache) {
              cache = void 0;
            } else {
              var _cache;
              cache = (_cache = cache) === null || _cache === void 0 || (_cache = _cache.map) === null || _cache === void 0 ? void 0 : _cache.get(derivative2);
            }
          });
          if ((_cache2 = cache) !== null && _cache2 !== void 0 && _cache2.value && updateCallTimes) {
            cache.value[1] = this.cacheCallTimes++;
          }
          return (_cache3 = cache) === null || _cache3 === void 0 ? void 0 : _cache3.value;
        }
      }, {
        key: "get",
        value: function get2(derivativeOption) {
          var _this$internalGet;
          return (_this$internalGet = this.internalGet(derivativeOption, true)) === null || _this$internalGet === void 0 ? void 0 : _this$internalGet[0];
        }
      }, {
        key: "has",
        value: function has(derivativeOption) {
          return !!this.internalGet(derivativeOption);
        }
      }, {
        key: "set",
        value: function set2(derivativeOption, value) {
          var _this = this;
          if (!this.has(derivativeOption)) {
            if (this.size() + 1 > ThemeCache2.MAX_CACHE_SIZE + ThemeCache2.MAX_CACHE_OFFSET) {
              var _this$keys$reduce = this.keys.reduce(function(result, key) {
                var _result = _slicedToArray(result, 2), callTimes = _result[1];
                if (_this.internalGet(key)[1] < callTimes) {
                  return [key, _this.internalGet(key)[1]];
                }
                return result;
              }, [this.keys[0], this.cacheCallTimes]), _this$keys$reduce2 = _slicedToArray(_this$keys$reduce, 1), targetKey = _this$keys$reduce2[0];
              this.delete(targetKey);
            }
            this.keys.push(derivativeOption);
          }
          var cache = this.cache;
          derivativeOption.forEach(function(derivative2, index2) {
            if (index2 === derivativeOption.length - 1) {
              cache.set(derivative2, {
                value: [value, _this.cacheCallTimes++]
              });
            } else {
              var cacheValue = cache.get(derivative2);
              if (!cacheValue) {
                cache.set(derivative2, {
                  map: /* @__PURE__ */ new Map()
                });
              } else if (!cacheValue.map) {
                cacheValue.map = /* @__PURE__ */ new Map();
              }
              cache = cache.get(derivative2).map;
            }
          });
        }
      }, {
        key: "deleteByPath",
        value: function deleteByPath(currentCache, derivatives) {
          var cache = currentCache.get(derivatives[0]);
          if (derivatives.length === 1) {
            var _cache$value;
            if (!cache.map) {
              currentCache.delete(derivatives[0]);
            } else {
              currentCache.set(derivatives[0], {
                map: cache.map
              });
            }
            return (_cache$value = cache.value) === null || _cache$value === void 0 ? void 0 : _cache$value[0];
          }
          var result = this.deleteByPath(cache.map, derivatives.slice(1));
          if ((!cache.map || cache.map.size === 0) && !cache.value) {
            currentCache.delete(derivatives[0]);
          }
          return result;
        }
      }, {
        key: "delete",
        value: function _delete(derivativeOption) {
          if (this.has(derivativeOption)) {
            this.keys = this.keys.filter(function(item) {
              return !sameDerivativeOption(item, derivativeOption);
            });
            return this.deleteByPath(this.cache, derivativeOption);
          }
          return void 0;
        }
      }]);
      return ThemeCache2;
    }();
    _defineProperty(ThemeCache, "MAX_CACHE_SIZE", 20);
    _defineProperty(ThemeCache, "MAX_CACHE_OFFSET", 5);
    var uuid$4 = 0;
    var Theme = /* @__PURE__ */ function() {
      function Theme2(derivatives) {
        _classCallCheck(this, Theme2);
        _defineProperty(this, "derivatives", void 0);
        _defineProperty(this, "id", void 0);
        this.derivatives = Array.isArray(derivatives) ? derivatives : [derivatives];
        this.id = uuid$4;
        if (derivatives.length === 0) {
          warning$2(derivatives.length > 0);
        }
        uuid$4 += 1;
      }
      _createClass(Theme2, [{
        key: "getDerivativeToken",
        value: function getDerivativeToken(token2) {
          return this.derivatives.reduce(function(result, derivative2) {
            return derivative2(token2, result);
          }, void 0);
        }
      }]);
      return Theme2;
    }();
    var cacheThemes = new ThemeCache();
    function createTheme(derivatives) {
      var derivativeArr = Array.isArray(derivatives) ? derivatives : [derivatives];
      if (!cacheThemes.has(derivativeArr)) {
        cacheThemes.set(derivativeArr, new Theme(derivativeArr));
      }
      return cacheThemes.get(derivativeArr);
    }
    var resultCache = /* @__PURE__ */ new WeakMap();
    var RESULT_VALUE = {};
    function memoResult(callback, deps) {
      var current = resultCache;
      for (var i = 0; i < deps.length; i += 1) {
        var dep = deps[i];
        if (!current.has(dep)) {
          current.set(dep, /* @__PURE__ */ new WeakMap());
        }
        current = current.get(dep);
      }
      if (!current.has(RESULT_VALUE)) {
        current.set(RESULT_VALUE, callback());
      }
      return current.get(RESULT_VALUE);
    }
    var flattenTokenCache = /* @__PURE__ */ new WeakMap();
    function flattenToken(token2) {
      var str = flattenTokenCache.get(token2) || "";
      if (!str) {
        Object.keys(token2).forEach(function(key) {
          var value = token2[key];
          str += key;
          if (value instanceof Theme) {
            str += value.id;
          } else if (value && _typeof(value) === "object") {
            str += flattenToken(value);
          } else {
            str += value;
          }
        });
        flattenTokenCache.set(token2, str);
      }
      return str;
    }
    function token2key(token2, salt) {
      return murmur2("".concat(salt, "_").concat(flattenToken(token2)));
    }
    var randomSelectorKey = "random-".concat(Date.now(), "-").concat(Math.random()).replace(/\./g, "");
    var checkContent = "_bAmBoO_";
    function supportSelector(styleStr, handleElement, supportCheck) {
      if (canUseDom()) {
        var _getComputedStyle$con, _ele$parentNode;
        updateCSS(styleStr, randomSelectorKey);
        var _ele = document.createElement("div");
        _ele.style.position = "fixed";
        _ele.style.left = "0";
        _ele.style.top = "0";
        handleElement === null || handleElement === void 0 || handleElement(_ele);
        document.body.appendChild(_ele);
        var support = supportCheck ? supportCheck(_ele) : (_getComputedStyle$con = getComputedStyle(_ele).content) === null || _getComputedStyle$con === void 0 ? void 0 : _getComputedStyle$con.includes(checkContent);
        (_ele$parentNode = _ele.parentNode) === null || _ele$parentNode === void 0 || _ele$parentNode.removeChild(_ele);
        removeCSS(randomSelectorKey);
        return support;
      }
      return false;
    }
    var canLayer = void 0;
    function supportLayer() {
      if (canLayer === void 0) {
        canLayer = supportSelector("@layer ".concat(randomSelectorKey, " { .").concat(randomSelectorKey, ' { content: "').concat(checkContent, '"!important; } }'), function(ele) {
          ele.className = randomSelectorKey;
        });
      }
      return canLayer;
    }
    var isClientSide = canUseDom();
    function unit$1(num) {
      if (typeof num === "number") {
        return "".concat(num, "px");
      }
      return num;
    }
    function toStyleStr(style2, tokenKey, styleId) {
      var _objectSpread2$1;
      var customizeAttrs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var plain = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
      if (plain) {
        return style2;
      }
      var attrs = _objectSpread2(_objectSpread2({}, customizeAttrs), {}, (_objectSpread2$1 = {}, _defineProperty(_objectSpread2$1, ATTR_TOKEN, tokenKey), _defineProperty(_objectSpread2$1, ATTR_MARK, styleId), _objectSpread2$1));
      var attrStr = Object.keys(attrs).map(function(attr) {
        var val = attrs[attr];
        return val ? "".concat(attr, '="').concat(val, '"') : null;
      }).filter(function(v2) {
        return v2;
      }).join(" ");
      return "<style ".concat(attrStr, ">").concat(style2, "</style>");
    }
    var token2CSSVar = function token2CSSVar2(token2) {
      var prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      return "--".concat(prefix ? "".concat(prefix, "-") : "").concat(token2).replace(/([a-z0-9])([A-Z])/g, "$1-$2").replace(/([A-Z]+)([A-Z][a-z0-9]+)/g, "$1-$2").replace(/([a-z])([A-Z0-9])/g, "$1-$2").toLowerCase();
    };
    var serializeCSSVar = function serializeCSSVar2(cssVars, hashId, options) {
      if (!Object.keys(cssVars).length) {
        return "";
      }
      return ".".concat(hashId).concat(options !== null && options !== void 0 && options.scope ? ".".concat(options.scope) : "", "{").concat(Object.entries(cssVars).map(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1];
        return "".concat(key, ":").concat(value, ";");
      }).join(""), "}");
    };
    var transformToken = function transformToken2(token2, themeKey, config) {
      var cssVars = {};
      var result = {};
      Object.entries(token2).forEach(function(_ref3) {
        var _config$preserve, _config$ignore;
        var _ref4 = _slicedToArray(_ref3, 2), key = _ref4[0], value = _ref4[1];
        if (config !== null && config !== void 0 && (_config$preserve = config.preserve) !== null && _config$preserve !== void 0 && _config$preserve[key]) {
          result[key] = value;
        } else if ((typeof value === "string" || typeof value === "number") && !(config !== null && config !== void 0 && (_config$ignore = config.ignore) !== null && _config$ignore !== void 0 && _config$ignore[key])) {
          var _config$unitless;
          var cssVar = token2CSSVar(key, config === null || config === void 0 ? void 0 : config.prefix);
          cssVars[cssVar] = typeof value === "number" && !(config !== null && config !== void 0 && (_config$unitless = config.unitless) !== null && _config$unitless !== void 0 && _config$unitless[key]) ? "".concat(value, "px") : String(value);
          result[key] = "var(".concat(cssVar, ")");
        }
      });
      return [result, serializeCSSVar(cssVars, themeKey, {
        scope: config === null || config === void 0 ? void 0 : config.scope
      })];
    };
    var useInternalLayoutEffect = canUseDom() ? reactExports.useLayoutEffect : reactExports.useEffect;
    var useLayoutEffect$1 = function useLayoutEffect2(callback, deps) {
      var firstMountRef = reactExports.useRef(true);
      useInternalLayoutEffect(function() {
        return callback(firstMountRef.current);
      }, deps);
      useInternalLayoutEffect(function() {
        firstMountRef.current = false;
        return function() {
          firstMountRef.current = true;
        };
      }, []);
    };
    var useLayoutUpdateEffect = function useLayoutUpdateEffect2(callback, deps) {
      useLayoutEffect$1(function(firstMount) {
        if (!firstMount) {
          return callback();
        }
      }, deps);
    };
    var fullClone$3 = _objectSpread2({}, React$1);
    var useInsertionEffect$1 = fullClone$3.useInsertionEffect;
    var useInsertionEffectPolyfill = function useInsertionEffectPolyfill2(renderEffect, effect, deps) {
      reactExports.useMemo(renderEffect, deps);
      useLayoutEffect$1(function() {
        return effect(true);
      }, deps);
    };
    var useCompatibleInsertionEffect = useInsertionEffect$1 ? function(renderEffect, effect, deps) {
      return useInsertionEffect$1(function() {
        renderEffect();
        return effect();
      }, deps);
    } : useInsertionEffectPolyfill;
    var fullClone$2 = _objectSpread2({}, React$1);
    var useInsertionEffect = fullClone$2.useInsertionEffect;
    var useCleanupRegister = function useCleanupRegister2(deps) {
      var effectCleanups = [];
      var cleanupFlag = false;
      function register(fn) {
        if (cleanupFlag) {
          return;
        }
        effectCleanups.push(fn);
      }
      reactExports.useEffect(function() {
        cleanupFlag = false;
        return function() {
          cleanupFlag = true;
          if (effectCleanups.length) {
            effectCleanups.forEach(function(fn) {
              return fn();
            });
          }
        };
      }, deps);
      return register;
    };
    var useRun = function useRun2() {
      return function(fn) {
        fn();
      };
    };
    var useEffectCleanupRegister = typeof useInsertionEffect !== "undefined" ? useCleanupRegister : useRun;
    function useGlobalCache(prefix, keyPath, cacheFn, onCacheRemove, onCacheEffect) {
      var _React$useContext = reactExports.useContext(StyleContext), globalCache = _React$useContext.cache;
      var fullPath = [prefix].concat(_toConsumableArray(keyPath));
      var deps = fullPath.join("_");
      var register = useEffectCleanupRegister([deps]);
      var buildCache = function buildCache2(updater) {
        globalCache.update(fullPath, function(prevCache) {
          var _ref = prevCache || [void 0, void 0], _ref2 = _slicedToArray(_ref, 2), _ref2$ = _ref2[0], times = _ref2$ === void 0 ? 0 : _ref2$, cache = _ref2[1];
          var tmpCache = cache;
          var mergedCache = tmpCache || cacheFn();
          var data = [times, mergedCache];
          return updater ? updater(data) : data;
        });
      };
      reactExports.useMemo(
        function() {
          buildCache();
        },
        /* eslint-disable react-hooks/exhaustive-deps */
        [deps]
        /* eslint-enable */
      );
      var cacheEntity = globalCache.get(fullPath);
      var cacheContent = cacheEntity[1];
      useCompatibleInsertionEffect(function() {
        onCacheEffect === null || onCacheEffect === void 0 || onCacheEffect(cacheContent);
      }, function(polyfill) {
        buildCache(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), times = _ref4[0], cache = _ref4[1];
          if (polyfill && times === 0) {
            onCacheEffect === null || onCacheEffect === void 0 || onCacheEffect(cacheContent);
          }
          return [times + 1, cache];
        });
        return function() {
          globalCache.update(fullPath, function(prevCache) {
            var _ref5 = prevCache || [], _ref6 = _slicedToArray(_ref5, 2), _ref6$ = _ref6[0], times = _ref6$ === void 0 ? 0 : _ref6$, cache = _ref6[1];
            var nextCount = times - 1;
            if (nextCount === 0) {
              register(function() {
                if (polyfill || !globalCache.get(fullPath)) {
                  onCacheRemove === null || onCacheRemove === void 0 || onCacheRemove(cache, false);
                }
              });
              return null;
            }
            return [times - 1, cache];
          });
        };
      }, [deps]);
      return cacheContent;
    }
    var EMPTY_OVERRIDE = {};
    var hashPrefix = "css";
    var tokenKeys = /* @__PURE__ */ new Map();
    function recordCleanToken(tokenKey) {
      tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) + 1);
    }
    function removeStyleTags(key, instanceId) {
      if (typeof document !== "undefined") {
        var styles = document.querySelectorAll("style[".concat(ATTR_TOKEN, '="').concat(key, '"]'));
        styles.forEach(function(style2) {
          if (style2[CSS_IN_JS_INSTANCE] === instanceId) {
            var _style$parentNode;
            (_style$parentNode = style2.parentNode) === null || _style$parentNode === void 0 || _style$parentNode.removeChild(style2);
          }
        });
      }
    }
    var TOKEN_THRESHOLD = 0;
    function cleanTokenStyle(tokenKey, instanceId) {
      tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) - 1);
      var tokenKeyList = Array.from(tokenKeys.keys());
      var cleanableKeyList = tokenKeyList.filter(function(key) {
        var count = tokenKeys.get(key) || 0;
        return count <= 0;
      });
      if (tokenKeyList.length - cleanableKeyList.length > TOKEN_THRESHOLD) {
        cleanableKeyList.forEach(function(key) {
          removeStyleTags(key, instanceId);
          tokenKeys.delete(key);
        });
      }
    }
    var getComputedToken$1 = function getComputedToken2(originToken, overrideToken, theme, format2) {
      var derivativeToken = theme.getDerivativeToken(originToken);
      var mergedDerivativeToken = _objectSpread2(_objectSpread2({}, derivativeToken), overrideToken);
      if (format2) {
        mergedDerivativeToken = format2(mergedDerivativeToken);
      }
      return mergedDerivativeToken;
    };
    var TOKEN_PREFIX = "token";
    function useCacheToken(theme, tokens2) {
      var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var _useContext = reactExports.useContext(StyleContext), instanceId = _useContext.cache.instanceId, container = _useContext.container;
      var _option$salt = option.salt, salt = _option$salt === void 0 ? "" : _option$salt, _option$override = option.override, override = _option$override === void 0 ? EMPTY_OVERRIDE : _option$override, formatToken2 = option.formatToken, compute = option.getComputedToken, cssVar = option.cssVar;
      var mergedToken = memoResult(function() {
        return Object.assign.apply(Object, [{}].concat(_toConsumableArray(tokens2)));
      }, tokens2);
      var tokenStr = flattenToken(mergedToken);
      var overrideTokenStr = flattenToken(override);
      var cssVarStr = cssVar ? flattenToken(cssVar) : "";
      var cachedToken = useGlobalCache(TOKEN_PREFIX, [salt, theme.id, tokenStr, overrideTokenStr, cssVarStr], function() {
        var _cssVar$key;
        var mergedDerivativeToken = compute ? compute(mergedToken, override, theme) : getComputedToken$1(mergedToken, override, theme, formatToken2);
        var actualToken = _objectSpread2({}, mergedDerivativeToken);
        var cssVarsStr = "";
        if (!!cssVar) {
          var _transformToken = transformToken(mergedDerivativeToken, cssVar.key, {
            prefix: cssVar.prefix,
            ignore: cssVar.ignore,
            unitless: cssVar.unitless,
            preserve: cssVar.preserve
          });
          var _transformToken2 = _slicedToArray(_transformToken, 2);
          mergedDerivativeToken = _transformToken2[0];
          cssVarsStr = _transformToken2[1];
        }
        var tokenKey = token2key(mergedDerivativeToken, salt);
        mergedDerivativeToken._tokenKey = tokenKey;
        actualToken._tokenKey = token2key(actualToken, salt);
        var themeKey = (_cssVar$key = cssVar === null || cssVar === void 0 ? void 0 : cssVar.key) !== null && _cssVar$key !== void 0 ? _cssVar$key : tokenKey;
        mergedDerivativeToken._themeKey = themeKey;
        recordCleanToken(themeKey);
        var hashId = "".concat(hashPrefix, "-").concat(murmur2(tokenKey));
        mergedDerivativeToken._hashId = hashId;
        return [mergedDerivativeToken, hashId, actualToken, cssVarsStr, (cssVar === null || cssVar === void 0 ? void 0 : cssVar.key) || ""];
      }, function(cache) {
        cleanTokenStyle(cache[0]._themeKey, instanceId);
      }, function(_ref) {
        var _ref2 = _slicedToArray(_ref, 4), token2 = _ref2[0], cssVarsStr = _ref2[3];
        if (cssVar && cssVarsStr) {
          var style2 = updateCSS(cssVarsStr, murmur2("css-variables-".concat(token2._themeKey)), {
            mark: ATTR_MARK,
            prepend: "queue",
            attachTo: container,
            priority: -999
          });
          style2[CSS_IN_JS_INSTANCE] = instanceId;
          style2.setAttribute(ATTR_TOKEN, token2._themeKey);
        }
      });
      return cachedToken;
    }
    var extract$2 = function extract2(cache, effectStyles, options) {
      var _cache = _slicedToArray(cache, 5), realToken = _cache[2], styleStr = _cache[3], cssVarKey = _cache[4];
      var _ref3 = options || {}, plain = _ref3.plain;
      if (!styleStr) {
        return null;
      }
      var styleId = realToken._tokenKey;
      var order = -999;
      var sharedAttrs = {
        "data-rc-order": "prependQueue",
        "data-rc-priority": "".concat(order)
      };
      var styleText = toStyleStr(styleStr, cssVarKey, styleId, sharedAttrs, plain);
      return [order, styleId, styleText];
    };
    var unitlessKeys = {
      animationIterationCount: 1,
      borderImageOutset: 1,
      borderImageSlice: 1,
      borderImageWidth: 1,
      boxFlex: 1,
      boxFlexGroup: 1,
      boxOrdinalGroup: 1,
      columnCount: 1,
      columns: 1,
      flex: 1,
      flexGrow: 1,
      flexPositive: 1,
      flexShrink: 1,
      flexNegative: 1,
      flexOrder: 1,
      gridRow: 1,
      gridRowEnd: 1,
      gridRowSpan: 1,
      gridRowStart: 1,
      gridColumn: 1,
      gridColumnEnd: 1,
      gridColumnSpan: 1,
      gridColumnStart: 1,
      msGridRow: 1,
      msGridRowSpan: 1,
      msGridColumn: 1,
      msGridColumnSpan: 1,
      fontWeight: 1,
      lineHeight: 1,
      opacity: 1,
      order: 1,
      orphans: 1,
      tabSize: 1,
      widows: 1,
      zIndex: 1,
      zoom: 1,
      WebkitLineClamp: 1,
      // SVG-related properties
      fillOpacity: 1,
      floodOpacity: 1,
      stopOpacity: 1,
      strokeDasharray: 1,
      strokeDashoffset: 1,
      strokeMiterlimit: 1,
      strokeOpacity: 1,
      strokeWidth: 1
    };
    var COMMENT = "comm";
    var RULESET = "rule";
    var DECLARATION = "decl";
    var IMPORT = "@import";
    var KEYFRAMES = "@keyframes";
    var LAYER = "@layer";
    var abs$2 = Math.abs;
    var from$1 = String.fromCharCode;
    function trim$1(value) {
      return value.trim();
    }
    function replace(value, pattern, replacement) {
      return value.replace(pattern, replacement);
    }
    function indexof(value, search) {
      return value.indexOf(search);
    }
    function charat(value, index2) {
      return value.charCodeAt(index2) | 0;
    }
    function substr(value, begin, end) {
      return value.slice(begin, end);
    }
    function strlen(value) {
      return value.length;
    }
    function sizeof(value) {
      return value.length;
    }
    function append(value, array) {
      return array.push(value), value;
    }
    var line = 1;
    var column = 1;
    var length = 0;
    var position = 0;
    var character = 0;
    var characters = "";
    function node(value, root, parent, type, props, children, length2, siblings) {
      return { value, root, parent, type, props, children, line, column, length: length2, return: "", siblings };
    }
    function char() {
      return character;
    }
    function prev() {
      character = position > 0 ? charat(characters, --position) : 0;
      if (column--, character === 10)
        column = 1, line--;
      return character;
    }
    function next() {
      character = position < length ? charat(characters, position++) : 0;
      if (column++, character === 10)
        column = 1, line++;
      return character;
    }
    function peek() {
      return charat(characters, position);
    }
    function caret() {
      return position;
    }
    function slice(begin, end) {
      return substr(characters, begin, end);
    }
    function token$1(type) {
      switch (type) {
        case 0:
        case 9:
        case 10:
        case 13:
        case 32:
          return 5;
        case 33:
        case 43:
        case 44:
        case 47:
        case 62:
        case 64:
        case 126:
        case 59:
        case 123:
        case 125:
          return 4;
        case 58:
          return 3;
        case 34:
        case 39:
        case 40:
        case 91:
          return 2;
        case 41:
        case 93:
          return 1;
      }
      return 0;
    }
    function alloc(value) {
      return line = column = 1, length = strlen(characters = value), position = 0, [];
    }
    function dealloc(value) {
      return characters = "", value;
    }
    function delimit(type) {
      return trim$1(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
    }
    function whitespace$1(type) {
      while (character = peek())
        if (character < 33)
          next();
        else
          break;
      return token$1(type) > 2 || token$1(character) > 3 ? "" : " ";
    }
    function escaping(index2, count) {
      while (--count && next())
        if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
          break;
      return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
    }
    function delimiter(type) {
      while (next())
        switch (character) {
          case type:
            return position;
          case 34:
          case 39:
            if (type !== 34 && type !== 39)
              delimiter(character);
            break;
          case 40:
            if (type === 41)
              delimiter(type);
            break;
          case 92:
            next();
            break;
        }
      return position;
    }
    function commenter(type, index2) {
      while (next())
        if (type + character === 47 + 10)
          break;
        else if (type + character === 42 + 42 && peek() === 47)
          break;
      return "/*" + slice(index2, position - 1) + "*" + from$1(type === 47 ? type : next());
    }
    function identifier(index2) {
      while (!token$1(peek()))
        next();
      return slice(index2, position);
    }
    function compile(value) {
      return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
    }
    function parse(value, root, parent, rule, rules2, rulesets, pseudo, points, declarations) {
      var index2 = 0;
      var offset2 = 0;
      var length2 = pseudo;
      var atrule = 0;
      var property = 0;
      var previous = 0;
      var variable = 1;
      var scanning = 1;
      var ampersand = 1;
      var character2 = 0;
      var type = "";
      var props = rules2;
      var children = rulesets;
      var reference = rule;
      var characters2 = type;
      while (scanning)
        switch (previous = character2, character2 = next()) {
          case 40:
            if (previous != 108 && charat(characters2, length2 - 1) == 58) {
              if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
                ampersand = -1;
              break;
            }
          case 34:
          case 39:
          case 91:
            characters2 += delimit(character2);
            break;
          case 9:
          case 10:
          case 13:
          case 32:
            characters2 += whitespace$1(previous);
            break;
          case 92:
            characters2 += escaping(caret() - 1, 7);
            continue;
          case 47:
            switch (peek()) {
              case 42:
              case 47:
                append(comment(commenter(next(), caret()), root, parent, declarations), declarations);
                break;
              default:
                characters2 += "/";
            }
            break;
          case 123 * variable:
            points[index2++] = strlen(characters2) * ampersand;
          case 125 * variable:
          case 59:
          case 0:
            switch (character2) {
              case 0:
              case 125:
                scanning = 0;
              case 59 + offset2:
                if (ampersand == -1)
                  characters2 = replace(characters2, /\f/g, "");
                if (property > 0 && strlen(characters2) - length2)
                  append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1, declarations) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2, declarations), declarations);
                break;
              case 59:
                characters2 += ";";
              default:
                append(reference = ruleset(characters2, root, parent, index2, offset2, rules2, points, type, props = [], children = [], length2, rulesets), rulesets);
                if (character2 === 123)
                  if (offset2 === 0)
                    parse(characters2, root, reference, reference, props, rulesets, length2, points, children);
                  else
                    switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                      case 100:
                      case 108:
                      case 109:
                      case 115:
                        parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules2, points, type, rules2, props = [], length2, children), children), rules2, children, length2, points, rule ? props : children);
                        break;
                      default:
                        parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                    }
            }
            index2 = offset2 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
            break;
          case 58:
            length2 = 1 + strlen(characters2), property = previous;
          default:
            if (variable < 1) {
              if (character2 == 123)
                --variable;
              else if (character2 == 125 && variable++ == 0 && prev() == 125)
                continue;
            }
            switch (characters2 += from$1(character2), character2 * variable) {
              case 38:
                ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
                break;
              case 44:
                points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
                break;
              case 64:
                if (peek() === 45)
                  characters2 += delimit(next());
                atrule = peek(), offset2 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
                break;
              case 45:
                if (previous === 45 && strlen(characters2) == 2)
                  variable = 0;
            }
        }
      return rulesets;
    }
    function ruleset(value, root, parent, index2, offset2, rules2, points, type, props, children, length2, siblings) {
      var post = offset2 - 1;
      var rule = offset2 === 0 ? rules2 : [""];
      var size = sizeof(rule);
      for (var i = 0, j = 0, k2 = 0; i < index2; ++i)
        for (var x2 = 0, y2 = substr(value, post + 1, post = abs$2(j = points[i])), z2 = value; x2 < size; ++x2)
          if (z2 = trim$1(j > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
            props[k2++] = z2;
      return node(value, root, parent, offset2 === 0 ? RULESET : type, props, children, length2, siblings);
    }
    function comment(value, root, parent, siblings) {
      return node(value, root, parent, COMMENT, from$1(char()), substr(value, 2, -2), 0, siblings);
    }
    function declaration(value, root, parent, length2, siblings) {
      return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2, siblings);
    }
    function serialize(children, callback) {
      var output = "";
      for (var i = 0; i < children.length; i++)
        output += callback(children[i], i, children, callback) || "";
      return output;
    }
    function stringify$1(element, index2, children, callback) {
      switch (element.type) {
        case LAYER:
          if (element.children.length)
            break;
        case IMPORT:
        case DECLARATION:
          return element.return = element.return || element.value;
        case COMMENT:
          return "";
        case KEYFRAMES:
          return element.return = element.value + "{" + serialize(element.children, callback) + "}";
        case RULESET:
          if (!strlen(element.value = element.props.join(",")))
            return "";
      }
      return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
    }
    var ATTR_CACHE_MAP = "data-ant-cssinjs-cache-path";
    var CSS_FILE_STYLE = "_FILE_STYLE__";
    var cachePathMap;
    var fromCSSFile = true;
    function prepare() {
      if (!cachePathMap) {
        cachePathMap = {};
        if (canUseDom()) {
          var div = document.createElement("div");
          div.className = ATTR_CACHE_MAP;
          div.style.position = "fixed";
          div.style.visibility = "hidden";
          div.style.top = "-9999px";
          document.body.appendChild(div);
          var content = getComputedStyle(div).content || "";
          content = content.replace(/^"/, "").replace(/"$/, "");
          content.split(";").forEach(function(item) {
            var _item$split = item.split(":"), _item$split2 = _slicedToArray(_item$split, 2), path = _item$split2[0], hash = _item$split2[1];
            cachePathMap[path] = hash;
          });
          var inlineMapStyle = document.querySelector("style[".concat(ATTR_CACHE_MAP, "]"));
          if (inlineMapStyle) {
            var _inlineMapStyle$paren;
            fromCSSFile = false;
            (_inlineMapStyle$paren = inlineMapStyle.parentNode) === null || _inlineMapStyle$paren === void 0 || _inlineMapStyle$paren.removeChild(inlineMapStyle);
          }
          document.body.removeChild(div);
        }
      }
    }
    function existPath(path) {
      prepare();
      return !!cachePathMap[path];
    }
    function getStyleAndHash(path) {
      var hash = cachePathMap[path];
      var styleStr = null;
      if (hash && canUseDom()) {
        if (fromCSSFile) {
          styleStr = CSS_FILE_STYLE;
        } else {
          var _style = document.querySelector("style[".concat(ATTR_MARK, '="').concat(cachePathMap[path], '"]'));
          if (_style) {
            styleStr = _style.innerHTML;
          } else {
            delete cachePathMap[path];
          }
        }
      }
      return [styleStr, hash];
    }
    var SKIP_CHECK = "_skip_check_";
    var MULTI_VALUE = "_multi_value_";
    function normalizeStyle(styleStr) {
      var serialized = serialize(compile(styleStr), stringify$1);
      return serialized.replace(/\{%%%\:[^;];}/g, ";");
    }
    function isCompoundCSSProperty(value) {
      return _typeof(value) === "object" && value && (SKIP_CHECK in value || MULTI_VALUE in value);
    }
    function injectSelectorHash(key, hashId, hashPriority) {
      if (!hashId) {
        return key;
      }
      var hashClassName = ".".concat(hashId);
      var hashSelector = hashPriority === "low" ? ":where(".concat(hashClassName, ")") : hashClassName;
      var keys2 = key.split(",").map(function(k2) {
        var _firstPath$match;
        var fullPath = k2.trim().split(/\s+/);
        var firstPath = fullPath[0] || "";
        var htmlElement = ((_firstPath$match = firstPath.match(/^\w+/)) === null || _firstPath$match === void 0 ? void 0 : _firstPath$match[0]) || "";
        firstPath = "".concat(htmlElement).concat(hashSelector).concat(firstPath.slice(htmlElement.length));
        return [firstPath].concat(_toConsumableArray(fullPath.slice(1))).join(" ");
      });
      return keys2.join(",");
    }
    var parseStyle = function parseStyle2(interpolation) {
      var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        root: true,
        parentSelectors: []
      }, root = _ref.root, injectHash = _ref.injectHash, parentSelectors = _ref.parentSelectors;
      var hashId = config.hashId, layer = config.layer;
      config.path;
      var hashPriority = config.hashPriority, _config$transformers = config.transformers, transformers = _config$transformers === void 0 ? [] : _config$transformers;
      config.linters;
      var styleStr = "";
      var effectStyle = {};
      function parseKeyframes(keyframes) {
        var animationName = keyframes.getName(hashId);
        if (!effectStyle[animationName]) {
          var _parseStyle = parseStyle2(keyframes.style, config, {
            root: false,
            parentSelectors
          }), _parseStyle2 = _slicedToArray(_parseStyle, 1), _parsedStr = _parseStyle2[0];
          effectStyle[animationName] = "@keyframes ".concat(keyframes.getName(hashId)).concat(_parsedStr);
        }
      }
      function flattenList(list) {
        var fullList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        list.forEach(function(item) {
          if (Array.isArray(item)) {
            flattenList(item, fullList);
          } else if (item) {
            fullList.push(item);
          }
        });
        return fullList;
      }
      var flattenStyleList = flattenList(Array.isArray(interpolation) ? interpolation : [interpolation]);
      flattenStyleList.forEach(function(originStyle) {
        var style2 = typeof originStyle === "string" && !root ? {} : originStyle;
        if (typeof style2 === "string") {
          styleStr += "".concat(style2, "\n");
        } else if (style2._keyframe) {
          parseKeyframes(style2);
        } else {
          var mergedStyle = transformers.reduce(function(prev2, trans) {
            var _trans$visit;
            return (trans === null || trans === void 0 || (_trans$visit = trans.visit) === null || _trans$visit === void 0 ? void 0 : _trans$visit.call(trans, prev2)) || prev2;
          }, style2);
          Object.keys(mergedStyle).forEach(function(key) {
            var value = mergedStyle[key];
            if (_typeof(value) === "object" && value && (key !== "animationName" || !value._keyframe) && !isCompoundCSSProperty(value)) {
              var subInjectHash = false;
              var mergedKey = key.trim();
              var nextRoot = false;
              if ((root || injectHash) && hashId) {
                if (mergedKey.startsWith("@")) {
                  subInjectHash = true;
                } else {
                  mergedKey = injectSelectorHash(key, hashId, hashPriority);
                }
              } else if (root && !hashId && (mergedKey === "&" || mergedKey === "")) {
                mergedKey = "";
                nextRoot = true;
              }
              var _parseStyle3 = parseStyle2(value, config, {
                root: nextRoot,
                injectHash: subInjectHash,
                parentSelectors: [].concat(_toConsumableArray(parentSelectors), [mergedKey])
              }), _parseStyle4 = _slicedToArray(_parseStyle3, 2), _parsedStr2 = _parseStyle4[0], childEffectStyle = _parseStyle4[1];
              effectStyle = _objectSpread2(_objectSpread2({}, effectStyle), childEffectStyle);
              styleStr += "".concat(mergedKey).concat(_parsedStr2);
            } else {
              let appendStyle = function(cssKey, cssValue) {
                var styleName = cssKey.replace(/[A-Z]/g, function(match5) {
                  return "-".concat(match5.toLowerCase());
                });
                var formatValue2 = cssValue;
                if (!unitlessKeys[cssKey] && typeof formatValue2 === "number" && formatValue2 !== 0) {
                  formatValue2 = "".concat(formatValue2, "px");
                }
                if (cssKey === "animationName" && cssValue !== null && cssValue !== void 0 && cssValue._keyframe) {
                  parseKeyframes(cssValue);
                  formatValue2 = cssValue.getName(hashId);
                }
                styleStr += "".concat(styleName, ":").concat(formatValue2, ";");
              };
              var _value;
              var actualValue = (_value = value === null || value === void 0 ? void 0 : value.value) !== null && _value !== void 0 ? _value : value;
              if (_typeof(value) === "object" && value !== null && value !== void 0 && value[MULTI_VALUE] && Array.isArray(actualValue)) {
                actualValue.forEach(function(item) {
                  appendStyle(key, item);
                });
              } else {
                appendStyle(key, actualValue);
              }
            }
          });
        }
      });
      if (!root) {
        styleStr = "{".concat(styleStr, "}");
      } else if (layer && supportLayer()) {
        var layerCells = layer.split(",");
        var layerName = layerCells[layerCells.length - 1].trim();
        styleStr = "@layer ".concat(layerName, " {").concat(styleStr, "}");
        if (layerCells.length > 1) {
          styleStr = "@layer ".concat(layer, "{%%%:%}").concat(styleStr);
        }
      }
      return [styleStr, effectStyle];
    };
    function uniqueHash(path, styleStr) {
      return murmur2("".concat(path.join("%")).concat(styleStr));
    }
    function Empty$3() {
      return null;
    }
    var STYLE_PREFIX = "style";
    function useStyleRegister(info, styleFn) {
      var token2 = info.token, path = info.path, hashId = info.hashId, layer = info.layer, nonce = info.nonce, clientOnly = info.clientOnly, _info$order = info.order, order = _info$order === void 0 ? 0 : _info$order;
      var _React$useContext = reactExports.useContext(StyleContext), autoClear = _React$useContext.autoClear;
      _React$useContext.mock;
      var defaultCache = _React$useContext.defaultCache, hashPriority = _React$useContext.hashPriority, container = _React$useContext.container, ssrInline = _React$useContext.ssrInline, transformers = _React$useContext.transformers, linters = _React$useContext.linters, cache = _React$useContext.cache;
      var tokenKey = token2._tokenKey;
      var fullPath = [tokenKey].concat(_toConsumableArray(path));
      var isMergedClientSide = isClientSide;
      var _useGlobalCache = useGlobalCache(
        STYLE_PREFIX,
        fullPath,
        // Create cache if needed
        function() {
          var cachePath = fullPath.join("|");
          if (existPath(cachePath)) {
            var _getStyleAndHash = getStyleAndHash(cachePath), _getStyleAndHash2 = _slicedToArray(_getStyleAndHash, 2), inlineCacheStyleStr = _getStyleAndHash2[0], styleHash = _getStyleAndHash2[1];
            if (inlineCacheStyleStr) {
              return [inlineCacheStyleStr, tokenKey, styleHash, {}, clientOnly, order];
            }
          }
          var styleObj = styleFn();
          var _parseStyle5 = parseStyle(styleObj, {
            hashId,
            hashPriority,
            layer,
            path: path.join("-"),
            transformers,
            linters
          }), _parseStyle6 = _slicedToArray(_parseStyle5, 2), parsedStyle = _parseStyle6[0], effectStyle = _parseStyle6[1];
          var styleStr = normalizeStyle(parsedStyle);
          var styleId = uniqueHash(fullPath, styleStr);
          return [styleStr, tokenKey, styleId, effectStyle, clientOnly, order];
        },
        // Remove cache if no need
        function(_ref2, fromHMR) {
          var _ref3 = _slicedToArray(_ref2, 3), styleId = _ref3[2];
          if ((fromHMR || autoClear) && isClientSide) {
            removeCSS(styleId, {
              mark: ATTR_MARK
            });
          }
        },
        // Effect: Inject style here
        function(_ref4) {
          var _ref5 = _slicedToArray(_ref4, 4), styleStr = _ref5[0];
          _ref5[1];
          var styleId = _ref5[2], effectStyle = _ref5[3];
          if (isMergedClientSide && styleStr !== CSS_FILE_STYLE) {
            var mergedCSSConfig = {
              mark: ATTR_MARK,
              prepend: "queue",
              attachTo: container,
              priority: order
            };
            var nonceStr = typeof nonce === "function" ? nonce() : nonce;
            if (nonceStr) {
              mergedCSSConfig.csp = {
                nonce: nonceStr
              };
            }
            var style2 = updateCSS(styleStr, styleId, mergedCSSConfig);
            style2[CSS_IN_JS_INSTANCE] = cache.instanceId;
            style2.setAttribute(ATTR_TOKEN, tokenKey);
            Object.keys(effectStyle).forEach(function(effectKey) {
              updateCSS(normalizeStyle(effectStyle[effectKey]), "_effect-".concat(effectKey), mergedCSSConfig);
            });
          }
        }
      ), _useGlobalCache2 = _slicedToArray(_useGlobalCache, 3), cachedStyleStr = _useGlobalCache2[0], cachedTokenKey = _useGlobalCache2[1], cachedStyleId = _useGlobalCache2[2];
      return function(node2) {
        var styleNode;
        if (!ssrInline || isMergedClientSide || !defaultCache) {
          styleNode = /* @__PURE__ */ reactExports.createElement(Empty$3, null);
        } else {
          var _ref6;
          styleNode = /* @__PURE__ */ reactExports.createElement("style", _extends$1({}, (_ref6 = {}, _defineProperty(_ref6, ATTR_TOKEN, cachedTokenKey), _defineProperty(_ref6, ATTR_MARK, cachedStyleId), _ref6), {
            dangerouslySetInnerHTML: {
              __html: cachedStyleStr
            }
          }));
        }
        return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, styleNode, node2);
      };
    }
    var extract$1 = function extract2(cache, effectStyles, options) {
      var _cache = _slicedToArray(cache, 6), styleStr = _cache[0], tokenKey = _cache[1], styleId = _cache[2], effectStyle = _cache[3], clientOnly = _cache[4], order = _cache[5];
      var _ref7 = options || {}, plain = _ref7.plain;
      if (clientOnly) {
        return null;
      }
      var keyStyleText = styleStr;
      var sharedAttrs = {
        "data-rc-order": "prependQueue",
        "data-rc-priority": "".concat(order)
      };
      keyStyleText = toStyleStr(styleStr, tokenKey, styleId, sharedAttrs, plain);
      if (effectStyle) {
        Object.keys(effectStyle).forEach(function(effectKey) {
          if (!effectStyles[effectKey]) {
            effectStyles[effectKey] = true;
            var effectStyleStr = normalizeStyle(effectStyle[effectKey]);
            keyStyleText += toStyleStr(effectStyleStr, tokenKey, "_effect-".concat(effectKey), sharedAttrs, plain);
          }
        });
      }
      return [order, styleId, keyStyleText];
    };
    var CSS_VAR_PREFIX = "cssVar";
    var useCSSVarRegister = function useCSSVarRegister2(config, fn) {
      var key = config.key, prefix = config.prefix, unitless2 = config.unitless, ignore2 = config.ignore, token2 = config.token, _config$scope = config.scope, scope = _config$scope === void 0 ? "" : _config$scope;
      var _useContext = reactExports.useContext(StyleContext), instanceId = _useContext.cache.instanceId, container = _useContext.container;
      var tokenKey = token2._tokenKey;
      var stylePath = [].concat(_toConsumableArray(config.path), [key, scope, tokenKey]);
      var cache = useGlobalCache(CSS_VAR_PREFIX, stylePath, function() {
        var originToken = fn();
        var _transformToken = transformToken(originToken, key, {
          prefix,
          unitless: unitless2,
          ignore: ignore2,
          scope
        }), _transformToken2 = _slicedToArray(_transformToken, 2), mergedToken = _transformToken2[0], cssVarsStr = _transformToken2[1];
        var styleId = uniqueHash(stylePath, cssVarsStr);
        return [mergedToken, cssVarsStr, styleId, key];
      }, function(_ref) {
        var _ref2 = _slicedToArray(_ref, 3), styleId = _ref2[2];
        if (isClientSide) {
          removeCSS(styleId, {
            mark: ATTR_MARK
          });
        }
      }, function(_ref3) {
        var _ref4 = _slicedToArray(_ref3, 3), cssVarsStr = _ref4[1], styleId = _ref4[2];
        if (!cssVarsStr) {
          return;
        }
        var style2 = updateCSS(cssVarsStr, styleId, {
          mark: ATTR_MARK,
          prepend: "queue",
          attachTo: container,
          priority: -999
        });
        style2[CSS_IN_JS_INSTANCE] = instanceId;
        style2.setAttribute(ATTR_TOKEN, key);
      });
      return cache;
    };
    var extract = function extract2(cache, effectStyles, options) {
      var _cache = _slicedToArray(cache, 4), styleStr = _cache[1], styleId = _cache[2], cssVarKey = _cache[3];
      var _ref5 = options || {}, plain = _ref5.plain;
      if (!styleStr) {
        return null;
      }
      var order = -999;
      var sharedAttrs = {
        "data-rc-order": "prependQueue",
        "data-rc-priority": "".concat(order)
      };
      var styleText = toStyleStr(styleStr, cssVarKey, styleId, sharedAttrs, plain);
      return [order, styleId, styleText];
    };
    var _ExtractStyleFns;
    _ExtractStyleFns = {}, _defineProperty(_ExtractStyleFns, STYLE_PREFIX, extract$1), _defineProperty(_ExtractStyleFns, TOKEN_PREFIX, extract$2), _defineProperty(_ExtractStyleFns, CSS_VAR_PREFIX, extract), _ExtractStyleFns;
    var Keyframe = /* @__PURE__ */ function() {
      function Keyframe2(name, style2) {
        _classCallCheck(this, Keyframe2);
        _defineProperty(this, "name", void 0);
        _defineProperty(this, "style", void 0);
        _defineProperty(this, "_keyframe", true);
        this.name = name;
        this.style = style2;
      }
      _createClass(Keyframe2, [{
        key: "getName",
        value: function getName() {
          var hashId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          return hashId ? "".concat(hashId, "-").concat(this.name) : this.name;
        }
      }]);
      return Keyframe2;
    }();
    function noSplit(list) {
      list.notSplit = true;
      return list;
    }
    ({
      // Inset
      inset: ["top", "right", "bottom", "left"],
      insetBlock: ["top", "bottom"],
      insetBlockStart: ["top"],
      insetBlockEnd: ["bottom"],
      insetInline: ["left", "right"],
      insetInlineStart: ["left"],
      insetInlineEnd: ["right"],
      // Margin
      marginBlock: ["marginTop", "marginBottom"],
      marginBlockStart: ["marginTop"],
      marginBlockEnd: ["marginBottom"],
      marginInline: ["marginLeft", "marginRight"],
      marginInlineStart: ["marginLeft"],
      marginInlineEnd: ["marginRight"],
      // Padding
      paddingBlock: ["paddingTop", "paddingBottom"],
      paddingBlockStart: ["paddingTop"],
      paddingBlockEnd: ["paddingBottom"],
      paddingInline: ["paddingLeft", "paddingRight"],
      paddingInlineStart: ["paddingLeft"],
      paddingInlineEnd: ["paddingRight"],
      // Border
      borderBlock: noSplit(["borderTop", "borderBottom"]),
      borderBlockStart: noSplit(["borderTop"]),
      borderBlockEnd: noSplit(["borderBottom"]),
      borderInline: noSplit(["borderLeft", "borderRight"]),
      borderInlineStart: noSplit(["borderLeft"]),
      borderInlineEnd: noSplit(["borderRight"]),
      // Border width
      borderBlockWidth: ["borderTopWidth", "borderBottomWidth"],
      borderBlockStartWidth: ["borderTopWidth"],
      borderBlockEndWidth: ["borderBottomWidth"],
      borderInlineWidth: ["borderLeftWidth", "borderRightWidth"],
      borderInlineStartWidth: ["borderLeftWidth"],
      borderInlineEndWidth: ["borderRightWidth"],
      // Border style
      borderBlockStyle: ["borderTopStyle", "borderBottomStyle"],
      borderBlockStartStyle: ["borderTopStyle"],
      borderBlockEndStyle: ["borderBottomStyle"],
      borderInlineStyle: ["borderLeftStyle", "borderRightStyle"],
      borderInlineStartStyle: ["borderLeftStyle"],
      borderInlineEndStyle: ["borderRightStyle"],
      // Border color
      borderBlockColor: ["borderTopColor", "borderBottomColor"],
      borderBlockStartColor: ["borderTopColor"],
      borderBlockEndColor: ["borderBottomColor"],
      borderInlineColor: ["borderLeftColor", "borderRightColor"],
      borderInlineStartColor: ["borderLeftColor"],
      borderInlineEndColor: ["borderRightColor"],
      // Border radius
      borderStartStartRadius: ["borderTopLeftRadius"],
      borderStartEndRadius: ["borderTopRightRadius"],
      borderEndStartRadius: ["borderBottomLeftRadius"],
      borderEndEndRadius: ["borderBottomRightRadius"]
    });
    var IconContext = /* @__PURE__ */ reactExports.createContext({});
    const Context$2 = IconContext;
    function _toArray(arr) {
      return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
    }
    function get$3(entity, path) {
      var current = entity;
      for (var i = 0; i < path.length; i += 1) {
        if (current === null || current === void 0) {
          return void 0;
        }
        current = current[path[i]];
      }
      return current;
    }
    function internalSet(entity, paths, value, removeIfUndefined) {
      if (!paths.length) {
        return value;
      }
      var _paths = _toArray(paths), path = _paths[0], restPath = _paths.slice(1);
      var clone2;
      if (!entity && typeof path === "number") {
        clone2 = [];
      } else if (Array.isArray(entity)) {
        clone2 = _toConsumableArray(entity);
      } else {
        clone2 = _objectSpread2({}, entity);
      }
      if (removeIfUndefined && value === void 0 && restPath.length === 1) {
        delete clone2[path][restPath[0]];
      } else {
        clone2[path] = internalSet(clone2[path], restPath, value, removeIfUndefined);
      }
      return clone2;
    }
    function set$2(entity, paths, value) {
      var removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      if (paths.length && removeIfUndefined && value === void 0 && !get$3(entity, paths.slice(0, -1))) {
        return entity;
      }
      return internalSet(entity, paths, value, removeIfUndefined);
    }
    function isObject$2(obj) {
      return _typeof(obj) === "object" && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
    }
    function createEmpty(source) {
      return Array.isArray(source) ? [] : {};
    }
    var keys$1 = typeof Reflect === "undefined" ? Object.keys : Reflect.ownKeys;
    function merge$2() {
      for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
        sources[_key] = arguments[_key];
      }
      var clone2 = createEmpty(sources[0]);
      sources.forEach(function(src) {
        function internalMerge(path, parentLoopSet) {
          var loopSet = new Set(parentLoopSet);
          var value = get$3(src, path);
          var isArr = Array.isArray(value);
          if (isArr || isObject$2(value)) {
            if (!loopSet.has(value)) {
              loopSet.add(value);
              var originValue = get$3(clone2, path);
              if (isArr) {
                clone2 = set$2(clone2, path, []);
              } else if (!originValue || _typeof(originValue) !== "object") {
                clone2 = set$2(clone2, path, createEmpty(value));
              }
              keys$1(value).forEach(function(key) {
                internalMerge([].concat(_toConsumableArray(path), [key]), loopSet);
              });
            }
          } else {
            clone2 = set$2(clone2, path, value);
          }
        }
        internalMerge([]);
      });
      return clone2;
    }
    function noop$4() {
    }
    const WarningContext = /* @__PURE__ */ reactExports.createContext({});
    const devUseWarning = () => {
      const noopWarning = () => {
      };
      noopWarning.deprecated = noop$4;
      return noopWarning;
    };
    const ValidateMessagesContext = /* @__PURE__ */ reactExports.createContext(void 0);
    var locale$9 = {
      // Options
      items_per_page: "/ page",
      jump_to: "Go to",
      jump_to_confirm: "confirm",
      page: "Page",
      // Pagination
      prev_page: "Previous Page",
      next_page: "Next Page",
      prev_5: "Previous 5 Pages",
      next_5: "Next 5 Pages",
      prev_3: "Previous 3 Pages",
      next_3: "Next 3 Pages",
      page_size: "Page Size"
    };
    var locale$8 = {
      locale: "en_US",
      today: "Today",
      now: "Now",
      backToToday: "Back to today",
      ok: "OK",
      clear: "Clear",
      month: "Month",
      year: "Year",
      timeSelect: "select time",
      dateSelect: "select date",
      weekSelect: "Choose a week",
      monthSelect: "Choose a month",
      yearSelect: "Choose a year",
      decadeSelect: "Choose a decade",
      yearFormat: "YYYY",
      dateFormat: "M/D/YYYY",
      dayFormat: "D",
      dateTimeFormat: "M/D/YYYY HH:mm:ss",
      monthBeforeYear: true,
      previousMonth: "Previous month (PageUp)",
      nextMonth: "Next month (PageDown)",
      previousYear: "Last year (Control + left)",
      nextYear: "Next year (Control + right)",
      previousDecade: "Last decade",
      nextDecade: "Next decade",
      previousCentury: "Last century",
      nextCentury: "Next century"
    };
    const locale$7 = {
      placeholder: "Select time",
      rangePlaceholder: ["Start time", "End time"]
    };
    const TimePicker = locale$7;
    const locale$6 = {
      lang: Object.assign({
        placeholder: "Select date",
        yearPlaceholder: "Select year",
        quarterPlaceholder: "Select quarter",
        monthPlaceholder: "Select month",
        weekPlaceholder: "Select week",
        rangePlaceholder: ["Start date", "End date"],
        rangeYearPlaceholder: ["Start year", "End year"],
        rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
        rangeMonthPlaceholder: ["Start month", "End month"],
        rangeWeekPlaceholder: ["Start week", "End week"]
      }, locale$8),
      timePickerLocale: Object.assign({}, TimePicker)
    };
    const enUS = locale$6;
    const typeTemplate$2 = "${label} is not a valid ${type}";
    const localeValues$1 = {
      locale: "en",
      Pagination: locale$9,
      DatePicker: enUS,
      TimePicker,
      Calendar: enUS,
      global: {
        placeholder: "Please select"
      },
      Table: {
        filterTitle: "Filter menu",
        filterConfirm: "OK",
        filterReset: "Reset",
        filterEmptyText: "No filters",
        filterCheckall: "Select all items",
        filterSearchPlaceholder: "Search in filters",
        emptyText: "No data",
        selectAll: "Select current page",
        selectInvert: "Invert current page",
        selectNone: "Clear all data",
        selectionAll: "Select all data",
        sortTitle: "Sort",
        expand: "Expand row",
        collapse: "Collapse row",
        triggerDesc: "Click to sort descending",
        triggerAsc: "Click to sort ascending",
        cancelSort: "Click to cancel sorting"
      },
      Tour: {
        Next: "Next",
        Previous: "Previous",
        Finish: "Finish"
      },
      Modal: {
        okText: "OK",
        cancelText: "Cancel",
        justOkText: "OK"
      },
      Popconfirm: {
        okText: "OK",
        cancelText: "Cancel"
      },
      Transfer: {
        titles: ["", ""],
        searchPlaceholder: "Search here",
        itemUnit: "item",
        itemsUnit: "items",
        remove: "Remove",
        selectCurrent: "Select current page",
        removeCurrent: "Remove current page",
        selectAll: "Select all data",
        removeAll: "Remove all data",
        selectInvert: "Invert current page"
      },
      Upload: {
        uploading: "Uploading...",
        removeFile: "Remove file",
        uploadError: "Upload error",
        previewFile: "Preview file",
        downloadFile: "Download file"
      },
      Empty: {
        description: "No data"
      },
      Icon: {
        icon: "icon"
      },
      Text: {
        edit: "Edit",
        copy: "Copy",
        copied: "Copied",
        expand: "Expand"
      },
      PageHeader: {
        back: "Back"
      },
      Form: {
        optional: "(optional)",
        defaultValidateMessages: {
          default: "Field validation error for ${label}",
          required: "Please enter ${label}",
          enum: "${label} must be one of [${enum}]",
          whitespace: "${label} cannot be a blank character",
          date: {
            format: "${label} date format is invalid",
            parse: "${label} cannot be converted to a date",
            invalid: "${label} is an invalid date"
          },
          types: {
            string: typeTemplate$2,
            method: typeTemplate$2,
            array: typeTemplate$2,
            object: typeTemplate$2,
            number: typeTemplate$2,
            date: typeTemplate$2,
            boolean: typeTemplate$2,
            integer: typeTemplate$2,
            float: typeTemplate$2,
            regexp: typeTemplate$2,
            email: typeTemplate$2,
            url: typeTemplate$2,
            hex: typeTemplate$2
          },
          string: {
            len: "${label} must be ${len} characters",
            min: "${label} must be at least ${min} characters",
            max: "${label} must be up to ${max} characters",
            range: "${label} must be between ${min}-${max} characters"
          },
          number: {
            len: "${label} must be equal to ${len}",
            min: "${label} must be minimum ${min}",
            max: "${label} must be maximum ${max}",
            range: "${label} must be between ${min}-${max}"
          },
          array: {
            len: "Must be ${len} ${label}",
            min: "At least ${min} ${label}",
            max: "At most ${max} ${label}",
            range: "The amount of ${label} must be between ${min}-${max}"
          },
          pattern: {
            mismatch: "${label} does not match the pattern ${pattern}"
          }
        }
      },
      Image: {
        preview: "Preview"
      },
      QRCode: {
        expired: "QR code expired",
        refresh: "Refresh"
      },
      ColorPicker: {
        presetEmpty: "Empty"
      }
    };
    const defaultLocale = localeValues$1;
    Object.assign({}, defaultLocale.Modal);
    let localeList = [];
    const generateLocale = () => localeList.reduce((merged, locale2) => Object.assign(Object.assign({}, merged), locale2), defaultLocale.Modal);
    function changeConfirmLocale(newLocale) {
      if (newLocale) {
        const cloneLocale = Object.assign({}, newLocale);
        localeList.push(cloneLocale);
        generateLocale();
        return () => {
          localeList = localeList.filter((locale2) => locale2 !== cloneLocale);
          generateLocale();
        };
      }
      Object.assign({}, defaultLocale.Modal);
    }
    const LocaleContext = /* @__PURE__ */ reactExports.createContext(void 0);
    const LocaleContext$1 = LocaleContext;
    const useLocale = (componentName, defaultLocale$1) => {
      const fullLocale = reactExports.useContext(LocaleContext$1);
      const getLocale2 = reactExports.useMemo(() => {
        var _a;
        const locale2 = defaultLocale$1 || defaultLocale[componentName];
        const localeFromContext = (_a = fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale[componentName]) !== null && _a !== void 0 ? _a : {};
        return Object.assign(Object.assign({}, typeof locale2 === "function" ? locale2() : locale2), localeFromContext || {});
      }, [componentName, defaultLocale$1, fullLocale]);
      const getLocaleCode = reactExports.useMemo(() => {
        const localeCode = fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale.locale;
        if ((fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale.exist) && !localeCode) {
          return defaultLocale.locale;
        }
        return localeCode;
      }, [fullLocale]);
      return [getLocale2, getLocaleCode];
    };
    const useLocale$1 = useLocale;
    const ANT_MARK = "internalMark";
    const LocaleProvider = (props) => {
      const {
        locale: locale2 = {},
        children,
        _ANT_MARK__
      } = props;
      reactExports.useEffect(() => {
        const clearLocale = changeConfirmLocale(locale2 && locale2.Modal);
        return clearLocale;
      }, [locale2]);
      const getMemoizedContextValue = reactExports.useMemo(() => Object.assign(Object.assign({}, locale2), {
        exist: true
      }), [locale2]);
      return /* @__PURE__ */ reactExports.createElement(LocaleContext$1.Provider, {
        value: getMemoizedContextValue
      }, children);
    };
    const LocaleProvider$1 = LocaleProvider;
    function bound01(n2, max2) {
      if (isOnePointZero(n2)) {
        n2 = "100%";
      }
      var isPercent = isPercentage(n2);
      n2 = max2 === 360 ? n2 : Math.min(max2, Math.max(0, parseFloat(n2)));
      if (isPercent) {
        n2 = parseInt(String(n2 * max2), 10) / 100;
      }
      if (Math.abs(n2 - max2) < 1e-6) {
        return 1;
      }
      if (max2 === 360) {
        n2 = (n2 < 0 ? n2 % max2 + max2 : n2 % max2) / parseFloat(String(max2));
      } else {
        n2 = n2 % max2 / parseFloat(String(max2));
      }
      return n2;
    }
    function clamp01(val) {
      return Math.min(1, Math.max(0, val));
    }
    function isOnePointZero(n2) {
      return typeof n2 === "string" && n2.indexOf(".") !== -1 && parseFloat(n2) === 1;
    }
    function isPercentage(n2) {
      return typeof n2 === "string" && n2.indexOf("%") !== -1;
    }
    function boundAlpha(a) {
      a = parseFloat(a);
      if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
      }
      return a;
    }
    function convertToPercentage(n2) {
      if (n2 <= 1) {
        return "".concat(Number(n2) * 100, "%");
      }
      return n2;
    }
    function pad2(c2) {
      return c2.length === 1 ? "0" + c2 : String(c2);
    }
    function rgbToRgb(r2, g2, b2) {
      return {
        r: bound01(r2, 255) * 255,
        g: bound01(g2, 255) * 255,
        b: bound01(b2, 255) * 255
      };
    }
    function rgbToHsl(r2, g2, b2) {
      r2 = bound01(r2, 255);
      g2 = bound01(g2, 255);
      b2 = bound01(b2, 255);
      var max2 = Math.max(r2, g2, b2);
      var min2 = Math.min(r2, g2, b2);
      var h2 = 0;
      var s = 0;
      var l2 = (max2 + min2) / 2;
      if (max2 === min2) {
        s = 0;
        h2 = 0;
      } else {
        var d2 = max2 - min2;
        s = l2 > 0.5 ? d2 / (2 - max2 - min2) : d2 / (max2 + min2);
        switch (max2) {
          case r2:
            h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            h2 = (b2 - r2) / d2 + 2;
            break;
          case b2:
            h2 = (r2 - g2) / d2 + 4;
            break;
        }
        h2 /= 6;
      }
      return { h: h2, s, l: l2 };
    }
    function hue2rgb(p2, q2, t2) {
      if (t2 < 0) {
        t2 += 1;
      }
      if (t2 > 1) {
        t2 -= 1;
      }
      if (t2 < 1 / 6) {
        return p2 + (q2 - p2) * (6 * t2);
      }
      if (t2 < 1 / 2) {
        return q2;
      }
      if (t2 < 2 / 3) {
        return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
      }
      return p2;
    }
    function hslToRgb(h2, s, l2) {
      var r2;
      var g2;
      var b2;
      h2 = bound01(h2, 360);
      s = bound01(s, 100);
      l2 = bound01(l2, 100);
      if (s === 0) {
        g2 = l2;
        b2 = l2;
        r2 = l2;
      } else {
        var q2 = l2 < 0.5 ? l2 * (1 + s) : l2 + s - l2 * s;
        var p2 = 2 * l2 - q2;
        r2 = hue2rgb(p2, q2, h2 + 1 / 3);
        g2 = hue2rgb(p2, q2, h2);
        b2 = hue2rgb(p2, q2, h2 - 1 / 3);
      }
      return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
    }
    function rgbToHsv(r2, g2, b2) {
      r2 = bound01(r2, 255);
      g2 = bound01(g2, 255);
      b2 = bound01(b2, 255);
      var max2 = Math.max(r2, g2, b2);
      var min2 = Math.min(r2, g2, b2);
      var h2 = 0;
      var v2 = max2;
      var d2 = max2 - min2;
      var s = max2 === 0 ? 0 : d2 / max2;
      if (max2 === min2) {
        h2 = 0;
      } else {
        switch (max2) {
          case r2:
            h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            h2 = (b2 - r2) / d2 + 2;
            break;
          case b2:
            h2 = (r2 - g2) / d2 + 4;
            break;
        }
        h2 /= 6;
      }
      return { h: h2, s, v: v2 };
    }
    function hsvToRgb(h2, s, v2) {
      h2 = bound01(h2, 360) * 6;
      s = bound01(s, 100);
      v2 = bound01(v2, 100);
      var i = Math.floor(h2);
      var f2 = h2 - i;
      var p2 = v2 * (1 - s);
      var q2 = v2 * (1 - f2 * s);
      var t2 = v2 * (1 - (1 - f2) * s);
      var mod2 = i % 6;
      var r2 = [v2, q2, p2, p2, t2, v2][mod2];
      var g2 = [t2, v2, v2, q2, p2, p2][mod2];
      var b2 = [p2, p2, t2, v2, v2, q2][mod2];
      return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
    }
    function rgbToHex(r2, g2, b2, allow3Char) {
      var hex = [
        pad2(Math.round(r2).toString(16)),
        pad2(Math.round(g2).toString(16)),
        pad2(Math.round(b2).toString(16))
      ];
      if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
      }
      return hex.join("");
    }
    function rgbaToHex(r2, g2, b2, a, allow4Char) {
      var hex = [
        pad2(Math.round(r2).toString(16)),
        pad2(Math.round(g2).toString(16)),
        pad2(Math.round(b2).toString(16)),
        pad2(convertDecimalToHex(a))
      ];
      if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
      }
      return hex.join("");
    }
    function convertDecimalToHex(d2) {
      return Math.round(parseFloat(d2) * 255).toString(16);
    }
    function convertHexToDecimal(h2) {
      return parseIntFromHex(h2) / 255;
    }
    function parseIntFromHex(val) {
      return parseInt(val, 16);
    }
    function numberInputToObject(color) {
      return {
        r: color >> 16,
        g: (color & 65280) >> 8,
        b: color & 255
      };
    }
    var names = {
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000000",
      blanchedalmond: "#ffebcd",
      blue: "#0000ff",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1e90ff",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#ff00ff",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      goldenrod: "#daa520",
      gold: "#ffd700",
      gray: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      lavenderblush: "#fff0f5",
      lavender: "#e6e6fa",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrodyellow: "#fafad2",
      lightgray: "#d3d3d3",
      lightgreen: "#90ee90",
      lightgrey: "#d3d3d3",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#00ff00",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#ff00ff",
      maroon: "#800000",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370db",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#db7093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      rebeccapurple: "#663399",
      red: "#ff0000",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      steelblue: "#4682b4",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      tomato: "#ff6347",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#ffffff",
      whitesmoke: "#f5f5f5",
      yellow: "#ffff00",
      yellowgreen: "#9acd32"
    };
    function inputToRGB(color) {
      var rgb = { r: 0, g: 0, b: 0 };
      var a = 1;
      var s = null;
      var v2 = null;
      var l2 = null;
      var ok2 = false;
      var format2 = false;
      if (typeof color === "string") {
        color = stringInputToObject(color);
      }
      if (typeof color === "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
          rgb = rgbToRgb(color.r, color.g, color.b);
          ok2 = true;
          format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
          s = convertToPercentage(color.s);
          v2 = convertToPercentage(color.v);
          rgb = hsvToRgb(color.h, s, v2);
          ok2 = true;
          format2 = "hsv";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
          s = convertToPercentage(color.s);
          l2 = convertToPercentage(color.l);
          rgb = hslToRgb(color.h, s, l2);
          ok2 = true;
          format2 = "hsl";
        }
        if (Object.prototype.hasOwnProperty.call(color, "a")) {
          a = color.a;
        }
      }
      a = boundAlpha(a);
      return {
        ok: ok2,
        format: color.format || format2,
        r: Math.min(255, Math.max(rgb.r, 0)),
        g: Math.min(255, Math.max(rgb.g, 0)),
        b: Math.min(255, Math.max(rgb.b, 0)),
        a
      };
    }
    var CSS_INTEGER = "[-\\+]?\\d+%?";
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
    var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
    var matchers = {
      CSS_UNIT: new RegExp(CSS_UNIT),
      rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
      rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
      hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
      hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
      hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
      hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
      hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
    function stringInputToObject(color) {
      color = color.trim().toLowerCase();
      if (color.length === 0) {
        return false;
      }
      var named = false;
      if (names[color]) {
        color = names[color];
        named = true;
      } else if (color === "transparent") {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
      }
      var match5 = matchers.rgb.exec(color);
      if (match5) {
        return { r: match5[1], g: match5[2], b: match5[3] };
      }
      match5 = matchers.rgba.exec(color);
      if (match5) {
        return { r: match5[1], g: match5[2], b: match5[3], a: match5[4] };
      }
      match5 = matchers.hsl.exec(color);
      if (match5) {
        return { h: match5[1], s: match5[2], l: match5[3] };
      }
      match5 = matchers.hsla.exec(color);
      if (match5) {
        return { h: match5[1], s: match5[2], l: match5[3], a: match5[4] };
      }
      match5 = matchers.hsv.exec(color);
      if (match5) {
        return { h: match5[1], s: match5[2], v: match5[3] };
      }
      match5 = matchers.hsva.exec(color);
      if (match5) {
        return { h: match5[1], s: match5[2], v: match5[3], a: match5[4] };
      }
      match5 = matchers.hex8.exec(color);
      if (match5) {
        return {
          r: parseIntFromHex(match5[1]),
          g: parseIntFromHex(match5[2]),
          b: parseIntFromHex(match5[3]),
          a: convertHexToDecimal(match5[4]),
          format: named ? "name" : "hex8"
        };
      }
      match5 = matchers.hex6.exec(color);
      if (match5) {
        return {
          r: parseIntFromHex(match5[1]),
          g: parseIntFromHex(match5[2]),
          b: parseIntFromHex(match5[3]),
          format: named ? "name" : "hex"
        };
      }
      match5 = matchers.hex4.exec(color);
      if (match5) {
        return {
          r: parseIntFromHex(match5[1] + match5[1]),
          g: parseIntFromHex(match5[2] + match5[2]),
          b: parseIntFromHex(match5[3] + match5[3]),
          a: convertHexToDecimal(match5[4] + match5[4]),
          format: named ? "name" : "hex8"
        };
      }
      match5 = matchers.hex3.exec(color);
      if (match5) {
        return {
          r: parseIntFromHex(match5[1] + match5[1]),
          g: parseIntFromHex(match5[2] + match5[2]),
          b: parseIntFromHex(match5[3] + match5[3]),
          format: named ? "name" : "hex"
        };
      }
      return false;
    }
    function isValidCSSUnit(color) {
      return Boolean(matchers.CSS_UNIT.exec(String(color)));
    }
    var TinyColor = (
      /** @class */
      function() {
        function TinyColor2(color, opts) {
          if (color === void 0) {
            color = "";
          }
          if (opts === void 0) {
            opts = {};
          }
          var _a;
          if (color instanceof TinyColor2) {
            return color;
          }
          if (typeof color === "number") {
            color = numberInputToObject(color);
          }
          this.originalInput = color;
          var rgb = inputToRGB(color);
          this.originalInput = color;
          this.r = rgb.r;
          this.g = rgb.g;
          this.b = rgb.b;
          this.a = rgb.a;
          this.roundA = Math.round(100 * this.a) / 100;
          this.format = (_a = opts.format) !== null && _a !== void 0 ? _a : rgb.format;
          this.gradientType = opts.gradientType;
          if (this.r < 1) {
            this.r = Math.round(this.r);
          }
          if (this.g < 1) {
            this.g = Math.round(this.g);
          }
          if (this.b < 1) {
            this.b = Math.round(this.b);
          }
          this.isValid = rgb.ok;
        }
        TinyColor2.prototype.isDark = function() {
          return this.getBrightness() < 128;
        };
        TinyColor2.prototype.isLight = function() {
          return !this.isDark();
        };
        TinyColor2.prototype.getBrightness = function() {
          var rgb = this.toRgb();
          return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
        };
        TinyColor2.prototype.getLuminance = function() {
          var rgb = this.toRgb();
          var R2;
          var G2;
          var B2;
          var RsRGB = rgb.r / 255;
          var GsRGB = rgb.g / 255;
          var BsRGB = rgb.b / 255;
          if (RsRGB <= 0.03928) {
            R2 = RsRGB / 12.92;
          } else {
            R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
          }
          if (GsRGB <= 0.03928) {
            G2 = GsRGB / 12.92;
          } else {
            G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
          }
          if (BsRGB <= 0.03928) {
            B2 = BsRGB / 12.92;
          } else {
            B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
          }
          return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
        };
        TinyColor2.prototype.getAlpha = function() {
          return this.a;
        };
        TinyColor2.prototype.setAlpha = function(alpha) {
          this.a = boundAlpha(alpha);
          this.roundA = Math.round(100 * this.a) / 100;
          return this;
        };
        TinyColor2.prototype.isMonochrome = function() {
          var s = this.toHsl().s;
          return s === 0;
        };
        TinyColor2.prototype.toHsv = function() {
          var hsv = rgbToHsv(this.r, this.g, this.b);
          return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
        };
        TinyColor2.prototype.toHsvString = function() {
          var hsv = rgbToHsv(this.r, this.g, this.b);
          var h2 = Math.round(hsv.h * 360);
          var s = Math.round(hsv.s * 100);
          var v2 = Math.round(hsv.v * 100);
          return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s, "%, ").concat(v2, "%)") : "hsva(".concat(h2, ", ").concat(s, "%, ").concat(v2, "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toHsl = function() {
          var hsl = rgbToHsl(this.r, this.g, this.b);
          return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
        };
        TinyColor2.prototype.toHslString = function() {
          var hsl = rgbToHsl(this.r, this.g, this.b);
          var h2 = Math.round(hsl.h * 360);
          var s = Math.round(hsl.s * 100);
          var l2 = Math.round(hsl.l * 100);
          return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s, "%, ").concat(l2, "%)") : "hsla(".concat(h2, ", ").concat(s, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toHex = function(allow3Char) {
          if (allow3Char === void 0) {
            allow3Char = false;
          }
          return rgbToHex(this.r, this.g, this.b, allow3Char);
        };
        TinyColor2.prototype.toHexString = function(allow3Char) {
          if (allow3Char === void 0) {
            allow3Char = false;
          }
          return "#" + this.toHex(allow3Char);
        };
        TinyColor2.prototype.toHex8 = function(allow4Char) {
          if (allow4Char === void 0) {
            allow4Char = false;
          }
          return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
        };
        TinyColor2.prototype.toHex8String = function(allow4Char) {
          if (allow4Char === void 0) {
            allow4Char = false;
          }
          return "#" + this.toHex8(allow4Char);
        };
        TinyColor2.prototype.toHexShortString = function(allowShortChar) {
          if (allowShortChar === void 0) {
            allowShortChar = false;
          }
          return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
        };
        TinyColor2.prototype.toRgb = function() {
          return {
            r: Math.round(this.r),
            g: Math.round(this.g),
            b: Math.round(this.b),
            a: this.a
          };
        };
        TinyColor2.prototype.toRgbString = function() {
          var r2 = Math.round(this.r);
          var g2 = Math.round(this.g);
          var b2 = Math.round(this.b);
          return this.a === 1 ? "rgb(".concat(r2, ", ").concat(g2, ", ").concat(b2, ")") : "rgba(".concat(r2, ", ").concat(g2, ", ").concat(b2, ", ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toPercentageRgb = function() {
          var fmt = function(x2) {
            return "".concat(Math.round(bound01(x2, 255) * 100), "%");
          };
          return {
            r: fmt(this.r),
            g: fmt(this.g),
            b: fmt(this.b),
            a: this.a
          };
        };
        TinyColor2.prototype.toPercentageRgbString = function() {
          var rnd = function(x2) {
            return Math.round(bound01(x2, 255) * 100);
          };
          return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toName = function() {
          if (this.a === 0) {
            return "transparent";
          }
          if (this.a < 1) {
            return false;
          }
          var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
          for (var _i = 0, _a = Object.entries(names); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            if (hex === value) {
              return key;
            }
          }
          return false;
        };
        TinyColor2.prototype.toString = function(format2) {
          var formatSet = Boolean(format2);
          format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
          var formattedString = false;
          var hasAlpha = this.a < 1 && this.a >= 0;
          var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
          if (needsAlphaFormat) {
            if (format2 === "name" && this.a === 0) {
              return this.toName();
            }
            return this.toRgbString();
          }
          if (format2 === "rgb") {
            formattedString = this.toRgbString();
          }
          if (format2 === "prgb") {
            formattedString = this.toPercentageRgbString();
          }
          if (format2 === "hex" || format2 === "hex6") {
            formattedString = this.toHexString();
          }
          if (format2 === "hex3") {
            formattedString = this.toHexString(true);
          }
          if (format2 === "hex4") {
            formattedString = this.toHex8String(true);
          }
          if (format2 === "hex8") {
            formattedString = this.toHex8String();
          }
          if (format2 === "name") {
            formattedString = this.toName();
          }
          if (format2 === "hsl") {
            formattedString = this.toHslString();
          }
          if (format2 === "hsv") {
            formattedString = this.toHsvString();
          }
          return formattedString || this.toHexString();
        };
        TinyColor2.prototype.toNumber = function() {
          return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
        };
        TinyColor2.prototype.clone = function() {
          return new TinyColor2(this.toString());
        };
        TinyColor2.prototype.lighten = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.l += amount / 100;
          hsl.l = clamp01(hsl.l);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.brighten = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var rgb = this.toRgb();
          rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
          rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
          rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
          return new TinyColor2(rgb);
        };
        TinyColor2.prototype.darken = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.l -= amount / 100;
          hsl.l = clamp01(hsl.l);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.tint = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          return this.mix("white", amount);
        };
        TinyColor2.prototype.shade = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          return this.mix("black", amount);
        };
        TinyColor2.prototype.desaturate = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.s -= amount / 100;
          hsl.s = clamp01(hsl.s);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.saturate = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.s += amount / 100;
          hsl.s = clamp01(hsl.s);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.greyscale = function() {
          return this.desaturate(100);
        };
        TinyColor2.prototype.spin = function(amount) {
          var hsl = this.toHsl();
          var hue = (hsl.h + amount) % 360;
          hsl.h = hue < 0 ? 360 + hue : hue;
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.mix = function(color, amount) {
          if (amount === void 0) {
            amount = 50;
          }
          var rgb1 = this.toRgb();
          var rgb2 = new TinyColor2(color).toRgb();
          var p2 = amount / 100;
          var rgba = {
            r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
            g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
            b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
            a: (rgb2.a - rgb1.a) * p2 + rgb1.a
          };
          return new TinyColor2(rgba);
        };
        TinyColor2.prototype.analogous = function(results, slices) {
          if (results === void 0) {
            results = 6;
          }
          if (slices === void 0) {
            slices = 30;
          }
          var hsl = this.toHsl();
          var part = 360 / slices;
          var ret = [this];
          for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
            hsl.h = (hsl.h + part) % 360;
            ret.push(new TinyColor2(hsl));
          }
          return ret;
        };
        TinyColor2.prototype.complement = function() {
          var hsl = this.toHsl();
          hsl.h = (hsl.h + 180) % 360;
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.monochromatic = function(results) {
          if (results === void 0) {
            results = 6;
          }
          var hsv = this.toHsv();
          var h2 = hsv.h;
          var s = hsv.s;
          var v2 = hsv.v;
          var res = [];
          var modification = 1 / results;
          while (results--) {
            res.push(new TinyColor2({ h: h2, s, v: v2 }));
            v2 = (v2 + modification) % 1;
          }
          return res;
        };
        TinyColor2.prototype.splitcomplement = function() {
          var hsl = this.toHsl();
          var h2 = hsl.h;
          return [
            this,
            new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
            new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
          ];
        };
        TinyColor2.prototype.onBackground = function(background) {
          var fg2 = this.toRgb();
          var bg2 = new TinyColor2(background).toRgb();
          var alpha = fg2.a + bg2.a * (1 - fg2.a);
          return new TinyColor2({
            r: (fg2.r * fg2.a + bg2.r * bg2.a * (1 - fg2.a)) / alpha,
            g: (fg2.g * fg2.a + bg2.g * bg2.a * (1 - fg2.a)) / alpha,
            b: (fg2.b * fg2.a + bg2.b * bg2.a * (1 - fg2.a)) / alpha,
            a: alpha
          });
        };
        TinyColor2.prototype.triad = function() {
          return this.polyad(3);
        };
        TinyColor2.prototype.tetrad = function() {
          return this.polyad(4);
        };
        TinyColor2.prototype.polyad = function(n2) {
          var hsl = this.toHsl();
          var h2 = hsl.h;
          var result = [this];
          var increment = 360 / n2;
          for (var i = 1; i < n2; i++) {
            result.push(new TinyColor2({ h: (h2 + i * increment) % 360, s: hsl.s, l: hsl.l }));
          }
          return result;
        };
        TinyColor2.prototype.equals = function(color) {
          return this.toRgbString() === new TinyColor2(color).toRgbString();
        };
        return TinyColor2;
      }()
    );
    var hueStep = 2;
    var saturationStep = 0.16;
    var saturationStep2 = 0.05;
    var brightnessStep1 = 0.05;
    var brightnessStep2 = 0.15;
    var lightColorCount = 5;
    var darkColorCount = 4;
    var darkColorMap = [{
      index: 7,
      opacity: 0.15
    }, {
      index: 6,
      opacity: 0.25
    }, {
      index: 5,
      opacity: 0.3
    }, {
      index: 5,
      opacity: 0.45
    }, {
      index: 5,
      opacity: 0.65
    }, {
      index: 5,
      opacity: 0.85
    }, {
      index: 4,
      opacity: 0.9
    }, {
      index: 3,
      opacity: 0.95
    }, {
      index: 2,
      opacity: 0.97
    }, {
      index: 1,
      opacity: 0.98
    }];
    function toHsv(_ref) {
      var r2 = _ref.r, g2 = _ref.g, b2 = _ref.b;
      var hsv = rgbToHsv(r2, g2, b2);
      return {
        h: hsv.h * 360,
        s: hsv.s,
        v: hsv.v
      };
    }
    function toHex(_ref2) {
      var r2 = _ref2.r, g2 = _ref2.g, b2 = _ref2.b;
      return "#".concat(rgbToHex(r2, g2, b2, false));
    }
    function mix(rgb1, rgb2, amount) {
      var p2 = amount / 100;
      var rgb = {
        r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
        g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
        b: (rgb2.b - rgb1.b) * p2 + rgb1.b
      };
      return rgb;
    }
    function getHue(hsv, i, light) {
      var hue;
      if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
        hue = light ? Math.round(hsv.h) - hueStep * i : Math.round(hsv.h) + hueStep * i;
      } else {
        hue = light ? Math.round(hsv.h) + hueStep * i : Math.round(hsv.h) - hueStep * i;
      }
      if (hue < 0) {
        hue += 360;
      } else if (hue >= 360) {
        hue -= 360;
      }
      return hue;
    }
    function getSaturation(hsv, i, light) {
      if (hsv.h === 0 && hsv.s === 0) {
        return hsv.s;
      }
      var saturation;
      if (light) {
        saturation = hsv.s - saturationStep * i;
      } else if (i === darkColorCount) {
        saturation = hsv.s + saturationStep;
      } else {
        saturation = hsv.s + saturationStep2 * i;
      }
      if (saturation > 1) {
        saturation = 1;
      }
      if (light && i === lightColorCount && saturation > 0.1) {
        saturation = 0.1;
      }
      if (saturation < 0.06) {
        saturation = 0.06;
      }
      return Number(saturation.toFixed(2));
    }
    function getValue$2(hsv, i, light) {
      var value;
      if (light) {
        value = hsv.v + brightnessStep1 * i;
      } else {
        value = hsv.v - brightnessStep2 * i;
      }
      if (value > 1) {
        value = 1;
      }
      return Number(value.toFixed(2));
    }
    function generate$1(color) {
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var patterns = [];
      var pColor = inputToRGB(color);
      for (var i = lightColorCount; i > 0; i -= 1) {
        var hsv = toHsv(pColor);
        var colorString = toHex(inputToRGB({
          h: getHue(hsv, i, true),
          s: getSaturation(hsv, i, true),
          v: getValue$2(hsv, i, true)
        }));
        patterns.push(colorString);
      }
      patterns.push(toHex(pColor));
      for (var _i = 1; _i <= darkColorCount; _i += 1) {
        var _hsv = toHsv(pColor);
        var _colorString = toHex(inputToRGB({
          h: getHue(_hsv, _i),
          s: getSaturation(_hsv, _i),
          v: getValue$2(_hsv, _i)
        }));
        patterns.push(_colorString);
      }
      if (opts.theme === "dark") {
        return darkColorMap.map(function(_ref3) {
          var index2 = _ref3.index, opacity = _ref3.opacity;
          var darkColorString = toHex(mix(inputToRGB(opts.backgroundColor || "#141414"), inputToRGB(patterns[index2]), opacity * 100));
          return darkColorString;
        });
      }
      return patterns;
    }
    var presetPrimaryColors = {
      red: "#F5222D",
      volcano: "#FA541C",
      orange: "#FA8C16",
      gold: "#FAAD14",
      yellow: "#FADB14",
      lime: "#A0D911",
      green: "#52C41A",
      cyan: "#13C2C2",
      blue: "#1677FF",
      geekblue: "#2F54EB",
      purple: "#722ED1",
      magenta: "#EB2F96",
      grey: "#666666"
    };
    var presetPalettes = {};
    var presetDarkPalettes = {};
    Object.keys(presetPrimaryColors).forEach(function(key) {
      presetPalettes[key] = generate$1(presetPrimaryColors[key]);
      presetPalettes[key].primary = presetPalettes[key][5];
      presetDarkPalettes[key] = generate$1(presetPrimaryColors[key], {
        theme: "dark",
        backgroundColor: "#141414"
      });
      presetDarkPalettes[key].primary = presetDarkPalettes[key][5];
    });
    var blue = presetPalettes.blue;
    const genControlHeight = (token2) => {
      const {
        controlHeight
      } = token2;
      return {
        controlHeightSM: controlHeight * 0.75,
        controlHeightXS: controlHeight * 0.5,
        controlHeightLG: controlHeight * 1.25
      };
    };
    const genControlHeight$1 = genControlHeight;
    function genSizeMapToken(token2) {
      const {
        sizeUnit,
        sizeStep
      } = token2;
      return {
        sizeXXL: sizeUnit * (sizeStep + 8),
        // 48
        sizeXL: sizeUnit * (sizeStep + 4),
        // 32
        sizeLG: sizeUnit * (sizeStep + 2),
        // 24
        sizeMD: sizeUnit * (sizeStep + 1),
        // 20
        sizeMS: sizeUnit * sizeStep,
        // 16
        size: sizeUnit * sizeStep,
        // 16
        sizeSM: sizeUnit * (sizeStep - 1),
        // 12
        sizeXS: sizeUnit * (sizeStep - 2),
        // 8
        sizeXXS: sizeUnit * (sizeStep - 3)
        // 4
      };
    }
    const defaultPresetColors = {
      blue: "#1677ff",
      purple: "#722ED1",
      cyan: "#13C2C2",
      green: "#52C41A",
      magenta: "#EB2F96",
      pink: "#eb2f96",
      red: "#F5222D",
      orange: "#FA8C16",
      yellow: "#FADB14",
      volcano: "#FA541C",
      geekblue: "#2F54EB",
      gold: "#FAAD14",
      lime: "#A0D911"
    };
    const seedToken = Object.assign(Object.assign({}, defaultPresetColors), {
      // Color
      colorPrimary: "#1677ff",
      colorSuccess: "#52c41a",
      colorWarning: "#faad14",
      colorError: "#ff4d4f",
      colorInfo: "#1677ff",
      colorLink: "",
      colorTextBase: "",
      colorBgBase: "",
      // Font
      fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
      fontFamilyCode: `'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace`,
      fontSize: 14,
      // Line
      lineWidth: 1,
      lineType: "solid",
      // Motion
      motionUnit: 0.1,
      motionBase: 0,
      motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
      motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
      motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
      motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
      motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
      motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
      motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
      motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
      // Radius
      borderRadius: 6,
      // Size
      sizeUnit: 4,
      sizeStep: 4,
      sizePopupArrow: 16,
      // Control Base
      controlHeight: 32,
      // zIndex
      zIndexBase: 0,
      zIndexPopupBase: 1e3,
      // Image
      opacityImage: 1,
      // Wireframe
      wireframe: false,
      // Motion
      motion: true
    });
    const seedToken$1 = seedToken;
    function genColorMapToken(seed, _ref) {
      let {
        generateColorPalettes: generateColorPalettes2,
        generateNeutralColorPalettes: generateNeutralColorPalettes2
      } = _ref;
      const {
        colorSuccess: colorSuccessBase,
        colorWarning: colorWarningBase,
        colorError: colorErrorBase,
        colorInfo: colorInfoBase,
        colorPrimary: colorPrimaryBase,
        colorBgBase,
        colorTextBase
      } = seed;
      const primaryColors = generateColorPalettes2(colorPrimaryBase);
      const successColors = generateColorPalettes2(colorSuccessBase);
      const warningColors = generateColorPalettes2(colorWarningBase);
      const errorColors = generateColorPalettes2(colorErrorBase);
      const infoColors = generateColorPalettes2(colorInfoBase);
      const neutralColors = generateNeutralColorPalettes2(colorBgBase, colorTextBase);
      const colorLink = seed.colorLink || seed.colorInfo;
      const linkColors = generateColorPalettes2(colorLink);
      return Object.assign(Object.assign({}, neutralColors), {
        colorPrimaryBg: primaryColors[1],
        colorPrimaryBgHover: primaryColors[2],
        colorPrimaryBorder: primaryColors[3],
        colorPrimaryBorderHover: primaryColors[4],
        colorPrimaryHover: primaryColors[5],
        colorPrimary: primaryColors[6],
        colorPrimaryActive: primaryColors[7],
        colorPrimaryTextHover: primaryColors[8],
        colorPrimaryText: primaryColors[9],
        colorPrimaryTextActive: primaryColors[10],
        colorSuccessBg: successColors[1],
        colorSuccessBgHover: successColors[2],
        colorSuccessBorder: successColors[3],
        colorSuccessBorderHover: successColors[4],
        colorSuccessHover: successColors[4],
        colorSuccess: successColors[6],
        colorSuccessActive: successColors[7],
        colorSuccessTextHover: successColors[8],
        colorSuccessText: successColors[9],
        colorSuccessTextActive: successColors[10],
        colorErrorBg: errorColors[1],
        colorErrorBgHover: errorColors[2],
        colorErrorBorder: errorColors[3],
        colorErrorBorderHover: errorColors[4],
        colorErrorHover: errorColors[5],
        colorError: errorColors[6],
        colorErrorActive: errorColors[7],
        colorErrorTextHover: errorColors[8],
        colorErrorText: errorColors[9],
        colorErrorTextActive: errorColors[10],
        colorWarningBg: warningColors[1],
        colorWarningBgHover: warningColors[2],
        colorWarningBorder: warningColors[3],
        colorWarningBorderHover: warningColors[4],
        colorWarningHover: warningColors[4],
        colorWarning: warningColors[6],
        colorWarningActive: warningColors[7],
        colorWarningTextHover: warningColors[8],
        colorWarningText: warningColors[9],
        colorWarningTextActive: warningColors[10],
        colorInfoBg: infoColors[1],
        colorInfoBgHover: infoColors[2],
        colorInfoBorder: infoColors[3],
        colorInfoBorderHover: infoColors[4],
        colorInfoHover: infoColors[4],
        colorInfo: infoColors[6],
        colorInfoActive: infoColors[7],
        colorInfoTextHover: infoColors[8],
        colorInfoText: infoColors[9],
        colorInfoTextActive: infoColors[10],
        colorLinkHover: linkColors[4],
        colorLink: linkColors[6],
        colorLinkActive: linkColors[7],
        colorBgMask: new TinyColor("#000").setAlpha(0.45).toRgbString(),
        colorWhite: "#fff"
      });
    }
    const genRadius = (radiusBase) => {
      let radiusLG = radiusBase;
      let radiusSM = radiusBase;
      let radiusXS = radiusBase;
      let radiusOuter = radiusBase;
      if (radiusBase < 6 && radiusBase >= 5) {
        radiusLG = radiusBase + 1;
      } else if (radiusBase < 16 && radiusBase >= 6) {
        radiusLG = radiusBase + 2;
      } else if (radiusBase >= 16) {
        radiusLG = 16;
      }
      if (radiusBase < 7 && radiusBase >= 5) {
        radiusSM = 4;
      } else if (radiusBase < 8 && radiusBase >= 7) {
        radiusSM = 5;
      } else if (radiusBase < 14 && radiusBase >= 8) {
        radiusSM = 6;
      } else if (radiusBase < 16 && radiusBase >= 14) {
        radiusSM = 7;
      } else if (radiusBase >= 16) {
        radiusSM = 8;
      }
      if (radiusBase < 6 && radiusBase >= 2) {
        radiusXS = 1;
      } else if (radiusBase >= 6) {
        radiusXS = 2;
      }
      if (radiusBase > 4 && radiusBase < 8) {
        radiusOuter = 4;
      } else if (radiusBase >= 8) {
        radiusOuter = 6;
      }
      return {
        borderRadius: radiusBase,
        borderRadiusXS: radiusXS,
        borderRadiusSM: radiusSM,
        borderRadiusLG: radiusLG,
        borderRadiusOuter: radiusOuter
      };
    };
    const genRadius$1 = genRadius;
    function genCommonMapToken(token2) {
      const {
        motionUnit,
        motionBase,
        borderRadius,
        lineWidth
      } = token2;
      return Object.assign({
        // motion
        motionDurationFast: `${(motionBase + motionUnit).toFixed(1)}s`,
        motionDurationMid: `${(motionBase + motionUnit * 2).toFixed(1)}s`,
        motionDurationSlow: `${(motionBase + motionUnit * 3).toFixed(1)}s`,
        // line
        lineWidthBold: lineWidth + 1
      }, genRadius$1(borderRadius));
    }
    const getAlphaColor$1 = (baseColor, alpha) => new TinyColor(baseColor).setAlpha(alpha).toRgbString();
    const getSolidColor = (baseColor, brightness) => {
      const instance = new TinyColor(baseColor);
      return instance.darken(brightness).toHexString();
    };
    const generateColorPalettes = (baseColor) => {
      const colors = generate$1(baseColor);
      return {
        1: colors[0],
        2: colors[1],
        3: colors[2],
        4: colors[3],
        5: colors[4],
        6: colors[5],
        7: colors[6],
        8: colors[4],
        9: colors[5],
        10: colors[6]
        // 8: colors[7],
        // 9: colors[8],
        // 10: colors[9],
      };
    };
    const generateNeutralColorPalettes = (bgBaseColor, textBaseColor) => {
      const colorBgBase = bgBaseColor || "#fff";
      const colorTextBase = textBaseColor || "#000";
      return {
        colorBgBase,
        colorTextBase,
        colorText: getAlphaColor$1(colorTextBase, 0.88),
        colorTextSecondary: getAlphaColor$1(colorTextBase, 0.65),
        colorTextTertiary: getAlphaColor$1(colorTextBase, 0.45),
        colorTextQuaternary: getAlphaColor$1(colorTextBase, 0.25),
        colorFill: getAlphaColor$1(colorTextBase, 0.15),
        colorFillSecondary: getAlphaColor$1(colorTextBase, 0.06),
        colorFillTertiary: getAlphaColor$1(colorTextBase, 0.04),
        colorFillQuaternary: getAlphaColor$1(colorTextBase, 0.02),
        colorBgLayout: getSolidColor(colorBgBase, 4),
        colorBgContainer: getSolidColor(colorBgBase, 0),
        colorBgElevated: getSolidColor(colorBgBase, 0),
        colorBgSpotlight: getAlphaColor$1(colorTextBase, 0.85),
        colorBgBlur: "transparent",
        colorBorder: getSolidColor(colorBgBase, 15),
        colorBorderSecondary: getSolidColor(colorBgBase, 6)
      };
    };
    function getFontSizes(base) {
      const fontSizes = new Array(10).fill(null).map((_, index2) => {
        const i = index2 - 1;
        const baseSize = base * Math.pow(2.71828, i / 5);
        const intSize = index2 > 1 ? Math.floor(baseSize) : Math.ceil(baseSize);
        return Math.floor(intSize / 2) * 2;
      });
      fontSizes[1] = base;
      return fontSizes.map((size) => {
        const height = size + 8;
        return {
          size,
          lineHeight: height / size
        };
      });
    }
    const genFontMapToken = (fontSize) => {
      const fontSizePairs = getFontSizes(fontSize);
      const fontSizes = fontSizePairs.map((pair) => pair.size);
      const lineHeights = fontSizePairs.map((pair) => pair.lineHeight);
      const fontSizeMD = fontSizes[1];
      const fontSizeSM = fontSizes[0];
      const fontSizeLG = fontSizes[2];
      const lineHeight = lineHeights[1];
      const lineHeightSM = lineHeights[0];
      const lineHeightLG = lineHeights[2];
      return {
        fontSizeSM,
        fontSize: fontSizeMD,
        fontSizeLG,
        fontSizeXL: fontSizes[3],
        fontSizeHeading1: fontSizes[6],
        fontSizeHeading2: fontSizes[5],
        fontSizeHeading3: fontSizes[4],
        fontSizeHeading4: fontSizes[3],
        fontSizeHeading5: fontSizes[2],
        lineHeight,
        lineHeightLG,
        lineHeightSM,
        fontHeight: Math.round(lineHeight * fontSizeMD),
        fontHeightLG: Math.round(lineHeightLG * fontSizeLG),
        fontHeightSM: Math.round(lineHeightSM * fontSizeSM),
        lineHeightHeading1: lineHeights[6],
        lineHeightHeading2: lineHeights[5],
        lineHeightHeading3: lineHeights[4],
        lineHeightHeading4: lineHeights[3],
        lineHeightHeading5: lineHeights[2]
      };
    };
    const genFontMapToken$1 = genFontMapToken;
    function derivative(token2) {
      const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
        const colors = generate$1(token2[colorKey]);
        return new Array(10).fill(1).reduce((prev2, _, i) => {
          prev2[`${colorKey}-${i + 1}`] = colors[i];
          prev2[`${colorKey}${i + 1}`] = colors[i];
          return prev2;
        }, {});
      }).reduce((prev2, cur) => {
        prev2 = Object.assign(Object.assign({}, prev2), cur);
        return prev2;
      }, {});
      return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, token2), colorPalettes), genColorMapToken(token2, {
        generateColorPalettes,
        generateNeutralColorPalettes
      })), genFontMapToken$1(token2.fontSize)), genSizeMapToken(token2)), genControlHeight$1(token2)), genCommonMapToken(token2));
    }
    const defaultTheme = createTheme(derivative);
    const defaultConfig = {
      token: seedToken$1,
      override: {
        override: seedToken$1
      },
      hashed: true
    };
    const DesignTokenContext = /* @__PURE__ */ React.createContext(defaultConfig);
    const defaultIconPrefixCls = "anticon";
    const defaultGetPrefixCls = (suffixCls, customizePrefixCls) => {
      if (customizePrefixCls) {
        return customizePrefixCls;
      }
      return suffixCls ? `ant-${suffixCls}` : "ant";
    };
    const ConfigContext = /* @__PURE__ */ reactExports.createContext({
      // We provide a default function for Context without provider
      getPrefixCls: defaultGetPrefixCls,
      iconPrefixCls: defaultIconPrefixCls
    });
    const dynamicStyleMark = `-ant-${Date.now()}-${Math.random()}`;
    function getStyle$1(globalPrefixCls2, theme) {
      const variables = {};
      const formatColor = (color, updater) => {
        let clone2 = color.clone();
        clone2 = (updater === null || updater === void 0 ? void 0 : updater(clone2)) || clone2;
        return clone2.toRgbString();
      };
      const fillColor = (colorVal, type) => {
        const baseColor = new TinyColor(colorVal);
        const colorPalettes = generate$1(baseColor.toRgbString());
        variables[`${type}-color`] = formatColor(baseColor);
        variables[`${type}-color-disabled`] = colorPalettes[1];
        variables[`${type}-color-hover`] = colorPalettes[4];
        variables[`${type}-color-active`] = colorPalettes[6];
        variables[`${type}-color-outline`] = baseColor.clone().setAlpha(0.2).toRgbString();
        variables[`${type}-color-deprecated-bg`] = colorPalettes[0];
        variables[`${type}-color-deprecated-border`] = colorPalettes[2];
      };
      if (theme.primaryColor) {
        fillColor(theme.primaryColor, "primary");
        const primaryColor = new TinyColor(theme.primaryColor);
        const primaryColors = generate$1(primaryColor.toRgbString());
        primaryColors.forEach((color, index2) => {
          variables[`primary-${index2 + 1}`] = color;
        });
        variables["primary-color-deprecated-l-35"] = formatColor(primaryColor, (c2) => c2.lighten(35));
        variables["primary-color-deprecated-l-20"] = formatColor(primaryColor, (c2) => c2.lighten(20));
        variables["primary-color-deprecated-t-20"] = formatColor(primaryColor, (c2) => c2.tint(20));
        variables["primary-color-deprecated-t-50"] = formatColor(primaryColor, (c2) => c2.tint(50));
        variables["primary-color-deprecated-f-12"] = formatColor(primaryColor, (c2) => c2.setAlpha(c2.getAlpha() * 0.12));
        const primaryActiveColor = new TinyColor(primaryColors[0]);
        variables["primary-color-active-deprecated-f-30"] = formatColor(primaryActiveColor, (c2) => c2.setAlpha(c2.getAlpha() * 0.3));
        variables["primary-color-active-deprecated-d-02"] = formatColor(primaryActiveColor, (c2) => c2.darken(2));
      }
      if (theme.successColor) {
        fillColor(theme.successColor, "success");
      }
      if (theme.warningColor) {
        fillColor(theme.warningColor, "warning");
      }
      if (theme.errorColor) {
        fillColor(theme.errorColor, "error");
      }
      if (theme.infoColor) {
        fillColor(theme.infoColor, "info");
      }
      const cssList = Object.keys(variables).map((key) => `--${globalPrefixCls2}-${key}: ${variables[key]};`);
      return `
  :root {
    ${cssList.join("\n")}
  }
  `.trim();
    }
    function registerTheme(globalPrefixCls2, theme) {
      const style2 = getStyle$1(globalPrefixCls2, theme);
      if (canUseDom()) {
        updateCSS(style2, `${dynamicStyleMark}-dynamic-theme`);
      }
    }
    const DisabledContext = /* @__PURE__ */ reactExports.createContext(false);
    const DisabledContextProvider = (_ref) => {
      let {
        children,
        disabled
      } = _ref;
      const originDisabled = reactExports.useContext(DisabledContext);
      return /* @__PURE__ */ reactExports.createElement(DisabledContext.Provider, {
        value: disabled !== null && disabled !== void 0 ? disabled : originDisabled
      }, children);
    };
    const DisabledContext$1 = DisabledContext;
    const SizeContext = /* @__PURE__ */ reactExports.createContext(void 0);
    const SizeContextProvider = (_ref) => {
      let {
        children,
        size
      } = _ref;
      const originSize = reactExports.useContext(SizeContext);
      return /* @__PURE__ */ reactExports.createElement(SizeContext.Provider, {
        value: size || originSize
      }, children);
    };
    const SizeContext$1 = SizeContext;
    function useConfig() {
      const componentDisabled = reactExports.useContext(DisabledContext$1);
      const componentSize = reactExports.useContext(SizeContext$1);
      return {
        componentDisabled,
        componentSize
      };
    }
    const PresetColors = ["blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold"];
    const version$1 = "5.12.2";
    function isStableColor(color) {
      return color >= 0 && color <= 255;
    }
    function getAlphaColor(frontColor, backgroundColor) {
      const {
        r: fR,
        g: fG,
        b: fB,
        a: originAlpha
      } = new TinyColor(frontColor).toRgb();
      if (originAlpha < 1) {
        return frontColor;
      }
      const {
        r: bR,
        g: bG,
        b: bB
      } = new TinyColor(backgroundColor).toRgb();
      for (let fA = 0.01; fA <= 1; fA += 0.01) {
        const r2 = Math.round((fR - bR * (1 - fA)) / fA);
        const g2 = Math.round((fG - bG * (1 - fA)) / fA);
        const b2 = Math.round((fB - bB * (1 - fA)) / fA);
        if (isStableColor(r2) && isStableColor(g2) && isStableColor(b2)) {
          return new TinyColor({
            r: r2,
            g: g2,
            b: b2,
            a: Math.round(fA * 100) / 100
          }).toRgbString();
        }
      }
      return new TinyColor({
        r: fR,
        g: fG,
        b: fB,
        a: 1
      }).toRgbString();
    }
    var __rest$H = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    function formatToken(derivativeToken) {
      const {
        override
      } = derivativeToken, restToken = __rest$H(derivativeToken, ["override"]);
      const overrideTokens = Object.assign({}, override);
      Object.keys(seedToken$1).forEach((token2) => {
        delete overrideTokens[token2];
      });
      const mergedToken = Object.assign(Object.assign({}, restToken), overrideTokens);
      const screenXS = 480;
      const screenSM = 576;
      const screenMD = 768;
      const screenLG = 992;
      const screenXL = 1200;
      const screenXXL = 1600;
      if (mergedToken.motion === false) {
        const fastDuration = "0s";
        mergedToken.motionDurationFast = fastDuration;
        mergedToken.motionDurationMid = fastDuration;
        mergedToken.motionDurationSlow = fastDuration;
      }
      const aliasToken = Object.assign(Object.assign(Object.assign({}, mergedToken), {
        // ============== Background ============== //
        colorFillContent: mergedToken.colorFillSecondary,
        colorFillContentHover: mergedToken.colorFill,
        colorFillAlter: mergedToken.colorFillQuaternary,
        colorBgContainerDisabled: mergedToken.colorFillTertiary,
        // ============== Split ============== //
        colorBorderBg: mergedToken.colorBgContainer,
        colorSplit: getAlphaColor(mergedToken.colorBorderSecondary, mergedToken.colorBgContainer),
        // ============== Text ============== //
        colorTextPlaceholder: mergedToken.colorTextQuaternary,
        colorTextDisabled: mergedToken.colorTextQuaternary,
        colorTextHeading: mergedToken.colorText,
        colorTextLabel: mergedToken.colorTextSecondary,
        colorTextDescription: mergedToken.colorTextTertiary,
        colorTextLightSolid: mergedToken.colorWhite,
        colorHighlight: mergedToken.colorError,
        colorBgTextHover: mergedToken.colorFillSecondary,
        colorBgTextActive: mergedToken.colorFill,
        colorIcon: mergedToken.colorTextTertiary,
        colorIconHover: mergedToken.colorText,
        colorErrorOutline: getAlphaColor(mergedToken.colorErrorBg, mergedToken.colorBgContainer),
        colorWarningOutline: getAlphaColor(mergedToken.colorWarningBg, mergedToken.colorBgContainer),
        // Font
        fontSizeIcon: mergedToken.fontSizeSM,
        // Line
        lineWidthFocus: mergedToken.lineWidth * 4,
        // Control
        lineWidth: mergedToken.lineWidth,
        controlOutlineWidth: mergedToken.lineWidth * 2,
        // Checkbox size and expand icon size
        controlInteractiveSize: mergedToken.controlHeight / 2,
        controlItemBgHover: mergedToken.colorFillTertiary,
        controlItemBgActive: mergedToken.colorPrimaryBg,
        controlItemBgActiveHover: mergedToken.colorPrimaryBgHover,
        controlItemBgActiveDisabled: mergedToken.colorFill,
        controlTmpOutline: mergedToken.colorFillQuaternary,
        controlOutline: getAlphaColor(mergedToken.colorPrimaryBg, mergedToken.colorBgContainer),
        lineType: mergedToken.lineType,
        borderRadius: mergedToken.borderRadius,
        borderRadiusXS: mergedToken.borderRadiusXS,
        borderRadiusSM: mergedToken.borderRadiusSM,
        borderRadiusLG: mergedToken.borderRadiusLG,
        fontWeightStrong: 600,
        opacityLoading: 0.65,
        linkDecoration: "none",
        linkHoverDecoration: "none",
        linkFocusDecoration: "none",
        controlPaddingHorizontal: 12,
        controlPaddingHorizontalSM: 8,
        paddingXXS: mergedToken.sizeXXS,
        paddingXS: mergedToken.sizeXS,
        paddingSM: mergedToken.sizeSM,
        padding: mergedToken.size,
        paddingMD: mergedToken.sizeMD,
        paddingLG: mergedToken.sizeLG,
        paddingXL: mergedToken.sizeXL,
        paddingContentHorizontalLG: mergedToken.sizeLG,
        paddingContentVerticalLG: mergedToken.sizeMS,
        paddingContentHorizontal: mergedToken.sizeMS,
        paddingContentVertical: mergedToken.sizeSM,
        paddingContentHorizontalSM: mergedToken.size,
        paddingContentVerticalSM: mergedToken.sizeXS,
        marginXXS: mergedToken.sizeXXS,
        marginXS: mergedToken.sizeXS,
        marginSM: mergedToken.sizeSM,
        margin: mergedToken.size,
        marginMD: mergedToken.sizeMD,
        marginLG: mergedToken.sizeLG,
        marginXL: mergedToken.sizeXL,
        marginXXL: mergedToken.sizeXXL,
        boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
        screenXS,
        screenXSMin: screenXS,
        screenXSMax: screenSM - 1,
        screenSM,
        screenSMMin: screenSM,
        screenSMMax: screenMD - 1,
        screenMD,
        screenMDMin: screenMD,
        screenMDMax: screenLG - 1,
        screenLG,
        screenLGMin: screenLG,
        screenLGMax: screenXL - 1,
        screenXL,
        screenXLMin: screenXL,
        screenXLMax: screenXXL - 1,
        screenXXL,
        screenXXLMin: screenXXL,
        boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
        boxShadowCard: `
      0 1px 2px -2px ${new TinyColor("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new TinyColor("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new TinyColor("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
        boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
        boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
        boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
        boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
      }), overrideTokens);
      return aliasToken;
    }
    var __rest$G = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const unitless = {
      lineHeight: true,
      lineHeightSM: true,
      lineHeightLG: true,
      lineHeightHeading1: true,
      lineHeightHeading2: true,
      lineHeightHeading3: true,
      lineHeightHeading4: true,
      lineHeightHeading5: true,
      opacityLoading: true,
      fontWeightStrong: true,
      zIndexPopupBase: true,
      zIndexBase: true
    };
    const ignore = {
      size: true,
      sizeSM: true,
      sizeLG: true,
      sizeMD: true,
      sizeXS: true,
      sizeXXS: true,
      sizeMS: true,
      sizeXL: true,
      sizeXXL: true,
      sizeUnit: true,
      sizeStep: true,
      motionBase: true,
      motionUnit: true
    };
    const preserve = {
      screenXS: true,
      screenXSMin: true,
      screenXSMax: true,
      screenSM: true,
      screenSMMin: true,
      screenSMMax: true,
      screenMD: true,
      screenMDMin: true,
      screenMDMax: true,
      screenLG: true,
      screenLGMin: true,
      screenLGMax: true,
      screenXL: true,
      screenXLMin: true,
      screenXLMax: true,
      screenXXL: true,
      screenXXLMin: true
    };
    const getComputedToken = (originToken, overrideToken, theme) => {
      const derivativeToken = theme.getDerivativeToken(originToken);
      const {
        override
      } = overrideToken, components = __rest$G(overrideToken, ["override"]);
      let mergedDerivativeToken = Object.assign(Object.assign({}, derivativeToken), {
        override
      });
      mergedDerivativeToken = formatToken(mergedDerivativeToken);
      if (components) {
        Object.entries(components).forEach((_ref) => {
          let [key, value] = _ref;
          const {
            theme: componentTheme
          } = value, componentTokens = __rest$G(value, ["theme"]);
          let mergedComponentToken = componentTokens;
          if (componentTheme) {
            mergedComponentToken = getComputedToken(Object.assign(Object.assign({}, mergedDerivativeToken), componentTokens), {
              override: componentTokens
            }, componentTheme);
          }
          mergedDerivativeToken[key] = mergedComponentToken;
        });
      }
      return mergedDerivativeToken;
    };
    function useToken$1() {
      const {
        token: rootDesignToken,
        hashed,
        theme,
        override,
        cssVar
      } = React.useContext(DesignTokenContext);
      const salt = `${version$1}-${hashed || ""}`;
      const mergedTheme = theme || defaultTheme;
      const [token2, hashId, realToken] = useCacheToken(mergedTheme, [seedToken$1, rootDesignToken], {
        salt,
        override,
        getComputedToken,
        // formatToken will not be consumed after 1.15.0 with getComputedToken.
        // But token will break if @ant-design/cssinjs is under 1.15.0 without it
        formatToken,
        cssVar: cssVar && {
          prefix: cssVar.prefix,
          key: cssVar.key,
          unitless,
          ignore,
          preserve
        }
      });
      return [mergedTheme, realToken, hashed ? hashId : "", token2, cssVar];
    }
    function useEvent(callback) {
      var fnRef = reactExports.useRef();
      fnRef.current = callback;
      var memoFn = reactExports.useCallback(function() {
        var _fnRef$current;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));
      }, []);
      return memoFn;
    }
    function useSafeState(defaultValue) {
      var destroyRef = reactExports.useRef(false);
      var _React$useState = reactExports.useState(defaultValue), _React$useState2 = _slicedToArray(_React$useState, 2), value = _React$useState2[0], setValue = _React$useState2[1];
      reactExports.useEffect(function() {
        destroyRef.current = false;
        return function() {
          destroyRef.current = true;
        };
      }, []);
      function safeSetState(updater, ignoreDestroy) {
        if (ignoreDestroy && destroyRef.current) {
          return;
        }
        setValue(updater);
      }
      return [value, safeSetState];
    }
    function hasValue$1(value) {
      return value !== void 0;
    }
    function useMergedState(defaultStateValue, option) {
      var _ref = option || {}, defaultValue = _ref.defaultValue, value = _ref.value, onChange = _ref.onChange, postState = _ref.postState;
      var _useState = useSafeState(function() {
        if (hasValue$1(value)) {
          return value;
        } else if (hasValue$1(defaultValue)) {
          return typeof defaultValue === "function" ? defaultValue() : defaultValue;
        } else {
          return typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
        }
      }), _useState2 = _slicedToArray(_useState, 2), innerValue = _useState2[0], setInnerValue = _useState2[1];
      var mergedValue = value !== void 0 ? value : innerValue;
      var postMergedValue = postState ? postState(mergedValue) : mergedValue;
      var onChangeFn = useEvent(onChange);
      var _useState3 = useSafeState([mergedValue]), _useState4 = _slicedToArray(_useState3, 2), prevValue = _useState4[0], setPrevValue = _useState4[1];
      useLayoutUpdateEffect(function() {
        var prev2 = prevValue[0];
        if (innerValue !== prev2) {
          onChangeFn(innerValue, prev2);
        }
      }, [prevValue]);
      useLayoutUpdateEffect(function() {
        if (!hasValue$1(value)) {
          setInnerValue(value);
        }
      }, [value]);
      var triggerChange = useEvent(function(updater, ignoreDestroy) {
        setInnerValue(updater, ignoreDestroy);
        setPrevValue([mergedValue], ignoreDestroy);
      });
      return [postMergedValue, triggerChange];
    }
    const operationUnit = (token2) => ({
      // FIXME: This use link but is a operation unit. Seems should be a colorPrimary.
      // And Typography use this to generate link style which should not do this.
      color: token2.colorLink,
      textDecoration: "none",
      outline: "none",
      cursor: "pointer",
      transition: `color ${token2.motionDurationSlow}`,
      "&:focus, &:hover": {
        color: token2.colorLinkHover
      },
      "&:active": {
        color: token2.colorLinkActive
      }
    });
    const textEllipsis = {
      overflow: "hidden",
      whiteSpace: "nowrap",
      textOverflow: "ellipsis"
    };
    const resetComponent = function(token2) {
      let needInheritFontFamily = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return {
        boxSizing: "border-box",
        margin: 0,
        padding: 0,
        color: token2.colorText,
        fontSize: token2.fontSize,
        // font-variant: @font-variant-base;
        lineHeight: token2.lineHeight,
        listStyle: "none",
        // font-feature-settings: @font-feature-settings-base;
        fontFamily: needInheritFontFamily ? "inherit" : token2.fontFamily
      };
    };
    const resetIcon = () => ({
      display: "inline-flex",
      alignItems: "center",
      color: "inherit",
      fontStyle: "normal",
      lineHeight: 0,
      textAlign: "center",
      textTransform: "none",
      // for SVG icon, see https://blog.prototypr.io/align-svg-icons-to-text-and-say-goodbye-to-font-icons-d44b3d7b26b4
      verticalAlign: "-0.125em",
      textRendering: "optimizeLegibility",
      "-webkit-font-smoothing": "antialiased",
      "-moz-osx-font-smoothing": "grayscale",
      "> *": {
        lineHeight: 1
      },
      svg: {
        display: "inline-block"
      }
    });
    const clearFix = () => ({
      // https://github.com/ant-design/ant-design/issues/21301#issuecomment-583955229
      "&::before": {
        display: "table",
        content: '""'
      },
      "&::after": {
        // https://github.com/ant-design/ant-design/issues/21864
        display: "table",
        clear: "both",
        content: '""'
      }
    });
    const genLinkStyle = (token2) => ({
      a: {
        color: token2.colorLink,
        textDecoration: token2.linkDecoration,
        backgroundColor: "transparent",
        // remove the gray background on active links in IE 10.
        outline: "none",
        cursor: "pointer",
        transition: `color ${token2.motionDurationSlow}`,
        "-webkit-text-decoration-skip": "objects",
        // remove gaps in links underline in iOS 8+ and Safari 8+.
        "&:hover": {
          color: token2.colorLinkHover
        },
        "&:active": {
          color: token2.colorLinkActive
        },
        [`&:active,
  &:hover`]: {
          textDecoration: token2.linkHoverDecoration,
          outline: 0
        },
        // https://github.com/ant-design/ant-design/issues/22503
        "&:focus": {
          textDecoration: token2.linkFocusDecoration,
          outline: 0
        },
        "&[disabled]": {
          color: token2.colorTextDisabled,
          cursor: "not-allowed"
        }
      }
    });
    const genCommonStyle = (token2, componentPrefixCls) => {
      const {
        fontFamily,
        fontSize
      } = token2;
      const rootPrefixSelector = `[class^="${componentPrefixCls}"], [class*=" ${componentPrefixCls}"]`;
      return {
        [rootPrefixSelector]: {
          fontFamily,
          fontSize,
          boxSizing: "border-box",
          "&::before, &::after": {
            boxSizing: "border-box"
          },
          [rootPrefixSelector]: {
            boxSizing: "border-box",
            "&::before, &::after": {
              boxSizing: "border-box"
            }
          }
        }
      };
    };
    const genFocusOutline = (token2) => ({
      outline: `${unit$1(token2.lineWidthFocus)} solid ${token2.colorPrimaryBorder}`,
      outlineOffset: 1,
      transition: "outline-offset 0s, outline 0s"
    });
    const genFocusStyle = (token2) => ({
      "&:focus-visible": Object.assign({}, genFocusOutline(token2))
    });
    let AbstractCalculator = /* @__PURE__ */ _createClass(function AbstractCalculator2() {
      _classCallCheck(this, AbstractCalculator2);
    });
    const AbstractCalculator$1 = AbstractCalculator;
    let NumCalculator = /* @__PURE__ */ function(_AbstractCalculator) {
      _inherits(NumCalculator2, _AbstractCalculator);
      var _super = _createSuper(NumCalculator2);
      function NumCalculator2(num) {
        var _this;
        _classCallCheck(this, NumCalculator2);
        _this = _super.call(this);
        _this.result = 0;
        if (num instanceof NumCalculator2) {
          _this.result = num.result;
        } else if (typeof num === "number") {
          _this.result = num;
        }
        return _this;
      }
      _createClass(NumCalculator2, [{
        key: "add",
        value: function add2(num) {
          if (num instanceof NumCalculator2) {
            this.result += num.result;
          } else if (typeof num === "number") {
            this.result += num;
          }
          return this;
        }
      }, {
        key: "sub",
        value: function sub(num) {
          if (num instanceof NumCalculator2) {
            this.result -= num.result;
          } else if (typeof num === "number") {
            this.result -= num;
          }
          return this;
        }
      }, {
        key: "mul",
        value: function mul(num) {
          if (num instanceof NumCalculator2) {
            this.result *= num.result;
          } else if (typeof num === "number") {
            this.result *= num;
          }
          return this;
        }
      }, {
        key: "div",
        value: function div(num) {
          if (num instanceof NumCalculator2) {
            this.result /= num.result;
          } else if (typeof num === "number") {
            this.result /= num;
          }
          return this;
        }
      }, {
        key: "equal",
        value: function equal() {
          return this.result;
        }
      }]);
      return NumCalculator2;
    }(AbstractCalculator$1);
    const CALC_UNIT = "CALC_UNIT";
    function unit(value) {
      if (typeof value === "number") {
        return `${value}${CALC_UNIT}`;
      }
      return value;
    }
    let CSSCalculator = /* @__PURE__ */ function(_AbstractCalculator) {
      _inherits(CSSCalculator2, _AbstractCalculator);
      var _super = _createSuper(CSSCalculator2);
      function CSSCalculator2(num) {
        var _this;
        _classCallCheck(this, CSSCalculator2);
        _this = _super.call(this);
        _this.result = "";
        if (num instanceof CSSCalculator2) {
          _this.result = `(${num.result})`;
        } else if (typeof num === "number") {
          _this.result = unit(num);
        } else if (typeof num === "string") {
          _this.result = num;
        }
        return _this;
      }
      _createClass(CSSCalculator2, [{
        key: "add",
        value: function add2(num) {
          if (num instanceof CSSCalculator2) {
            this.result = `${this.result} + ${num.getResult()}`;
          } else if (typeof num === "number" || typeof num === "string") {
            this.result = `${this.result} + ${unit(num)}`;
          }
          this.lowPriority = true;
          return this;
        }
      }, {
        key: "sub",
        value: function sub(num) {
          if (num instanceof CSSCalculator2) {
            this.result = `${this.result} - ${num.getResult()}`;
          } else if (typeof num === "number" || typeof num === "string") {
            this.result = `${this.result} - ${unit(num)}`;
          }
          this.lowPriority = true;
          return this;
        }
      }, {
        key: "mul",
        value: function mul(num) {
          if (this.lowPriority) {
            this.result = `(${this.result})`;
          }
          if (num instanceof CSSCalculator2) {
            this.result = `${this.result} * ${num.getResult(true)}`;
          } else if (typeof num === "number" || typeof num === "string") {
            this.result = `${this.result} * ${num}`;
          }
          this.lowPriority = false;
          return this;
        }
      }, {
        key: "div",
        value: function div(num) {
          if (this.lowPriority) {
            this.result = `(${this.result})`;
          }
          if (num instanceof CSSCalculator2) {
            this.result = `${this.result} / ${num.getResult(true)}`;
          } else if (typeof num === "number" || typeof num === "string") {
            this.result = `${this.result} / ${num}`;
          }
          this.lowPriority = false;
          return this;
        }
      }, {
        key: "getResult",
        value: function getResult(force) {
          return this.lowPriority || force ? `(${this.result})` : this.result;
        }
      }, {
        key: "equal",
        value: function equal(options) {
          const {
            unit: cssUnit = true
          } = options || {};
          const regexp = new RegExp(`${CALC_UNIT}`, "g");
          this.result = this.result.replace(regexp, cssUnit ? "px" : "");
          if (typeof this.lowPriority !== "undefined") {
            return `calc(${this.result})`;
          }
          return this.result;
        }
      }]);
      return CSSCalculator2;
    }(AbstractCalculator$1);
    const genCalc = (type) => {
      const Calculator = type === "css" ? CSSCalculator : NumCalculator;
      return (num) => new Calculator(num);
    };
    const genCalc$1 = genCalc;
    function genMaxMin(type) {
      if (type === "js") {
        return {
          max: Math.max,
          min: Math.min
        };
      }
      return {
        max: function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return `max(${args.map((value) => unit$1(value)).join(",")})`;
        },
        min: function() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          return `min(${args.map((value) => unit$1(value)).join(",")})`;
        }
      };
    }
    const enableStatistic = typeof CSSINJS_STATISTIC !== "undefined";
    let recording = true;
    function merge$1() {
      for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {
        objs[_key] = arguments[_key];
      }
      if (!enableStatistic) {
        return Object.assign.apply(Object, [{}].concat(objs));
      }
      recording = false;
      const ret = {};
      objs.forEach((obj) => {
        const keys2 = Object.keys(obj);
        keys2.forEach((key) => {
          Object.defineProperty(ret, key, {
            configurable: true,
            enumerable: true,
            get: () => obj[key]
          });
        });
      });
      recording = true;
      return ret;
    }
    const statistic = {};
    function noop$3() {
    }
    function statisticToken(token2) {
      let tokenKeys2;
      let proxy = token2;
      let flush = noop$3;
      if (enableStatistic && typeof Proxy !== "undefined") {
        tokenKeys2 = /* @__PURE__ */ new Set();
        proxy = new Proxy(token2, {
          get(obj, prop) {
            if (recording) {
              tokenKeys2.add(prop);
            }
            return obj[prop];
          }
        });
        flush = (componentName, componentToken) => {
          var _a;
          statistic[componentName] = {
            global: Array.from(tokenKeys2),
            component: Object.assign(Object.assign({}, (_a = statistic[componentName]) === null || _a === void 0 ? void 0 : _a.component), componentToken)
          };
        };
      }
      return {
        token: proxy,
        keys: tokenKeys2,
        flush
      };
    }
    const useResetIconStyle = (iconPrefixCls, csp) => {
      const [theme, token2] = useToken$1();
      return useStyleRegister({
        theme,
        token: token2,
        hashId: "",
        path: ["ant-design-icons", iconPrefixCls],
        nonce: () => csp === null || csp === void 0 ? void 0 : csp.nonce
      }, () => [{
        [`.${iconPrefixCls}`]: Object.assign(Object.assign({}, resetIcon()), {
          [`.${iconPrefixCls} .${iconPrefixCls}-icon`]: {
            display: "block"
          }
        })
      }]);
    };
    const useStyle$m = useResetIconStyle;
    const getDefaultComponentToken = (component, token2, getDefaultToken) => {
      var _a;
      if (typeof getDefaultToken === "function") {
        return getDefaultToken(merge$1(token2, (_a = token2[component]) !== null && _a !== void 0 ? _a : {}));
      }
      return getDefaultToken !== null && getDefaultToken !== void 0 ? getDefaultToken : {};
    };
    const getComponentToken = (component, token2, defaultToken, options) => {
      const customToken = Object.assign({}, token2[component]);
      if (options === null || options === void 0 ? void 0 : options.deprecatedTokens) {
        const {
          deprecatedTokens
        } = options;
        deprecatedTokens.forEach((_ref) => {
          let [oldTokenKey, newTokenKey] = _ref;
          var _a;
          if ((customToken === null || customToken === void 0 ? void 0 : customToken[oldTokenKey]) || (customToken === null || customToken === void 0 ? void 0 : customToken[newTokenKey])) {
            (_a = customToken[newTokenKey]) !== null && _a !== void 0 ? _a : customToken[newTokenKey] = customToken === null || customToken === void 0 ? void 0 : customToken[oldTokenKey];
          }
        });
      }
      let mergedToken = Object.assign(Object.assign({}, defaultToken), customToken);
      if (options === null || options === void 0 ? void 0 : options.format) {
        mergedToken = options.format(mergedToken);
      }
      Object.keys(mergedToken).forEach((key) => {
        if (mergedToken[key] === token2[key]) {
          delete mergedToken[key];
        }
      });
      return mergedToken;
    };
    const getCompVarPrefix = (component, prefix) => `${[prefix, component.replace(/([A-Z]+)([A-Z][a-z]+)/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2")].filter(Boolean).join("-")}`;
    function genComponentStyleHook(componentName, styleFn, getDefaultToken) {
      let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      const cells = Array.isArray(componentName) ? componentName : [componentName, componentName];
      const [component] = cells;
      const concatComponent = cells.join("-");
      return (prefixCls) => {
        const [theme, realToken, hashId, token2, cssVar] = useToken$1();
        const {
          getPrefixCls,
          iconPrefixCls,
          csp
        } = reactExports.useContext(ConfigContext);
        const rootPrefixCls = getPrefixCls();
        const type = cssVar ? "css" : "js";
        const calc = genCalc$1(type);
        const {
          max: max2,
          min: min2
        } = genMaxMin(type);
        const sharedConfig = {
          theme,
          token: token2,
          hashId,
          nonce: () => csp === null || csp === void 0 ? void 0 : csp.nonce,
          clientOnly: options.clientOnly,
          // antd is always at top of styles
          order: options.order || -999
        };
        useStyleRegister(Object.assign(Object.assign({}, sharedConfig), {
          clientOnly: false,
          path: ["Shared", rootPrefixCls]
        }), () => [{
          // Link
          "&": genLinkStyle(token2)
        }]);
        useStyle$m(iconPrefixCls, csp);
        const wrapSSR = useStyleRegister(Object.assign(Object.assign({}, sharedConfig), {
          path: [concatComponent, prefixCls, iconPrefixCls]
        }), () => {
          if (options.injectStyle === false) {
            return [];
          }
          const {
            token: proxyToken,
            flush
          } = statisticToken(token2);
          const defaultComponentToken = getDefaultComponentToken(component, realToken, getDefaultToken);
          const componentCls = `.${prefixCls}`;
          const componentToken = getComponentToken(component, realToken, defaultComponentToken, {
            deprecatedTokens: options.deprecatedTokens,
            format: options.format
          });
          if (cssVar) {
            Object.keys(defaultComponentToken).forEach((key) => {
              defaultComponentToken[key] = `var(${token2CSSVar(key, getCompVarPrefix(component, cssVar.prefix))})`;
            });
          }
          const mergedToken = merge$1(proxyToken, {
            componentCls,
            prefixCls,
            iconCls: `.${iconPrefixCls}`,
            antCls: `.${rootPrefixCls}`,
            calc,
            max: max2,
            min: min2
          }, cssVar ? defaultComponentToken : componentToken);
          const styleInterpolation = styleFn(mergedToken, {
            hashId,
            prefixCls,
            rootPrefixCls,
            iconPrefixCls
          });
          flush(component, componentToken);
          return [options.resetStyle === false ? null : genCommonStyle(mergedToken, prefixCls), styleInterpolation];
        });
        return [wrapSSR, classNames(hashId, cssVar === null || cssVar === void 0 ? void 0 : cssVar.key)];
      };
    }
    const genSubStyleComponent = (componentName, styleFn, getDefaultToken, options) => {
      const useStyle2 = genComponentStyleHook(componentName, styleFn, getDefaultToken, Object.assign({
        resetStyle: false,
        // Sub Style should default after root one
        order: -998
      }, options));
      const StyledComponent = (_ref2) => {
        let {
          prefixCls
        } = _ref2;
        useStyle2(prefixCls);
        return null;
      };
      return StyledComponent;
    };
    const genCSSVarRegister = (component, getDefaultToken, options) => {
      function prefixToken(key) {
        return `${component}${key.slice(0, 1).toUpperCase()}${key.slice(1)}`;
      }
      const {
        unitless: originUnitless = {},
        injectStyle = true
      } = options !== null && options !== void 0 ? options : {};
      const compUnitless = {
        [prefixToken("zIndexPopup")]: true
      };
      Object.keys(originUnitless).forEach((key) => {
        compUnitless[prefixToken(key)] = originUnitless[key];
      });
      const CSSVarRegister = (_ref3) => {
        let {
          rootCls,
          cssVar
        } = _ref3;
        const [, realToken] = useToken$1();
        useCSSVarRegister({
          path: [component],
          prefix: cssVar.prefix,
          key: cssVar === null || cssVar === void 0 ? void 0 : cssVar.key,
          unitless: Object.assign(Object.assign({}, unitless), compUnitless),
          ignore,
          token: realToken,
          scope: rootCls
        }, () => {
          const defaultToken = getDefaultComponentToken(component, realToken, getDefaultToken);
          const componentToken = getComponentToken(component, realToken, defaultToken, {
            format: options === null || options === void 0 ? void 0 : options.format,
            deprecatedTokens: options === null || options === void 0 ? void 0 : options.deprecatedTokens
          });
          Object.keys(defaultToken).forEach((key) => {
            componentToken[prefixToken(key)] = componentToken[key];
            delete componentToken[key];
          });
          return componentToken;
        });
        return null;
      };
      const useCSSVar = (rootCls) => {
        const [, , , , cssVar] = useToken$1();
        return (node2) => injectStyle && cssVar ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(CSSVarRegister, {
          rootCls,
          cssVar,
          component
        }), node2) : node2;
      };
      return useCSSVar;
    };
    const genStyleHooks = (component, styleFn, getDefaultToken, options) => {
      const useStyle2 = genComponentStyleHook(component, styleFn, getDefaultToken, options);
      const useCSSVar = genCSSVarRegister(component, getDefaultToken, options);
      return function(prefixCls) {
        let rootCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : prefixCls;
        const [, hashId] = useStyle2(prefixCls);
        const wrapCSSVar = useCSSVar(rootCls);
        return [wrapCSSVar, hashId];
      };
    };
    function genPresetColor(token2, genCss) {
      return PresetColors.reduce((prev2, colorKey) => {
        const lightColor = token2[`${colorKey}1`];
        const lightBorderColor = token2[`${colorKey}3`];
        const darkColor = token2[`${colorKey}6`];
        const textColor = token2[`${colorKey}7`];
        return Object.assign(Object.assign({}, prev2), genCss(colorKey, {
          lightColor,
          lightBorderColor,
          darkColor,
          textColor
        }));
      }, {});
    }
    const fullClone$1 = Object.assign({}, React$1);
    const {
      useId: useId$3
    } = fullClone$1;
    const useEmptyId = () => "";
    const useThemeKey = typeof useId$3 === "undefined" ? useEmptyId : useId$3;
    const useThemeKey$1 = useThemeKey;
    function useTheme(theme, parentTheme) {
      devUseWarning();
      const themeConfig = theme || {};
      const parentThemeConfig = themeConfig.inherit === false || !parentTheme ? defaultConfig : parentTheme;
      const themeKey = useThemeKey$1();
      return useMemo(() => {
        var _a2, _b;
        if (!theme) {
          return parentTheme;
        }
        const mergedComponents = Object.assign({}, parentThemeConfig.components);
        Object.keys(theme.components || {}).forEach((componentName) => {
          mergedComponents[componentName] = Object.assign(Object.assign({}, mergedComponents[componentName]), theme.components[componentName]);
        });
        const cssVarKey = `css-var-${themeKey.replace(/:/g, "")}`;
        const mergedCssVar = ((_a2 = themeConfig.cssVar) !== null && _a2 !== void 0 ? _a2 : parentThemeConfig.cssVar) && Object.assign(Object.assign(Object.assign({
          prefix: "ant"
        }, typeof parentThemeConfig.cssVar === "object" ? parentThemeConfig.cssVar : {}), typeof themeConfig.cssVar === "object" ? themeConfig.cssVar : {}), {
          key: typeof themeConfig.cssVar === "object" && ((_b = themeConfig.cssVar) === null || _b === void 0 ? void 0 : _b.key) || cssVarKey
        });
        return Object.assign(Object.assign(Object.assign({}, parentThemeConfig), themeConfig), {
          token: Object.assign(Object.assign({}, parentThemeConfig.token), themeConfig.token),
          components: mergedComponents,
          cssVar: mergedCssVar
        });
      }, [themeConfig, parentThemeConfig], (prev2, next2) => prev2.some((prevTheme, index2) => {
        const nextTheme = next2[index2];
        return !isEqual$1(prevTheme, nextTheme, true);
      }));
    }
    var _excluded$H = ["children"];
    var Context$1 = /* @__PURE__ */ reactExports.createContext({});
    function MotionProvider(_ref) {
      var children = _ref.children, props = _objectWithoutProperties(_ref, _excluded$H);
      return /* @__PURE__ */ reactExports.createElement(Context$1.Provider, {
        value: props
      }, children);
    }
    var DomWrapper = /* @__PURE__ */ function(_React$Component) {
      _inherits(DomWrapper2, _React$Component);
      var _super = _createSuper(DomWrapper2);
      function DomWrapper2() {
        _classCallCheck(this, DomWrapper2);
        return _super.apply(this, arguments);
      }
      _createClass(DomWrapper2, [{
        key: "render",
        value: function render2() {
          return this.props.children;
        }
      }]);
      return DomWrapper2;
    }(reactExports.Component);
    var STATUS_NONE = "none";
    var STATUS_APPEAR = "appear";
    var STATUS_ENTER = "enter";
    var STATUS_LEAVE = "leave";
    var STEP_NONE = "none";
    var STEP_PREPARE = "prepare";
    var STEP_START = "start";
    var STEP_ACTIVE = "active";
    var STEP_ACTIVATED = "end";
    var STEP_PREPARED = "prepared";
    function makePrefixMap(styleProp, eventName) {
      var prefixes = {};
      prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
      prefixes["Webkit".concat(styleProp)] = "webkit".concat(eventName);
      prefixes["Moz".concat(styleProp)] = "moz".concat(eventName);
      prefixes["ms".concat(styleProp)] = "MS".concat(eventName);
      prefixes["O".concat(styleProp)] = "o".concat(eventName.toLowerCase());
      return prefixes;
    }
    function getVendorPrefixes(domSupport, win) {
      var prefixes = {
        animationend: makePrefixMap("Animation", "AnimationEnd"),
        transitionend: makePrefixMap("Transition", "TransitionEnd")
      };
      if (domSupport) {
        if (!("AnimationEvent" in win)) {
          delete prefixes.animationend.animation;
        }
        if (!("TransitionEvent" in win)) {
          delete prefixes.transitionend.transition;
        }
      }
      return prefixes;
    }
    var vendorPrefixes = getVendorPrefixes(canUseDom(), typeof window !== "undefined" ? window : {});
    var style = {};
    if (canUseDom()) {
      var _document$createEleme = document.createElement("div");
      style = _document$createEleme.style;
    }
    var prefixedEventNames = {};
    function getVendorPrefixedEventName(eventName) {
      if (prefixedEventNames[eventName]) {
        return prefixedEventNames[eventName];
      }
      var prefixMap = vendorPrefixes[eventName];
      if (prefixMap) {
        var stylePropList = Object.keys(prefixMap);
        var len = stylePropList.length;
        for (var i = 0; i < len; i += 1) {
          var styleProp = stylePropList[i];
          if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style) {
            prefixedEventNames[eventName] = prefixMap[styleProp];
            return prefixedEventNames[eventName];
          }
        }
      }
      return "";
    }
    var internalAnimationEndName = getVendorPrefixedEventName("animationend");
    var internalTransitionEndName = getVendorPrefixedEventName("transitionend");
    var supportTransition = !!(internalAnimationEndName && internalTransitionEndName);
    var animationEndName = internalAnimationEndName || "animationend";
    var transitionEndName = internalTransitionEndName || "transitionend";
    function getTransitionName$1(transitionName, transitionType) {
      if (!transitionName)
        return null;
      if (_typeof(transitionName) === "object") {
        var type = transitionType.replace(/-\w/g, function(match5) {
          return match5[1].toUpperCase();
        });
        return transitionName[type];
      }
      return "".concat(transitionName, "-").concat(transitionType);
    }
    const useDomMotionEvents = function(callback) {
      var cacheElementRef = reactExports.useRef();
      var callbackRef = reactExports.useRef(callback);
      callbackRef.current = callback;
      var onInternalMotionEnd = reactExports.useCallback(function(event) {
        callbackRef.current(event);
      }, []);
      function removeMotionEvents(element) {
        if (element) {
          element.removeEventListener(transitionEndName, onInternalMotionEnd);
          element.removeEventListener(animationEndName, onInternalMotionEnd);
        }
      }
      function patchMotionEvents(element) {
        if (cacheElementRef.current && cacheElementRef.current !== element) {
          removeMotionEvents(cacheElementRef.current);
        }
        if (element && element !== cacheElementRef.current) {
          element.addEventListener(transitionEndName, onInternalMotionEnd);
          element.addEventListener(animationEndName, onInternalMotionEnd);
          cacheElementRef.current = element;
        }
      }
      reactExports.useEffect(function() {
        return function() {
          removeMotionEvents(cacheElementRef.current);
        };
      }, []);
      return [patchMotionEvents, removeMotionEvents];
    };
    var useIsomorphicLayoutEffect = canUseDom() ? reactExports.useLayoutEffect : reactExports.useEffect;
    const useNextFrame = function() {
      var nextFrameRef = reactExports.useRef(null);
      function cancelNextFrame() {
        wrapperRaf.cancel(nextFrameRef.current);
      }
      function nextFrame(callback) {
        var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
        cancelNextFrame();
        var nextFrameId = wrapperRaf(function() {
          if (delay <= 1) {
            callback({
              isCanceled: function isCanceled() {
                return nextFrameId !== nextFrameRef.current;
              }
            });
          } else {
            nextFrame(callback, delay - 1);
          }
        });
        nextFrameRef.current = nextFrameId;
      }
      reactExports.useEffect(function() {
        return function() {
          cancelNextFrame();
        };
      }, []);
      return [nextFrame, cancelNextFrame];
    };
    var FULL_STEP_QUEUE = [STEP_PREPARE, STEP_START, STEP_ACTIVE, STEP_ACTIVATED];
    var SIMPLE_STEP_QUEUE = [STEP_PREPARE, STEP_PREPARED];
    var SkipStep = false;
    var DoStep = true;
    function isActive(step) {
      return step === STEP_ACTIVE || step === STEP_ACTIVATED;
    }
    const useStepQueue = function(status, prepareOnly, callback) {
      var _useState = useSafeState(STEP_NONE), _useState2 = _slicedToArray(_useState, 2), step = _useState2[0], setStep = _useState2[1];
      var _useNextFrame = useNextFrame(), _useNextFrame2 = _slicedToArray(_useNextFrame, 2), nextFrame = _useNextFrame2[0], cancelNextFrame = _useNextFrame2[1];
      function startQueue() {
        setStep(STEP_PREPARE, true);
      }
      var STEP_QUEUE = prepareOnly ? SIMPLE_STEP_QUEUE : FULL_STEP_QUEUE;
      useIsomorphicLayoutEffect(function() {
        if (step !== STEP_NONE && step !== STEP_ACTIVATED) {
          var index2 = STEP_QUEUE.indexOf(step);
          var nextStep = STEP_QUEUE[index2 + 1];
          var result = callback(step);
          if (result === SkipStep) {
            setStep(nextStep, true);
          } else if (nextStep) {
            nextFrame(function(info) {
              function doNext() {
                if (info.isCanceled())
                  return;
                setStep(nextStep, true);
              }
              if (result === true) {
                doNext();
              } else {
                Promise.resolve(result).then(doNext);
              }
            });
          }
        }
      }, [status, step]);
      reactExports.useEffect(function() {
        return function() {
          cancelNextFrame();
        };
      }, []);
      return [startQueue, step];
    };
    function useStatus(supportMotion, visible, getElement, _ref) {
      var _ref$motionEnter = _ref.motionEnter, motionEnter = _ref$motionEnter === void 0 ? true : _ref$motionEnter, _ref$motionAppear = _ref.motionAppear, motionAppear = _ref$motionAppear === void 0 ? true : _ref$motionAppear, _ref$motionLeave = _ref.motionLeave, motionLeave = _ref$motionLeave === void 0 ? true : _ref$motionLeave, motionDeadline = _ref.motionDeadline, motionLeaveImmediately = _ref.motionLeaveImmediately, onAppearPrepare = _ref.onAppearPrepare, onEnterPrepare = _ref.onEnterPrepare, onLeavePrepare = _ref.onLeavePrepare, onAppearStart = _ref.onAppearStart, onEnterStart = _ref.onEnterStart, onLeaveStart = _ref.onLeaveStart, onAppearActive = _ref.onAppearActive, onEnterActive = _ref.onEnterActive, onLeaveActive = _ref.onLeaveActive, onAppearEnd = _ref.onAppearEnd, onEnterEnd = _ref.onEnterEnd, onLeaveEnd = _ref.onLeaveEnd, onVisibleChanged = _ref.onVisibleChanged;
      var _useState = useSafeState(), _useState2 = _slicedToArray(_useState, 2), asyncVisible = _useState2[0], setAsyncVisible = _useState2[1];
      var _useState3 = useSafeState(STATUS_NONE), _useState4 = _slicedToArray(_useState3, 2), status = _useState4[0], setStatus = _useState4[1];
      var _useState5 = useSafeState(null), _useState6 = _slicedToArray(_useState5, 2), style2 = _useState6[0], setStyle = _useState6[1];
      var mountedRef = reactExports.useRef(false);
      var deadlineRef = reactExports.useRef(null);
      function getDomElement() {
        return getElement();
      }
      var activeRef = reactExports.useRef(false);
      function updateMotionEndStatus() {
        setStatus(STATUS_NONE, true);
        setStyle(null, true);
      }
      function onInternalMotionEnd(event) {
        var element = getDomElement();
        if (event && !event.deadline && event.target !== element) {
          return;
        }
        var currentActive = activeRef.current;
        var canEnd;
        if (status === STATUS_APPEAR && currentActive) {
          canEnd = onAppearEnd === null || onAppearEnd === void 0 ? void 0 : onAppearEnd(element, event);
        } else if (status === STATUS_ENTER && currentActive) {
          canEnd = onEnterEnd === null || onEnterEnd === void 0 ? void 0 : onEnterEnd(element, event);
        } else if (status === STATUS_LEAVE && currentActive) {
          canEnd = onLeaveEnd === null || onLeaveEnd === void 0 ? void 0 : onLeaveEnd(element, event);
        }
        if (status !== STATUS_NONE && currentActive && canEnd !== false) {
          updateMotionEndStatus();
        }
      }
      var _useDomMotionEvents = useDomMotionEvents(onInternalMotionEnd), _useDomMotionEvents2 = _slicedToArray(_useDomMotionEvents, 1), patchMotionEvents = _useDomMotionEvents2[0];
      var getEventHandlers = function getEventHandlers2(targetStatus) {
        var _ref2, _ref3, _ref4;
        switch (targetStatus) {
          case STATUS_APPEAR:
            return _ref2 = {}, _defineProperty(_ref2, STEP_PREPARE, onAppearPrepare), _defineProperty(_ref2, STEP_START, onAppearStart), _defineProperty(_ref2, STEP_ACTIVE, onAppearActive), _ref2;
          case STATUS_ENTER:
            return _ref3 = {}, _defineProperty(_ref3, STEP_PREPARE, onEnterPrepare), _defineProperty(_ref3, STEP_START, onEnterStart), _defineProperty(_ref3, STEP_ACTIVE, onEnterActive), _ref3;
          case STATUS_LEAVE:
            return _ref4 = {}, _defineProperty(_ref4, STEP_PREPARE, onLeavePrepare), _defineProperty(_ref4, STEP_START, onLeaveStart), _defineProperty(_ref4, STEP_ACTIVE, onLeaveActive), _ref4;
          default:
            return {};
        }
      };
      var eventHandlers = reactExports.useMemo(function() {
        return getEventHandlers(status);
      }, [status]);
      var _useStepQueue = useStepQueue(status, !supportMotion, function(newStep) {
        if (newStep === STEP_PREPARE) {
          var onPrepare = eventHandlers[STEP_PREPARE];
          if (!onPrepare) {
            return SkipStep;
          }
          return onPrepare(getDomElement());
        }
        if (step in eventHandlers) {
          var _eventHandlers$step;
          setStyle(((_eventHandlers$step = eventHandlers[step]) === null || _eventHandlers$step === void 0 ? void 0 : _eventHandlers$step.call(eventHandlers, getDomElement(), null)) || null);
        }
        if (step === STEP_ACTIVE) {
          patchMotionEvents(getDomElement());
          if (motionDeadline > 0) {
            clearTimeout(deadlineRef.current);
            deadlineRef.current = setTimeout(function() {
              onInternalMotionEnd({
                deadline: true
              });
            }, motionDeadline);
          }
        }
        if (step === STEP_PREPARED) {
          updateMotionEndStatus();
        }
        return DoStep;
      }), _useStepQueue2 = _slicedToArray(_useStepQueue, 2), startStep = _useStepQueue2[0], step = _useStepQueue2[1];
      var active = isActive(step);
      activeRef.current = active;
      useIsomorphicLayoutEffect(function() {
        setAsyncVisible(visible);
        var isMounted = mountedRef.current;
        mountedRef.current = true;
        var nextStatus;
        if (!isMounted && visible && motionAppear) {
          nextStatus = STATUS_APPEAR;
        }
        if (isMounted && visible && motionEnter) {
          nextStatus = STATUS_ENTER;
        }
        if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {
          nextStatus = STATUS_LEAVE;
        }
        var nextEventHandlers = getEventHandlers(nextStatus);
        if (nextStatus && (supportMotion || nextEventHandlers[STEP_PREPARE])) {
          setStatus(nextStatus);
          startStep();
        } else {
          setStatus(STATUS_NONE);
        }
      }, [visible]);
      reactExports.useEffect(function() {
        if (
          // Cancel appear
          status === STATUS_APPEAR && !motionAppear || // Cancel enter
          status === STATUS_ENTER && !motionEnter || // Cancel leave
          status === STATUS_LEAVE && !motionLeave
        ) {
          setStatus(STATUS_NONE);
        }
      }, [motionAppear, motionEnter, motionLeave]);
      reactExports.useEffect(function() {
        return function() {
          mountedRef.current = false;
          clearTimeout(deadlineRef.current);
        };
      }, []);
      var firstMountChangeRef = reactExports.useRef(false);
      reactExports.useEffect(function() {
        if (asyncVisible) {
          firstMountChangeRef.current = true;
        }
        if (asyncVisible !== void 0 && status === STATUS_NONE) {
          if (firstMountChangeRef.current || asyncVisible) {
            onVisibleChanged === null || onVisibleChanged === void 0 ? void 0 : onVisibleChanged(asyncVisible);
          }
          firstMountChangeRef.current = true;
        }
      }, [asyncVisible, status]);
      var mergedStyle = style2;
      if (eventHandlers[STEP_PREPARE] && step === STEP_START) {
        mergedStyle = _objectSpread2({
          transition: "none"
        }, mergedStyle);
      }
      return [status, step, mergedStyle, asyncVisible !== null && asyncVisible !== void 0 ? asyncVisible : visible];
    }
    function genCSSMotion(config) {
      var transitionSupport = config;
      if (_typeof(config) === "object") {
        transitionSupport = config.transitionSupport;
      }
      function isSupportTransition(props, contextMotion) {
        return !!(props.motionName && transitionSupport && contextMotion !== false);
      }
      var CSSMotion2 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
        var _props$visible = props.visible, visible = _props$visible === void 0 ? true : _props$visible, _props$removeOnLeave = props.removeOnLeave, removeOnLeave = _props$removeOnLeave === void 0 ? true : _props$removeOnLeave, forceRender = props.forceRender, children = props.children, motionName = props.motionName, leavedClassName = props.leavedClassName, eventProps = props.eventProps;
        var _React$useContext = reactExports.useContext(Context$1), contextMotion = _React$useContext.motion;
        var supportMotion = isSupportTransition(props, contextMotion);
        var nodeRef = reactExports.useRef();
        var wrapperNodeRef = reactExports.useRef();
        function getDomElement() {
          try {
            return nodeRef.current instanceof HTMLElement ? nodeRef.current : findDOMNode(wrapperNodeRef.current);
          } catch (e2) {
            return null;
          }
        }
        var _useStatus = useStatus(supportMotion, visible, getDomElement, props), _useStatus2 = _slicedToArray(_useStatus, 4), status = _useStatus2[0], statusStep = _useStatus2[1], statusStyle = _useStatus2[2], mergedVisible = _useStatus2[3];
        var renderedRef = reactExports.useRef(mergedVisible);
        if (mergedVisible) {
          renderedRef.current = true;
        }
        var setNodeRef = reactExports.useCallback(function(node2) {
          nodeRef.current = node2;
          fillRef(ref, node2);
        }, [ref]);
        var motionChildren;
        var mergedProps = _objectSpread2(_objectSpread2({}, eventProps), {}, {
          visible
        });
        if (!children) {
          motionChildren = null;
        } else if (status === STATUS_NONE) {
          if (mergedVisible) {
            motionChildren = children(_objectSpread2({}, mergedProps), setNodeRef);
          } else if (!removeOnLeave && renderedRef.current && leavedClassName) {
            motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
              className: leavedClassName
            }), setNodeRef);
          } else if (forceRender || !removeOnLeave && !leavedClassName) {
            motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
              style: {
                display: "none"
              }
            }), setNodeRef);
          } else {
            motionChildren = null;
          }
        } else {
          var _classNames;
          var statusSuffix;
          if (statusStep === STEP_PREPARE) {
            statusSuffix = "prepare";
          } else if (isActive(statusStep)) {
            statusSuffix = "active";
          } else if (statusStep === STEP_START) {
            statusSuffix = "start";
          }
          var motionCls = getTransitionName$1(motionName, "".concat(status, "-").concat(statusSuffix));
          motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
            className: classNames(getTransitionName$1(motionName, status), (_classNames = {}, _defineProperty(_classNames, motionCls, motionCls && statusSuffix), _defineProperty(_classNames, motionName, typeof motionName === "string"), _classNames)),
            style: statusStyle
          }), setNodeRef);
        }
        if (/* @__PURE__ */ reactExports.isValidElement(motionChildren) && supportRef(motionChildren)) {
          var _ref = motionChildren, originNodeRef = _ref.ref;
          if (!originNodeRef) {
            motionChildren = /* @__PURE__ */ reactExports.cloneElement(motionChildren, {
              ref: setNodeRef
            });
          }
        }
        return /* @__PURE__ */ reactExports.createElement(DomWrapper, {
          ref: wrapperNodeRef
        }, motionChildren);
      });
      CSSMotion2.displayName = "CSSMotion";
      return CSSMotion2;
    }
    const CSSMotion = genCSSMotion(supportTransition);
    var STATUS_ADD = "add";
    var STATUS_KEEP = "keep";
    var STATUS_REMOVE = "remove";
    var STATUS_REMOVED = "removed";
    function wrapKeyToObject(key) {
      var keyObj;
      if (key && _typeof(key) === "object" && "key" in key) {
        keyObj = key;
      } else {
        keyObj = {
          key
        };
      }
      return _objectSpread2(_objectSpread2({}, keyObj), {}, {
        key: String(keyObj.key)
      });
    }
    function parseKeys() {
      var keys2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      return keys2.map(wrapKeyToObject);
    }
    function diffKeys() {
      var prevKeys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var currentKeys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var list = [];
      var currentIndex = 0;
      var currentLen = currentKeys.length;
      var prevKeyObjects = parseKeys(prevKeys);
      var currentKeyObjects = parseKeys(currentKeys);
      prevKeyObjects.forEach(function(keyObj) {
        var hit = false;
        for (var i = currentIndex; i < currentLen; i += 1) {
          var currentKeyObj = currentKeyObjects[i];
          if (currentKeyObj.key === keyObj.key) {
            if (currentIndex < i) {
              list = list.concat(currentKeyObjects.slice(currentIndex, i).map(function(obj) {
                return _objectSpread2(_objectSpread2({}, obj), {}, {
                  status: STATUS_ADD
                });
              }));
              currentIndex = i;
            }
            list.push(_objectSpread2(_objectSpread2({}, currentKeyObj), {}, {
              status: STATUS_KEEP
            }));
            currentIndex += 1;
            hit = true;
            break;
          }
        }
        if (!hit) {
          list.push(_objectSpread2(_objectSpread2({}, keyObj), {}, {
            status: STATUS_REMOVE
          }));
        }
      });
      if (currentIndex < currentLen) {
        list = list.concat(currentKeyObjects.slice(currentIndex).map(function(obj) {
          return _objectSpread2(_objectSpread2({}, obj), {}, {
            status: STATUS_ADD
          });
        }));
      }
      var keys2 = {};
      list.forEach(function(_ref) {
        var key = _ref.key;
        keys2[key] = (keys2[key] || 0) + 1;
      });
      var duplicatedKeys = Object.keys(keys2).filter(function(key) {
        return keys2[key] > 1;
      });
      duplicatedKeys.forEach(function(matchKey) {
        list = list.filter(function(_ref2) {
          var key = _ref2.key, status = _ref2.status;
          return key !== matchKey || status !== STATUS_REMOVE;
        });
        list.forEach(function(node2) {
          if (node2.key === matchKey) {
            node2.status = STATUS_KEEP;
          }
        });
      });
      return list;
    }
    var _excluded$G = ["component", "children", "onVisibleChanged", "onAllRemoved"], _excluded2$6 = ["status"];
    var MOTION_PROP_NAMES = ["eventProps", "visible", "children", "motionName", "motionAppear", "motionEnter", "motionLeave", "motionLeaveImmediately", "motionDeadline", "removeOnLeave", "leavedClassName", "onAppearPrepare", "onAppearStart", "onAppearActive", "onAppearEnd", "onEnterStart", "onEnterActive", "onEnterEnd", "onLeaveStart", "onLeaveActive", "onLeaveEnd"];
    function genCSSMotionList(transitionSupport) {
      var CSSMotion$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : CSSMotion;
      var CSSMotionList2 = /* @__PURE__ */ function(_React$Component) {
        _inherits(CSSMotionList3, _React$Component);
        var _super = _createSuper(CSSMotionList3);
        function CSSMotionList3() {
          var _this;
          _classCallCheck(this, CSSMotionList3);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "state", {
            keyEntities: []
          });
          _defineProperty(_assertThisInitialized(_this), "removeKey", function(removeKey) {
            var keyEntities = _this.state.keyEntities;
            var nextKeyEntities = keyEntities.map(function(entity) {
              if (entity.key !== removeKey)
                return entity;
              return _objectSpread2(_objectSpread2({}, entity), {}, {
                status: STATUS_REMOVED
              });
            });
            _this.setState({
              keyEntities: nextKeyEntities
            });
            return nextKeyEntities.filter(function(_ref) {
              var status = _ref.status;
              return status !== STATUS_REMOVED;
            }).length;
          });
          return _this;
        }
        _createClass(CSSMotionList3, [{
          key: "render",
          value: function render2() {
            var _this2 = this;
            var keyEntities = this.state.keyEntities;
            var _this$props = this.props, component = _this$props.component, children = _this$props.children, _onVisibleChanged = _this$props.onVisibleChanged, onAllRemoved = _this$props.onAllRemoved, restProps = _objectWithoutProperties(_this$props, _excluded$G);
            var Component = component || reactExports.Fragment;
            var motionProps = {};
            MOTION_PROP_NAMES.forEach(function(prop) {
              motionProps[prop] = restProps[prop];
              delete restProps[prop];
            });
            delete restProps.keys;
            return /* @__PURE__ */ reactExports.createElement(Component, restProps, keyEntities.map(function(_ref2, index2) {
              var status = _ref2.status, eventProps = _objectWithoutProperties(_ref2, _excluded2$6);
              var visible = status === STATUS_ADD || status === STATUS_KEEP;
              return /* @__PURE__ */ reactExports.createElement(CSSMotion$1, _extends$1({}, motionProps, {
                key: eventProps.key,
                visible,
                eventProps,
                onVisibleChanged: function onVisibleChanged(changedVisible) {
                  _onVisibleChanged === null || _onVisibleChanged === void 0 ? void 0 : _onVisibleChanged(changedVisible, {
                    key: eventProps.key
                  });
                  if (!changedVisible) {
                    var restKeysCount = _this2.removeKey(eventProps.key);
                    if (restKeysCount === 0 && onAllRemoved) {
                      onAllRemoved();
                    }
                  }
                }
              }), function(props, ref) {
                return children(_objectSpread2(_objectSpread2({}, props), {}, {
                  index: index2
                }), ref);
              });
            }));
          }
        }], [{
          key: "getDerivedStateFromProps",
          value: function getDerivedStateFromProps(_ref3, _ref4) {
            var keys2 = _ref3.keys;
            var keyEntities = _ref4.keyEntities;
            var parsedKeyObjects = parseKeys(keys2);
            var mixedKeyEntities = diffKeys(keyEntities, parsedKeyObjects);
            return {
              keyEntities: mixedKeyEntities.filter(function(entity) {
                var prevEntity = keyEntities.find(function(_ref5) {
                  var key = _ref5.key;
                  return entity.key === key;
                });
                if (prevEntity && prevEntity.status === STATUS_REMOVED && entity.status === STATUS_REMOVE) {
                  return false;
                }
                return true;
              })
            };
          }
        }]);
        return CSSMotionList3;
      }(reactExports.Component);
      _defineProperty(CSSMotionList2, "defaultProps", {
        component: "div"
      });
      return CSSMotionList2;
    }
    const CSSMotionList = genCSSMotionList(supportTransition);
    function MotionWrapper(props) {
      const {
        children
      } = props;
      const [, token2] = useToken$1();
      const {
        motion
      } = token2;
      const needWrapMotionProviderRef = reactExports.useRef(false);
      needWrapMotionProviderRef.current = needWrapMotionProviderRef.current || motion === false;
      if (needWrapMotionProviderRef.current) {
        return /* @__PURE__ */ reactExports.createElement(MotionProvider, {
          motion
        }, children);
      }
      return children;
    }
    const PropWarning = () => null;
    var __rest$F = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const PASSED_PROPS = ["getTargetContainer", "getPopupContainer", "renderEmpty", "pageHeader", "input", "pagination", "form", "select", "button"];
    const defaultPrefixCls = "ant";
    let globalPrefixCls;
    function getGlobalPrefixCls() {
      return globalPrefixCls || defaultPrefixCls;
    }
    function isLegacyTheme(theme) {
      return Object.keys(theme).some((key) => key.endsWith("Color"));
    }
    const setGlobalConfig = (_ref) => {
      let {
        prefixCls,
        iconPrefixCls,
        theme
      } = _ref;
      if (prefixCls !== void 0) {
        globalPrefixCls = prefixCls;
      }
      if (theme) {
        if (isLegacyTheme(theme)) {
          registerTheme(getGlobalPrefixCls(), theme);
        }
      }
    };
    const ProviderChildren = (props) => {
      const {
        children,
        csp: customCsp,
        autoInsertSpaceInButton,
        alert: alert2,
        anchor,
        form,
        locale: locale2,
        componentSize,
        direction,
        space,
        virtual,
        dropdownMatchSelectWidth,
        popupMatchSelectWidth,
        popupOverflow,
        legacyLocale,
        parentContext,
        iconPrefixCls: customIconPrefixCls,
        theme,
        componentDisabled,
        segmented,
        statistic: statistic2,
        spin,
        calendar: calendar2,
        carousel,
        cascader,
        collapse,
        typography,
        checkbox,
        descriptions,
        divider,
        drawer,
        skeleton,
        steps,
        image,
        layout,
        list,
        mentions,
        modal,
        progress,
        result,
        slider,
        breadcrumb,
        menu,
        pagination,
        input,
        empty: empty2,
        badge,
        radio,
        rate,
        switch: SWITCH,
        transfer,
        avatar,
        message,
        tag,
        table,
        card,
        tabs,
        timeline,
        timePicker,
        upload: upload2,
        notification,
        tree,
        colorPicker,
        datePicker,
        rangePicker,
        flex,
        wave,
        dropdown,
        warning: warningConfig
      } = props;
      const getPrefixCls = reactExports.useCallback((suffixCls, customizePrefixCls) => {
        const {
          prefixCls
        } = props;
        if (customizePrefixCls) {
          return customizePrefixCls;
        }
        const mergedPrefixCls = prefixCls || parentContext.getPrefixCls("");
        return suffixCls ? `${mergedPrefixCls}-${suffixCls}` : mergedPrefixCls;
      }, [parentContext.getPrefixCls, props.prefixCls]);
      const iconPrefixCls = customIconPrefixCls || parentContext.iconPrefixCls || defaultIconPrefixCls;
      const csp = customCsp || parentContext.csp;
      useStyle$m(iconPrefixCls, csp);
      const mergedTheme = useTheme(theme, parentContext.theme);
      const baseConfig2 = {
        csp,
        autoInsertSpaceInButton,
        alert: alert2,
        anchor,
        locale: locale2 || legacyLocale,
        direction,
        space,
        virtual,
        popupMatchSelectWidth: popupMatchSelectWidth !== null && popupMatchSelectWidth !== void 0 ? popupMatchSelectWidth : dropdownMatchSelectWidth,
        popupOverflow,
        getPrefixCls,
        iconPrefixCls,
        theme: mergedTheme,
        segmented,
        statistic: statistic2,
        spin,
        calendar: calendar2,
        carousel,
        cascader,
        collapse,
        typography,
        checkbox,
        descriptions,
        divider,
        drawer,
        skeleton,
        steps,
        image,
        input,
        layout,
        list,
        mentions,
        modal,
        progress,
        result,
        slider,
        breadcrumb,
        menu,
        pagination,
        empty: empty2,
        badge,
        radio,
        rate,
        switch: SWITCH,
        transfer,
        avatar,
        message,
        tag,
        table,
        card,
        tabs,
        timeline,
        timePicker,
        upload: upload2,
        notification,
        tree,
        colorPicker,
        datePicker,
        rangePicker,
        flex,
        wave,
        dropdown,
        warning: warningConfig
      };
      const config = Object.assign({}, parentContext);
      Object.keys(baseConfig2).forEach((key) => {
        if (baseConfig2[key] !== void 0) {
          config[key] = baseConfig2[key];
        }
      });
      PASSED_PROPS.forEach((propName) => {
        const propValue = props[propName];
        if (propValue) {
          config[propName] = propValue;
        }
      });
      const memoedConfig = useMemo(() => config, config, (prevConfig, currentConfig) => {
        const prevKeys = Object.keys(prevConfig);
        const currentKeys = Object.keys(currentConfig);
        return prevKeys.length !== currentKeys.length || prevKeys.some((key) => prevConfig[key] !== currentConfig[key]);
      });
      const memoIconContextValue = reactExports.useMemo(() => ({
        prefixCls: iconPrefixCls,
        csp
      }), [iconPrefixCls, csp]);
      let childNode = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(PropWarning, {
        dropdownMatchSelectWidth
      }), children);
      const validateMessages = reactExports.useMemo(() => {
        var _a, _b, _c, _d;
        return merge$2(((_a = defaultLocale.Form) === null || _a === void 0 ? void 0 : _a.defaultValidateMessages) || {}, ((_c = (_b = memoedConfig.locale) === null || _b === void 0 ? void 0 : _b.Form) === null || _c === void 0 ? void 0 : _c.defaultValidateMessages) || {}, ((_d = memoedConfig.form) === null || _d === void 0 ? void 0 : _d.validateMessages) || {}, (form === null || form === void 0 ? void 0 : form.validateMessages) || {});
      }, [memoedConfig, form === null || form === void 0 ? void 0 : form.validateMessages]);
      if (Object.keys(validateMessages).length > 0) {
        childNode = /* @__PURE__ */ reactExports.createElement(ValidateMessagesContext.Provider, {
          value: validateMessages
        }, childNode);
      }
      if (locale2) {
        childNode = /* @__PURE__ */ reactExports.createElement(LocaleProvider$1, {
          locale: locale2,
          _ANT_MARK__: ANT_MARK
        }, childNode);
      }
      if (iconPrefixCls || csp) {
        childNode = /* @__PURE__ */ reactExports.createElement(Context$2.Provider, {
          value: memoIconContextValue
        }, childNode);
      }
      if (componentSize) {
        childNode = /* @__PURE__ */ reactExports.createElement(SizeContextProvider, {
          size: componentSize
        }, childNode);
      }
      childNode = /* @__PURE__ */ reactExports.createElement(MotionWrapper, null, childNode);
      const memoTheme = reactExports.useMemo(() => {
        const _a = mergedTheme || {}, {
          algorithm,
          token: token2,
          components,
          cssVar
        } = _a, rest = __rest$F(_a, ["algorithm", "token", "components", "cssVar"]);
        const themeObj = algorithm && (!Array.isArray(algorithm) || algorithm.length > 0) ? createTheme(algorithm) : defaultTheme;
        const parsedComponents = {};
        Object.entries(components || {}).forEach((_ref2) => {
          let [componentName, componentToken] = _ref2;
          const parsedToken = Object.assign({}, componentToken);
          if ("algorithm" in parsedToken) {
            if (parsedToken.algorithm === true) {
              parsedToken.theme = themeObj;
            } else if (Array.isArray(parsedToken.algorithm) || typeof parsedToken.algorithm === "function") {
              parsedToken.theme = createTheme(parsedToken.algorithm);
            }
            delete parsedToken.algorithm;
          }
          parsedComponents[componentName] = parsedToken;
        });
        const mergedToken = Object.assign(Object.assign({}, seedToken$1), token2);
        return Object.assign(Object.assign({}, rest), {
          theme: themeObj,
          token: mergedToken,
          components: parsedComponents,
          override: Object.assign({
            override: mergedToken
          }, parsedComponents),
          cssVar
        });
      }, [mergedTheme]);
      if (theme) {
        childNode = /* @__PURE__ */ reactExports.createElement(DesignTokenContext.Provider, {
          value: memoTheme
        }, childNode);
      }
      if (memoedConfig.warning) {
        childNode = /* @__PURE__ */ reactExports.createElement(WarningContext.Provider, {
          value: memoedConfig.warning
        }, childNode);
      }
      if (componentDisabled !== void 0) {
        childNode = /* @__PURE__ */ reactExports.createElement(DisabledContextProvider, {
          disabled: componentDisabled
        }, childNode);
      }
      return /* @__PURE__ */ reactExports.createElement(ConfigContext.Provider, {
        value: memoedConfig
      }, childNode);
    };
    const ConfigProvider = (props) => {
      const context = reactExports.useContext(ConfigContext);
      const antLocale = reactExports.useContext(LocaleContext$1);
      return /* @__PURE__ */ reactExports.createElement(ProviderChildren, Object.assign({
        parentContext: context,
        legacyLocale: antLocale
      }, props));
    };
    ConfigProvider.ConfigContext = ConfigContext;
    ConfigProvider.SizeContext = SizeContext$1;
    ConfigProvider.config = setGlobalConfig;
    ConfigProvider.useConfig = useConfig;
    Object.defineProperty(ConfigProvider, "SizeContext", {
      get: () => {
        return SizeContext$1;
      }
    });
    const ConfigProvider$1 = ConfigProvider;
    var CheckCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" } }] }, "name": "check-circle", "theme": "filled" };
    const CheckCircleFilledSvg = CheckCircleFilled$2;
    function getRoot(ele) {
      var _ele$getRootNode;
      return ele === null || ele === void 0 || (_ele$getRootNode = ele.getRootNode) === null || _ele$getRootNode === void 0 ? void 0 : _ele$getRootNode.call(ele);
    }
    function inShadow(ele) {
      return getRoot(ele) instanceof ShadowRoot;
    }
    function getShadowRoot(ele) {
      return inShadow(ele) ? getRoot(ele) : null;
    }
    function camelCase(input) {
      return input.replace(/-(.)/g, function(match5, g2) {
        return g2.toUpperCase();
      });
    }
    function warning$1(valid, message) {
      warningOnce(valid, "[@ant-design/icons] ".concat(message));
    }
    function isIconDefinition(target) {
      return _typeof(target) === "object" && typeof target.name === "string" && typeof target.theme === "string" && (_typeof(target.icon) === "object" || typeof target.icon === "function");
    }
    function normalizeAttrs() {
      var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return Object.keys(attrs).reduce(function(acc, key) {
        var val = attrs[key];
        switch (key) {
          case "class":
            acc.className = val;
            delete acc.class;
            break;
          default:
            delete acc[key];
            acc[camelCase(key)] = val;
        }
        return acc;
      }, {});
    }
    function generate(node2, key, rootProps) {
      if (!rootProps) {
        return /* @__PURE__ */ React.createElement(node2.tag, _objectSpread2({
          key
        }, normalizeAttrs(node2.attrs)), (node2.children || []).map(function(child, index2) {
          return generate(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
        }));
      }
      return /* @__PURE__ */ React.createElement(node2.tag, _objectSpread2(_objectSpread2({
        key
      }, normalizeAttrs(node2.attrs)), rootProps), (node2.children || []).map(function(child, index2) {
        return generate(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
      }));
    }
    function getSecondaryColor(primaryColor) {
      return generate$1(primaryColor)[0];
    }
    function normalizeTwoToneColors(twoToneColor) {
      if (!twoToneColor) {
        return [];
      }
      return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
    }
    var iconStyles = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
    var useInsertStyles = function useInsertStyles2(eleRef) {
      var _useContext = reactExports.useContext(Context$2), csp = _useContext.csp, prefixCls = _useContext.prefixCls;
      var mergedStyleStr = iconStyles;
      if (prefixCls) {
        mergedStyleStr = mergedStyleStr.replace(/anticon/g, prefixCls);
      }
      reactExports.useEffect(function() {
        var ele = eleRef.current;
        var shadowRoot = getShadowRoot(ele);
        updateCSS(mergedStyleStr, "@ant-design-icons", {
          prepend: true,
          csp,
          attachTo: shadowRoot
        });
      }, []);
    };
    var _excluded$F = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"];
    var twoToneColorPalette = {
      primaryColor: "#333",
      secondaryColor: "#E6E6E6",
      calculated: false
    };
    function setTwoToneColors(_ref) {
      var primaryColor = _ref.primaryColor, secondaryColor = _ref.secondaryColor;
      twoToneColorPalette.primaryColor = primaryColor;
      twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
      twoToneColorPalette.calculated = !!secondaryColor;
    }
    function getTwoToneColors() {
      return _objectSpread2({}, twoToneColorPalette);
    }
    var IconBase = function IconBase2(props) {
      var icon = props.icon, className = props.className, onClick = props.onClick, style2 = props.style, primaryColor = props.primaryColor, secondaryColor = props.secondaryColor, restProps = _objectWithoutProperties(props, _excluded$F);
      var svgRef = reactExports.useRef();
      var colors = twoToneColorPalette;
      if (primaryColor) {
        colors = {
          primaryColor,
          secondaryColor: secondaryColor || getSecondaryColor(primaryColor)
        };
      }
      useInsertStyles(svgRef);
      warning$1(isIconDefinition(icon), "icon should be icon definiton, but got ".concat(icon));
      if (!isIconDefinition(icon)) {
        return null;
      }
      var target = icon;
      if (target && typeof target.icon === "function") {
        target = _objectSpread2(_objectSpread2({}, target), {}, {
          icon: target.icon(colors.primaryColor, colors.secondaryColor)
        });
      }
      return generate(target.icon, "svg-".concat(target.name), _objectSpread2(_objectSpread2({
        className,
        onClick,
        style: style2,
        "data-icon": target.name,
        width: "1em",
        height: "1em",
        fill: "currentColor",
        "aria-hidden": "true"
      }, restProps), {}, {
        ref: svgRef
      }));
    };
    IconBase.displayName = "IconReact";
    IconBase.getTwoToneColors = getTwoToneColors;
    IconBase.setTwoToneColors = setTwoToneColors;
    const ReactIcon = IconBase;
    function setTwoToneColor(twoToneColor) {
      var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
      return ReactIcon.setTwoToneColors({
        primaryColor,
        secondaryColor
      });
    }
    function getTwoToneColor() {
      var colors = ReactIcon.getTwoToneColors();
      if (!colors.calculated) {
        return colors.primaryColor;
      }
      return [colors.primaryColor, colors.secondaryColor];
    }
    var _excluded$E = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
    setTwoToneColor(blue.primary);
    var Icon$1 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var _classNames;
      var className = props.className, icon = props.icon, spin = props.spin, rotate = props.rotate, tabIndex = props.tabIndex, onClick = props.onClick, twoToneColor = props.twoToneColor, restProps = _objectWithoutProperties(props, _excluded$E);
      var _React$useContext = reactExports.useContext(Context$2), _React$useContext$pre = _React$useContext.prefixCls, prefixCls = _React$useContext$pre === void 0 ? "anticon" : _React$useContext$pre, rootClassName = _React$useContext.rootClassName;
      var classString = classNames(rootClassName, prefixCls, (_classNames = {}, _defineProperty(_classNames, "".concat(prefixCls, "-").concat(icon.name), !!icon.name), _defineProperty(_classNames, "".concat(prefixCls, "-spin"), !!spin || icon.name === "loading"), _classNames), className);
      var iconTabIndex = tabIndex;
      if (iconTabIndex === void 0 && onClick) {
        iconTabIndex = -1;
      }
      var svgStyle = rotate ? {
        msTransform: "rotate(".concat(rotate, "deg)"),
        transform: "rotate(".concat(rotate, "deg)")
      } : void 0;
      var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
      return /* @__PURE__ */ reactExports.createElement("span", _extends$1({
        role: "img",
        "aria-label": icon.name
      }, restProps, {
        ref,
        tabIndex: iconTabIndex,
        onClick,
        className: classString
      }), /* @__PURE__ */ reactExports.createElement(ReactIcon, {
        icon,
        primaryColor,
        secondaryColor,
        style: svgStyle
      }));
    });
    Icon$1.displayName = "AntdIcon";
    Icon$1.getTwoToneColor = getTwoToneColor;
    Icon$1.setTwoToneColor = setTwoToneColor;
    const AntdIcon = Icon$1;
    var CheckCircleFilled = function CheckCircleFilled2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: CheckCircleFilledSvg
      }));
    };
    const CheckCircleFilled$1 = /* @__PURE__ */ reactExports.forwardRef(CheckCircleFilled);
    var CloseCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "fill-rule": "evenodd", "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z" } }] }, "name": "close-circle", "theme": "filled" };
    const CloseCircleFilledSvg = CloseCircleFilled$2;
    var CloseCircleFilled = function CloseCircleFilled2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: CloseCircleFilledSvg
      }));
    };
    const CloseCircleFilled$1 = /* @__PURE__ */ reactExports.forwardRef(CloseCircleFilled);
    var CloseOutlined$2 = { "icon": { "tag": "svg", "attrs": { "fill-rule": "evenodd", "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z" } }] }, "name": "close", "theme": "outlined" };
    const CloseOutlinedSvg = CloseOutlined$2;
    var CloseOutlined = function CloseOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: CloseOutlinedSvg
      }));
    };
    const CloseOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(CloseOutlined);
    var ExclamationCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "exclamation-circle", "theme": "filled" };
    const ExclamationCircleFilledSvg = ExclamationCircleFilled$2;
    var ExclamationCircleFilled = function ExclamationCircleFilled2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: ExclamationCircleFilledSvg
      }));
    };
    const ExclamationCircleFilled$1 = /* @__PURE__ */ reactExports.forwardRef(ExclamationCircleFilled);
    var attributes = "accept acceptCharset accessKey action allowFullScreen allowTransparency\n    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge\n    charSet checked classID className colSpan cols content contentEditable contextMenu\n    controls coords crossOrigin data dateTime default defer dir disabled download draggable\n    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder\n    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity\n    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media\n    mediaGroup method min minLength multiple muted name noValidate nonce open\n    optimum pattern placeholder poster preload radioGroup readOnly rel required\n    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected\n    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style\n    summary tabIndex target title type useMap value width wmode wrap";
    var eventsName = "onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown\n    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick\n    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown\n    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel\n    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough\n    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata\n    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError";
    var propList = "".concat(attributes, " ").concat(eventsName).split(/[\s\n]+/);
    var ariaPrefix = "aria-";
    var dataPrefix = "data-";
    function match(key, prefix) {
      return key.indexOf(prefix) === 0;
    }
    function pickAttrs(props) {
      var ariaOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var mergedConfig;
      if (ariaOnly === false) {
        mergedConfig = {
          aria: true,
          data: true,
          attr: true
        };
      } else if (ariaOnly === true) {
        mergedConfig = {
          aria: true
        };
      } else {
        mergedConfig = _objectSpread2({}, ariaOnly);
      }
      var attrs = {};
      Object.keys(props).forEach(function(key) {
        if (
          // Aria
          mergedConfig.aria && (key === "role" || match(key, ariaPrefix)) || // Data
          mergedConfig.data && match(key, dataPrefix) || // Attr
          mergedConfig.attr && propList.includes(key)
        ) {
          attrs[key] = props[key];
        }
      });
      return attrs;
    }
    const {
      isValidElement
    } = React$1;
    function isFragment(child) {
      return child && isValidElement(child) && child.type === reactExports.Fragment;
    }
    function replaceElement(element, replacement, props) {
      if (!isValidElement(element)) {
        return replacement;
      }
      return /* @__PURE__ */ reactExports.cloneElement(element, typeof props === "function" ? props(element.props || {}) : props);
    }
    function cloneElement(element, props) {
      return replaceElement(element, element, props);
    }
    const t = (t2) => "object" == typeof t2 && null != t2 && 1 === t2.nodeType, e$1 = (t2, e2) => (!e2 || "hidden" !== t2) && ("visible" !== t2 && "clip" !== t2), n = (t2, n2) => {
      if (t2.clientHeight < t2.scrollHeight || t2.clientWidth < t2.scrollWidth) {
        const o2 = getComputedStyle(t2, null);
        return e$1(o2.overflowY, n2) || e$1(o2.overflowX, n2) || ((t3) => {
          const e2 = ((t4) => {
            if (!t4.ownerDocument || !t4.ownerDocument.defaultView)
              return null;
            try {
              return t4.ownerDocument.defaultView.frameElement;
            } catch (t5) {
              return null;
            }
          })(t3);
          return !!e2 && (e2.clientHeight < t3.scrollHeight || e2.clientWidth < t3.scrollWidth);
        })(t2);
      }
      return false;
    }, o$1 = (t2, e2, n2, o2, l2, r2, i, s) => r2 < t2 && i > e2 || r2 > t2 && i < e2 ? 0 : r2 <= t2 && s <= n2 || i >= e2 && s >= n2 ? r2 - t2 - o2 : i > e2 && s < n2 || r2 < t2 && s > n2 ? i - e2 + l2 : 0, l = (t2) => {
      const e2 = t2.parentElement;
      return null == e2 ? t2.getRootNode().host || null : e2;
    }, r = (e2, r2) => {
      var i, s, d2, h2;
      if ("undefined" == typeof document)
        return [];
      const { scrollMode: c2, block: f2, inline: u2, boundary: a, skipOverflowHiddenElements: g2 } = r2, p2 = "function" == typeof a ? a : (t2) => t2 !== a;
      if (!t(e2))
        throw new TypeError("Invalid target");
      const m2 = document.scrollingElement || document.documentElement, w2 = [];
      let W2 = e2;
      for (; t(W2) && p2(W2); ) {
        if (W2 = l(W2), W2 === m2) {
          w2.push(W2);
          break;
        }
        null != W2 && W2 === document.body && n(W2) && !n(document.documentElement) || null != W2 && n(W2, g2) && w2.push(W2);
      }
      const b2 = null != (s = null == (i = window.visualViewport) ? void 0 : i.width) ? s : innerWidth, H2 = null != (h2 = null == (d2 = window.visualViewport) ? void 0 : d2.height) ? h2 : innerHeight, { scrollX: y2, scrollY: M2 } = window, { height: v2, width: E2, top: x2, right: C2, bottom: I2, left: R2 } = e2.getBoundingClientRect(), { top: T2, right: B2, bottom: F2, left: V2 } = ((t2) => {
        const e3 = window.getComputedStyle(t2);
        return { top: parseFloat(e3.scrollMarginTop) || 0, right: parseFloat(e3.scrollMarginRight) || 0, bottom: parseFloat(e3.scrollMarginBottom) || 0, left: parseFloat(e3.scrollMarginLeft) || 0 };
      })(e2);
      let k2 = "start" === f2 || "nearest" === f2 ? x2 - T2 : "end" === f2 ? I2 + F2 : x2 + v2 / 2 - T2 + F2, D2 = "center" === u2 ? R2 + E2 / 2 - V2 + B2 : "end" === u2 ? C2 + B2 : R2 - V2;
      const L2 = [];
      for (let t2 = 0; t2 < w2.length; t2++) {
        const e3 = w2[t2], { height: n2, width: l2, top: r3, right: i2, bottom: s2, left: d3 } = e3.getBoundingClientRect();
        if ("if-needed" === c2 && x2 >= 0 && R2 >= 0 && I2 <= H2 && C2 <= b2 && x2 >= r3 && I2 <= s2 && R2 >= d3 && C2 <= i2)
          return L2;
        const h3 = getComputedStyle(e3), a2 = parseInt(h3.borderLeftWidth, 10), g3 = parseInt(h3.borderTopWidth, 10), p3 = parseInt(h3.borderRightWidth, 10), W3 = parseInt(h3.borderBottomWidth, 10);
        let T3 = 0, B3 = 0;
        const F3 = "offsetWidth" in e3 ? e3.offsetWidth - e3.clientWidth - a2 - p3 : 0, V3 = "offsetHeight" in e3 ? e3.offsetHeight - e3.clientHeight - g3 - W3 : 0, S2 = "offsetWidth" in e3 ? 0 === e3.offsetWidth ? 0 : l2 / e3.offsetWidth : 0, X2 = "offsetHeight" in e3 ? 0 === e3.offsetHeight ? 0 : n2 / e3.offsetHeight : 0;
        if (m2 === e3)
          T3 = "start" === f2 ? k2 : "end" === f2 ? k2 - H2 : "nearest" === f2 ? o$1(M2, M2 + H2, H2, g3, W3, M2 + k2, M2 + k2 + v2, v2) : k2 - H2 / 2, B3 = "start" === u2 ? D2 : "center" === u2 ? D2 - b2 / 2 : "end" === u2 ? D2 - b2 : o$1(y2, y2 + b2, b2, a2, p3, y2 + D2, y2 + D2 + E2, E2), T3 = Math.max(0, T3 + M2), B3 = Math.max(0, B3 + y2);
        else {
          T3 = "start" === f2 ? k2 - r3 - g3 : "end" === f2 ? k2 - s2 + W3 + V3 : "nearest" === f2 ? o$1(r3, s2, n2, g3, W3 + V3, k2, k2 + v2, v2) : k2 - (r3 + n2 / 2) + V3 / 2, B3 = "start" === u2 ? D2 - d3 - a2 : "center" === u2 ? D2 - (d3 + l2 / 2) + F3 / 2 : "end" === u2 ? D2 - i2 + p3 + F3 : o$1(d3, i2, l2, a2, p3 + F3, D2, D2 + E2, E2);
          const { scrollLeft: t3, scrollTop: h4 } = e3;
          T3 = 0 === X2 ? 0 : Math.max(0, Math.min(h4 + T3 / X2, e3.scrollHeight - n2 / X2 + V3)), B3 = 0 === S2 ? 0 : Math.max(0, Math.min(t3 + B3 / S2, e3.scrollWidth - l2 / S2 + F3)), k2 += h4 - T3, D2 += t3 - B3;
        }
        L2.push({ el: e3, top: T3, left: B3 });
      }
      return L2;
    };
    const o = (t2) => false === t2 ? { block: "end", inline: "nearest" } : ((t3) => t3 === Object(t3) && 0 !== Object.keys(t3).length)(t2) ? t2 : { block: "start", inline: "nearest" };
    function e(e2, r$12) {
      if (!e2.isConnected || !((t2) => {
        let o2 = t2;
        for (; o2 && o2.parentNode; ) {
          if (o2.parentNode === document)
            return true;
          o2 = o2.parentNode instanceof ShadowRoot ? o2.parentNode.host : o2.parentNode;
        }
        return false;
      })(e2))
        return;
      const n2 = ((t2) => {
        const o2 = window.getComputedStyle(t2);
        return { top: parseFloat(o2.scrollMarginTop) || 0, right: parseFloat(o2.scrollMarginRight) || 0, bottom: parseFloat(o2.scrollMarginBottom) || 0, left: parseFloat(o2.scrollMarginLeft) || 0 };
      })(e2);
      if (((t2) => "object" == typeof t2 && "function" == typeof t2.behavior)(r$12))
        return r$12.behavior(r(e2, r$12));
      const l2 = "boolean" == typeof r$12 || null == r$12 ? void 0 : r$12.behavior;
      for (const { el: a, top: i, left: s } of r(e2, o(r$12))) {
        const t2 = i - n2.top + n2.bottom, o2 = s - n2.left + n2.right;
        a.scroll({ top: t2, left: o2, behavior: l2 });
      }
    }
    function isWindow(obj) {
      return obj !== null && obj !== void 0 && obj === obj.window;
    }
    function getScroll(target, top) {
      var _a, _b;
      if (typeof window === "undefined") {
        return 0;
      }
      const method = top ? "scrollTop" : "scrollLeft";
      let result = 0;
      if (isWindow(target)) {
        result = target[top ? "pageYOffset" : "pageXOffset"];
      } else if (target instanceof Document) {
        result = target.documentElement[method];
      } else if (target instanceof HTMLElement) {
        result = target[method];
      } else if (target) {
        result = target[method];
      }
      if (target && !isWindow(target) && typeof result !== "number") {
        result = (_b = ((_a = target.ownerDocument) !== null && _a !== void 0 ? _a : target).documentElement) === null || _b === void 0 ? void 0 : _b[method];
      }
      return result;
    }
    function easeInOutCubic(t2, b2, c2, d2) {
      const cc2 = c2 - b2;
      t2 /= d2 / 2;
      if (t2 < 1) {
        return cc2 / 2 * t2 * t2 * t2 + b2;
      }
      return cc2 / 2 * ((t2 -= 2) * t2 * t2 + 2) + b2;
    }
    function scrollTo$1(y2) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const {
        getContainer: getContainer2 = () => window,
        callback,
        duration = 450
      } = options;
      const container = getContainer2();
      const scrollTop = getScroll(container, true);
      const startTime = Date.now();
      const frameFunc = () => {
        const timestamp = Date.now();
        const time = timestamp - startTime;
        const nextScrollTop = easeInOutCubic(time > duration ? duration : time, scrollTop, y2, duration);
        if (isWindow(container)) {
          container.scrollTo(window.pageXOffset, nextScrollTop);
        } else if (container instanceof Document || container.constructor.name === "HTMLDocument") {
          container.documentElement.scrollTop = nextScrollTop;
        } else {
          container.scrollTop = nextScrollTop;
        }
        if (time < duration) {
          wrapperRaf(frameFunc);
        } else if (typeof callback === "function") {
          callback();
        }
      };
      wrapperRaf(frameFunc);
    }
    const useCSSVarCls = (prefixCls) => {
      const [, , , , cssVar] = useToken$1();
      return cssVar ? `${prefixCls}-css-var` : "";
    };
    const useCSSVarCls$1 = useCSSVarCls;
    var KeyCode = {
      /**
       * MAC_ENTER
       */
      MAC_ENTER: 3,
      /**
       * BACKSPACE
       */
      BACKSPACE: 8,
      /**
       * TAB
       */
      TAB: 9,
      /**
       * NUMLOCK on FF/Safari Mac
       */
      NUM_CENTER: 12,
      // NUMLOCK on FF/Safari Mac
      /**
       * ENTER
       */
      ENTER: 13,
      /**
       * SHIFT
       */
      SHIFT: 16,
      /**
       * CTRL
       */
      CTRL: 17,
      /**
       * ALT
       */
      ALT: 18,
      /**
       * PAUSE
       */
      PAUSE: 19,
      /**
       * CAPS_LOCK
       */
      CAPS_LOCK: 20,
      /**
       * ESC
       */
      ESC: 27,
      /**
       * SPACE
       */
      SPACE: 32,
      /**
       * PAGE_UP
       */
      PAGE_UP: 33,
      // also NUM_NORTH_EAST
      /**
       * PAGE_DOWN
       */
      PAGE_DOWN: 34,
      // also NUM_SOUTH_EAST
      /**
       * END
       */
      END: 35,
      // also NUM_SOUTH_WEST
      /**
       * HOME
       */
      HOME: 36,
      // also NUM_NORTH_WEST
      /**
       * LEFT
       */
      LEFT: 37,
      // also NUM_WEST
      /**
       * UP
       */
      UP: 38,
      // also NUM_NORTH
      /**
       * RIGHT
       */
      RIGHT: 39,
      // also NUM_EAST
      /**
       * DOWN
       */
      DOWN: 40,
      // also NUM_SOUTH
      /**
       * PRINT_SCREEN
       */
      PRINT_SCREEN: 44,
      /**
       * INSERT
       */
      INSERT: 45,
      // also NUM_INSERT
      /**
       * DELETE
       */
      DELETE: 46,
      // also NUM_DELETE
      /**
       * ZERO
       */
      ZERO: 48,
      /**
       * ONE
       */
      ONE: 49,
      /**
       * TWO
       */
      TWO: 50,
      /**
       * THREE
       */
      THREE: 51,
      /**
       * FOUR
       */
      FOUR: 52,
      /**
       * FIVE
       */
      FIVE: 53,
      /**
       * SIX
       */
      SIX: 54,
      /**
       * SEVEN
       */
      SEVEN: 55,
      /**
       * EIGHT
       */
      EIGHT: 56,
      /**
       * NINE
       */
      NINE: 57,
      /**
       * QUESTION_MARK
       */
      QUESTION_MARK: 63,
      // needs localization
      /**
       * A
       */
      A: 65,
      /**
       * B
       */
      B: 66,
      /**
       * C
       */
      C: 67,
      /**
       * D
       */
      D: 68,
      /**
       * E
       */
      E: 69,
      /**
       * F
       */
      F: 70,
      /**
       * G
       */
      G: 71,
      /**
       * H
       */
      H: 72,
      /**
       * I
       */
      I: 73,
      /**
       * J
       */
      J: 74,
      /**
       * K
       */
      K: 75,
      /**
       * L
       */
      L: 76,
      /**
       * M
       */
      M: 77,
      /**
       * N
       */
      N: 78,
      /**
       * O
       */
      O: 79,
      /**
       * P
       */
      P: 80,
      /**
       * Q
       */
      Q: 81,
      /**
       * R
       */
      R: 82,
      /**
       * S
       */
      S: 83,
      /**
       * T
       */
      T: 84,
      /**
       * U
       */
      U: 85,
      /**
       * V
       */
      V: 86,
      /**
       * W
       */
      W: 87,
      /**
       * X
       */
      X: 88,
      /**
       * Y
       */
      Y: 89,
      /**
       * Z
       */
      Z: 90,
      /**
       * META
       */
      META: 91,
      // WIN_KEY_LEFT
      /**
       * WIN_KEY_RIGHT
       */
      WIN_KEY_RIGHT: 92,
      /**
       * CONTEXT_MENU
       */
      CONTEXT_MENU: 93,
      /**
       * NUM_ZERO
       */
      NUM_ZERO: 96,
      /**
       * NUM_ONE
       */
      NUM_ONE: 97,
      /**
       * NUM_TWO
       */
      NUM_TWO: 98,
      /**
       * NUM_THREE
       */
      NUM_THREE: 99,
      /**
       * NUM_FOUR
       */
      NUM_FOUR: 100,
      /**
       * NUM_FIVE
       */
      NUM_FIVE: 101,
      /**
       * NUM_SIX
       */
      NUM_SIX: 102,
      /**
       * NUM_SEVEN
       */
      NUM_SEVEN: 103,
      /**
       * NUM_EIGHT
       */
      NUM_EIGHT: 104,
      /**
       * NUM_NINE
       */
      NUM_NINE: 105,
      /**
       * NUM_MULTIPLY
       */
      NUM_MULTIPLY: 106,
      /**
       * NUM_PLUS
       */
      NUM_PLUS: 107,
      /**
       * NUM_MINUS
       */
      NUM_MINUS: 109,
      /**
       * NUM_PERIOD
       */
      NUM_PERIOD: 110,
      /**
       * NUM_DIVISION
       */
      NUM_DIVISION: 111,
      /**
       * F1
       */
      F1: 112,
      /**
       * F2
       */
      F2: 113,
      /**
       * F3
       */
      F3: 114,
      /**
       * F4
       */
      F4: 115,
      /**
       * F5
       */
      F5: 116,
      /**
       * F6
       */
      F6: 117,
      /**
       * F7
       */
      F7: 118,
      /**
       * F8
       */
      F8: 119,
      /**
       * F9
       */
      F9: 120,
      /**
       * F10
       */
      F10: 121,
      /**
       * F11
       */
      F11: 122,
      /**
       * F12
       */
      F12: 123,
      /**
       * NUMLOCK
       */
      NUMLOCK: 144,
      /**
       * SEMICOLON
       */
      SEMICOLON: 186,
      // needs localization
      /**
       * DASH
       */
      DASH: 189,
      // needs localization
      /**
       * EQUALS
       */
      EQUALS: 187,
      // needs localization
      /**
       * COMMA
       */
      COMMA: 188,
      // needs localization
      /**
       * PERIOD
       */
      PERIOD: 190,
      // needs localization
      /**
       * SLASH
       */
      SLASH: 191,
      // needs localization
      /**
       * APOSTROPHE
       */
      APOSTROPHE: 192,
      // needs localization
      /**
       * SINGLE_QUOTE
       */
      SINGLE_QUOTE: 222,
      // needs localization
      /**
       * OPEN_SQUARE_BRACKET
       */
      OPEN_SQUARE_BRACKET: 219,
      // needs localization
      /**
       * BACKSLASH
       */
      BACKSLASH: 220,
      // needs localization
      /**
       * CLOSE_SQUARE_BRACKET
       */
      CLOSE_SQUARE_BRACKET: 221,
      // needs localization
      /**
       * WIN_KEY
       */
      WIN_KEY: 224,
      /**
       * MAC_FF_META
       */
      MAC_FF_META: 224,
      // Firefox (Gecko) fires this for the meta key instead of 91
      /**
       * WIN_IME
       */
      WIN_IME: 229,
      // ======================== Function ========================
      /**
       * whether text and modified key is entered at the same time.
       */
      isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e2) {
        var keyCode = e2.keyCode;
        if (e2.altKey && !e2.ctrlKey || e2.metaKey || // Function keys don't generate text
        keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
          return false;
        }
        switch (keyCode) {
          case KeyCode.ALT:
          case KeyCode.CAPS_LOCK:
          case KeyCode.CONTEXT_MENU:
          case KeyCode.CTRL:
          case KeyCode.DOWN:
          case KeyCode.END:
          case KeyCode.ESC:
          case KeyCode.HOME:
          case KeyCode.INSERT:
          case KeyCode.LEFT:
          case KeyCode.MAC_FF_META:
          case KeyCode.META:
          case KeyCode.NUMLOCK:
          case KeyCode.NUM_CENTER:
          case KeyCode.PAGE_DOWN:
          case KeyCode.PAGE_UP:
          case KeyCode.PAUSE:
          case KeyCode.PRINT_SCREEN:
          case KeyCode.RIGHT:
          case KeyCode.SHIFT:
          case KeyCode.UP:
          case KeyCode.WIN_KEY:
          case KeyCode.WIN_KEY_RIGHT:
            return false;
          default:
            return true;
        }
      },
      /**
       * whether character is entered.
       */
      isCharacterKey: function isCharacterKey(keyCode) {
        if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
          return true;
        }
        if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
          return true;
        }
        if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
          return true;
        }
        if (window.navigator.userAgent.indexOf("WebKit") !== -1 && keyCode === 0) {
          return true;
        }
        switch (keyCode) {
          case KeyCode.SPACE:
          case KeyCode.QUESTION_MARK:
          case KeyCode.NUM_PLUS:
          case KeyCode.NUM_MINUS:
          case KeyCode.NUM_PERIOD:
          case KeyCode.NUM_DIVISION:
          case KeyCode.SEMICOLON:
          case KeyCode.DASH:
          case KeyCode.EQUALS:
          case KeyCode.COMMA:
          case KeyCode.PERIOD:
          case KeyCode.SLASH:
          case KeyCode.APOSTROPHE:
          case KeyCode.SINGLE_QUOTE:
          case KeyCode.OPEN_SQUARE_BRACKET:
          case KeyCode.BACKSLASH:
          case KeyCode.CLOSE_SQUARE_BRACKET:
            return true;
          default:
            return false;
        }
      }
    };
    var LoadingOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, "name": "loading", "theme": "outlined" };
    const LoadingOutlinedSvg = LoadingOutlined$2;
    var LoadingOutlined = function LoadingOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: LoadingOutlinedSvg
      }));
    };
    const LoadingOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(LoadingOutlined);
    const zIndexContext = /* @__PURE__ */ React.createContext(void 0);
    const zIndexContext$1 = zIndexContext;
    const CONTAINER_OFFSET = 100;
    const CONTAINER_OFFSET_MAX_COUNT = 10;
    const CONTAINER_MAX_OFFSET = CONTAINER_OFFSET * CONTAINER_OFFSET_MAX_COUNT;
    const containerBaseZIndexOffset = {
      Modal: CONTAINER_OFFSET,
      Drawer: CONTAINER_OFFSET,
      Popover: CONTAINER_OFFSET,
      Popconfirm: CONTAINER_OFFSET,
      Tooltip: CONTAINER_OFFSET,
      Tour: CONTAINER_OFFSET
    };
    const consumerBaseZIndexOffset = {
      SelectLike: 50,
      Dropdown: 50,
      DatePicker: 50,
      Menu: 50,
      ImagePreview: 1
    };
    function isContainerType(type) {
      return type in containerBaseZIndexOffset;
    }
    function useZIndex(componentType, customZIndex) {
      const [, token2] = useToken$1();
      const parentZIndex = React.useContext(zIndexContext$1);
      const isContainer = isContainerType(componentType);
      if (customZIndex !== void 0) {
        return [customZIndex, customZIndex];
      }
      let zIndex = parentZIndex !== null && parentZIndex !== void 0 ? parentZIndex : 0;
      if (isContainer) {
        zIndex += // Use preset token zIndex by default but not stack when has parent container
        (parentZIndex ? 0 : token2.zIndexPopupBase) + // Container offset
        containerBaseZIndexOffset[componentType];
        zIndex = Math.min(zIndex, token2.zIndexPopupBase + CONTAINER_MAX_OFFSET);
      } else {
        zIndex += consumerBaseZIndexOffset[componentType];
      }
      return [parentZIndex === void 0 ? customZIndex : zIndex, zIndex];
    }
    function _regeneratorRuntime() {
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e2;
      };
      var t2, e2 = {}, r2 = Object.prototype, n2 = r2.hasOwnProperty, o2 = Object.defineProperty || function(t3, e3, r3) {
        t3[e3] = r3.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c2 = i.asyncIterator || "@@asyncIterator", u2 = i.toStringTag || "@@toStringTag";
      function define(t3, e3, r3) {
        return Object.defineProperty(t3, e3, {
          value: r3,
          enumerable: true,
          configurable: true,
          writable: true
        }), t3[e3];
      }
      try {
        define({}, "");
      } catch (t3) {
        define = function define2(t4, e3, r3) {
          return t4[e3] = r3;
        };
      }
      function wrap(t3, e3, r3, n3) {
        var i2 = e3 && e3.prototype instanceof Generator ? e3 : Generator, a2 = Object.create(i2.prototype), c3 = new Context2(n3 || []);
        return o2(a2, "_invoke", {
          value: makeInvokeMethod(t3, r3, c3)
        }), a2;
      }
      function tryCatch(t3, e3, r3) {
        try {
          return {
            type: "normal",
            arg: t3.call(e3, r3)
          };
        } catch (t4) {
          return {
            type: "throw",
            arg: t4
          };
        }
      }
      e2.wrap = wrap;
      var h2 = "suspendedStart", l2 = "suspendedYield", f2 = "executing", s = "completed", y2 = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p2 = {};
      define(p2, a, function() {
        return this;
      });
      var d2 = Object.getPrototypeOf, v2 = d2 && d2(d2(values([])));
      v2 && v2 !== r2 && n2.call(v2, a) && (p2 = v2);
      var g2 = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p2);
      function defineIteratorMethods(t3) {
        ["next", "throw", "return"].forEach(function(e3) {
          define(t3, e3, function(t4) {
            return this._invoke(e3, t4);
          });
        });
      }
      function AsyncIterator(t3, e3) {
        function invoke(r4, o3, i2, a2) {
          var c3 = tryCatch(t3[r4], t3, o3);
          if ("throw" !== c3.type) {
            var u3 = c3.arg, h3 = u3.value;
            return h3 && "object" == _typeof(h3) && n2.call(h3, "__await") ? e3.resolve(h3.__await).then(function(t4) {
              invoke("next", t4, i2, a2);
            }, function(t4) {
              invoke("throw", t4, i2, a2);
            }) : e3.resolve(h3).then(function(t4) {
              u3.value = t4, i2(u3);
            }, function(t4) {
              return invoke("throw", t4, i2, a2);
            });
          }
          a2(c3.arg);
        }
        var r3;
        o2(this, "_invoke", {
          value: function value(t4, n3) {
            function callInvokeWithMethodAndArg() {
              return new e3(function(e4, r4) {
                invoke(t4, n3, e4, r4);
              });
            }
            return r3 = r3 ? r3.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
        });
      }
      function makeInvokeMethod(e3, r3, n3) {
        var o3 = h2;
        return function(i2, a2) {
          if (o3 === f2)
            throw new Error("Generator is already running");
          if (o3 === s) {
            if ("throw" === i2)
              throw a2;
            return {
              value: t2,
              done: true
            };
          }
          for (n3.method = i2, n3.arg = a2; ; ) {
            var c3 = n3.delegate;
            if (c3) {
              var u3 = maybeInvokeDelegate(c3, n3);
              if (u3) {
                if (u3 === y2)
                  continue;
                return u3;
              }
            }
            if ("next" === n3.method)
              n3.sent = n3._sent = n3.arg;
            else if ("throw" === n3.method) {
              if (o3 === h2)
                throw o3 = s, n3.arg;
              n3.dispatchException(n3.arg);
            } else
              "return" === n3.method && n3.abrupt("return", n3.arg);
            o3 = f2;
            var p3 = tryCatch(e3, r3, n3);
            if ("normal" === p3.type) {
              if (o3 = n3.done ? s : l2, p3.arg === y2)
                continue;
              return {
                value: p3.arg,
                done: n3.done
              };
            }
            "throw" === p3.type && (o3 = s, n3.method = "throw", n3.arg = p3.arg);
          }
        };
      }
      function maybeInvokeDelegate(e3, r3) {
        var n3 = r3.method, o3 = e3.iterator[n3];
        if (o3 === t2)
          return r3.delegate = null, "throw" === n3 && e3.iterator["return"] && (r3.method = "return", r3.arg = t2, maybeInvokeDelegate(e3, r3), "throw" === r3.method) || "return" !== n3 && (r3.method = "throw", r3.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), y2;
        var i2 = tryCatch(o3, e3.iterator, r3.arg);
        if ("throw" === i2.type)
          return r3.method = "throw", r3.arg = i2.arg, r3.delegate = null, y2;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r3[e3.resultName] = a2.value, r3.next = e3.nextLoc, "return" !== r3.method && (r3.method = "next", r3.arg = t2), r3.delegate = null, y2) : a2 : (r3.method = "throw", r3.arg = new TypeError("iterator result is not an object"), r3.delegate = null, y2);
      }
      function pushTryEntry(t3) {
        var e3 = {
          tryLoc: t3[0]
        };
        1 in t3 && (e3.catchLoc = t3[1]), 2 in t3 && (e3.finallyLoc = t3[2], e3.afterLoc = t3[3]), this.tryEntries.push(e3);
      }
      function resetTryEntry(t3) {
        var e3 = t3.completion || {};
        e3.type = "normal", delete e3.arg, t3.completion = e3;
      }
      function Context2(t3) {
        this.tryEntries = [{
          tryLoc: "root"
        }], t3.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e3) {
        if (e3 || "" === e3) {
          var r3 = e3[a];
          if (r3)
            return r3.call(e3);
          if ("function" == typeof e3.next)
            return e3;
          if (!isNaN(e3.length)) {
            var o3 = -1, i2 = function next2() {
              for (; ++o3 < e3.length; )
                if (n2.call(e3, o3))
                  return next2.value = e3[o3], next2.done = false, next2;
              return next2.value = t2, next2.done = true, next2;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e3) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o2(g2, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: true
      }), o2(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: true
      }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u2, "GeneratorFunction"), e2.isGeneratorFunction = function(t3) {
        var e3 = "function" == typeof t3 && t3.constructor;
        return !!e3 && (e3 === GeneratorFunction || "GeneratorFunction" === (e3.displayName || e3.name));
      }, e2.mark = function(t3) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t3, GeneratorFunctionPrototype) : (t3.__proto__ = GeneratorFunctionPrototype, define(t3, u2, "GeneratorFunction")), t3.prototype = Object.create(g2), t3;
      }, e2.awrap = function(t3) {
        return {
          __await: t3
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c2, function() {
        return this;
      }), e2.AsyncIterator = AsyncIterator, e2.async = function(t3, r3, n3, o3, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t3, r3, n3, o3), i2);
        return e2.isGeneratorFunction(r3) ? a2 : a2.next().then(function(t4) {
          return t4.done ? t4.value : a2.next();
        });
      }, defineIteratorMethods(g2), define(g2, u2, "Generator"), define(g2, a, function() {
        return this;
      }), define(g2, "toString", function() {
        return "[object Generator]";
      }), e2.keys = function(t3) {
        var e3 = Object(t3), r3 = [];
        for (var n3 in e3)
          r3.push(n3);
        return r3.reverse(), function next2() {
          for (; r3.length; ) {
            var t4 = r3.pop();
            if (t4 in e3)
              return next2.value = t4, next2.done = false, next2;
          }
          return next2.done = true, next2;
        };
      }, e2.values = values, Context2.prototype = {
        constructor: Context2,
        reset: function reset(e3) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = t2, this.done = false, this.delegate = null, this.method = "next", this.arg = t2, this.tryEntries.forEach(resetTryEntry), !e3)
            for (var r3 in this)
              "t" === r3.charAt(0) && n2.call(this, r3) && !isNaN(+r3.slice(1)) && (this[r3] = t2);
        },
        stop: function stop() {
          this.done = true;
          var t3 = this.tryEntries[0].completion;
          if ("throw" === t3.type)
            throw t3.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(e3) {
          if (this.done)
            throw e3;
          var r3 = this;
          function handle(n3, o4) {
            return a2.type = "throw", a2.arg = e3, r3.next = n3, o4 && (r3.method = "next", r3.arg = t2), !!o4;
          }
          for (var o3 = this.tryEntries.length - 1; o3 >= 0; --o3) {
            var i2 = this.tryEntries[o3], a2 = i2.completion;
            if ("root" === i2.tryLoc)
              return handle("end");
            if (i2.tryLoc <= this.prev) {
              var c3 = n2.call(i2, "catchLoc"), u3 = n2.call(i2, "finallyLoc");
              if (c3 && u3) {
                if (this.prev < i2.catchLoc)
                  return handle(i2.catchLoc, true);
                if (this.prev < i2.finallyLoc)
                  return handle(i2.finallyLoc);
              } else if (c3) {
                if (this.prev < i2.catchLoc)
                  return handle(i2.catchLoc, true);
              } else {
                if (!u3)
                  throw new Error("try statement without catch or finally");
                if (this.prev < i2.finallyLoc)
                  return handle(i2.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(t3, e3) {
          for (var r3 = this.tryEntries.length - 1; r3 >= 0; --r3) {
            var o3 = this.tryEntries[r3];
            if (o3.tryLoc <= this.prev && n2.call(o3, "finallyLoc") && this.prev < o3.finallyLoc) {
              var i2 = o3;
              break;
            }
          }
          i2 && ("break" === t3 || "continue" === t3) && i2.tryLoc <= e3 && e3 <= i2.finallyLoc && (i2 = null);
          var a2 = i2 ? i2.completion : {};
          return a2.type = t3, a2.arg = e3, i2 ? (this.method = "next", this.next = i2.finallyLoc, y2) : this.complete(a2);
        },
        complete: function complete(t3, e3) {
          if ("throw" === t3.type)
            throw t3.arg;
          return "break" === t3.type || "continue" === t3.type ? this.next = t3.arg : "return" === t3.type ? (this.rval = this.arg = t3.arg, this.method = "return", this.next = "end") : "normal" === t3.type && e3 && (this.next = e3), y2;
        },
        finish: function finish(t3) {
          for (var e3 = this.tryEntries.length - 1; e3 >= 0; --e3) {
            var r3 = this.tryEntries[e3];
            if (r3.finallyLoc === t3)
              return this.complete(r3.completion, r3.afterLoc), resetTryEntry(r3), y2;
          }
        },
        "catch": function _catch(t3) {
          for (var e3 = this.tryEntries.length - 1; e3 >= 0; --e3) {
            var r3 = this.tryEntries[e3];
            if (r3.tryLoc === t3) {
              var n3 = r3.completion;
              if ("throw" === n3.type) {
                var o3 = n3.arg;
                resetTryEntry(r3);
              }
              return o3;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(e3, r3, n3) {
          return this.delegate = {
            iterator: values(e3),
            resultName: r3,
            nextLoc: n3
          }, "next" === this.method && (this.arg = t2), y2;
        }
      }, e2;
    }
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var fullClone = _objectSpread2({}, ReactDOM$1);
    var version = fullClone.version, reactRender = fullClone.render, unmountComponentAtNode = fullClone.unmountComponentAtNode;
    var createRoot;
    try {
      var mainVersion = Number((version || "").split(".")[0]);
      if (mainVersion >= 18) {
        createRoot = fullClone.createRoot;
      }
    } catch (e2) {
    }
    function toggleWarning(skip) {
      var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = fullClone.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      if (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && _typeof(__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === "object") {
        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = skip;
      }
    }
    var MARK = "__rc_react_root__";
    function modernRender(node2, container) {
      toggleWarning(true);
      var root = container[MARK] || createRoot(container);
      toggleWarning(false);
      root.render(node2);
      container[MARK] = root;
    }
    function legacyRender(node2, container) {
      reactRender(node2, container);
    }
    function render(node2, container) {
      if (createRoot) {
        modernRender(node2, container);
        return;
      }
      legacyRender(node2, container);
    }
    function modernUnmount(_x) {
      return _modernUnmount.apply(this, arguments);
    }
    function _modernUnmount() {
      _modernUnmount = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(container) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", Promise.resolve().then(function() {
                  var _container$MARK;
                  (_container$MARK = container[MARK]) === null || _container$MARK === void 0 || _container$MARK.unmount();
                  delete container[MARK];
                }));
              case 1:
              case "end":
                return _context.stop();
            }
        }, _callee);
      }));
      return _modernUnmount.apply(this, arguments);
    }
    function legacyUnmount(container) {
      unmountComponentAtNode(container);
    }
    function unmount(_x2) {
      return _unmount.apply(this, arguments);
    }
    function _unmount() {
      _unmount = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(container) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(createRoot !== void 0)) {
                  _context2.next = 2;
                  break;
                }
                return _context2.abrupt("return", modernUnmount(container));
              case 2:
                legacyUnmount(container);
              case 3:
              case "end":
                return _context2.stop();
            }
        }, _callee2);
      }));
      return _unmount.apply(this, arguments);
    }
    const getCollapsedHeight = () => ({
      height: 0,
      opacity: 0
    });
    const getRealHeight = (node2) => {
      const {
        scrollHeight
      } = node2;
      return {
        height: scrollHeight,
        opacity: 1
      };
    };
    const getCurrentHeight = (node2) => ({
      height: node2 ? node2.offsetHeight : 0
    });
    const skipOpacityTransition = (_, event) => (event === null || event === void 0 ? void 0 : event.deadline) === true || event.propertyName === "height";
    const initCollapseMotion = function() {
      let rootCls = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "ant";
      return {
        motionName: `${rootCls}-motion-collapse`,
        onAppearStart: getCollapsedHeight,
        onEnterStart: getCollapsedHeight,
        onAppearActive: getRealHeight,
        onEnterActive: getRealHeight,
        onLeaveStart: getCurrentHeight,
        onLeaveActive: getCollapsedHeight,
        onAppearEnd: skipOpacityTransition,
        onEnterEnd: skipOpacityTransition,
        onLeaveEnd: skipOpacityTransition,
        motionDeadline: 500
      };
    };
    const getTransitionName = (rootPrefixCls, motion, transitionName) => {
      if (transitionName !== void 0) {
        return transitionName;
      }
      return `${rootPrefixCls}-${motion}`;
    };
    const isVisible = function(element) {
      if (!element) {
        return false;
      }
      if (element instanceof Element) {
        if (element.offsetParent) {
          return true;
        }
        if (element.getBBox) {
          var _getBBox = element.getBBox(), width = _getBBox.width, height = _getBBox.height;
          if (width || height) {
            return true;
          }
        }
        if (element.getBoundingClientRect) {
          var _element$getBoundingC = element.getBoundingClientRect(), _width = _element$getBoundingC.width, _height = _element$getBoundingC.height;
          if (_width || _height) {
            return true;
          }
        }
      }
      return false;
    };
    const genWaveStyle = (token2) => {
      const {
        componentCls,
        colorPrimary
      } = token2;
      return {
        [componentCls]: {
          position: "absolute",
          background: "transparent",
          pointerEvents: "none",
          boxSizing: "border-box",
          color: `var(--wave-color, ${colorPrimary})`,
          boxShadow: `0 0 0 0 currentcolor`,
          opacity: 0.2,
          // =================== Motion ===================
          "&.wave-motion-appear": {
            transition: [`box-shadow 0.4s ${token2.motionEaseOutCirc}`, `opacity 2s ${token2.motionEaseOutCirc}`].join(","),
            "&-active": {
              boxShadow: `0 0 0 6px currentcolor`,
              opacity: 0
            },
            "&.wave-quick": {
              transition: [`box-shadow 0.3s ${token2.motionEaseInOut}`, `opacity 0.35s ${token2.motionEaseInOut}`].join(",")
            }
          }
        }
      };
    };
    const useStyle$l = genComponentStyleHook("Wave", (token2) => [genWaveStyle(token2)]);
    function isNotGrey(color) {
      const match5 = (color || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
      if (match5 && match5[1] && match5[2] && match5[3]) {
        return !(match5[1] === match5[2] && match5[2] === match5[3]);
      }
      return true;
    }
    function isValidWaveColor(color) {
      return color && color !== "#fff" && color !== "#ffffff" && color !== "rgb(255, 255, 255)" && color !== "rgba(255, 255, 255, 1)" && isNotGrey(color) && !/rgba\((?:\d*, ){3}0\)/.test(color) && // any transparent rgba color
      color !== "transparent";
    }
    function getTargetWaveColor(node2) {
      const {
        borderTopColor,
        borderColor,
        backgroundColor
      } = getComputedStyle(node2);
      if (isValidWaveColor(borderTopColor)) {
        return borderTopColor;
      }
      if (isValidWaveColor(borderColor)) {
        return borderColor;
      }
      if (isValidWaveColor(backgroundColor)) {
        return backgroundColor;
      }
      return null;
    }
    const TARGET_CLS = "ant-wave-target";
    function validateNum(value) {
      return Number.isNaN(value) ? 0 : value;
    }
    const WaveEffect = (props) => {
      const {
        className,
        target,
        component
      } = props;
      const divRef = reactExports.useRef(null);
      const [color, setWaveColor] = reactExports.useState(null);
      const [borderRadius, setBorderRadius] = reactExports.useState([]);
      const [left, setLeft] = reactExports.useState(0);
      const [top, setTop] = reactExports.useState(0);
      const [width, setWidth] = reactExports.useState(0);
      const [height, setHeight] = reactExports.useState(0);
      const [enabled, setEnabled] = reactExports.useState(false);
      const waveStyle = {
        left,
        top,
        width,
        height,
        borderRadius: borderRadius.map((radius) => `${radius}px`).join(" ")
      };
      if (color) {
        waveStyle["--wave-color"] = color;
      }
      function syncPos() {
        const nodeStyle = getComputedStyle(target);
        setWaveColor(getTargetWaveColor(target));
        const isStatic = nodeStyle.position === "static";
        const {
          borderLeftWidth,
          borderTopWidth
        } = nodeStyle;
        setLeft(isStatic ? target.offsetLeft : validateNum(-parseFloat(borderLeftWidth)));
        setTop(isStatic ? target.offsetTop : validateNum(-parseFloat(borderTopWidth)));
        setWidth(target.offsetWidth);
        setHeight(target.offsetHeight);
        const {
          borderTopLeftRadius,
          borderTopRightRadius,
          borderBottomLeftRadius,
          borderBottomRightRadius
        } = nodeStyle;
        setBorderRadius([borderTopLeftRadius, borderTopRightRadius, borderBottomRightRadius, borderBottomLeftRadius].map((radius) => validateNum(parseFloat(radius))));
      }
      reactExports.useEffect(() => {
        if (target) {
          const id2 = wrapperRaf(() => {
            syncPos();
            setEnabled(true);
          });
          let resizeObserver2;
          if (typeof ResizeObserver !== "undefined") {
            resizeObserver2 = new ResizeObserver(syncPos);
            resizeObserver2.observe(target);
          }
          return () => {
            wrapperRaf.cancel(id2);
            resizeObserver2 === null || resizeObserver2 === void 0 ? void 0 : resizeObserver2.disconnect();
          };
        }
      }, []);
      if (!enabled) {
        return null;
      }
      const isSmallComponent = (component === "Checkbox" || component === "Radio") && (target === null || target === void 0 ? void 0 : target.classList.contains(TARGET_CLS));
      return /* @__PURE__ */ reactExports.createElement(CSSMotion, {
        visible: true,
        motionAppear: true,
        motionName: "wave-motion",
        motionDeadline: 5e3,
        onAppearEnd: (_, event) => {
          var _a;
          if (event.deadline || event.propertyName === "opacity") {
            const holder = (_a = divRef.current) === null || _a === void 0 ? void 0 : _a.parentElement;
            unmount(holder).then(() => {
              holder === null || holder === void 0 ? void 0 : holder.remove();
            });
          }
          return false;
        }
      }, (_ref) => {
        let {
          className: motionClassName
        } = _ref;
        return /* @__PURE__ */ reactExports.createElement("div", {
          ref: divRef,
          className: classNames(className, {
            "wave-quick": isSmallComponent
          }, motionClassName),
          style: waveStyle
        });
      });
    };
    const showWaveEffect = (target, info) => {
      var _a;
      const {
        component
      } = info;
      if (component === "Checkbox" && !((_a = target.querySelector("input")) === null || _a === void 0 ? void 0 : _a.checked)) {
        return;
      }
      const holder = document.createElement("div");
      holder.style.position = "absolute";
      holder.style.left = "0px";
      holder.style.top = "0px";
      target === null || target === void 0 ? void 0 : target.insertBefore(holder, target === null || target === void 0 ? void 0 : target.firstChild);
      render(/* @__PURE__ */ reactExports.createElement(WaveEffect, Object.assign({}, info, {
        target
      })), holder);
    };
    const showWaveEffect$1 = showWaveEffect;
    function useWave(nodeRef, className, component) {
      const {
        wave
      } = reactExports.useContext(ConfigContext);
      const [, token2, hashId] = useToken$1();
      const showWave = useEvent((event) => {
        const node2 = nodeRef.current;
        if ((wave === null || wave === void 0 ? void 0 : wave.disabled) || !node2) {
          return;
        }
        const targetNode = node2.querySelector(`.${TARGET_CLS}`) || node2;
        const {
          showEffect
        } = wave || {};
        (showEffect || showWaveEffect$1)(targetNode, {
          className,
          token: token2,
          component,
          event,
          hashId
        });
      });
      const rafId = reactExports.useRef();
      const showDebounceWave = (event) => {
        wrapperRaf.cancel(rafId.current);
        rafId.current = wrapperRaf(() => {
          showWave(event);
        });
      };
      return showDebounceWave;
    }
    const Wave = (props) => {
      const {
        children,
        disabled,
        component
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const containerRef = reactExports.useRef(null);
      const prefixCls = getPrefixCls("wave");
      const [, hashId] = useStyle$l(prefixCls);
      const showWave = useWave(containerRef, classNames(prefixCls, hashId), component);
      React.useEffect(() => {
        const node2 = containerRef.current;
        if (!node2 || node2.nodeType !== 1 || disabled) {
          return;
        }
        const onClick = (e2) => {
          if (!isVisible(e2.target) || // No need wave
          !node2.getAttribute || node2.getAttribute("disabled") || node2.disabled || node2.className.includes("disabled") || node2.className.includes("-leave")) {
            return;
          }
          showWave(e2);
        };
        node2.addEventListener("click", onClick, true);
        return () => {
          node2.removeEventListener("click", onClick, true);
        };
      }, [disabled]);
      if (!/* @__PURE__ */ React.isValidElement(children)) {
        return children !== null && children !== void 0 ? children : null;
      }
      const ref = supportRef(children) ? composeRef(children.ref, containerRef) : containerRef;
      return cloneElement(children, {
        ref
      });
    };
    const Wave$1 = Wave;
    const useSize = (customSize) => {
      const size = React.useContext(SizeContext$1);
      const mergedSize = React.useMemo(() => {
        if (!customSize) {
          return size;
        }
        if (typeof customSize === "string") {
          return customSize !== null && customSize !== void 0 ? customSize : size;
        }
        if (customSize instanceof Function) {
          return customSize(size);
        }
        return size;
      }, [customSize, size]);
      return mergedSize;
    };
    const useSize$1 = useSize;
    const genSpaceCompactStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [componentCls]: {
          "&-block": {
            display: "flex",
            width: "100%"
          },
          "&-vertical": {
            flexDirection: "column"
          }
        }
      };
    };
    const genSpaceCompactStyle$1 = genSpaceCompactStyle;
    const genSpaceStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [componentCls]: {
          display: "inline-flex",
          "&-rtl": {
            direction: "rtl"
          },
          "&-vertical": {
            flexDirection: "column"
          },
          "&-align": {
            flexDirection: "column",
            "&-center": {
              alignItems: "center"
            },
            "&-start": {
              alignItems: "flex-start"
            },
            "&-end": {
              alignItems: "flex-end"
            },
            "&-baseline": {
              alignItems: "baseline"
            }
          },
          [`${componentCls}-item:empty`]: {
            display: "none"
          }
        }
      };
    };
    const genSpaceGapStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [componentCls]: {
          "&-gap-row-small": {
            rowGap: token2.spaceGapSmallSize
          },
          "&-gap-row-middle": {
            rowGap: token2.spaceGapMiddleSize
          },
          "&-gap-row-large": {
            rowGap: token2.spaceGapLargeSize
          },
          "&-gap-col-small": {
            columnGap: token2.spaceGapSmallSize
          },
          "&-gap-col-middle": {
            columnGap: token2.spaceGapMiddleSize
          },
          "&-gap-col-large": {
            columnGap: token2.spaceGapLargeSize
          }
        }
      };
    };
    const useStyle$k = genStyleHooks("Space", (token2) => {
      const spaceToken = merge$1(token2, {
        spaceGapSmallSize: token2.paddingXS,
        spaceGapMiddleSize: token2.padding,
        spaceGapLargeSize: token2.paddingLG
      });
      return [genSpaceStyle(spaceToken), genSpaceGapStyle(spaceToken), genSpaceCompactStyle$1(spaceToken)];
    }, () => ({}), {
      // Space component don't apply extra font style
      // https://github.com/ant-design/ant-design/issues/40315
      resetStyle: false
    });
    var __rest$E = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const SpaceCompactItemContext = /* @__PURE__ */ reactExports.createContext(null);
    const useCompactItemContext = (prefixCls, direction) => {
      const compactItemContext = reactExports.useContext(SpaceCompactItemContext);
      const compactItemClassnames = reactExports.useMemo(() => {
        if (!compactItemContext) {
          return "";
        }
        const {
          compactDirection,
          isFirstItem,
          isLastItem
        } = compactItemContext;
        const separator = compactDirection === "vertical" ? "-vertical-" : "-";
        return classNames(`${prefixCls}-compact${separator}item`, {
          [`${prefixCls}-compact${separator}first-item`]: isFirstItem,
          [`${prefixCls}-compact${separator}last-item`]: isLastItem,
          [`${prefixCls}-compact${separator}item-rtl`]: direction === "rtl"
        });
      }, [prefixCls, direction, compactItemContext]);
      return {
        compactSize: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactSize,
        compactDirection: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactDirection,
        compactItemClassnames
      };
    };
    const NoCompactStyle = (_ref) => {
      let {
        children
      } = _ref;
      return /* @__PURE__ */ reactExports.createElement(SpaceCompactItemContext.Provider, {
        value: null
      }, children);
    };
    const CompactItem = (_a) => {
      var {
        children
      } = _a, otherProps = __rest$E(_a, ["children"]);
      return /* @__PURE__ */ reactExports.createElement(SpaceCompactItemContext.Provider, {
        value: otherProps
      }, children);
    };
    const Compact = (props) => {
      const {
        getPrefixCls,
        direction: directionConfig
      } = reactExports.useContext(ConfigContext);
      const {
        size,
        direction,
        block,
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        children
      } = props, restProps = __rest$E(props, ["size", "direction", "block", "prefixCls", "className", "rootClassName", "children"]);
      const mergedSize = useSize$1((ctx) => size !== null && size !== void 0 ? size : ctx);
      const prefixCls = getPrefixCls("space-compact", customizePrefixCls);
      const [wrapCSSVar, hashId] = useStyle$k(prefixCls);
      const clx = classNames(prefixCls, hashId, {
        [`${prefixCls}-rtl`]: directionConfig === "rtl",
        [`${prefixCls}-block`]: block,
        [`${prefixCls}-vertical`]: direction === "vertical"
      }, className, rootClassName);
      const compactItemContext = reactExports.useContext(SpaceCompactItemContext);
      const childNodes = toArray$a(children);
      const nodes = reactExports.useMemo(() => childNodes.map((child, i) => {
        const key = child && child.key || `${prefixCls}-item-${i}`;
        return /* @__PURE__ */ reactExports.createElement(CompactItem, {
          key,
          compactSize: mergedSize,
          compactDirection: direction,
          isFirstItem: i === 0 && (!compactItemContext || (compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.isFirstItem)),
          isLastItem: i === childNodes.length - 1 && (!compactItemContext || (compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.isLastItem))
        }, child);
      }), [size, childNodes, compactItemContext]);
      if (childNodes.length === 0) {
        return null;
      }
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("div", Object.assign({
        className: clx
      }, restProps), nodes));
    };
    var __rest$D = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const GroupSizeContext = /* @__PURE__ */ reactExports.createContext(void 0);
    const ButtonGroup = (props) => {
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const {
        prefixCls: customizePrefixCls,
        size,
        className
      } = props, others = __rest$D(props, ["prefixCls", "size", "className"]);
      const prefixCls = getPrefixCls("btn-group", customizePrefixCls);
      const [, , hashId] = useToken$1();
      let sizeCls = "";
      switch (size) {
        case "large":
          sizeCls = "lg";
          break;
        case "small":
          sizeCls = "sm";
          break;
      }
      const classes = classNames(prefixCls, {
        [`${prefixCls}-${sizeCls}`]: sizeCls,
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, className, hashId);
      return /* @__PURE__ */ reactExports.createElement(GroupSizeContext.Provider, {
        value: size
      }, /* @__PURE__ */ reactExports.createElement("div", Object.assign({}, others, {
        className: classes
      })));
    };
    const Group$4 = ButtonGroup;
    const rxTwoCNChar = /^[\u4e00-\u9fa5]{2}$/;
    const isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
    function isString$2(str) {
      return typeof str === "string";
    }
    function isUnBorderedButtonType(type) {
      return type === "text" || type === "link";
    }
    function splitCNCharsBySpace(child, needInserted) {
      if (child === null || child === void 0) {
        return;
      }
      const SPACE = needInserted ? " " : "";
      if (typeof child !== "string" && typeof child !== "number" && isString$2(child.type) && isTwoCNChar(child.props.children)) {
        return cloneElement(child, {
          children: child.props.children.split("").join(SPACE)
        });
      }
      if (isString$2(child)) {
        return isTwoCNChar(child) ? /* @__PURE__ */ React.createElement("span", null, child.split("").join(SPACE)) : /* @__PURE__ */ React.createElement("span", null, child);
      }
      if (isFragment(child)) {
        return /* @__PURE__ */ React.createElement("span", null, child);
      }
      return child;
    }
    function spaceChildren(children, needInserted) {
      let isPrevChildPure = false;
      const childList = [];
      React.Children.forEach(children, (child) => {
        const type = typeof child;
        const isCurrentChildPure = type === "string" || type === "number";
        if (isPrevChildPure && isCurrentChildPure) {
          const lastIndex = childList.length - 1;
          const lastChild = childList[lastIndex];
          childList[lastIndex] = `${lastChild}${child}`;
        } else {
          childList.push(child);
        }
        isPrevChildPure = isCurrentChildPure;
      });
      return React.Children.map(childList, (child) => splitCNCharsBySpace(child, needInserted));
    }
    const IconWrapper = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        className,
        style: style2,
        children,
        prefixCls
      } = props;
      const iconWrapperCls = classNames(`${prefixCls}-icon`, className);
      return /* @__PURE__ */ React.createElement("span", {
        ref,
        className: iconWrapperCls,
        style: style2
      }, children);
    });
    const IconWrapper$1 = IconWrapper;
    const InnerLoadingIcon = /* @__PURE__ */ reactExports.forwardRef((_ref, ref) => {
      let {
        prefixCls,
        className,
        style: style2,
        iconClassName
      } = _ref;
      const mergedIconCls = classNames(`${prefixCls}-loading-icon`, className);
      return /* @__PURE__ */ React.createElement(IconWrapper$1, {
        prefixCls,
        className: mergedIconCls,
        style: style2,
        ref
      }, /* @__PURE__ */ React.createElement(LoadingOutlined$1, {
        className: iconClassName
      }));
    });
    const getCollapsedWidth = () => ({
      width: 0,
      opacity: 0,
      transform: "scale(0)"
    });
    const getRealWidth = (node2) => ({
      width: node2.scrollWidth,
      opacity: 1,
      transform: "scale(1)"
    });
    const LoadingIcon = (props) => {
      const {
        prefixCls,
        loading,
        existIcon,
        className,
        style: style2
      } = props;
      const visible = !!loading;
      if (existIcon) {
        return /* @__PURE__ */ React.createElement(InnerLoadingIcon, {
          prefixCls,
          className,
          style: style2
        });
      }
      return /* @__PURE__ */ React.createElement(CSSMotion, {
        visible,
        // We do not really use this motionName
        motionName: `${prefixCls}-loading-icon-motion`,
        motionLeave: visible,
        removeOnLeave: true,
        onAppearStart: getCollapsedWidth,
        onAppearActive: getRealWidth,
        onEnterStart: getCollapsedWidth,
        onEnterActive: getRealWidth,
        onLeaveStart: getRealWidth,
        onLeaveActive: getCollapsedWidth
      }, (_ref2, ref) => {
        let {
          className: motionCls,
          style: motionStyle
        } = _ref2;
        return /* @__PURE__ */ React.createElement(InnerLoadingIcon, {
          prefixCls,
          className,
          style: Object.assign(Object.assign({}, style2), motionStyle),
          ref,
          iconClassName: motionCls
        });
      });
    };
    const LoadingIcon$1 = LoadingIcon;
    const genButtonBorderStyle = (buttonTypeCls, borderColor) => ({
      // Border
      [`> span, > ${buttonTypeCls}`]: {
        "&:not(:last-child)": {
          [`&, & > ${buttonTypeCls}`]: {
            "&:not(:disabled)": {
              borderInlineEndColor: borderColor
            }
          }
        },
        "&:not(:first-child)": {
          [`&, & > ${buttonTypeCls}`]: {
            "&:not(:disabled)": {
              borderInlineStartColor: borderColor
            }
          }
        }
      }
    });
    const genGroupStyle$1 = (token2) => {
      const {
        componentCls,
        fontSize,
        lineWidth,
        groupBorderColor,
        colorErrorHover
      } = token2;
      return {
        [`${componentCls}-group`]: [
          {
            position: "relative",
            display: "inline-flex",
            // Border
            [`> span, > ${componentCls}`]: {
              "&:not(:last-child)": {
                [`&, & > ${componentCls}`]: {
                  borderStartEndRadius: 0,
                  borderEndEndRadius: 0
                }
              },
              "&:not(:first-child)": {
                marginInlineStart: token2.calc(lineWidth).mul(-1).equal(),
                [`&, & > ${componentCls}`]: {
                  borderStartStartRadius: 0,
                  borderEndStartRadius: 0
                }
              }
            },
            [componentCls]: {
              position: "relative",
              zIndex: 1,
              [`&:hover,
          &:focus,
          &:active`]: {
                zIndex: 2
              },
              "&[disabled]": {
                zIndex: 0
              }
            },
            [`${componentCls}-icon-only`]: {
              fontSize
            }
          },
          // Border Color
          genButtonBorderStyle(`${componentCls}-primary`, groupBorderColor),
          genButtonBorderStyle(`${componentCls}-danger`, colorErrorHover)
        ]
      };
    };
    const genGroupStyle$2 = genGroupStyle$1;
    const genSharedButtonStyle = (token2) => {
      const {
        componentCls,
        iconCls,
        fontWeight
      } = token2;
      return {
        [componentCls]: {
          outline: "none",
          position: "relative",
          display: "inline-block",
          fontWeight,
          whiteSpace: "nowrap",
          textAlign: "center",
          backgroundImage: "none",
          background: "transparent",
          border: `${unit$1(token2.lineWidth)} ${token2.lineType} transparent`,
          cursor: "pointer",
          transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
          userSelect: "none",
          touchAction: "manipulation",
          lineHeight: token2.lineHeight,
          color: token2.colorText,
          "&:disabled > *": {
            pointerEvents: "none"
          },
          "> span": {
            display: "inline-block"
          },
          [`${componentCls}-icon`]: {
            lineHeight: 0
          },
          // Leave a space between icon and text.
          [`> ${iconCls} + span, > span + ${iconCls}`]: {
            marginInlineStart: token2.marginXS
          },
          [`&:not(${componentCls}-icon-only) > ${componentCls}-icon`]: {
            [`&${componentCls}-loading-icon, &:not(:last-child)`]: {
              marginInlineEnd: token2.marginXS
            }
          },
          "> a": {
            color: "currentColor"
          },
          "&:not(:disabled)": Object.assign({}, genFocusStyle(token2)),
          [`&${componentCls}-two-chinese-chars::first-letter`]: {
            letterSpacing: "0.34em"
          },
          [`&${componentCls}-two-chinese-chars > *:not(${iconCls})`]: {
            marginInlineEnd: "-0.34em",
            letterSpacing: "0.34em"
          },
          // make `btn-icon-only` not too narrow
          [`&-icon-only${componentCls}-compact-item`]: {
            flex: "none"
          }
        }
      };
    };
    const genHoverActiveButtonStyle = (btnCls, hoverStyle, activeStyle) => ({
      [`&:not(:disabled):not(${btnCls}-disabled)`]: {
        "&:hover": hoverStyle,
        "&:active": activeStyle
      }
    });
    const genCircleButtonStyle = (token2) => ({
      minWidth: token2.controlHeight,
      paddingInlineStart: 0,
      paddingInlineEnd: 0,
      borderRadius: "50%"
    });
    const genRoundButtonStyle = (token2) => ({
      borderRadius: token2.controlHeight,
      paddingInlineStart: token2.calc(token2.controlHeight).div(2).equal(),
      paddingInlineEnd: token2.calc(token2.controlHeight).div(2).equal()
    });
    const genDisabledStyle$1 = (token2) => ({
      cursor: "not-allowed",
      borderColor: token2.borderColorDisabled,
      color: token2.colorTextDisabled,
      background: token2.colorBgContainerDisabled,
      boxShadow: "none"
    });
    const genGhostButtonStyle = (btnCls, background, textColor, borderColor, textColorDisabled, borderColorDisabled, hoverStyle, activeStyle) => ({
      [`&${btnCls}-background-ghost`]: Object.assign(Object.assign({
        color: textColor || void 0,
        background,
        borderColor: borderColor || void 0,
        boxShadow: "none"
      }, genHoverActiveButtonStyle(btnCls, Object.assign({
        background
      }, hoverStyle), Object.assign({
        background
      }, activeStyle))), {
        "&:disabled": {
          cursor: "not-allowed",
          color: textColorDisabled || void 0,
          borderColor: borderColorDisabled || void 0
        }
      })
    });
    const genSolidDisabledButtonStyle = (token2) => ({
      [`&:disabled, &${token2.componentCls}-disabled`]: Object.assign({}, genDisabledStyle$1(token2))
    });
    const genSolidButtonStyle = (token2) => Object.assign({}, genSolidDisabledButtonStyle(token2));
    const genPureDisabledButtonStyle = (token2) => ({
      [`&:disabled, &${token2.componentCls}-disabled`]: {
        cursor: "not-allowed",
        color: token2.colorTextDisabled
      }
    });
    const genDefaultButtonStyle = (token2) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genSolidButtonStyle(token2)), {
      background: token2.defaultBg,
      borderColor: token2.defaultBorderColor,
      color: token2.defaultColor,
      boxShadow: token2.defaultShadow
    }), genHoverActiveButtonStyle(token2.componentCls, {
      color: token2.colorPrimaryHover,
      borderColor: token2.colorPrimaryHover
    }, {
      color: token2.colorPrimaryActive,
      borderColor: token2.colorPrimaryActive
    })), genGhostButtonStyle(token2.componentCls, token2.ghostBg, token2.defaultGhostColor, token2.defaultGhostBorderColor, token2.colorTextDisabled, token2.colorBorder)), {
      [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign(Object.assign({
        color: token2.colorError,
        borderColor: token2.colorError
      }, genHoverActiveButtonStyle(token2.componentCls, {
        color: token2.colorErrorHover,
        borderColor: token2.colorErrorBorderHover
      }, {
        color: token2.colorErrorActive,
        borderColor: token2.colorErrorActive
      })), genGhostButtonStyle(token2.componentCls, token2.ghostBg, token2.colorError, token2.colorError, token2.colorTextDisabled, token2.colorBorder)), genSolidDisabledButtonStyle(token2))
    });
    const genPrimaryButtonStyle = (token2) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genSolidButtonStyle(token2)), {
      color: token2.primaryColor,
      background: token2.colorPrimary,
      boxShadow: token2.primaryShadow
    }), genHoverActiveButtonStyle(token2.componentCls, {
      color: token2.colorTextLightSolid,
      background: token2.colorPrimaryHover
    }, {
      color: token2.colorTextLightSolid,
      background: token2.colorPrimaryActive
    })), genGhostButtonStyle(token2.componentCls, token2.ghostBg, token2.colorPrimary, token2.colorPrimary, token2.colorTextDisabled, token2.colorBorder, {
      color: token2.colorPrimaryHover,
      borderColor: token2.colorPrimaryHover
    }, {
      color: token2.colorPrimaryActive,
      borderColor: token2.colorPrimaryActive
    })), {
      [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign(Object.assign({
        background: token2.colorError,
        boxShadow: token2.dangerShadow,
        color: token2.dangerColor
      }, genHoverActiveButtonStyle(token2.componentCls, {
        background: token2.colorErrorHover
      }, {
        background: token2.colorErrorActive
      })), genGhostButtonStyle(token2.componentCls, token2.ghostBg, token2.colorError, token2.colorError, token2.colorTextDisabled, token2.colorBorder, {
        color: token2.colorErrorHover,
        borderColor: token2.colorErrorHover
      }, {
        color: token2.colorErrorActive,
        borderColor: token2.colorErrorActive
      })), genSolidDisabledButtonStyle(token2))
    });
    const genDashedButtonStyle = (token2) => Object.assign(Object.assign({}, genDefaultButtonStyle(token2)), {
      borderStyle: "dashed"
    });
    const genLinkButtonStyle = (token2) => Object.assign(Object.assign(Object.assign({
      color: token2.colorLink
    }, genHoverActiveButtonStyle(token2.componentCls, {
      color: token2.colorLinkHover,
      background: token2.linkHoverBg
    }, {
      color: token2.colorLinkActive
    })), genPureDisabledButtonStyle(token2)), {
      [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign({
        color: token2.colorError
      }, genHoverActiveButtonStyle(token2.componentCls, {
        color: token2.colorErrorHover
      }, {
        color: token2.colorErrorActive
      })), genPureDisabledButtonStyle(token2))
    });
    const genTextButtonStyle = (token2) => Object.assign(Object.assign(Object.assign({}, genHoverActiveButtonStyle(token2.componentCls, {
      color: token2.colorText,
      background: token2.textHoverBg
    }, {
      color: token2.colorText,
      background: token2.colorBgTextActive
    })), genPureDisabledButtonStyle(token2)), {
      [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign({
        color: token2.colorError
      }, genPureDisabledButtonStyle(token2)), genHoverActiveButtonStyle(token2.componentCls, {
        color: token2.colorErrorHover,
        background: token2.colorErrorBg
      }, {
        color: token2.colorErrorHover,
        background: token2.colorErrorBg
      }))
    });
    const genTypeButtonStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}-default`]: genDefaultButtonStyle(token2),
        [`${componentCls}-primary`]: genPrimaryButtonStyle(token2),
        [`${componentCls}-dashed`]: genDashedButtonStyle(token2),
        [`${componentCls}-link`]: genLinkButtonStyle(token2),
        [`${componentCls}-text`]: genTextButtonStyle(token2),
        [`${componentCls}-ghost`]: genGhostButtonStyle(token2.componentCls, token2.ghostBg, token2.colorBgContainer, token2.colorBgContainer, token2.colorTextDisabled, token2.colorBorder)
      };
    };
    const genSizeButtonStyle = function(token2) {
      let sizePrefixCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      const {
        componentCls,
        controlHeight,
        fontSize,
        borderRadius,
        buttonPaddingHorizontal,
        iconCls,
        buttonPaddingVertical
      } = token2;
      const iconOnlyCls = `${componentCls}-icon-only`;
      return [
        // Size
        {
          [`${componentCls}${sizePrefixCls}`]: {
            fontSize,
            height: controlHeight,
            padding: `${unit$1(buttonPaddingVertical)} ${unit$1(buttonPaddingHorizontal)}`,
            borderRadius,
            [`&${iconOnlyCls}`]: {
              width: controlHeight,
              paddingInlineStart: 0,
              paddingInlineEnd: 0,
              [`&${componentCls}-round`]: {
                width: "auto"
              },
              [iconCls]: {
                fontSize: token2.buttonIconOnlyFontSize
              }
            },
            // Loading
            [`&${componentCls}-loading`]: {
              opacity: token2.opacityLoading,
              cursor: "default"
            },
            [`${componentCls}-loading-icon`]: {
              transition: `width ${token2.motionDurationSlow} ${token2.motionEaseInOut}, opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut}`
            }
          }
        },
        // Shape - patch prefixCls again to override solid border radius style
        {
          [`${componentCls}${componentCls}-circle${sizePrefixCls}`]: genCircleButtonStyle(token2)
        },
        {
          [`${componentCls}${componentCls}-round${sizePrefixCls}`]: genRoundButtonStyle(token2)
        }
      ];
    };
    const genSizeBaseButtonStyle = (token2) => genSizeButtonStyle(merge$1(token2, {
      fontSize: token2.contentFontSize
    }));
    const genSizeSmallButtonStyle = (token2) => {
      const smallToken = merge$1(token2, {
        controlHeight: token2.controlHeightSM,
        fontSize: token2.contentFontSizeSM,
        padding: token2.paddingXS,
        buttonPaddingHorizontal: token2.paddingInlineSM,
        buttonPaddingVertical: token2.paddingBlockSM,
        borderRadius: token2.borderRadiusSM,
        buttonIconOnlyFontSize: token2.onlyIconSizeSM
      });
      return genSizeButtonStyle(smallToken, `${token2.componentCls}-sm`);
    };
    const genSizeLargeButtonStyle = (token2) => {
      const largeToken = merge$1(token2, {
        controlHeight: token2.controlHeightLG,
        fontSize: token2.contentFontSizeLG,
        buttonPaddingHorizontal: token2.paddingInlineLG,
        buttonPaddingVertical: token2.paddingBlockLG,
        borderRadius: token2.borderRadiusLG,
        buttonIconOnlyFontSize: token2.onlyIconSizeLG
      });
      return genSizeButtonStyle(largeToken, `${token2.componentCls}-lg`);
    };
    const genBlockButtonStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [componentCls]: {
          [`&${componentCls}-block`]: {
            width: "100%"
          }
        }
      };
    };
    const prepareToken$3 = (token2) => {
      const {
        paddingInline,
        onlyIconSize,
        paddingBlock
      } = token2;
      const buttonToken = merge$1(token2, {
        buttonPaddingHorizontal: paddingInline,
        buttonPaddingVertical: paddingBlock,
        buttonIconOnlyFontSize: onlyIconSize
      });
      return buttonToken;
    };
    const prepareComponentToken$g = (token2) => {
      const contentFontSize = token2.fontSize;
      const contentFontSizeSM = token2.fontSize;
      const contentFontSizeLG = token2.fontSizeLG;
      return {
        fontWeight: 400,
        defaultShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlTmpOutline}`,
        primaryShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlOutline}`,
        dangerShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.colorErrorOutline}`,
        primaryColor: token2.colorTextLightSolid,
        dangerColor: token2.colorTextLightSolid,
        borderColorDisabled: token2.colorBorder,
        defaultGhostColor: token2.colorBgContainer,
        ghostBg: "transparent",
        defaultGhostBorderColor: token2.colorBgContainer,
        paddingInline: token2.paddingContentHorizontal - token2.lineWidth,
        paddingInlineLG: token2.paddingContentHorizontal - token2.lineWidth,
        paddingInlineSM: 8 - token2.lineWidth,
        paddingBlock: Math.max((token2.controlHeight - contentFontSize * token2.lineHeight) / 2 - token2.lineWidth, 0),
        paddingBlockSM: Math.max((token2.controlHeightSM - contentFontSizeSM * token2.lineHeight) / 2 - token2.lineWidth, 0),
        paddingBlockLG: Math.max((token2.controlHeightLG - contentFontSizeLG * token2.lineHeight) / 2 - token2.lineWidth, 0),
        onlyIconSize: token2.fontSizeLG,
        onlyIconSizeSM: token2.fontSizeLG - 2,
        onlyIconSizeLG: token2.fontSizeLG + 2,
        groupBorderColor: token2.colorPrimaryHover,
        linkHoverBg: "transparent",
        textHoverBg: token2.colorBgTextHover,
        defaultColor: token2.colorText,
        defaultBg: token2.colorBgContainer,
        defaultBorderColor: token2.colorBorder,
        defaultBorderColorDisabled: token2.colorBorder,
        contentFontSize,
        contentFontSizeSM,
        contentFontSizeLG
      };
    };
    const useStyle$j = genStyleHooks("Button", (token2) => {
      const buttonToken = prepareToken$3(token2);
      return [
        // Shared
        genSharedButtonStyle(buttonToken),
        // Size
        genSizeSmallButtonStyle(buttonToken),
        genSizeBaseButtonStyle(buttonToken),
        genSizeLargeButtonStyle(buttonToken),
        // Block
        genBlockButtonStyle(buttonToken),
        // Group (type, ghost, danger, loading)
        genTypeButtonStyle(buttonToken),
        // Button Group
        genGroupStyle$2(buttonToken)
      ];
    }, prepareComponentToken$g, {
      unitless: {
        fontWeight: true
      }
    });
    function compactItemBorder(token2, parentCls, options) {
      const {
        focusElCls,
        focus,
        borderElCls
      } = options;
      const childCombinator = borderElCls ? "> *" : "";
      const hoverEffects = ["hover", focus ? "focus" : null, "active"].filter(Boolean).map((n2) => `&:${n2} ${childCombinator}`).join(",");
      return {
        [`&-item:not(${parentCls}-last-item)`]: {
          marginInlineEnd: token2.calc(token2.lineWidth).mul(-1).equal()
        },
        "&-item": Object.assign(Object.assign({
          [hoverEffects]: {
            zIndex: 2
          }
        }, focusElCls ? {
          [`&${focusElCls}`]: {
            zIndex: 2
          }
        } : {}), {
          [`&[disabled] ${childCombinator}`]: {
            zIndex: 0
          }
        })
      };
    }
    function compactItemBorderRadius(prefixCls, parentCls, options) {
      const {
        borderElCls
      } = options;
      const childCombinator = borderElCls ? `> ${borderElCls}` : "";
      return {
        [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item) ${childCombinator}`]: {
          borderRadius: 0
        },
        [`&-item:not(${parentCls}-last-item)${parentCls}-first-item`]: {
          [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        },
        [`&-item:not(${parentCls}-first-item)${parentCls}-last-item`]: {
          [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          }
        }
      };
    }
    function genCompactItemStyle(token2) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        focus: true
      };
      const {
        componentCls
      } = token2;
      const compactCls = `${componentCls}-compact`;
      return {
        [compactCls]: Object.assign(Object.assign({}, compactItemBorder(token2, compactCls, options)), compactItemBorderRadius(componentCls, compactCls, options))
      };
    }
    function compactItemVerticalBorder(token2, parentCls) {
      return {
        // border collapse
        [`&-item:not(${parentCls}-last-item)`]: {
          marginBottom: token2.calc(token2.lineWidth).mul(-1).equal()
        },
        "&-item": {
          "&:hover,&:focus,&:active": {
            zIndex: 2
          },
          "&[disabled]": {
            zIndex: 0
          }
        }
      };
    }
    function compactItemBorderVerticalRadius(prefixCls, parentCls) {
      return {
        [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item)`]: {
          borderRadius: 0
        },
        [`&-item${parentCls}-first-item:not(${parentCls}-last-item)`]: {
          [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
            borderEndEndRadius: 0,
            borderEndStartRadius: 0
          }
        },
        [`&-item${parentCls}-last-item:not(${parentCls}-first-item)`]: {
          [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
            borderStartStartRadius: 0,
            borderStartEndRadius: 0
          }
        }
      };
    }
    function genCompactItemVerticalStyle(token2) {
      const compactCls = `${token2.componentCls}-compact-vertical`;
      return {
        [compactCls]: Object.assign(Object.assign({}, compactItemVerticalBorder(token2, compactCls)), compactItemBorderVerticalRadius(token2.componentCls, compactCls))
      };
    }
    const genButtonCompactStyle = (token2) => {
      const {
        componentCls,
        calc
      } = token2;
      return {
        [componentCls]: {
          // Special styles for Primary Button
          [`&-compact-item${componentCls}-primary`]: {
            [`&:not([disabled]) + ${componentCls}-compact-item${componentCls}-primary:not([disabled])`]: {
              position: "relative",
              "&:before": {
                position: "absolute",
                top: calc(token2.lineWidth).mul(-1).equal(),
                insetInlineStart: calc(token2.lineWidth).mul(-1).equal(),
                display: "inline-block",
                width: token2.lineWidth,
                height: `calc(100% + ${unit$1(token2.lineWidth)} * 2)`,
                backgroundColor: token2.colorPrimaryHover,
                content: '""'
              }
            }
          },
          // Special styles for Primary Button
          "&-compact-vertical-item": {
            [`&${componentCls}-primary`]: {
              [`&:not([disabled]) + ${componentCls}-compact-vertical-item${componentCls}-primary:not([disabled])`]: {
                position: "relative",
                "&:before": {
                  position: "absolute",
                  top: calc(token2.lineWidth).mul(-1).equal(),
                  insetInlineStart: calc(token2.lineWidth).mul(-1).equal(),
                  display: "inline-block",
                  width: `calc(100% + ${unit$1(token2.lineWidth)} * 2)`,
                  height: token2.lineWidth,
                  backgroundColor: token2.colorPrimaryHover,
                  content: '""'
                }
              }
            }
          }
        }
      };
    };
    const CompactCmp = genSubStyleComponent(["Button", "compact"], (token2) => {
      const buttonToken = prepareToken$3(token2);
      return [
        // Space Compact
        genCompactItemStyle(buttonToken),
        genCompactItemVerticalStyle(buttonToken),
        genButtonCompactStyle(buttonToken)
      ];
    }, prepareComponentToken$g);
    var __rest$C = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    function getLoadingConfig(loading) {
      if (typeof loading === "object" && loading) {
        let delay = loading === null || loading === void 0 ? void 0 : loading.delay;
        delay = !Number.isNaN(delay) && typeof delay === "number" ? delay : 0;
        return {
          loading: delay <= 0,
          delay
        };
      }
      return {
        loading: !!loading,
        delay: 0
      };
    }
    const InternalButton = (props, ref) => {
      var _a, _b;
      const {
        loading = false,
        prefixCls: customizePrefixCls,
        type = "default",
        danger,
        shape = "default",
        size: customizeSize,
        styles,
        disabled: customDisabled,
        className,
        rootClassName,
        children,
        icon,
        ghost = false,
        block = false,
        // React does not recognize the `htmlType` prop on a DOM element. Here we pick it out of `rest`.
        htmlType = "button",
        classNames: customClassNames,
        style: customStyle = {}
      } = props, rest = __rest$C(props, ["loading", "prefixCls", "type", "danger", "shape", "size", "styles", "disabled", "className", "rootClassName", "children", "icon", "ghost", "block", "htmlType", "classNames", "style"]);
      const {
        getPrefixCls,
        autoInsertSpaceInButton,
        direction,
        button
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("btn", customizePrefixCls);
      const [wrapCSSVar, hashId] = useStyle$j(prefixCls);
      const disabled = reactExports.useContext(DisabledContext$1);
      const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
      const groupSize = reactExports.useContext(GroupSizeContext);
      const loadingOrDelay = reactExports.useMemo(() => getLoadingConfig(loading), [loading]);
      const [innerLoading, setLoading] = reactExports.useState(loadingOrDelay.loading);
      const [hasTwoCNChar, setHasTwoCNChar] = reactExports.useState(false);
      const internalRef = /* @__PURE__ */ reactExports.createRef();
      const buttonRef = composeRef(ref, internalRef);
      const needInserted = reactExports.Children.count(children) === 1 && !icon && !isUnBorderedButtonType(type);
      reactExports.useEffect(() => {
        let delayTimer = null;
        if (loadingOrDelay.delay > 0) {
          delayTimer = setTimeout(() => {
            delayTimer = null;
            setLoading(true);
          }, loadingOrDelay.delay);
        } else {
          setLoading(loadingOrDelay.loading);
        }
        function cleanupTimer() {
          if (delayTimer) {
            clearTimeout(delayTimer);
            delayTimer = null;
          }
        }
        return cleanupTimer;
      }, [loadingOrDelay]);
      reactExports.useEffect(() => {
        if (!buttonRef || !buttonRef.current || autoInsertSpaceInButton === false) {
          return;
        }
        const buttonText = buttonRef.current.textContent;
        if (needInserted && isTwoCNChar(buttonText)) {
          if (!hasTwoCNChar) {
            setHasTwoCNChar(true);
          }
        } else if (hasTwoCNChar) {
          setHasTwoCNChar(false);
        }
      }, [buttonRef]);
      const handleClick = (e2) => {
        const {
          onClick
        } = props;
        if (innerLoading || mergedDisabled) {
          e2.preventDefault();
          return;
        }
        onClick === null || onClick === void 0 ? void 0 : onClick(e2);
      };
      const autoInsertSpace = autoInsertSpaceInButton !== false;
      const {
        compactSize,
        compactItemClassnames
      } = useCompactItemContext(prefixCls, direction);
      const sizeClassNameMap = {
        large: "lg",
        small: "sm",
        middle: void 0
      };
      const sizeFullName = useSize$1((ctxSize) => {
        var _a2, _b2;
        return (_b2 = (_a2 = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a2 !== void 0 ? _a2 : groupSize) !== null && _b2 !== void 0 ? _b2 : ctxSize;
      });
      const sizeCls = sizeFullName ? sizeClassNameMap[sizeFullName] || "" : "";
      const iconType = innerLoading ? "loading" : icon;
      const linkButtonRestProps = omit(rest, ["navigate"]);
      const classes = classNames(prefixCls, hashId, {
        [`${prefixCls}-${shape}`]: shape !== "default" && shape,
        [`${prefixCls}-${type}`]: type,
        [`${prefixCls}-${sizeCls}`]: sizeCls,
        [`${prefixCls}-icon-only`]: !children && children !== 0 && !!iconType,
        [`${prefixCls}-background-ghost`]: ghost && !isUnBorderedButtonType(type),
        [`${prefixCls}-loading`]: innerLoading,
        [`${prefixCls}-two-chinese-chars`]: hasTwoCNChar && autoInsertSpace && !innerLoading,
        [`${prefixCls}-block`]: block,
        [`${prefixCls}-dangerous`]: !!danger,
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, compactItemClassnames, className, rootClassName, button === null || button === void 0 ? void 0 : button.className);
      const fullStyle = Object.assign(Object.assign({}, button === null || button === void 0 ? void 0 : button.style), customStyle);
      const iconClasses = classNames(customClassNames === null || customClassNames === void 0 ? void 0 : customClassNames.icon, (_a = button === null || button === void 0 ? void 0 : button.classNames) === null || _a === void 0 ? void 0 : _a.icon);
      const iconStyle = Object.assign(Object.assign({}, (styles === null || styles === void 0 ? void 0 : styles.icon) || {}), ((_b = button === null || button === void 0 ? void 0 : button.styles) === null || _b === void 0 ? void 0 : _b.icon) || {});
      const iconNode = icon && !innerLoading ? /* @__PURE__ */ React.createElement(IconWrapper$1, {
        prefixCls,
        className: iconClasses,
        style: iconStyle
      }, icon) : /* @__PURE__ */ React.createElement(LoadingIcon$1, {
        existIcon: !!icon,
        prefixCls,
        loading: !!innerLoading
      });
      const kids = children || children === 0 ? spaceChildren(children, needInserted && autoInsertSpace) : null;
      if (linkButtonRestProps.href !== void 0) {
        return wrapCSSVar(/* @__PURE__ */ React.createElement("a", Object.assign({}, linkButtonRestProps, {
          className: classNames(classes, {
            [`${prefixCls}-disabled`]: mergedDisabled
          }),
          href: mergedDisabled ? void 0 : linkButtonRestProps.href,
          style: fullStyle,
          onClick: handleClick,
          ref: buttonRef,
          tabIndex: mergedDisabled ? -1 : 0
        }), iconNode, kids));
      }
      let buttonNode = /* @__PURE__ */ React.createElement("button", Object.assign({}, rest, {
        type: htmlType,
        className: classes,
        style: fullStyle,
        onClick: handleClick,
        disabled: mergedDisabled,
        ref: buttonRef
      }), iconNode, kids, compactItemClassnames && /* @__PURE__ */ React.createElement(CompactCmp, {
        key: "compact",
        prefixCls
      }));
      if (!isUnBorderedButtonType(type)) {
        buttonNode = /* @__PURE__ */ React.createElement(Wave$1, {
          component: "Button",
          disabled: !!innerLoading
        }, buttonNode);
      }
      return wrapCSSVar(buttonNode);
    };
    const Button$1 = /* @__PURE__ */ reactExports.forwardRef(InternalButton);
    Button$1.Group = Group$4;
    Button$1.__ANT_BUTTON = true;
    const Button$2 = Button$1;
    var OrderContext = /* @__PURE__ */ reactExports.createContext(null);
    var EMPTY_LIST$4 = [];
    function useDom(render2, debug) {
      var _React$useState = reactExports.useState(function() {
        if (!canUseDom()) {
          return null;
        }
        var defaultEle = document.createElement("div");
        return defaultEle;
      }), _React$useState2 = _slicedToArray(_React$useState, 1), ele = _React$useState2[0];
      var appendedRef = reactExports.useRef(false);
      var queueCreate = reactExports.useContext(OrderContext);
      var _React$useState3 = reactExports.useState(EMPTY_LIST$4), _React$useState4 = _slicedToArray(_React$useState3, 2), queue = _React$useState4[0], setQueue = _React$useState4[1];
      var mergedQueueCreate = queueCreate || (appendedRef.current ? void 0 : function(appendFn) {
        setQueue(function(origin) {
          var newQueue = [appendFn].concat(_toConsumableArray(origin));
          return newQueue;
        });
      });
      function append2() {
        if (!ele.parentElement) {
          document.body.appendChild(ele);
        }
        appendedRef.current = true;
      }
      function cleanup2() {
        var _ele$parentElement;
        (_ele$parentElement = ele.parentElement) === null || _ele$parentElement === void 0 ? void 0 : _ele$parentElement.removeChild(ele);
        appendedRef.current = false;
      }
      useLayoutEffect$1(function() {
        if (render2) {
          if (queueCreate) {
            queueCreate(append2);
          } else {
            append2();
          }
        } else {
          cleanup2();
        }
        return cleanup2;
      }, [render2]);
      useLayoutEffect$1(function() {
        if (queue.length) {
          queue.forEach(function(appendFn) {
            return appendFn();
          });
          setQueue(EMPTY_LIST$4);
        }
      }, [queue]);
      return [ele, mergedQueueCreate];
    }
    var cached;
    function getScrollBarSize(fresh) {
      if (typeof document === "undefined") {
        return 0;
      }
      if (fresh || cached === void 0) {
        var inner = document.createElement("div");
        inner.style.width = "100%";
        inner.style.height = "200px";
        var outer = document.createElement("div");
        var outerStyle = outer.style;
        outerStyle.position = "absolute";
        outerStyle.top = "0";
        outerStyle.left = "0";
        outerStyle.pointerEvents = "none";
        outerStyle.visibility = "hidden";
        outerStyle.width = "200px";
        outerStyle.height = "150px";
        outerStyle.overflow = "hidden";
        outer.appendChild(inner);
        document.body.appendChild(outer);
        var widthContained = inner.offsetWidth;
        outer.style.overflow = "scroll";
        var widthScroll = inner.offsetWidth;
        if (widthContained === widthScroll) {
          widthScroll = outer.clientWidth;
        }
        document.body.removeChild(outer);
        cached = widthContained - widthScroll;
      }
      return cached;
    }
    function ensureSize(str) {
      var match5 = str.match(/^(.*)px$/);
      var value = Number(match5 === null || match5 === void 0 ? void 0 : match5[1]);
      return Number.isNaN(value) ? getScrollBarSize() : value;
    }
    function getTargetScrollBarSize(target) {
      if (typeof document === "undefined" || !target || !(target instanceof Element)) {
        return {
          width: 0,
          height: 0
        };
      }
      var _getComputedStyle = getComputedStyle(target, "::-webkit-scrollbar"), width = _getComputedStyle.width, height = _getComputedStyle.height;
      return {
        width: ensureSize(width),
        height: ensureSize(height)
      };
    }
    function isBodyOverflowing() {
      return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
    }
    var UNIQUE_ID = "rc-util-locker-".concat(Date.now());
    var uuid$3 = 0;
    function useScrollLocker(lock) {
      var mergedLock = !!lock;
      var _React$useState = reactExports.useState(function() {
        uuid$3 += 1;
        return "".concat(UNIQUE_ID, "_").concat(uuid$3);
      }), _React$useState2 = _slicedToArray(_React$useState, 1), id2 = _React$useState2[0];
      useLayoutEffect$1(function() {
        if (mergedLock) {
          var scrollbarSize = getTargetScrollBarSize(document.body).width;
          var isOverflow = isBodyOverflowing();
          updateCSS("\nhtml body {\n  overflow-y: hidden;\n  ".concat(isOverflow ? "width: calc(100% - ".concat(scrollbarSize, "px);") : "", "\n}"), id2);
        } else {
          removeCSS(id2);
        }
        return function() {
          removeCSS(id2);
        };
      }, [mergedLock, id2]);
    }
    var inline = false;
    function inlineMock(nextInline) {
      if (typeof nextInline === "boolean") {
        inline = nextInline;
      }
      return inline;
    }
    var getPortalContainer = function getPortalContainer2(getContainer2) {
      if (getContainer2 === false) {
        return false;
      }
      if (!canUseDom() || !getContainer2) {
        return null;
      }
      if (typeof getContainer2 === "string") {
        return document.querySelector(getContainer2);
      }
      if (typeof getContainer2 === "function") {
        return getContainer2();
      }
      return getContainer2;
    };
    var Portal = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var open = props.open, autoLock = props.autoLock, getContainer2 = props.getContainer;
      props.debug;
      var _props$autoDestroy = props.autoDestroy, autoDestroy = _props$autoDestroy === void 0 ? true : _props$autoDestroy, children = props.children;
      var _React$useState = reactExports.useState(open), _React$useState2 = _slicedToArray(_React$useState, 2), shouldRender = _React$useState2[0], setShouldRender = _React$useState2[1];
      var mergedRender = shouldRender || open;
      reactExports.useEffect(function() {
        if (autoDestroy || open) {
          setShouldRender(open);
        }
      }, [open, autoDestroy]);
      var _React$useState3 = reactExports.useState(function() {
        return getPortalContainer(getContainer2);
      }), _React$useState4 = _slicedToArray(_React$useState3, 2), innerContainer = _React$useState4[0], setInnerContainer = _React$useState4[1];
      reactExports.useEffect(function() {
        var customizeContainer = getPortalContainer(getContainer2);
        setInnerContainer(customizeContainer !== null && customizeContainer !== void 0 ? customizeContainer : null);
      });
      var _useDom = useDom(mergedRender && !innerContainer), _useDom2 = _slicedToArray(_useDom, 2), defaultContainer2 = _useDom2[0], queueCreate = _useDom2[1];
      var mergedContainer = innerContainer !== null && innerContainer !== void 0 ? innerContainer : defaultContainer2;
      useScrollLocker(autoLock && open && canUseDom() && (mergedContainer === defaultContainer2 || mergedContainer === document.body));
      var childRef = null;
      if (children && supportRef(children) && ref) {
        var _ref = children;
        childRef = _ref.ref;
      }
      var mergedRef = useComposeRef(childRef, ref);
      if (!mergedRender || !canUseDom() || innerContainer === void 0) {
        return null;
      }
      var renderInline = mergedContainer === false || inlineMock();
      var reffedChildren = children;
      if (ref) {
        reffedChildren = /* @__PURE__ */ reactExports.cloneElement(children, {
          ref: mergedRef
        });
      }
      return /* @__PURE__ */ reactExports.createElement(OrderContext.Provider, {
        value: queueCreate
      }, renderInline ? reffedChildren : /* @__PURE__ */ reactDomExports.createPortal(reffedChildren, mergedContainer));
    });
    function getUseId() {
      var fullClone2 = _objectSpread2({}, React$1);
      return fullClone2.useId;
    }
    var uuid$2 = 0;
    var useOriginId = getUseId();
    const useId$2 = useOriginId ? (
      // Use React `useId`
      function useId2(id2) {
        var reactId = useOriginId();
        if (id2) {
          return id2;
        }
        return reactId;
      }
    ) : (
      // Use compatible of `useId`
      function useCompatId(id2) {
        var _React$useState = reactExports.useState("ssr-id"), _React$useState2 = _slicedToArray(_React$useState, 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
        reactExports.useEffect(function() {
          var nextId = uuid$2;
          uuid$2 += 1;
          setInnerId("rc_unique_".concat(nextId));
        }, []);
        if (id2) {
          return id2;
        }
        return innerId;
      }
    );
    var isStyleNameSupport = function isStyleNameSupport2(styleName) {
      if (canUseDom() && window.document.documentElement) {
        var styleNameList = Array.isArray(styleName) ? styleName : [styleName];
        var documentElement = window.document.documentElement;
        return styleNameList.some(function(name) {
          return name in documentElement.style;
        });
      }
      return false;
    };
    var isStyleValueSupport = function isStyleValueSupport2(styleName, value) {
      if (!isStyleNameSupport(styleName)) {
        return false;
      }
      var ele = document.createElement("div");
      var origin = ele.style[styleName];
      ele.style[styleName] = value;
      return ele.style[styleName] !== origin;
    };
    function isStyleSupport(styleName, styleValue) {
      if (!Array.isArray(styleName) && styleValue !== void 0) {
        return isStyleValueSupport(styleName, styleValue);
      }
      return isStyleNameSupport(styleName);
    }
    var HOOK_MARK = "RC_FORM_INTERNAL_HOOKS";
    var warningFunc = function warningFunc2() {
      warningOnce(false, "Can not find FormContext. Please make sure you wrap Field under Form.");
    };
    var Context = /* @__PURE__ */ reactExports.createContext({
      getFieldValue: warningFunc,
      getFieldsValue: warningFunc,
      getFieldError: warningFunc,
      getFieldWarning: warningFunc,
      getFieldsError: warningFunc,
      isFieldsTouched: warningFunc,
      isFieldTouched: warningFunc,
      isFieldValidating: warningFunc,
      isFieldsValidating: warningFunc,
      resetFields: warningFunc,
      setFields: warningFunc,
      setFieldValue: warningFunc,
      setFieldsValue: warningFunc,
      validateFields: warningFunc,
      submit: warningFunc,
      getInternalHooks: function getInternalHooks() {
        warningFunc();
        return {
          dispatch: warningFunc,
          initEntityValue: warningFunc,
          registerField: warningFunc,
          useSubscribe: warningFunc,
          setInitialValues: warningFunc,
          destroyForm: warningFunc,
          setCallbacks: warningFunc,
          registerWatch: warningFunc,
          getFields: warningFunc,
          setValidateMessages: warningFunc,
          setPreserve: warningFunc,
          getInitialValue: warningFunc
        };
      }
    });
    var ListContext = /* @__PURE__ */ reactExports.createContext(null);
    function toArray$9(value) {
      if (value === void 0 || value === null) {
        return [];
      }
      return Array.isArray(value) ? value : [value];
    }
    function isFormInstance(form) {
      return form && !!form._init;
    }
    var define_process_env_default = {};
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o2) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o22) {
        return o22.__proto__ || Object.getPrototypeOf(o22);
      };
      return _getPrototypeOf(o2);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o22, p22) {
        o22.__proto__ = p22;
        return o22;
      };
      return _setPrototypeOf(o2, p2);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct.bind();
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    var formatRegExp = /%[sdj%]/g;
    var warning = function warning2() {
    };
    if (typeof process !== "undefined" && define_process_env_default && false) {
      warning = function warning3(type4, errors) {
        if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
          if (errors.every(function(e2) {
            return typeof e2 === "string";
          })) {
            console.warn(type4, errors);
          }
        }
      };
    }
    function convertFieldsError(errors) {
      if (!errors || !errors.length)
        return null;
      var fields = {};
      errors.forEach(function(error) {
        var field = error.field;
        fields[field] = fields[field] || [];
        fields[field].push(error);
      });
      return fields;
    }
    function format$1(template) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var i = 0;
      var len = args.length;
      if (typeof template === "function") {
        return template.apply(null, args);
      }
      if (typeof template === "string") {
        var str = template.replace(formatRegExp, function(x2) {
          if (x2 === "%%") {
            return "%";
          }
          if (i >= len) {
            return x2;
          }
          switch (x2) {
            case "%s":
              return String(args[i++]);
            case "%d":
              return Number(args[i++]);
            case "%j":
              try {
                return JSON.stringify(args[i++]);
              } catch (_) {
                return "[Circular]";
              }
              break;
            default:
              return x2;
          }
        });
        return str;
      }
      return template;
    }
    function isNativeStringType(type4) {
      return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
    }
    function isEmptyValue(value, type4) {
      if (value === void 0 || value === null) {
        return true;
      }
      if (type4 === "array" && Array.isArray(value) && !value.length) {
        return true;
      }
      if (isNativeStringType(type4) && typeof value === "string" && !value) {
        return true;
      }
      return false;
    }
    function asyncParallelArray(arr, func, callback) {
      var results = [];
      var total = 0;
      var arrLength = arr.length;
      function count(errors) {
        results.push.apply(results, errors || []);
        total++;
        if (total === arrLength) {
          callback(results);
        }
      }
      arr.forEach(function(a) {
        func(a, count);
      });
    }
    function asyncSerialArray(arr, func, callback) {
      var index2 = 0;
      var arrLength = arr.length;
      function next2(errors) {
        if (errors && errors.length) {
          callback(errors);
          return;
        }
        var original = index2;
        index2 = index2 + 1;
        if (original < arrLength) {
          func(arr[original], next2);
        } else {
          callback([]);
        }
      }
      next2([]);
    }
    function flattenObjArr(objArr) {
      var ret = [];
      Object.keys(objArr).forEach(function(k2) {
        ret.push.apply(ret, objArr[k2] || []);
      });
      return ret;
    }
    var AsyncValidationError = /* @__PURE__ */ function(_Error) {
      _inheritsLoose(AsyncValidationError2, _Error);
      function AsyncValidationError2(errors, fields) {
        var _this;
        _this = _Error.call(this, "Async Validation Error") || this;
        _this.errors = errors;
        _this.fields = fields;
        return _this;
      }
      return AsyncValidationError2;
    }(/* @__PURE__ */ _wrapNativeSuper(Error));
    function asyncMap(objArr, option, func, callback, source) {
      if (option.first) {
        var _pending = new Promise(function(resolve, reject) {
          var next2 = function next22(errors) {
            callback(errors);
            return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
          };
          var flattenArr = flattenObjArr(objArr);
          asyncSerialArray(flattenArr, func, next2);
        });
        _pending["catch"](function(e2) {
          return e2;
        });
        return _pending;
      }
      var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
      var objArrKeys = Object.keys(objArr);
      var objArrLength = objArrKeys.length;
      var total = 0;
      var results = [];
      var pending = new Promise(function(resolve, reject) {
        var next2 = function next22(errors) {
          results.push.apply(results, errors);
          total++;
          if (total === objArrLength) {
            callback(results);
            return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
          }
        };
        if (!objArrKeys.length) {
          callback(results);
          resolve(source);
        }
        objArrKeys.forEach(function(key) {
          var arr = objArr[key];
          if (firstFields.indexOf(key) !== -1) {
            asyncSerialArray(arr, func, next2);
          } else {
            asyncParallelArray(arr, func, next2);
          }
        });
      });
      pending["catch"](function(e2) {
        return e2;
      });
      return pending;
    }
    function isErrorObj(obj) {
      return !!(obj && obj.message !== void 0);
    }
    function getValue$1(value, path) {
      var v2 = value;
      for (var i = 0; i < path.length; i++) {
        if (v2 == void 0) {
          return v2;
        }
        v2 = v2[path[i]];
      }
      return v2;
    }
    function complementError(rule, source) {
      return function(oe2) {
        var fieldValue;
        if (rule.fullFields) {
          fieldValue = getValue$1(source, rule.fullFields);
        } else {
          fieldValue = source[oe2.field || rule.fullField];
        }
        if (isErrorObj(oe2)) {
          oe2.field = oe2.field || rule.fullField;
          oe2.fieldValue = fieldValue;
          return oe2;
        }
        return {
          message: typeof oe2 === "function" ? oe2() : oe2,
          fieldValue,
          field: oe2.field || rule.fullField
        };
      };
    }
    function deepMerge(target, source) {
      if (source) {
        for (var s in source) {
          if (source.hasOwnProperty(s)) {
            var value = source[s];
            if (typeof value === "object" && typeof target[s] === "object") {
              target[s] = _extends({}, target[s], value);
            } else {
              target[s] = value;
            }
          }
        }
      }
      return target;
    }
    var required$1 = function required(rule, value, source, errors, options, type4) {
      if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
        errors.push(format$1(options.messages.required, rule.fullField));
      }
    };
    var whitespace = function whitespace2(rule, value, source, errors, options) {
      if (/^\s+$/.test(value) || value === "") {
        errors.push(format$1(options.messages.whitespace, rule.fullField));
      }
    };
    var urlReg;
    var getUrlRegex = function() {
      if (urlReg) {
        return urlReg;
      }
      var word = "[a-fA-F\\d:]";
      var b2 = function b22(options) {
        return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
      };
      var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
      var v6seg = "[a-fA-F\\d]{1,4}";
      var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
      var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
      var v4exact = new RegExp("^" + v4 + "$");
      var v6exact = new RegExp("^" + v6 + "$");
      var ip = function ip2(options) {
        return options && options.exact ? v46Exact : new RegExp("(?:" + b2(options) + v4 + b2(options) + ")|(?:" + b2(options) + v6 + b2(options) + ")", "g");
      };
      ip.v4 = function(options) {
        return options && options.exact ? v4exact : new RegExp("" + b2(options) + v4 + b2(options), "g");
      };
      ip.v6 = function(options) {
        return options && options.exact ? v6exact : new RegExp("" + b2(options) + v6 + b2(options), "g");
      };
      var protocol = "(?:(?:[a-z]+:)?//)";
      var auth = "(?:\\S+(?::\\S*)?@)?";
      var ipv4 = ip.v4().source;
      var ipv6 = ip.v6().source;
      var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
      var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
      var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
      var port = "(?::\\d{2,5})?";
      var path = '(?:[/?#][^\\s"]*)?';
      var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
      urlReg = new RegExp("(?:^" + regex + "$)", "i");
      return urlReg;
    };
    var pattern$2 = {
      // http://emailregex.com/
      email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
      // url: new RegExp(
      //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
      //   'i',
      // ),
      hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
    };
    var types = {
      integer: function integer(value) {
        return types.number(value) && parseInt(value, 10) === value;
      },
      "float": function float(value) {
        return types.number(value) && !types.integer(value);
      },
      array: function array(value) {
        return Array.isArray(value);
      },
      regexp: function regexp(value) {
        if (value instanceof RegExp) {
          return true;
        }
        try {
          return !!new RegExp(value);
        } catch (e2) {
          return false;
        }
      },
      date: function date(value) {
        return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
      },
      number: function number(value) {
        if (isNaN(value)) {
          return false;
        }
        return typeof value === "number";
      },
      object: function object(value) {
        return typeof value === "object" && !types.array(value);
      },
      method: function method(value) {
        return typeof value === "function";
      },
      email: function email(value) {
        return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
      },
      url: function url(value) {
        return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
      },
      hex: function hex(value) {
        return typeof value === "string" && !!value.match(pattern$2.hex);
      }
    };
    var type$1 = function type(rule, value, source, errors, options) {
      if (rule.required && value === void 0) {
        required$1(rule, value, source, errors, options);
        return;
      }
      var custom2 = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
      var ruleType = rule.type;
      if (custom2.indexOf(ruleType) > -1) {
        if (!types[ruleType](value)) {
          errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
        }
      } else if (ruleType && typeof value !== rule.type) {
        errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
      }
    };
    var range = function range2(rule, value, source, errors, options) {
      var len = typeof rule.len === "number";
      var min2 = typeof rule.min === "number";
      var max2 = typeof rule.max === "number";
      var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var val = value;
      var key = null;
      var num = typeof value === "number";
      var str = typeof value === "string";
      var arr = Array.isArray(value);
      if (num) {
        key = "number";
      } else if (str) {
        key = "string";
      } else if (arr) {
        key = "array";
      }
      if (!key) {
        return false;
      }
      if (arr) {
        val = value.length;
      }
      if (str) {
        val = value.replace(spRegexp, "_").length;
      }
      if (len) {
        if (val !== rule.len) {
          errors.push(format$1(options.messages[key].len, rule.fullField, rule.len));
        }
      } else if (min2 && !max2 && val < rule.min) {
        errors.push(format$1(options.messages[key].min, rule.fullField, rule.min));
      } else if (max2 && !min2 && val > rule.max) {
        errors.push(format$1(options.messages[key].max, rule.fullField, rule.max));
      } else if (min2 && max2 && (val < rule.min || val > rule.max)) {
        errors.push(format$1(options.messages[key].range, rule.fullField, rule.min, rule.max));
      }
    };
    var ENUM$1 = "enum";
    var enumerable$1 = function enumerable(rule, value, source, errors, options) {
      rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
      if (rule[ENUM$1].indexOf(value) === -1) {
        errors.push(format$1(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
      }
    };
    var pattern$1 = function pattern(rule, value, source, errors, options) {
      if (rule.pattern) {
        if (rule.pattern instanceof RegExp) {
          rule.pattern.lastIndex = 0;
          if (!rule.pattern.test(value)) {
            errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
          }
        } else if (typeof rule.pattern === "string") {
          var _pattern = new RegExp(rule.pattern);
          if (!_pattern.test(value)) {
            errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
          }
        }
      }
    };
    var rules = {
      required: required$1,
      whitespace,
      type: type$1,
      range,
      "enum": enumerable$1,
      pattern: pattern$1
    };
    var string = function string2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "string") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, "string");
        if (!isEmptyValue(value, "string")) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
          rules.pattern(rule, value, source, errors, options);
          if (rule.whitespace === true) {
            rules.whitespace(rule, value, source, errors, options);
          }
        }
      }
      callback(errors);
    };
    var method2 = function method3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var number2 = function number3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (value === "") {
          value = void 0;
        }
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var _boolean = function _boolean2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var regexp2 = function regexp3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value)) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var integer2 = function integer3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var floatFn = function floatFn2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var array2 = function array3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if ((value === void 0 || value === null) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, "array");
        if (value !== void 0 && value !== null) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var object2 = function object3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var ENUM = "enum";
    var enumerable2 = function enumerable3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== void 0) {
          rules[ENUM](rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var pattern2 = function pattern3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "string") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value, "string")) {
          rules.pattern(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var date2 = function date3(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, "date") && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value, "date")) {
          var dateObject;
          if (value instanceof Date) {
            dateObject = value;
          } else {
            dateObject = new Date(value);
          }
          rules.type(rule, dateObject, source, errors, options);
          if (dateObject) {
            rules.range(rule, dateObject.getTime(), source, errors, options);
          }
        }
      }
      callback(errors);
    };
    var required2 = function required3(rule, value, callback, source, options) {
      var errors = [];
      var type4 = Array.isArray(value) ? "array" : typeof value;
      rules.required(rule, value, source, errors, options, type4);
      callback(errors);
    };
    var type2 = function type3(rule, value, callback, source, options) {
      var ruleType = rule.type;
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, ruleType) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, ruleType);
        if (!isEmptyValue(value, ruleType)) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };
    var any = function any2(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
      }
      callback(errors);
    };
    var validators$2 = {
      string,
      method: method2,
      number: number2,
      "boolean": _boolean,
      regexp: regexp2,
      integer: integer2,
      "float": floatFn,
      array: array2,
      object: object2,
      "enum": enumerable2,
      pattern: pattern2,
      date: date2,
      url: type2,
      hex: type2,
      email: type2,
      required: required2,
      any
    };
    function newMessages() {
      return {
        "default": "Validation error on field %s",
        required: "%s is required",
        "enum": "%s must be one of %s",
        whitespace: "%s cannot be empty",
        date: {
          format: "%s date %s is invalid for format %s",
          parse: "%s date could not be parsed, %s is invalid ",
          invalid: "%s date %s is invalid"
        },
        types: {
          string: "%s is not a %s",
          method: "%s is not a %s (function)",
          array: "%s is not an %s",
          object: "%s is not an %s",
          number: "%s is not a %s",
          date: "%s is not a %s",
          "boolean": "%s is not a %s",
          integer: "%s is not an %s",
          "float": "%s is not a %s",
          regexp: "%s is not a valid %s",
          email: "%s is not a valid %s",
          url: "%s is not a valid %s",
          hex: "%s is not a valid %s"
        },
        string: {
          len: "%s must be exactly %s characters",
          min: "%s must be at least %s characters",
          max: "%s cannot be longer than %s characters",
          range: "%s must be between %s and %s characters"
        },
        number: {
          len: "%s must equal %s",
          min: "%s cannot be less than %s",
          max: "%s cannot be greater than %s",
          range: "%s must be between %s and %s"
        },
        array: {
          len: "%s must be exactly %s in length",
          min: "%s cannot be less than %s in length",
          max: "%s cannot be greater than %s in length",
          range: "%s must be between %s and %s in length"
        },
        pattern: {
          mismatch: "%s value %s does not match pattern %s"
        },
        clone: function clone2() {
          var cloned = JSON.parse(JSON.stringify(this));
          cloned.clone = this.clone;
          return cloned;
        }
      };
    }
    var messages = newMessages();
    var Schema = /* @__PURE__ */ function() {
      function Schema2(descriptor) {
        this.rules = null;
        this._messages = messages;
        this.define(descriptor);
      }
      var _proto = Schema2.prototype;
      _proto.define = function define(rules2) {
        var _this = this;
        if (!rules2) {
          throw new Error("Cannot configure a schema with no rules");
        }
        if (typeof rules2 !== "object" || Array.isArray(rules2)) {
          throw new Error("Rules must be an object");
        }
        this.rules = {};
        Object.keys(rules2).forEach(function(name) {
          var item = rules2[name];
          _this.rules[name] = Array.isArray(item) ? item : [item];
        });
      };
      _proto.messages = function messages2(_messages) {
        if (_messages) {
          this._messages = deepMerge(newMessages(), _messages);
        }
        return this._messages;
      };
      _proto.validate = function validate(source_, o2, oc2) {
        var _this2 = this;
        if (o2 === void 0) {
          o2 = {};
        }
        if (oc2 === void 0) {
          oc2 = function oc22() {
          };
        }
        var source = source_;
        var options = o2;
        var callback = oc2;
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        if (!this.rules || Object.keys(this.rules).length === 0) {
          if (callback) {
            callback(null, source);
          }
          return Promise.resolve(source);
        }
        function complete(results) {
          var errors = [];
          var fields = {};
          function add2(e2) {
            if (Array.isArray(e2)) {
              var _errors;
              errors = (_errors = errors).concat.apply(_errors, e2);
            } else {
              errors.push(e2);
            }
          }
          for (var i = 0; i < results.length; i++) {
            add2(results[i]);
          }
          if (!errors.length) {
            callback(null, source);
          } else {
            fields = convertFieldsError(errors);
            callback(errors, fields);
          }
        }
        if (options.messages) {
          var messages$1 = this.messages();
          if (messages$1 === messages) {
            messages$1 = newMessages();
          }
          deepMerge(messages$1, options.messages);
          options.messages = messages$1;
        } else {
          options.messages = this.messages();
        }
        var series = {};
        var keys2 = options.keys || Object.keys(this.rules);
        keys2.forEach(function(z2) {
          var arr = _this2.rules[z2];
          var value = source[z2];
          arr.forEach(function(r2) {
            var rule = r2;
            if (typeof rule.transform === "function") {
              if (source === source_) {
                source = _extends({}, source);
              }
              value = source[z2] = rule.transform(value);
            }
            if (typeof rule === "function") {
              rule = {
                validator: rule
              };
            } else {
              rule = _extends({}, rule);
            }
            rule.validator = _this2.getValidationMethod(rule);
            if (!rule.validator) {
              return;
            }
            rule.field = z2;
            rule.fullField = rule.fullField || z2;
            rule.type = _this2.getType(rule);
            series[z2] = series[z2] || [];
            series[z2].push({
              rule,
              value,
              source,
              field: z2
            });
          });
        });
        var errorFields = {};
        return asyncMap(series, options, function(data, doIt) {
          var rule = data.rule;
          var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
          deep = deep && (rule.required || !rule.required && data.value);
          rule.field = data.field;
          function addFullField(key, schema) {
            return _extends({}, schema, {
              fullField: rule.fullField + "." + key,
              fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
            });
          }
          function cb2(e2) {
            if (e2 === void 0) {
              e2 = [];
            }
            var errorList = Array.isArray(e2) ? e2 : [e2];
            if (!options.suppressWarning && errorList.length) {
              Schema2.warning("async-validator:", errorList);
            }
            if (errorList.length && rule.message !== void 0) {
              errorList = [].concat(rule.message);
            }
            var filledErrors = errorList.map(complementError(rule, source));
            if (options.first && filledErrors.length) {
              errorFields[rule.field] = 1;
              return doIt(filledErrors);
            }
            if (!deep) {
              doIt(filledErrors);
            } else {
              if (rule.required && !data.value) {
                if (rule.message !== void 0) {
                  filledErrors = [].concat(rule.message).map(complementError(rule, source));
                } else if (options.error) {
                  filledErrors = [options.error(rule, format$1(options.messages.required, rule.field))];
                }
                return doIt(filledErrors);
              }
              var fieldsSchema = {};
              if (rule.defaultField) {
                Object.keys(data.value).map(function(key) {
                  fieldsSchema[key] = rule.defaultField;
                });
              }
              fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
              var paredFieldsSchema = {};
              Object.keys(fieldsSchema).forEach(function(field) {
                var fieldSchema = fieldsSchema[field];
                var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
                paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
              });
              var schema = new Schema2(paredFieldsSchema);
              schema.messages(options.messages);
              if (data.rule.options) {
                data.rule.options.messages = options.messages;
                data.rule.options.error = options.error;
              }
              schema.validate(data.value, data.rule.options || options, function(errs) {
                var finalErrors = [];
                if (filledErrors && filledErrors.length) {
                  finalErrors.push.apply(finalErrors, filledErrors);
                }
                if (errs && errs.length) {
                  finalErrors.push.apply(finalErrors, errs);
                }
                doIt(finalErrors.length ? finalErrors : null);
              });
            }
          }
          var res;
          if (rule.asyncValidator) {
            res = rule.asyncValidator(rule, data.value, cb2, data.source, options);
          } else if (rule.validator) {
            try {
              res = rule.validator(rule, data.value, cb2, data.source, options);
            } catch (error) {
              console.error == null ? void 0 : console.error(error);
              if (!options.suppressValidatorError) {
                setTimeout(function() {
                  throw error;
                }, 0);
              }
              cb2(error.message);
            }
            if (res === true) {
              cb2();
            } else if (res === false) {
              cb2(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
            } else if (res instanceof Array) {
              cb2(res);
            } else if (res instanceof Error) {
              cb2(res.message);
            }
          }
          if (res && res.then) {
            res.then(function() {
              return cb2();
            }, function(e2) {
              return cb2(e2);
            });
          }
        }, function(results) {
          complete(results);
        }, source);
      };
      _proto.getType = function getType(rule) {
        if (rule.type === void 0 && rule.pattern instanceof RegExp) {
          rule.type = "pattern";
        }
        if (typeof rule.validator !== "function" && rule.type && !validators$2.hasOwnProperty(rule.type)) {
          throw new Error(format$1("Unknown rule type %s", rule.type));
        }
        return rule.type || "string";
      };
      _proto.getValidationMethod = function getValidationMethod(rule) {
        if (typeof rule.validator === "function") {
          return rule.validator;
        }
        var keys2 = Object.keys(rule);
        var messageIndex = keys2.indexOf("message");
        if (messageIndex !== -1) {
          keys2.splice(messageIndex, 1);
        }
        if (keys2.length === 1 && keys2[0] === "required") {
          return validators$2.required;
        }
        return validators$2[this.getType(rule)] || void 0;
      };
      return Schema2;
    }();
    Schema.register = function register(type4, validator2) {
      if (typeof validator2 !== "function") {
        throw new Error("Cannot register a validator by type, validator is not a function");
      }
      validators$2[type4] = validator2;
    };
    Schema.warning = warning;
    Schema.messages = messages;
    Schema.validators = validators$2;
    var typeTemplate$1 = "'${name}' is not a valid ${type}";
    var defaultValidateMessages = {
      default: "Validation error on field '${name}'",
      required: "'${name}' is required",
      enum: "'${name}' must be one of [${enum}]",
      whitespace: "'${name}' cannot be empty",
      date: {
        format: "'${name}' is invalid for format date",
        parse: "'${name}' could not be parsed as date",
        invalid: "'${name}' is invalid date"
      },
      types: {
        string: typeTemplate$1,
        method: typeTemplate$1,
        array: typeTemplate$1,
        object: typeTemplate$1,
        number: typeTemplate$1,
        date: typeTemplate$1,
        boolean: typeTemplate$1,
        integer: typeTemplate$1,
        float: typeTemplate$1,
        regexp: typeTemplate$1,
        email: typeTemplate$1,
        url: typeTemplate$1,
        hex: typeTemplate$1
      },
      string: {
        len: "'${name}' must be exactly ${len} characters",
        min: "'${name}' must be at least ${min} characters",
        max: "'${name}' cannot be longer than ${max} characters",
        range: "'${name}' must be between ${min} and ${max} characters"
      },
      number: {
        len: "'${name}' must equal ${len}",
        min: "'${name}' cannot be less than ${min}",
        max: "'${name}' cannot be greater than ${max}",
        range: "'${name}' must be between ${min} and ${max}"
      },
      array: {
        len: "'${name}' must be exactly ${len} in length",
        min: "'${name}' cannot be less than ${min} in length",
        max: "'${name}' cannot be greater than ${max} in length",
        range: "'${name}' must be between ${min} and ${max} in length"
      },
      pattern: {
        mismatch: "'${name}' does not match pattern ${pattern}"
      }
    };
    var AsyncValidator = Schema;
    function replaceMessage(template, kv) {
      return template.replace(/\$\{\w+\}/g, function(str) {
        var key = str.slice(2, -1);
        return kv[key];
      });
    }
    var CODE_LOGIC_ERROR = "CODE_LOGIC_ERROR";
    function validateRule(_x, _x2, _x3, _x4, _x5) {
      return _validateRule.apply(this, arguments);
    }
    function _validateRule() {
      _validateRule = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(name, value, rule, options, messageVariables) {
        var cloneRule, originValidator, subRuleField, validator2, messages2, result, subResults, kv, fillVariableResult;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                cloneRule = _objectSpread2({}, rule);
                delete cloneRule.ruleIndex;
                AsyncValidator.warning = function() {
                  return void 0;
                };
                if (cloneRule.validator) {
                  originValidator = cloneRule.validator;
                  cloneRule.validator = function() {
                    try {
                      return originValidator.apply(void 0, arguments);
                    } catch (error) {
                      console.error(error);
                      return Promise.reject(CODE_LOGIC_ERROR);
                    }
                  };
                }
                subRuleField = null;
                if (cloneRule && cloneRule.type === "array" && cloneRule.defaultField) {
                  subRuleField = cloneRule.defaultField;
                  delete cloneRule.defaultField;
                }
                validator2 = new AsyncValidator(_defineProperty({}, name, [cloneRule]));
                messages2 = merge$2(defaultValidateMessages, options.validateMessages);
                validator2.messages(messages2);
                result = [];
                _context2.prev = 10;
                _context2.next = 13;
                return Promise.resolve(validator2.validate(_defineProperty({}, name, value), _objectSpread2({}, options)));
              case 13:
                _context2.next = 18;
                break;
              case 15:
                _context2.prev = 15;
                _context2.t0 = _context2["catch"](10);
                if (_context2.t0.errors) {
                  result = _context2.t0.errors.map(function(_ref4, index2) {
                    var message = _ref4.message;
                    var mergedMessage = message === CODE_LOGIC_ERROR ? messages2.default : message;
                    return /* @__PURE__ */ reactExports.isValidElement(mergedMessage) ? (
                      // Wrap ReactNode with `key`
                      reactExports.cloneElement(mergedMessage, {
                        key: "error_".concat(index2)
                      })
                    ) : mergedMessage;
                  });
                }
              case 18:
                if (!(!result.length && subRuleField)) {
                  _context2.next = 23;
                  break;
                }
                _context2.next = 21;
                return Promise.all(value.map(function(subValue, i) {
                  return validateRule("".concat(name, ".").concat(i), subValue, subRuleField, options, messageVariables);
                }));
              case 21:
                subResults = _context2.sent;
                return _context2.abrupt("return", subResults.reduce(function(prev2, errors) {
                  return [].concat(_toConsumableArray(prev2), _toConsumableArray(errors));
                }, []));
              case 23:
                kv = _objectSpread2(_objectSpread2({}, rule), {}, {
                  name,
                  enum: (rule.enum || []).join(", ")
                }, messageVariables);
                fillVariableResult = result.map(function(error) {
                  if (typeof error === "string") {
                    return replaceMessage(error, kv);
                  }
                  return error;
                });
                return _context2.abrupt("return", fillVariableResult);
              case 26:
              case "end":
                return _context2.stop();
            }
        }, _callee2, null, [[10, 15]]);
      }));
      return _validateRule.apply(this, arguments);
    }
    function validateRules(namePath, value, rules2, options, validateFirst, messageVariables) {
      var name = namePath.join(".");
      var filledRules = rules2.map(function(currentRule, ruleIndex) {
        var originValidatorFunc = currentRule.validator;
        var cloneRule = _objectSpread2(_objectSpread2({}, currentRule), {}, {
          ruleIndex
        });
        if (originValidatorFunc) {
          cloneRule.validator = function(rule, val, callback) {
            var hasPromise = false;
            var wrappedCallback = function wrappedCallback2() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              Promise.resolve().then(function() {
                warningOnce(!hasPromise, "Your validator function has already return a promise. `callback` will be ignored.");
                if (!hasPromise) {
                  callback.apply(void 0, args);
                }
              });
            };
            var promise = originValidatorFunc(rule, val, wrappedCallback);
            hasPromise = promise && typeof promise.then === "function" && typeof promise.catch === "function";
            warningOnce(hasPromise, "`callback` is deprecated. Please return a promise instead.");
            if (hasPromise) {
              promise.then(function() {
                callback();
              }).catch(function(err) {
                callback(err || " ");
              });
            }
          };
        }
        return cloneRule;
      }).sort(function(_ref, _ref2) {
        var w1 = _ref.warningOnly, i1 = _ref.ruleIndex;
        var w2 = _ref2.warningOnly, i2 = _ref2.ruleIndex;
        if (!!w1 === !!w2) {
          return i1 - i2;
        }
        if (w1) {
          return 1;
        }
        return -1;
      });
      var summaryPromise;
      if (validateFirst === true) {
        summaryPromise = new Promise(/* @__PURE__ */ function() {
          var _ref3 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(resolve, reject) {
            var i, rule, errors;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    i = 0;
                  case 1:
                    if (!(i < filledRules.length)) {
                      _context.next = 12;
                      break;
                    }
                    rule = filledRules[i];
                    _context.next = 5;
                    return validateRule(name, value, rule, options, messageVariables);
                  case 5:
                    errors = _context.sent;
                    if (!errors.length) {
                      _context.next = 9;
                      break;
                    }
                    reject([{
                      errors,
                      rule
                    }]);
                    return _context.abrupt("return");
                  case 9:
                    i += 1;
                    _context.next = 1;
                    break;
                  case 12:
                    resolve([]);
                  case 13:
                  case "end":
                    return _context.stop();
                }
            }, _callee);
          }));
          return function(_x6, _x7) {
            return _ref3.apply(this, arguments);
          };
        }());
      } else {
        var rulePromises = filledRules.map(function(rule) {
          return validateRule(name, value, rule, options, messageVariables).then(function(errors) {
            return {
              errors,
              rule
            };
          });
        });
        summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then(function(errors) {
          return Promise.reject(errors);
        });
      }
      summaryPromise.catch(function(e2) {
        return e2;
      });
      return summaryPromise;
    }
    function finishOnAllFailed(_x8) {
      return _finishOnAllFailed.apply(this, arguments);
    }
    function _finishOnAllFailed() {
      _finishOnAllFailed = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee3(rulePromises) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1)
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", Promise.all(rulePromises).then(function(errorsList) {
                  var _ref5;
                  var errors = (_ref5 = []).concat.apply(_ref5, _toConsumableArray(errorsList));
                  return errors;
                }));
              case 1:
              case "end":
                return _context3.stop();
            }
        }, _callee3);
      }));
      return _finishOnAllFailed.apply(this, arguments);
    }
    function finishOnFirstFailed(_x9) {
      return _finishOnFirstFailed.apply(this, arguments);
    }
    function _finishOnFirstFailed() {
      _finishOnFirstFailed = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee4(rulePromises) {
        var count;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1)
            switch (_context4.prev = _context4.next) {
              case 0:
                count = 0;
                return _context4.abrupt("return", new Promise(function(resolve) {
                  rulePromises.forEach(function(promise) {
                    promise.then(function(ruleError) {
                      if (ruleError.errors.length) {
                        resolve([ruleError]);
                      }
                      count += 1;
                      if (count === rulePromises.length) {
                        resolve([]);
                      }
                    });
                  });
                }));
              case 2:
              case "end":
                return _context4.stop();
            }
        }, _callee4);
      }));
      return _finishOnFirstFailed.apply(this, arguments);
    }
    function getNamePath(path) {
      return toArray$9(path);
    }
    function cloneByNamePathList(store, namePathList) {
      var newStore = {};
      namePathList.forEach(function(namePath) {
        var value = get$3(store, namePath);
        newStore = set$2(newStore, namePath, value);
      });
      return newStore;
    }
    function containsNamePath(namePathList, namePath) {
      var partialMatch = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      return namePathList && namePathList.some(function(path) {
        return matchNamePath(namePath, path, partialMatch);
      });
    }
    function matchNamePath(namePath, subNamePath) {
      var partialMatch = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      if (!namePath || !subNamePath) {
        return false;
      }
      if (!partialMatch && namePath.length !== subNamePath.length) {
        return false;
      }
      return subNamePath.every(function(nameUnit, i) {
        return namePath[i] === nameUnit;
      });
    }
    function isSimilar(source, target) {
      if (source === target) {
        return true;
      }
      if (!source && target || source && !target) {
        return false;
      }
      if (!source || !target || _typeof(source) !== "object" || _typeof(target) !== "object") {
        return false;
      }
      var sourceKeys = Object.keys(source);
      var targetKeys = Object.keys(target);
      var keys2 = new Set([].concat(sourceKeys, targetKeys));
      return _toConsumableArray(keys2).every(function(key) {
        var sourceValue = source[key];
        var targetValue = target[key];
        if (typeof sourceValue === "function" && typeof targetValue === "function") {
          return true;
        }
        return sourceValue === targetValue;
      });
    }
    function defaultGetValueFromEvent(valuePropName) {
      var event = arguments.length <= 1 ? void 0 : arguments[1];
      if (event && event.target && _typeof(event.target) === "object" && valuePropName in event.target) {
        return event.target[valuePropName];
      }
      return event;
    }
    function move(array, moveIndex, toIndex) {
      var length2 = array.length;
      if (moveIndex < 0 || moveIndex >= length2 || toIndex < 0 || toIndex >= length2) {
        return array;
      }
      var item = array[moveIndex];
      var diff2 = moveIndex - toIndex;
      if (diff2 > 0) {
        return [].concat(_toConsumableArray(array.slice(0, toIndex)), [item], _toConsumableArray(array.slice(toIndex, moveIndex)), _toConsumableArray(array.slice(moveIndex + 1, length2)));
      }
      if (diff2 < 0) {
        return [].concat(_toConsumableArray(array.slice(0, moveIndex)), _toConsumableArray(array.slice(moveIndex + 1, toIndex + 1)), [item], _toConsumableArray(array.slice(toIndex + 1, length2)));
      }
      return array;
    }
    var _excluded$D = ["name"];
    var EMPTY_ERRORS = [];
    function requireUpdate(shouldUpdate, prev2, next2, prevValue, nextValue, info) {
      if (typeof shouldUpdate === "function") {
        return shouldUpdate(prev2, next2, "source" in info ? {
          source: info.source
        } : {});
      }
      return prevValue !== nextValue;
    }
    var Field = /* @__PURE__ */ function(_React$Component) {
      _inherits(Field2, _React$Component);
      var _super = _createSuper(Field2);
      function Field2(props) {
        var _this;
        _classCallCheck(this, Field2);
        _this = _super.call(this, props);
        _defineProperty(_assertThisInitialized(_this), "state", {
          resetCount: 0
        });
        _defineProperty(_assertThisInitialized(_this), "cancelRegisterFunc", null);
        _defineProperty(_assertThisInitialized(_this), "mounted", false);
        _defineProperty(_assertThisInitialized(_this), "touched", false);
        _defineProperty(_assertThisInitialized(_this), "dirty", false);
        _defineProperty(_assertThisInitialized(_this), "validatePromise", void 0);
        _defineProperty(_assertThisInitialized(_this), "prevValidating", void 0);
        _defineProperty(_assertThisInitialized(_this), "errors", EMPTY_ERRORS);
        _defineProperty(_assertThisInitialized(_this), "warnings", EMPTY_ERRORS);
        _defineProperty(_assertThisInitialized(_this), "cancelRegister", function() {
          var _this$props = _this.props, preserve2 = _this$props.preserve, isListField = _this$props.isListField, name = _this$props.name;
          if (_this.cancelRegisterFunc) {
            _this.cancelRegisterFunc(isListField, preserve2, getNamePath(name));
          }
          _this.cancelRegisterFunc = null;
        });
        _defineProperty(_assertThisInitialized(_this), "getNamePath", function() {
          var _this$props2 = _this.props, name = _this$props2.name, fieldContext = _this$props2.fieldContext;
          var _fieldContext$prefixN = fieldContext.prefixName, prefixName = _fieldContext$prefixN === void 0 ? [] : _fieldContext$prefixN;
          return name !== void 0 ? [].concat(_toConsumableArray(prefixName), _toConsumableArray(name)) : [];
        });
        _defineProperty(_assertThisInitialized(_this), "getRules", function() {
          var _this$props3 = _this.props, _this$props3$rules = _this$props3.rules, rules2 = _this$props3$rules === void 0 ? [] : _this$props3$rules, fieldContext = _this$props3.fieldContext;
          return rules2.map(function(rule) {
            if (typeof rule === "function") {
              return rule(fieldContext);
            }
            return rule;
          });
        });
        _defineProperty(_assertThisInitialized(_this), "refresh", function() {
          if (!_this.mounted)
            return;
          _this.setState(function(_ref) {
            var resetCount = _ref.resetCount;
            return {
              resetCount: resetCount + 1
            };
          });
        });
        _defineProperty(_assertThisInitialized(_this), "metaCache", null);
        _defineProperty(_assertThisInitialized(_this), "triggerMetaEvent", function(destroy) {
          var onMetaChange = _this.props.onMetaChange;
          if (onMetaChange) {
            var _meta = _objectSpread2(_objectSpread2({}, _this.getMeta()), {}, {
              destroy
            });
            if (!isEqual$1(_this.metaCache, _meta)) {
              onMetaChange(_meta);
            }
            _this.metaCache = _meta;
          } else {
            _this.metaCache = null;
          }
        });
        _defineProperty(_assertThisInitialized(_this), "onStoreChange", function(prevStore, namePathList, info) {
          var _this$props4 = _this.props, shouldUpdate = _this$props4.shouldUpdate, _this$props4$dependen = _this$props4.dependencies, dependencies = _this$props4$dependen === void 0 ? [] : _this$props4$dependen, onReset = _this$props4.onReset;
          var store = info.store;
          var namePath = _this.getNamePath();
          var prevValue = _this.getValue(prevStore);
          var curValue = _this.getValue(store);
          var namePathMatch = namePathList && containsNamePath(namePathList, namePath);
          if (info.type === "valueUpdate" && info.source === "external" && prevValue !== curValue) {
            _this.touched = true;
            _this.dirty = true;
            _this.validatePromise = null;
            _this.errors = EMPTY_ERRORS;
            _this.warnings = EMPTY_ERRORS;
            _this.triggerMetaEvent();
          }
          switch (info.type) {
            case "reset":
              if (!namePathList || namePathMatch) {
                _this.touched = false;
                _this.dirty = false;
                _this.validatePromise = void 0;
                _this.errors = EMPTY_ERRORS;
                _this.warnings = EMPTY_ERRORS;
                _this.triggerMetaEvent();
                onReset === null || onReset === void 0 || onReset();
                _this.refresh();
                return;
              }
              break;
            case "remove": {
              if (shouldUpdate) {
                _this.reRender();
                return;
              }
              break;
            }
            case "setField": {
              var data = info.data;
              if (namePathMatch) {
                if ("touched" in data) {
                  _this.touched = data.touched;
                }
                if ("validating" in data && !("originRCField" in data)) {
                  _this.validatePromise = data.validating ? Promise.resolve([]) : null;
                }
                if ("errors" in data) {
                  _this.errors = data.errors || EMPTY_ERRORS;
                }
                if ("warnings" in data) {
                  _this.warnings = data.warnings || EMPTY_ERRORS;
                }
                _this.dirty = true;
                _this.triggerMetaEvent();
                _this.reRender();
                return;
              } else if ("value" in data && containsNamePath(namePathList, namePath, true)) {
                _this.reRender();
                return;
              }
              if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
                _this.reRender();
                return;
              }
              break;
            }
            case "dependenciesUpdate": {
              var dependencyList = dependencies.map(getNamePath);
              if (dependencyList.some(function(dependency) {
                return containsNamePath(info.relatedFields, dependency);
              })) {
                _this.reRender();
                return;
              }
              break;
            }
            default:
              if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
                _this.reRender();
                return;
              }
              break;
          }
          if (shouldUpdate === true) {
            _this.reRender();
          }
        });
        _defineProperty(_assertThisInitialized(_this), "validateRules", function(options) {
          var namePath = _this.getNamePath();
          var currentValue = _this.getValue();
          var _ref2 = options || {}, triggerName = _ref2.triggerName, _ref2$validateOnly = _ref2.validateOnly, validateOnly = _ref2$validateOnly === void 0 ? false : _ref2$validateOnly;
          var rootPromise = Promise.resolve().then(/* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee() {
            var _this$props5, _this$props5$validate, validateFirst, messageVariables, validateDebounce, filteredRules, promise;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    if (_this.mounted) {
                      _context.next = 2;
                      break;
                    }
                    return _context.abrupt("return", []);
                  case 2:
                    _this$props5 = _this.props, _this$props5$validate = _this$props5.validateFirst, validateFirst = _this$props5$validate === void 0 ? false : _this$props5$validate, messageVariables = _this$props5.messageVariables, validateDebounce = _this$props5.validateDebounce;
                    filteredRules = _this.getRules();
                    if (triggerName) {
                      filteredRules = filteredRules.filter(function(rule) {
                        return rule;
                      }).filter(function(rule) {
                        var validateTrigger = rule.validateTrigger;
                        if (!validateTrigger) {
                          return true;
                        }
                        var triggerList = toArray$9(validateTrigger);
                        return triggerList.includes(triggerName);
                      });
                    }
                    if (!(validateDebounce && triggerName)) {
                      _context.next = 10;
                      break;
                    }
                    _context.next = 8;
                    return new Promise(function(resolve) {
                      setTimeout(resolve, validateDebounce);
                    });
                  case 8:
                    if (!(_this.validatePromise !== rootPromise)) {
                      _context.next = 10;
                      break;
                    }
                    return _context.abrupt("return", []);
                  case 10:
                    promise = validateRules(namePath, currentValue, filteredRules, options, validateFirst, messageVariables);
                    promise.catch(function(e2) {
                      return e2;
                    }).then(function() {
                      var ruleErrors = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : EMPTY_ERRORS;
                      if (_this.validatePromise === rootPromise) {
                        var _ruleErrors$forEach;
                        _this.validatePromise = null;
                        var nextErrors = [];
                        var nextWarnings = [];
                        (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 || _ruleErrors$forEach.call(ruleErrors, function(_ref4) {
                          var warningOnly = _ref4.rule.warningOnly, _ref4$errors = _ref4.errors, errors = _ref4$errors === void 0 ? EMPTY_ERRORS : _ref4$errors;
                          if (warningOnly) {
                            nextWarnings.push.apply(nextWarnings, _toConsumableArray(errors));
                          } else {
                            nextErrors.push.apply(nextErrors, _toConsumableArray(errors));
                          }
                        });
                        _this.errors = nextErrors;
                        _this.warnings = nextWarnings;
                        _this.triggerMetaEvent();
                        _this.reRender();
                      }
                    });
                    return _context.abrupt("return", promise);
                  case 13:
                  case "end":
                    return _context.stop();
                }
            }, _callee);
          })));
          if (validateOnly) {
            return rootPromise;
          }
          _this.validatePromise = rootPromise;
          _this.dirty = true;
          _this.errors = EMPTY_ERRORS;
          _this.warnings = EMPTY_ERRORS;
          _this.triggerMetaEvent();
          _this.reRender();
          return rootPromise;
        });
        _defineProperty(_assertThisInitialized(_this), "isFieldValidating", function() {
          return !!_this.validatePromise;
        });
        _defineProperty(_assertThisInitialized(_this), "isFieldTouched", function() {
          return _this.touched;
        });
        _defineProperty(_assertThisInitialized(_this), "isFieldDirty", function() {
          if (_this.dirty || _this.props.initialValue !== void 0) {
            return true;
          }
          var fieldContext = _this.props.fieldContext;
          var _fieldContext$getInte = fieldContext.getInternalHooks(HOOK_MARK), getInitialValue = _fieldContext$getInte.getInitialValue;
          if (getInitialValue(_this.getNamePath()) !== void 0) {
            return true;
          }
          return false;
        });
        _defineProperty(_assertThisInitialized(_this), "getErrors", function() {
          return _this.errors;
        });
        _defineProperty(_assertThisInitialized(_this), "getWarnings", function() {
          return _this.warnings;
        });
        _defineProperty(_assertThisInitialized(_this), "isListField", function() {
          return _this.props.isListField;
        });
        _defineProperty(_assertThisInitialized(_this), "isList", function() {
          return _this.props.isList;
        });
        _defineProperty(_assertThisInitialized(_this), "isPreserve", function() {
          return _this.props.preserve;
        });
        _defineProperty(_assertThisInitialized(_this), "getMeta", function() {
          _this.prevValidating = _this.isFieldValidating();
          var meta = {
            touched: _this.isFieldTouched(),
            validating: _this.prevValidating,
            errors: _this.errors,
            warnings: _this.warnings,
            name: _this.getNamePath(),
            validated: _this.validatePromise === null
          };
          return meta;
        });
        _defineProperty(_assertThisInitialized(_this), "getOnlyChild", function(children) {
          if (typeof children === "function") {
            var _meta2 = _this.getMeta();
            return _objectSpread2(_objectSpread2({}, _this.getOnlyChild(children(_this.getControlled(), _meta2, _this.props.fieldContext))), {}, {
              isFunction: true
            });
          }
          var childList = toArray$a(children);
          if (childList.length !== 1 || !/* @__PURE__ */ reactExports.isValidElement(childList[0])) {
            return {
              child: childList,
              isFunction: false
            };
          }
          return {
            child: childList[0],
            isFunction: false
          };
        });
        _defineProperty(_assertThisInitialized(_this), "getValue", function(store) {
          var getFieldsValue = _this.props.fieldContext.getFieldsValue;
          var namePath = _this.getNamePath();
          return get$3(store || getFieldsValue(true), namePath);
        });
        _defineProperty(_assertThisInitialized(_this), "getControlled", function() {
          var childProps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var _this$props6 = _this.props, trigger = _this$props6.trigger, validateTrigger = _this$props6.validateTrigger, getValueFromEvent = _this$props6.getValueFromEvent, normalize2 = _this$props6.normalize, valuePropName = _this$props6.valuePropName, getValueProps = _this$props6.getValueProps, fieldContext = _this$props6.fieldContext;
          var mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : fieldContext.validateTrigger;
          var namePath = _this.getNamePath();
          var getInternalHooks2 = fieldContext.getInternalHooks, getFieldsValue = fieldContext.getFieldsValue;
          var _getInternalHooks = getInternalHooks2(HOOK_MARK), dispatch = _getInternalHooks.dispatch;
          var value = _this.getValue();
          var mergedGetValueProps = getValueProps || function(val) {
            return _defineProperty({}, valuePropName, val);
          };
          var originTriggerFunc = childProps[trigger];
          var control = _objectSpread2(_objectSpread2({}, childProps), mergedGetValueProps(value));
          control[trigger] = function() {
            _this.touched = true;
            _this.dirty = true;
            _this.triggerMetaEvent();
            var newValue;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            if (getValueFromEvent) {
              newValue = getValueFromEvent.apply(void 0, args);
            } else {
              newValue = defaultGetValueFromEvent.apply(void 0, [valuePropName].concat(args));
            }
            if (normalize2) {
              newValue = normalize2(newValue, value, getFieldsValue(true));
            }
            dispatch({
              type: "updateValue",
              namePath,
              value: newValue
            });
            if (originTriggerFunc) {
              originTriggerFunc.apply(void 0, args);
            }
          };
          var validateTriggerList = toArray$9(mergedValidateTrigger || []);
          validateTriggerList.forEach(function(triggerName) {
            var originTrigger = control[triggerName];
            control[triggerName] = function() {
              if (originTrigger) {
                originTrigger.apply(void 0, arguments);
              }
              var rules2 = _this.props.rules;
              if (rules2 && rules2.length) {
                dispatch({
                  type: "validateField",
                  namePath,
                  triggerName
                });
              }
            };
          });
          return control;
        });
        if (props.fieldContext) {
          var getInternalHooks = props.fieldContext.getInternalHooks;
          var _getInternalHooks2 = getInternalHooks(HOOK_MARK), initEntityValue = _getInternalHooks2.initEntityValue;
          initEntityValue(_assertThisInitialized(_this));
        }
        return _this;
      }
      _createClass(Field2, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          var _this$props7 = this.props, shouldUpdate = _this$props7.shouldUpdate, fieldContext = _this$props7.fieldContext;
          this.mounted = true;
          if (fieldContext) {
            var getInternalHooks = fieldContext.getInternalHooks;
            var _getInternalHooks3 = getInternalHooks(HOOK_MARK), registerField = _getInternalHooks3.registerField;
            this.cancelRegisterFunc = registerField(this);
          }
          if (shouldUpdate === true) {
            this.reRender();
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.cancelRegister();
          this.triggerMetaEvent(true);
          this.mounted = false;
        }
      }, {
        key: "reRender",
        value: function reRender() {
          if (!this.mounted)
            return;
          this.forceUpdate();
        }
      }, {
        key: "render",
        value: function render2() {
          var resetCount = this.state.resetCount;
          var children = this.props.children;
          var _this$getOnlyChild = this.getOnlyChild(children), child = _this$getOnlyChild.child, isFunction2 = _this$getOnlyChild.isFunction;
          var returnChildNode;
          if (isFunction2) {
            returnChildNode = child;
          } else if (/* @__PURE__ */ reactExports.isValidElement(child)) {
            returnChildNode = /* @__PURE__ */ reactExports.cloneElement(child, this.getControlled(child.props));
          } else {
            warningOnce(!child, "`children` of Field is not validate ReactElement.");
            returnChildNode = child;
          }
          return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, {
            key: resetCount
          }, returnChildNode);
        }
      }]);
      return Field2;
    }(reactExports.Component);
    _defineProperty(Field, "contextType", Context);
    _defineProperty(Field, "defaultProps", {
      trigger: "onChange",
      valuePropName: "value"
    });
    function WrapperField(_ref6) {
      var name = _ref6.name, restProps = _objectWithoutProperties(_ref6, _excluded$D);
      var fieldContext = reactExports.useContext(Context);
      var listContext = reactExports.useContext(ListContext);
      var namePath = name !== void 0 ? getNamePath(name) : void 0;
      var key = "keep";
      if (!restProps.isListField) {
        key = "_".concat((namePath || []).join("_"));
      }
      return /* @__PURE__ */ reactExports.createElement(Field, _extends$1({
        key,
        name: namePath,
        isListField: !!listContext
      }, restProps, {
        fieldContext
      }));
    }
    function List$2(_ref) {
      var name = _ref.name, initialValue = _ref.initialValue, children = _ref.children, rules2 = _ref.rules, validateTrigger = _ref.validateTrigger, isListField = _ref.isListField;
      var context = reactExports.useContext(Context);
      var wrapperListContext = reactExports.useContext(ListContext);
      var keyRef = reactExports.useRef({
        keys: [],
        id: 0
      });
      var keyManager = keyRef.current;
      var prefixName = reactExports.useMemo(function() {
        var parentPrefixName = getNamePath(context.prefixName) || [];
        return [].concat(_toConsumableArray(parentPrefixName), _toConsumableArray(getNamePath(name)));
      }, [context.prefixName, name]);
      var fieldContext = reactExports.useMemo(function() {
        return _objectSpread2(_objectSpread2({}, context), {}, {
          prefixName
        });
      }, [context, prefixName]);
      var listContext = reactExports.useMemo(function() {
        return {
          getKey: function getKey2(namePath) {
            var len = prefixName.length;
            var pathName = namePath[len];
            return [keyManager.keys[pathName], namePath.slice(len + 1)];
          }
        };
      }, [prefixName]);
      if (typeof children !== "function") {
        warningOnce(false, "Form.List only accepts function as children.");
        return null;
      }
      var shouldUpdate = function shouldUpdate2(prevValue, nextValue, _ref2) {
        var source = _ref2.source;
        if (source === "internal") {
          return false;
        }
        return prevValue !== nextValue;
      };
      return /* @__PURE__ */ reactExports.createElement(ListContext.Provider, {
        value: listContext
      }, /* @__PURE__ */ reactExports.createElement(Context.Provider, {
        value: fieldContext
      }, /* @__PURE__ */ reactExports.createElement(WrapperField, {
        name: [],
        shouldUpdate,
        rules: rules2,
        validateTrigger,
        initialValue,
        isList: true,
        isListField: isListField !== null && isListField !== void 0 ? isListField : !!wrapperListContext
      }, function(_ref3, meta) {
        var _ref3$value = _ref3.value, value = _ref3$value === void 0 ? [] : _ref3$value, onChange = _ref3.onChange;
        var getFieldValue = context.getFieldValue;
        var getNewValue = function getNewValue2() {
          var values = getFieldValue(prefixName || []);
          return values || [];
        };
        var operations = {
          add: function add2(defaultValue, index2) {
            var newValue = getNewValue();
            if (index2 >= 0 && index2 <= newValue.length) {
              keyManager.keys = [].concat(_toConsumableArray(keyManager.keys.slice(0, index2)), [keyManager.id], _toConsumableArray(keyManager.keys.slice(index2)));
              onChange([].concat(_toConsumableArray(newValue.slice(0, index2)), [defaultValue], _toConsumableArray(newValue.slice(index2))));
            } else {
              keyManager.keys = [].concat(_toConsumableArray(keyManager.keys), [keyManager.id]);
              onChange([].concat(_toConsumableArray(newValue), [defaultValue]));
            }
            keyManager.id += 1;
          },
          remove: function remove(index2) {
            var newValue = getNewValue();
            var indexSet = new Set(Array.isArray(index2) ? index2 : [index2]);
            if (indexSet.size <= 0) {
              return;
            }
            keyManager.keys = keyManager.keys.filter(function(_, keysIndex) {
              return !indexSet.has(keysIndex);
            });
            onChange(newValue.filter(function(_, valueIndex) {
              return !indexSet.has(valueIndex);
            }));
          },
          move: function move$1(from2, to2) {
            if (from2 === to2) {
              return;
            }
            var newValue = getNewValue();
            if (from2 < 0 || from2 >= newValue.length || to2 < 0 || to2 >= newValue.length) {
              return;
            }
            keyManager.keys = move(keyManager.keys, from2, to2);
            onChange(move(newValue, from2, to2));
          }
        };
        var listValue = value || [];
        if (!Array.isArray(listValue)) {
          listValue = [];
        }
        return children(listValue.map(function(__, index2) {
          var key = keyManager.keys[index2];
          if (key === void 0) {
            keyManager.keys[index2] = keyManager.id;
            key = keyManager.keys[index2];
            keyManager.id += 1;
          }
          return {
            name: index2,
            key,
            isListField: true
          };
        }), operations, meta);
      })));
    }
    function allPromiseFinish(promiseList) {
      var hasError = false;
      var count = promiseList.length;
      var results = [];
      if (!promiseList.length) {
        return Promise.resolve([]);
      }
      return new Promise(function(resolve, reject) {
        promiseList.forEach(function(promise, index2) {
          promise.catch(function(e2) {
            hasError = true;
            return e2;
          }).then(function(result) {
            count -= 1;
            results[index2] = result;
            if (count > 0) {
              return;
            }
            if (hasError) {
              reject(results);
            }
            resolve(results);
          });
        });
      });
    }
    var SPLIT = "__@field_split__";
    function normalize(namePath) {
      return namePath.map(function(cell) {
        return "".concat(_typeof(cell), ":").concat(cell);
      }).join(SPLIT);
    }
    var NameMap = /* @__PURE__ */ function() {
      function NameMap2() {
        _classCallCheck(this, NameMap2);
        _defineProperty(this, "kvs", /* @__PURE__ */ new Map());
      }
      _createClass(NameMap2, [{
        key: "set",
        value: function set2(key, value) {
          this.kvs.set(normalize(key), value);
        }
      }, {
        key: "get",
        value: function get2(key) {
          return this.kvs.get(normalize(key));
        }
      }, {
        key: "update",
        value: function update(key, updater) {
          var origin = this.get(key);
          var next2 = updater(origin);
          if (!next2) {
            this.delete(key);
          } else {
            this.set(key, next2);
          }
        }
      }, {
        key: "delete",
        value: function _delete(key) {
          this.kvs.delete(normalize(key));
        }
        // Since we only use this in test, let simply realize this
      }, {
        key: "map",
        value: function map2(callback) {
          return _toConsumableArray(this.kvs.entries()).map(function(_ref) {
            var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1];
            var cells = key.split(SPLIT);
            return callback({
              key: cells.map(function(cell) {
                var _cell$match = cell.match(/^([^:]*):(.*)$/), _cell$match2 = _slicedToArray(_cell$match, 3), type = _cell$match2[1], unit2 = _cell$match2[2];
                return type === "number" ? Number(unit2) : unit2;
              }),
              value
            });
          });
        }
      }, {
        key: "toJSON",
        value: function toJSON2() {
          var json = {};
          this.map(function(_ref3) {
            var key = _ref3.key, value = _ref3.value;
            json[key.join(".")] = value;
            return null;
          });
          return json;
        }
      }]);
      return NameMap2;
    }();
    var _excluded$C = ["name"];
    var FormStore = /* @__PURE__ */ _createClass(function FormStore2(forceRootUpdate) {
      var _this = this;
      _classCallCheck(this, FormStore2);
      _defineProperty(this, "formHooked", false);
      _defineProperty(this, "forceRootUpdate", void 0);
      _defineProperty(this, "subscribable", true);
      _defineProperty(this, "store", {});
      _defineProperty(this, "fieldEntities", []);
      _defineProperty(this, "initialValues", {});
      _defineProperty(this, "callbacks", {});
      _defineProperty(this, "validateMessages", null);
      _defineProperty(this, "preserve", null);
      _defineProperty(this, "lastValidatePromise", null);
      _defineProperty(this, "getForm", function() {
        return {
          getFieldValue: _this.getFieldValue,
          getFieldsValue: _this.getFieldsValue,
          getFieldError: _this.getFieldError,
          getFieldWarning: _this.getFieldWarning,
          getFieldsError: _this.getFieldsError,
          isFieldsTouched: _this.isFieldsTouched,
          isFieldTouched: _this.isFieldTouched,
          isFieldValidating: _this.isFieldValidating,
          isFieldsValidating: _this.isFieldsValidating,
          resetFields: _this.resetFields,
          setFields: _this.setFields,
          setFieldValue: _this.setFieldValue,
          setFieldsValue: _this.setFieldsValue,
          validateFields: _this.validateFields,
          submit: _this.submit,
          _init: true,
          getInternalHooks: _this.getInternalHooks
        };
      });
      _defineProperty(this, "getInternalHooks", function(key) {
        if (key === HOOK_MARK) {
          _this.formHooked = true;
          return {
            dispatch: _this.dispatch,
            initEntityValue: _this.initEntityValue,
            registerField: _this.registerField,
            useSubscribe: _this.useSubscribe,
            setInitialValues: _this.setInitialValues,
            destroyForm: _this.destroyForm,
            setCallbacks: _this.setCallbacks,
            setValidateMessages: _this.setValidateMessages,
            getFields: _this.getFields,
            setPreserve: _this.setPreserve,
            getInitialValue: _this.getInitialValue,
            registerWatch: _this.registerWatch
          };
        }
        warningOnce(false, "`getInternalHooks` is internal usage. Should not call directly.");
        return null;
      });
      _defineProperty(this, "useSubscribe", function(subscribable) {
        _this.subscribable = subscribable;
      });
      _defineProperty(this, "prevWithoutPreserves", null);
      _defineProperty(this, "setInitialValues", function(initialValues, init) {
        _this.initialValues = initialValues || {};
        if (init) {
          var _this$prevWithoutPres;
          var nextStore = merge$2(initialValues, _this.store);
          (_this$prevWithoutPres = _this.prevWithoutPreserves) === null || _this$prevWithoutPres === void 0 || _this$prevWithoutPres.map(function(_ref) {
            var namePath = _ref.key;
            nextStore = set$2(nextStore, namePath, get$3(initialValues, namePath));
          });
          _this.prevWithoutPreserves = null;
          _this.updateStore(nextStore);
        }
      });
      _defineProperty(this, "destroyForm", function() {
        var prevWithoutPreserves = new NameMap();
        _this.getFieldEntities(true).forEach(function(entity) {
          if (!_this.isMergedPreserve(entity.isPreserve())) {
            prevWithoutPreserves.set(entity.getNamePath(), true);
          }
        });
        _this.prevWithoutPreserves = prevWithoutPreserves;
      });
      _defineProperty(this, "getInitialValue", function(namePath) {
        var initValue = get$3(_this.initialValues, namePath);
        return namePath.length ? merge$2(initValue) : initValue;
      });
      _defineProperty(this, "setCallbacks", function(callbacks) {
        _this.callbacks = callbacks;
      });
      _defineProperty(this, "setValidateMessages", function(validateMessages) {
        _this.validateMessages = validateMessages;
      });
      _defineProperty(this, "setPreserve", function(preserve2) {
        _this.preserve = preserve2;
      });
      _defineProperty(this, "watchList", []);
      _defineProperty(this, "registerWatch", function(callback) {
        _this.watchList.push(callback);
        return function() {
          _this.watchList = _this.watchList.filter(function(fn) {
            return fn !== callback;
          });
        };
      });
      _defineProperty(this, "notifyWatch", function() {
        var namePath = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        if (_this.watchList.length) {
          var values = _this.getFieldsValue();
          var allValues = _this.getFieldsValue(true);
          _this.watchList.forEach(function(callback) {
            callback(values, allValues, namePath);
          });
        }
      });
      _defineProperty(this, "timeoutId", null);
      _defineProperty(this, "warningUnhooked", function() {
      });
      _defineProperty(this, "updateStore", function(nextStore) {
        _this.store = nextStore;
      });
      _defineProperty(this, "getFieldEntities", function() {
        var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        if (!pure) {
          return _this.fieldEntities;
        }
        return _this.fieldEntities.filter(function(field) {
          return field.getNamePath().length;
        });
      });
      _defineProperty(this, "getFieldsMap", function() {
        var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        var cache = new NameMap();
        _this.getFieldEntities(pure).forEach(function(field) {
          var namePath = field.getNamePath();
          cache.set(namePath, field);
        });
        return cache;
      });
      _defineProperty(this, "getFieldEntitiesForNamePathList", function(nameList) {
        if (!nameList) {
          return _this.getFieldEntities(true);
        }
        var cache = _this.getFieldsMap(true);
        return nameList.map(function(name) {
          var namePath = getNamePath(name);
          return cache.get(namePath) || {
            INVALIDATE_NAME_PATH: getNamePath(name)
          };
        });
      });
      _defineProperty(this, "getFieldsValue", function(nameList, filterFunc) {
        _this.warningUnhooked();
        var mergedNameList;
        var mergedFilterFunc;
        var mergedStrict;
        if (nameList === true || Array.isArray(nameList)) {
          mergedNameList = nameList;
          mergedFilterFunc = filterFunc;
        } else if (nameList && _typeof(nameList) === "object") {
          mergedStrict = nameList.strict;
          mergedFilterFunc = nameList.filter;
        }
        if (mergedNameList === true && !mergedFilterFunc) {
          return _this.store;
        }
        var fieldEntities = _this.getFieldEntitiesForNamePathList(Array.isArray(mergedNameList) ? mergedNameList : null);
        var filteredNameList = [];
        fieldEntities.forEach(function(entity) {
          var _isListField, _ref3;
          var namePath = "INVALIDATE_NAME_PATH" in entity ? entity.INVALIDATE_NAME_PATH : entity.getNamePath();
          if (mergedStrict) {
            var _isList, _ref2;
            if ((_isList = (_ref2 = entity).isList) !== null && _isList !== void 0 && _isList.call(_ref2)) {
              return;
            }
          } else if (!mergedNameList && (_isListField = (_ref3 = entity).isListField) !== null && _isListField !== void 0 && _isListField.call(_ref3)) {
            return;
          }
          if (!mergedFilterFunc) {
            filteredNameList.push(namePath);
          } else {
            var meta = "getMeta" in entity ? entity.getMeta() : null;
            if (mergedFilterFunc(meta)) {
              filteredNameList.push(namePath);
            }
          }
        });
        return cloneByNamePathList(_this.store, filteredNameList.map(getNamePath));
      });
      _defineProperty(this, "getFieldValue", function(name) {
        _this.warningUnhooked();
        var namePath = getNamePath(name);
        return get$3(_this.store, namePath);
      });
      _defineProperty(this, "getFieldsError", function(nameList) {
        _this.warningUnhooked();
        var fieldEntities = _this.getFieldEntitiesForNamePathList(nameList);
        return fieldEntities.map(function(entity, index2) {
          if (entity && !("INVALIDATE_NAME_PATH" in entity)) {
            return {
              name: entity.getNamePath(),
              errors: entity.getErrors(),
              warnings: entity.getWarnings()
            };
          }
          return {
            name: getNamePath(nameList[index2]),
            errors: [],
            warnings: []
          };
        });
      });
      _defineProperty(this, "getFieldError", function(name) {
        _this.warningUnhooked();
        var namePath = getNamePath(name);
        var fieldError = _this.getFieldsError([namePath])[0];
        return fieldError.errors;
      });
      _defineProperty(this, "getFieldWarning", function(name) {
        _this.warningUnhooked();
        var namePath = getNamePath(name);
        var fieldError = _this.getFieldsError([namePath])[0];
        return fieldError.warnings;
      });
      _defineProperty(this, "isFieldsTouched", function() {
        _this.warningUnhooked();
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var arg0 = args[0], arg1 = args[1];
        var namePathList;
        var isAllFieldsTouched = false;
        if (args.length === 0) {
          namePathList = null;
        } else if (args.length === 1) {
          if (Array.isArray(arg0)) {
            namePathList = arg0.map(getNamePath);
            isAllFieldsTouched = false;
          } else {
            namePathList = null;
            isAllFieldsTouched = arg0;
          }
        } else {
          namePathList = arg0.map(getNamePath);
          isAllFieldsTouched = arg1;
        }
        var fieldEntities = _this.getFieldEntities(true);
        var isFieldTouched = function isFieldTouched2(field) {
          return field.isFieldTouched();
        };
        if (!namePathList) {
          return isAllFieldsTouched ? fieldEntities.every(isFieldTouched) : fieldEntities.some(isFieldTouched);
        }
        var map2 = new NameMap();
        namePathList.forEach(function(shortNamePath) {
          map2.set(shortNamePath, []);
        });
        fieldEntities.forEach(function(field) {
          var fieldNamePath = field.getNamePath();
          namePathList.forEach(function(shortNamePath) {
            if (shortNamePath.every(function(nameUnit, i) {
              return fieldNamePath[i] === nameUnit;
            })) {
              map2.update(shortNamePath, function(list) {
                return [].concat(_toConsumableArray(list), [field]);
              });
            }
          });
        });
        var isNamePathListTouched = function isNamePathListTouched2(entities) {
          return entities.some(isFieldTouched);
        };
        var namePathListEntities = map2.map(function(_ref4) {
          var value = _ref4.value;
          return value;
        });
        return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);
      });
      _defineProperty(this, "isFieldTouched", function(name) {
        _this.warningUnhooked();
        return _this.isFieldsTouched([name]);
      });
      _defineProperty(this, "isFieldsValidating", function(nameList) {
        _this.warningUnhooked();
        var fieldEntities = _this.getFieldEntities();
        if (!nameList) {
          return fieldEntities.some(function(testField) {
            return testField.isFieldValidating();
          });
        }
        var namePathList = nameList.map(getNamePath);
        return fieldEntities.some(function(testField) {
          var fieldNamePath = testField.getNamePath();
          return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();
        });
      });
      _defineProperty(this, "isFieldValidating", function(name) {
        _this.warningUnhooked();
        return _this.isFieldsValidating([name]);
      });
      _defineProperty(this, "resetWithFieldInitialValue", function() {
        var info = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var cache = new NameMap();
        var fieldEntities = _this.getFieldEntities(true);
        fieldEntities.forEach(function(field) {
          var initialValue = field.props.initialValue;
          var namePath = field.getNamePath();
          if (initialValue !== void 0) {
            var records = cache.get(namePath) || /* @__PURE__ */ new Set();
            records.add({
              entity: field,
              value: initialValue
            });
            cache.set(namePath, records);
          }
        });
        var resetWithFields = function resetWithFields2(entities) {
          entities.forEach(function(field) {
            var initialValue = field.props.initialValue;
            if (initialValue !== void 0) {
              var namePath = field.getNamePath();
              var formInitialValue = _this.getInitialValue(namePath);
              if (formInitialValue !== void 0) {
                warningOnce(false, "Form already set 'initialValues' with path '".concat(namePath.join("."), "'. Field can not overwrite it."));
              } else {
                var records = cache.get(namePath);
                if (records && records.size > 1) {
                  warningOnce(false, "Multiple Field with path '".concat(namePath.join("."), "' set 'initialValue'. Can not decide which one to pick."));
                } else if (records) {
                  var originValue = _this.getFieldValue(namePath);
                  var isListField = field.isListField();
                  if (!isListField && (!info.skipExist || originValue === void 0)) {
                    _this.updateStore(set$2(_this.store, namePath, _toConsumableArray(records)[0].value));
                  }
                }
              }
            }
          });
        };
        var requiredFieldEntities;
        if (info.entities) {
          requiredFieldEntities = info.entities;
        } else if (info.namePathList) {
          requiredFieldEntities = [];
          info.namePathList.forEach(function(namePath) {
            var records = cache.get(namePath);
            if (records) {
              var _requiredFieldEntitie;
              (_requiredFieldEntitie = requiredFieldEntities).push.apply(_requiredFieldEntitie, _toConsumableArray(_toConsumableArray(records).map(function(r2) {
                return r2.entity;
              })));
            }
          });
        } else {
          requiredFieldEntities = fieldEntities;
        }
        resetWithFields(requiredFieldEntities);
      });
      _defineProperty(this, "resetFields", function(nameList) {
        _this.warningUnhooked();
        var prevStore = _this.store;
        if (!nameList) {
          _this.updateStore(merge$2(_this.initialValues));
          _this.resetWithFieldInitialValue();
          _this.notifyObservers(prevStore, null, {
            type: "reset"
          });
          _this.notifyWatch();
          return;
        }
        var namePathList = nameList.map(getNamePath);
        namePathList.forEach(function(namePath) {
          var initialValue = _this.getInitialValue(namePath);
          _this.updateStore(set$2(_this.store, namePath, initialValue));
        });
        _this.resetWithFieldInitialValue({
          namePathList
        });
        _this.notifyObservers(prevStore, namePathList, {
          type: "reset"
        });
        _this.notifyWatch(namePathList);
      });
      _defineProperty(this, "setFields", function(fields) {
        _this.warningUnhooked();
        var prevStore = _this.store;
        var namePathList = [];
        fields.forEach(function(fieldData) {
          var name = fieldData.name, data = _objectWithoutProperties(fieldData, _excluded$C);
          var namePath = getNamePath(name);
          namePathList.push(namePath);
          if ("value" in data) {
            _this.updateStore(set$2(_this.store, namePath, data.value));
          }
          _this.notifyObservers(prevStore, [namePath], {
            type: "setField",
            data: fieldData
          });
        });
        _this.notifyWatch(namePathList);
      });
      _defineProperty(this, "getFields", function() {
        var entities = _this.getFieldEntities(true);
        var fields = entities.map(function(field) {
          var namePath = field.getNamePath();
          var meta = field.getMeta();
          var fieldData = _objectSpread2(_objectSpread2({}, meta), {}, {
            name: namePath,
            value: _this.getFieldValue(namePath)
          });
          Object.defineProperty(fieldData, "originRCField", {
            value: true
          });
          return fieldData;
        });
        return fields;
      });
      _defineProperty(this, "initEntityValue", function(entity) {
        var initialValue = entity.props.initialValue;
        if (initialValue !== void 0) {
          var namePath = entity.getNamePath();
          var prevValue = get$3(_this.store, namePath);
          if (prevValue === void 0) {
            _this.updateStore(set$2(_this.store, namePath, initialValue));
          }
        }
      });
      _defineProperty(this, "isMergedPreserve", function(fieldPreserve) {
        var mergedPreserve = fieldPreserve !== void 0 ? fieldPreserve : _this.preserve;
        return mergedPreserve !== null && mergedPreserve !== void 0 ? mergedPreserve : true;
      });
      _defineProperty(this, "registerField", function(entity) {
        _this.fieldEntities.push(entity);
        var namePath = entity.getNamePath();
        _this.notifyWatch([namePath]);
        if (entity.props.initialValue !== void 0) {
          var prevStore = _this.store;
          _this.resetWithFieldInitialValue({
            entities: [entity],
            skipExist: true
          });
          _this.notifyObservers(prevStore, [entity.getNamePath()], {
            type: "valueUpdate",
            source: "internal"
          });
        }
        return function(isListField, preserve2) {
          var subNamePath = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
          _this.fieldEntities = _this.fieldEntities.filter(function(item) {
            return item !== entity;
          });
          if (!_this.isMergedPreserve(preserve2) && (!isListField || subNamePath.length > 1)) {
            var defaultValue = isListField ? void 0 : _this.getInitialValue(namePath);
            if (namePath.length && _this.getFieldValue(namePath) !== defaultValue && _this.fieldEntities.every(function(field) {
              return (
                // Only reset when no namePath exist
                !matchNamePath(field.getNamePath(), namePath)
              );
            })) {
              var _prevStore = _this.store;
              _this.updateStore(set$2(_prevStore, namePath, defaultValue, true));
              _this.notifyObservers(_prevStore, [namePath], {
                type: "remove"
              });
              _this.triggerDependenciesUpdate(_prevStore, namePath);
            }
          }
          _this.notifyWatch([namePath]);
        };
      });
      _defineProperty(this, "dispatch", function(action) {
        switch (action.type) {
          case "updateValue": {
            var namePath = action.namePath, value = action.value;
            _this.updateValue(namePath, value);
            break;
          }
          case "validateField": {
            var _namePath = action.namePath, triggerName = action.triggerName;
            _this.validateFields([_namePath], {
              triggerName
            });
            break;
          }
        }
      });
      _defineProperty(this, "notifyObservers", function(prevStore, namePathList, info) {
        if (_this.subscribable) {
          var mergedInfo = _objectSpread2(_objectSpread2({}, info), {}, {
            store: _this.getFieldsValue(true)
          });
          _this.getFieldEntities().forEach(function(_ref5) {
            var onStoreChange = _ref5.onStoreChange;
            onStoreChange(prevStore, namePathList, mergedInfo);
          });
        } else {
          _this.forceRootUpdate();
        }
      });
      _defineProperty(this, "triggerDependenciesUpdate", function(prevStore, namePath) {
        var childrenFields = _this.getDependencyChildrenFields(namePath);
        if (childrenFields.length) {
          _this.validateFields(childrenFields);
        }
        _this.notifyObservers(prevStore, childrenFields, {
          type: "dependenciesUpdate",
          relatedFields: [namePath].concat(_toConsumableArray(childrenFields))
        });
        return childrenFields;
      });
      _defineProperty(this, "updateValue", function(name, value) {
        var namePath = getNamePath(name);
        var prevStore = _this.store;
        _this.updateStore(set$2(_this.store, namePath, value));
        _this.notifyObservers(prevStore, [namePath], {
          type: "valueUpdate",
          source: "internal"
        });
        _this.notifyWatch([namePath]);
        var childrenFields = _this.triggerDependenciesUpdate(prevStore, namePath);
        var onValuesChange = _this.callbacks.onValuesChange;
        if (onValuesChange) {
          var changedValues = cloneByNamePathList(_this.store, [namePath]);
          onValuesChange(changedValues, _this.getFieldsValue());
        }
        _this.triggerOnFieldsChange([namePath].concat(_toConsumableArray(childrenFields)));
      });
      _defineProperty(this, "setFieldsValue", function(store) {
        _this.warningUnhooked();
        var prevStore = _this.store;
        if (store) {
          var nextStore = merge$2(_this.store, store);
          _this.updateStore(nextStore);
        }
        _this.notifyObservers(prevStore, null, {
          type: "valueUpdate",
          source: "external"
        });
        _this.notifyWatch();
      });
      _defineProperty(this, "setFieldValue", function(name, value) {
        _this.setFields([{
          name,
          value
        }]);
      });
      _defineProperty(this, "getDependencyChildrenFields", function(rootNamePath) {
        var children = /* @__PURE__ */ new Set();
        var childrenFields = [];
        var dependencies2fields = new NameMap();
        _this.getFieldEntities().forEach(function(field) {
          var dependencies = field.props.dependencies;
          (dependencies || []).forEach(function(dependency) {
            var dependencyNamePath = getNamePath(dependency);
            dependencies2fields.update(dependencyNamePath, function() {
              var fields = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Set();
              fields.add(field);
              return fields;
            });
          });
        });
        var fillChildren = function fillChildren2(namePath) {
          var fields = dependencies2fields.get(namePath) || /* @__PURE__ */ new Set();
          fields.forEach(function(field) {
            if (!children.has(field)) {
              children.add(field);
              var fieldNamePath = field.getNamePath();
              if (field.isFieldDirty() && fieldNamePath.length) {
                childrenFields.push(fieldNamePath);
                fillChildren2(fieldNamePath);
              }
            }
          });
        };
        fillChildren(rootNamePath);
        return childrenFields;
      });
      _defineProperty(this, "triggerOnFieldsChange", function(namePathList, filedErrors) {
        var onFieldsChange = _this.callbacks.onFieldsChange;
        if (onFieldsChange) {
          var fields = _this.getFields();
          if (filedErrors) {
            var cache = new NameMap();
            filedErrors.forEach(function(_ref6) {
              var name = _ref6.name, errors = _ref6.errors;
              cache.set(name, errors);
            });
            fields.forEach(function(field) {
              field.errors = cache.get(field.name) || field.errors;
            });
          }
          var changedFields = fields.filter(function(_ref7) {
            var fieldName = _ref7.name;
            return containsNamePath(namePathList, fieldName);
          });
          if (changedFields.length) {
            onFieldsChange(changedFields, fields);
          }
        }
      });
      _defineProperty(this, "validateFields", function(arg1, arg2) {
        _this.warningUnhooked();
        var nameList;
        var options;
        if (Array.isArray(arg1) || typeof arg1 === "string" || typeof arg2 === "string") {
          nameList = arg1;
          options = arg2;
        } else {
          options = arg1;
        }
        var provideNameList = !!nameList;
        var namePathList = provideNameList ? nameList.map(getNamePath) : [];
        var promiseList = [];
        var TMP_SPLIT = String(Date.now());
        var validateNamePathList = /* @__PURE__ */ new Set();
        var _ref8 = options || {}, recursive = _ref8.recursive, dirty = _ref8.dirty;
        _this.getFieldEntities(true).forEach(function(field) {
          if (!provideNameList) {
            namePathList.push(field.getNamePath());
          }
          if (!field.props.rules || !field.props.rules.length) {
            return;
          }
          if (dirty && !field.isFieldDirty()) {
            return;
          }
          var fieldNamePath = field.getNamePath();
          validateNamePathList.add(fieldNamePath.join(TMP_SPLIT));
          if (!provideNameList || containsNamePath(namePathList, fieldNamePath, recursive)) {
            var promise = field.validateRules(_objectSpread2({
              validateMessages: _objectSpread2(_objectSpread2({}, defaultValidateMessages), _this.validateMessages)
            }, options));
            promiseList.push(promise.then(function() {
              return {
                name: fieldNamePath,
                errors: [],
                warnings: []
              };
            }).catch(function(ruleErrors) {
              var _ruleErrors$forEach;
              var mergedErrors = [];
              var mergedWarnings = [];
              (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 || _ruleErrors$forEach.call(ruleErrors, function(_ref9) {
                var warningOnly = _ref9.rule.warningOnly, errors = _ref9.errors;
                if (warningOnly) {
                  mergedWarnings.push.apply(mergedWarnings, _toConsumableArray(errors));
                } else {
                  mergedErrors.push.apply(mergedErrors, _toConsumableArray(errors));
                }
              });
              if (mergedErrors.length) {
                return Promise.reject({
                  name: fieldNamePath,
                  errors: mergedErrors,
                  warnings: mergedWarnings
                });
              }
              return {
                name: fieldNamePath,
                errors: mergedErrors,
                warnings: mergedWarnings
              };
            }));
          }
        });
        var summaryPromise = allPromiseFinish(promiseList);
        _this.lastValidatePromise = summaryPromise;
        summaryPromise.catch(function(results) {
          return results;
        }).then(function(results) {
          var resultNamePathList = results.map(function(_ref10) {
            var name = _ref10.name;
            return name;
          });
          _this.notifyObservers(_this.store, resultNamePathList, {
            type: "validateFinish"
          });
          _this.triggerOnFieldsChange(resultNamePathList, results);
        });
        var returnPromise = summaryPromise.then(function() {
          if (_this.lastValidatePromise === summaryPromise) {
            return Promise.resolve(_this.getFieldsValue(namePathList));
          }
          return Promise.reject([]);
        }).catch(function(results) {
          var errorList = results.filter(function(result) {
            return result && result.errors.length;
          });
          return Promise.reject({
            values: _this.getFieldsValue(namePathList),
            errorFields: errorList,
            outOfDate: _this.lastValidatePromise !== summaryPromise
          });
        });
        returnPromise.catch(function(e2) {
          return e2;
        });
        var triggerNamePathList = namePathList.filter(function(namePath) {
          return validateNamePathList.has(namePath.join(TMP_SPLIT));
        });
        _this.triggerOnFieldsChange(triggerNamePathList);
        return returnPromise;
      });
      _defineProperty(this, "submit", function() {
        _this.warningUnhooked();
        _this.validateFields().then(function(values) {
          var onFinish = _this.callbacks.onFinish;
          if (onFinish) {
            try {
              onFinish(values);
            } catch (err) {
              console.error(err);
            }
          }
        }).catch(function(e2) {
          var onFinishFailed = _this.callbacks.onFinishFailed;
          if (onFinishFailed) {
            onFinishFailed(e2);
          }
        });
      });
      this.forceRootUpdate = forceRootUpdate;
    });
    function useForm$1(form) {
      var formRef = reactExports.useRef();
      var _React$useState = reactExports.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), forceUpdate = _React$useState2[1];
      if (!formRef.current) {
        if (form) {
          formRef.current = form;
        } else {
          var forceReRender = function forceReRender2() {
            forceUpdate({});
          };
          var formStore = new FormStore(forceReRender);
          formRef.current = formStore.getForm();
        }
      }
      return [formRef.current];
    }
    var FormContext$1 = /* @__PURE__ */ reactExports.createContext({
      triggerFormChange: function triggerFormChange() {
      },
      triggerFormFinish: function triggerFormFinish() {
      },
      registerForm: function registerForm() {
      },
      unregisterForm: function unregisterForm() {
      }
    });
    var FormProvider$1 = function FormProvider2(_ref) {
      var validateMessages = _ref.validateMessages, onFormChange = _ref.onFormChange, onFormFinish = _ref.onFormFinish, children = _ref.children;
      var formContext = reactExports.useContext(FormContext$1);
      var formsRef = reactExports.useRef({});
      return /* @__PURE__ */ reactExports.createElement(FormContext$1.Provider, {
        value: _objectSpread2(_objectSpread2({}, formContext), {}, {
          validateMessages: _objectSpread2(_objectSpread2({}, formContext.validateMessages), validateMessages),
          // =========================================================
          // =                  Global Form Control                  =
          // =========================================================
          triggerFormChange: function triggerFormChange(name, changedFields) {
            if (onFormChange) {
              onFormChange(name, {
                changedFields,
                forms: formsRef.current
              });
            }
            formContext.triggerFormChange(name, changedFields);
          },
          triggerFormFinish: function triggerFormFinish(name, values) {
            if (onFormFinish) {
              onFormFinish(name, {
                values,
                forms: formsRef.current
              });
            }
            formContext.triggerFormFinish(name, values);
          },
          registerForm: function registerForm(name, form) {
            if (name) {
              formsRef.current = _objectSpread2(_objectSpread2({}, formsRef.current), {}, _defineProperty({}, name, form));
            }
            formContext.registerForm(name, form);
          },
          unregisterForm: function unregisterForm(name) {
            var newForms = _objectSpread2({}, formsRef.current);
            delete newForms[name];
            formsRef.current = newForms;
            formContext.unregisterForm(name);
          }
        })
      }, children);
    };
    var _excluded$B = ["name", "initialValues", "fields", "form", "preserve", "children", "component", "validateMessages", "validateTrigger", "onValuesChange", "onFieldsChange", "onFinish", "onFinishFailed"];
    var Form$3 = function Form2(_ref, ref) {
      var name = _ref.name, initialValues = _ref.initialValues, fields = _ref.fields, form = _ref.form, preserve2 = _ref.preserve, children = _ref.children, _ref$component = _ref.component, Component = _ref$component === void 0 ? "form" : _ref$component, validateMessages = _ref.validateMessages, _ref$validateTrigger = _ref.validateTrigger, validateTrigger = _ref$validateTrigger === void 0 ? "onChange" : _ref$validateTrigger, onValuesChange = _ref.onValuesChange, _onFieldsChange = _ref.onFieldsChange, _onFinish = _ref.onFinish, onFinishFailed = _ref.onFinishFailed, restProps = _objectWithoutProperties(_ref, _excluded$B);
      var formContext = reactExports.useContext(FormContext$1);
      var _useForm = useForm$1(form), _useForm2 = _slicedToArray(_useForm, 1), formInstance = _useForm2[0];
      var _getInternalHooks = formInstance.getInternalHooks(HOOK_MARK), useSubscribe = _getInternalHooks.useSubscribe, setInitialValues = _getInternalHooks.setInitialValues, setCallbacks = _getInternalHooks.setCallbacks, setValidateMessages = _getInternalHooks.setValidateMessages, setPreserve = _getInternalHooks.setPreserve, destroyForm = _getInternalHooks.destroyForm;
      reactExports.useImperativeHandle(ref, function() {
        return formInstance;
      });
      reactExports.useEffect(function() {
        formContext.registerForm(name, formInstance);
        return function() {
          formContext.unregisterForm(name);
        };
      }, [formContext, formInstance, name]);
      setValidateMessages(_objectSpread2(_objectSpread2({}, formContext.validateMessages), validateMessages));
      setCallbacks({
        onValuesChange,
        onFieldsChange: function onFieldsChange(changedFields) {
          formContext.triggerFormChange(name, changedFields);
          if (_onFieldsChange) {
            for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              rest[_key - 1] = arguments[_key];
            }
            _onFieldsChange.apply(void 0, [changedFields].concat(rest));
          }
        },
        onFinish: function onFinish(values) {
          formContext.triggerFormFinish(name, values);
          if (_onFinish) {
            _onFinish(values);
          }
        },
        onFinishFailed
      });
      setPreserve(preserve2);
      var mountRef = reactExports.useRef(null);
      setInitialValues(initialValues, !mountRef.current);
      if (!mountRef.current) {
        mountRef.current = true;
      }
      reactExports.useEffect(
        function() {
          return destroyForm;
        },
        // eslint-disable-next-line react-hooks/exhaustive-deps
        []
      );
      var childrenNode;
      var childrenRenderProps = typeof children === "function";
      if (childrenRenderProps) {
        var _values = formInstance.getFieldsValue(true);
        childrenNode = children(_values, formInstance);
      } else {
        childrenNode = children;
      }
      useSubscribe(!childrenRenderProps);
      var prevFieldsRef = reactExports.useRef();
      reactExports.useEffect(function() {
        if (!isSimilar(prevFieldsRef.current || [], fields || [])) {
          formInstance.setFields(fields || []);
        }
        prevFieldsRef.current = fields;
      }, [fields, formInstance]);
      var formContextValue = reactExports.useMemo(function() {
        return _objectSpread2(_objectSpread2({}, formInstance), {}, {
          validateTrigger
        });
      }, [formInstance, validateTrigger]);
      var wrapperNode = /* @__PURE__ */ reactExports.createElement(ListContext.Provider, {
        value: null
      }, /* @__PURE__ */ reactExports.createElement(Context.Provider, {
        value: formContextValue
      }, childrenNode));
      if (Component === false) {
        return wrapperNode;
      }
      return /* @__PURE__ */ reactExports.createElement(Component, _extends$1({}, restProps, {
        onSubmit: function onSubmit(event) {
          event.preventDefault();
          event.stopPropagation();
          formInstance.submit();
        },
        onReset: function onReset(event) {
          var _restProps$onReset;
          event.preventDefault();
          formInstance.resetFields();
          (_restProps$onReset = restProps.onReset) === null || _restProps$onReset === void 0 || _restProps$onReset.call(restProps, event);
        }
      }), wrapperNode);
    };
    function stringify(value) {
      try {
        return JSON.stringify(value);
      } catch (err) {
        return Math.random();
      }
    }
    function useWatch$1() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var dependencies = args[0], _args$ = args[1], _form = _args$ === void 0 ? {} : _args$;
      var options = isFormInstance(_form) ? {
        form: _form
      } : _form;
      var form = options.form;
      var _useState = reactExports.useState(), _useState2 = _slicedToArray(_useState, 2), value = _useState2[0], setValue = _useState2[1];
      var valueStr = reactExports.useMemo(function() {
        return stringify(value);
      }, [value]);
      var valueStrRef = reactExports.useRef(valueStr);
      valueStrRef.current = valueStr;
      var fieldContext = reactExports.useContext(Context);
      var formInstance = form || fieldContext;
      var isValidForm = formInstance && formInstance._init;
      var namePath = getNamePath(dependencies);
      var namePathRef = reactExports.useRef(namePath);
      namePathRef.current = namePath;
      reactExports.useEffect(
        function() {
          if (!isValidForm) {
            return;
          }
          var getFieldsValue = formInstance.getFieldsValue, getInternalHooks = formInstance.getInternalHooks;
          var _getInternalHooks = getInternalHooks(HOOK_MARK), registerWatch = _getInternalHooks.registerWatch;
          var getWatchValue = function getWatchValue2(values, allValues) {
            var watchValue = options.preserve ? allValues : values;
            return typeof dependencies === "function" ? dependencies(watchValue) : get$3(watchValue, namePathRef.current);
          };
          var cancelRegister = registerWatch(function(values, allValues) {
            var newValue = getWatchValue(values, allValues);
            var nextValueStr = stringify(newValue);
            if (valueStrRef.current !== nextValueStr) {
              valueStrRef.current = nextValueStr;
              setValue(newValue);
            }
          });
          var initialValue = getWatchValue(getFieldsValue(), getFieldsValue(true));
          if (value !== initialValue) {
            setValue(initialValue);
          }
          return cancelRegister;
        },
        // We do not need re-register since namePath content is the same
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [isValidForm]
      );
      return value;
    }
    var InternalForm$2 = /* @__PURE__ */ reactExports.forwardRef(Form$3);
    var RefForm = InternalForm$2;
    RefForm.FormProvider = FormProvider$1;
    RefForm.Field = WrapperField;
    RefForm.List = List$2;
    RefForm.useForm = useForm$1;
    RefForm.useWatch = useWatch$1;
    const FormContext = /* @__PURE__ */ reactExports.createContext({
      labelAlign: "right",
      vertical: false,
      itemRef: () => {
      }
    });
    const NoStyleItemContext = /* @__PURE__ */ reactExports.createContext(null);
    const FormProvider = (props) => {
      const providerProps = omit(props, ["prefixCls"]);
      return /* @__PURE__ */ reactExports.createElement(FormProvider$1, Object.assign({}, providerProps));
    };
    const FormItemPrefixContext = /* @__PURE__ */ reactExports.createContext({
      prefixCls: ""
    });
    const FormItemInputContext = /* @__PURE__ */ reactExports.createContext({});
    const NoFormStyle = (_ref) => {
      let {
        children,
        status,
        override
      } = _ref;
      const formItemInputContext = reactExports.useContext(FormItemInputContext);
      const newFormItemInputContext = reactExports.useMemo(() => {
        const newContext = Object.assign({}, formItemInputContext);
        if (override) {
          delete newContext.isFormItemInput;
        }
        if (status) {
          delete newContext.status;
          delete newContext.hasFeedback;
          delete newContext.feedbackIcon;
        }
        return newContext;
      }, [status, override, formItemInputContext]);
      return /* @__PURE__ */ reactExports.createElement(FormItemInputContext.Provider, {
        value: newFormItemInputContext
      }, children);
    };
    const initMotionCommon = (duration) => ({
      animationDuration: duration,
      animationFillMode: "both"
    });
    const initMotionCommonLeave = (duration) => ({
      animationDuration: duration,
      animationFillMode: "both"
    });
    const initMotion = function(motionCls, inKeyframes, outKeyframes, duration) {
      let sameLevel = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
      const sameLevelPrefix = sameLevel ? "&" : "";
      return {
        [`
      ${sameLevelPrefix}${motionCls}-enter,
      ${sameLevelPrefix}${motionCls}-appear
    `]: Object.assign(Object.assign({}, initMotionCommon(duration)), {
          animationPlayState: "paused"
        }),
        [`${sameLevelPrefix}${motionCls}-leave`]: Object.assign(Object.assign({}, initMotionCommonLeave(duration)), {
          animationPlayState: "paused"
        }),
        [`
      ${sameLevelPrefix}${motionCls}-enter${motionCls}-enter-active,
      ${sameLevelPrefix}${motionCls}-appear${motionCls}-appear-active
    `]: {
          animationName: inKeyframes,
          animationPlayState: "running"
        },
        [`${sameLevelPrefix}${motionCls}-leave${motionCls}-leave-active`]: {
          animationName: outKeyframes,
          animationPlayState: "running",
          pointerEvents: "none"
        }
      };
    };
    const fadeIn = new Keyframe("antFadeIn", {
      "0%": {
        opacity: 0
      },
      "100%": {
        opacity: 1
      }
    });
    const fadeOut = new Keyframe("antFadeOut", {
      "0%": {
        opacity: 1
      },
      "100%": {
        opacity: 0
      }
    });
    const initFadeMotion = function(token2) {
      let sameLevel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      const {
        antCls
      } = token2;
      const motionCls = `${antCls}-fade`;
      const sameLevelPrefix = sameLevel ? "&" : "";
      return [initMotion(motionCls, fadeIn, fadeOut, token2.motionDurationMid, sameLevel), {
        [`
        ${sameLevelPrefix}${motionCls}-enter,
        ${sameLevelPrefix}${motionCls}-appear
      `]: {
          opacity: 0,
          animationTimingFunction: "linear"
        },
        [`${sameLevelPrefix}${motionCls}-leave`]: {
          animationTimingFunction: "linear"
        }
      }];
    };
    const moveDownIn = new Keyframe("antMoveDownIn", {
      "0%": {
        transform: "translate3d(0, 100%, 0)",
        transformOrigin: "0 0",
        opacity: 0
      },
      "100%": {
        transform: "translate3d(0, 0, 0)",
        transformOrigin: "0 0",
        opacity: 1
      }
    });
    const moveDownOut = new Keyframe("antMoveDownOut", {
      "0%": {
        transform: "translate3d(0, 0, 0)",
        transformOrigin: "0 0",
        opacity: 1
      },
      "100%": {
        transform: "translate3d(0, 100%, 0)",
        transformOrigin: "0 0",
        opacity: 0
      }
    });
    const moveLeftIn = new Keyframe("antMoveLeftIn", {
      "0%": {
        transform: "translate3d(-100%, 0, 0)",
        transformOrigin: "0 0",
        opacity: 0
      },
      "100%": {
        transform: "translate3d(0, 0, 0)",
        transformOrigin: "0 0",
        opacity: 1
      }
    });
    const moveLeftOut = new Keyframe("antMoveLeftOut", {
      "0%": {
        transform: "translate3d(0, 0, 0)",
        transformOrigin: "0 0",
        opacity: 1
      },
      "100%": {
        transform: "translate3d(-100%, 0, 0)",
        transformOrigin: "0 0",
        opacity: 0
      }
    });
    const moveRightIn = new Keyframe("antMoveRightIn", {
      "0%": {
        transform: "translate3d(100%, 0, 0)",
        transformOrigin: "0 0",
        opacity: 0
      },
      "100%": {
        transform: "translate3d(0, 0, 0)",
        transformOrigin: "0 0",
        opacity: 1
      }
    });
    const moveRightOut = new Keyframe("antMoveRightOut", {
      "0%": {
        transform: "translate3d(0, 0, 0)",
        transformOrigin: "0 0",
        opacity: 1
      },
      "100%": {
        transform: "translate3d(100%, 0, 0)",
        transformOrigin: "0 0",
        opacity: 0
      }
    });
    const moveUpIn = new Keyframe("antMoveUpIn", {
      "0%": {
        transform: "translate3d(0, -100%, 0)",
        transformOrigin: "0 0",
        opacity: 0
      },
      "100%": {
        transform: "translate3d(0, 0, 0)",
        transformOrigin: "0 0",
        opacity: 1
      }
    });
    const moveUpOut = new Keyframe("antMoveUpOut", {
      "0%": {
        transform: "translate3d(0, 0, 0)",
        transformOrigin: "0 0",
        opacity: 1
      },
      "100%": {
        transform: "translate3d(0, -100%, 0)",
        transformOrigin: "0 0",
        opacity: 0
      }
    });
    const moveMotion = {
      "move-up": {
        inKeyframes: moveUpIn,
        outKeyframes: moveUpOut
      },
      "move-down": {
        inKeyframes: moveDownIn,
        outKeyframes: moveDownOut
      },
      "move-left": {
        inKeyframes: moveLeftIn,
        outKeyframes: moveLeftOut
      },
      "move-right": {
        inKeyframes: moveRightIn,
        outKeyframes: moveRightOut
      }
    };
    const initMoveMotion = (token2, motionName) => {
      const {
        antCls
      } = token2;
      const motionCls = `${antCls}-${motionName}`;
      const {
        inKeyframes,
        outKeyframes
      } = moveMotion[motionName];
      return [initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
        [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
          opacity: 0,
          animationTimingFunction: token2.motionEaseOutCirc
        },
        [`${motionCls}-leave`]: {
          animationTimingFunction: token2.motionEaseInOutCirc
        }
      }];
    };
    const slideUpIn = new Keyframe("antSlideUpIn", {
      "0%": {
        transform: "scaleY(0.8)",
        transformOrigin: "0% 0%",
        opacity: 0
      },
      "100%": {
        transform: "scaleY(1)",
        transformOrigin: "0% 0%",
        opacity: 1
      }
    });
    const slideUpOut = new Keyframe("antSlideUpOut", {
      "0%": {
        transform: "scaleY(1)",
        transformOrigin: "0% 0%",
        opacity: 1
      },
      "100%": {
        transform: "scaleY(0.8)",
        transformOrigin: "0% 0%",
        opacity: 0
      }
    });
    const slideDownIn = new Keyframe("antSlideDownIn", {
      "0%": {
        transform: "scaleY(0.8)",
        transformOrigin: "100% 100%",
        opacity: 0
      },
      "100%": {
        transform: "scaleY(1)",
        transformOrigin: "100% 100%",
        opacity: 1
      }
    });
    const slideDownOut = new Keyframe("antSlideDownOut", {
      "0%": {
        transform: "scaleY(1)",
        transformOrigin: "100% 100%",
        opacity: 1
      },
      "100%": {
        transform: "scaleY(0.8)",
        transformOrigin: "100% 100%",
        opacity: 0
      }
    });
    const slideLeftIn = new Keyframe("antSlideLeftIn", {
      "0%": {
        transform: "scaleX(0.8)",
        transformOrigin: "0% 0%",
        opacity: 0
      },
      "100%": {
        transform: "scaleX(1)",
        transformOrigin: "0% 0%",
        opacity: 1
      }
    });
    const slideLeftOut = new Keyframe("antSlideLeftOut", {
      "0%": {
        transform: "scaleX(1)",
        transformOrigin: "0% 0%",
        opacity: 1
      },
      "100%": {
        transform: "scaleX(0.8)",
        transformOrigin: "0% 0%",
        opacity: 0
      }
    });
    const slideRightIn = new Keyframe("antSlideRightIn", {
      "0%": {
        transform: "scaleX(0.8)",
        transformOrigin: "100% 0%",
        opacity: 0
      },
      "100%": {
        transform: "scaleX(1)",
        transformOrigin: "100% 0%",
        opacity: 1
      }
    });
    const slideRightOut = new Keyframe("antSlideRightOut", {
      "0%": {
        transform: "scaleX(1)",
        transformOrigin: "100% 0%",
        opacity: 1
      },
      "100%": {
        transform: "scaleX(0.8)",
        transformOrigin: "100% 0%",
        opacity: 0
      }
    });
    const slideMotion = {
      "slide-up": {
        inKeyframes: slideUpIn,
        outKeyframes: slideUpOut
      },
      "slide-down": {
        inKeyframes: slideDownIn,
        outKeyframes: slideDownOut
      },
      "slide-left": {
        inKeyframes: slideLeftIn,
        outKeyframes: slideLeftOut
      },
      "slide-right": {
        inKeyframes: slideRightIn,
        outKeyframes: slideRightOut
      }
    };
    const initSlideMotion = (token2, motionName) => {
      const {
        antCls
      } = token2;
      const motionCls = `${antCls}-${motionName}`;
      const {
        inKeyframes,
        outKeyframes
      } = slideMotion[motionName];
      return [initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
        [`
      ${motionCls}-enter,
      ${motionCls}-appear
    `]: {
          transform: "scale(0)",
          transformOrigin: "0% 0%",
          opacity: 0,
          animationTimingFunction: token2.motionEaseOutQuint,
          [`&-prepare`]: {
            transform: "scale(1)"
          }
        },
        [`${motionCls}-leave`]: {
          animationTimingFunction: token2.motionEaseInQuint
        }
      }];
    };
    const zoomIn = new Keyframe("antZoomIn", {
      "0%": {
        transform: "scale(0.2)",
        opacity: 0
      },
      "100%": {
        transform: "scale(1)",
        opacity: 1
      }
    });
    const zoomOut = new Keyframe("antZoomOut", {
      "0%": {
        transform: "scale(1)"
      },
      "100%": {
        transform: "scale(0.2)",
        opacity: 0
      }
    });
    const zoomBigIn = new Keyframe("antZoomBigIn", {
      "0%": {
        transform: "scale(0.8)",
        opacity: 0
      },
      "100%": {
        transform: "scale(1)",
        opacity: 1
      }
    });
    const zoomBigOut = new Keyframe("antZoomBigOut", {
      "0%": {
        transform: "scale(1)"
      },
      "100%": {
        transform: "scale(0.8)",
        opacity: 0
      }
    });
    const zoomUpIn = new Keyframe("antZoomUpIn", {
      "0%": {
        transform: "scale(0.8)",
        transformOrigin: "50% 0%",
        opacity: 0
      },
      "100%": {
        transform: "scale(1)",
        transformOrigin: "50% 0%"
      }
    });
    const zoomUpOut = new Keyframe("antZoomUpOut", {
      "0%": {
        transform: "scale(1)",
        transformOrigin: "50% 0%"
      },
      "100%": {
        transform: "scale(0.8)",
        transformOrigin: "50% 0%",
        opacity: 0
      }
    });
    const zoomLeftIn = new Keyframe("antZoomLeftIn", {
      "0%": {
        transform: "scale(0.8)",
        transformOrigin: "0% 50%",
        opacity: 0
      },
      "100%": {
        transform: "scale(1)",
        transformOrigin: "0% 50%"
      }
    });
    const zoomLeftOut = new Keyframe("antZoomLeftOut", {
      "0%": {
        transform: "scale(1)",
        transformOrigin: "0% 50%"
      },
      "100%": {
        transform: "scale(0.8)",
        transformOrigin: "0% 50%",
        opacity: 0
      }
    });
    const zoomRightIn = new Keyframe("antZoomRightIn", {
      "0%": {
        transform: "scale(0.8)",
        transformOrigin: "100% 50%",
        opacity: 0
      },
      "100%": {
        transform: "scale(1)",
        transformOrigin: "100% 50%"
      }
    });
    const zoomRightOut = new Keyframe("antZoomRightOut", {
      "0%": {
        transform: "scale(1)",
        transformOrigin: "100% 50%"
      },
      "100%": {
        transform: "scale(0.8)",
        transformOrigin: "100% 50%",
        opacity: 0
      }
    });
    const zoomDownIn = new Keyframe("antZoomDownIn", {
      "0%": {
        transform: "scale(0.8)",
        transformOrigin: "50% 100%",
        opacity: 0
      },
      "100%": {
        transform: "scale(1)",
        transformOrigin: "50% 100%"
      }
    });
    const zoomDownOut = new Keyframe("antZoomDownOut", {
      "0%": {
        transform: "scale(1)",
        transformOrigin: "50% 100%"
      },
      "100%": {
        transform: "scale(0.8)",
        transformOrigin: "50% 100%",
        opacity: 0
      }
    });
    const zoomMotion = {
      zoom: {
        inKeyframes: zoomIn,
        outKeyframes: zoomOut
      },
      "zoom-big": {
        inKeyframes: zoomBigIn,
        outKeyframes: zoomBigOut
      },
      "zoom-big-fast": {
        inKeyframes: zoomBigIn,
        outKeyframes: zoomBigOut
      },
      "zoom-left": {
        inKeyframes: zoomLeftIn,
        outKeyframes: zoomLeftOut
      },
      "zoom-right": {
        inKeyframes: zoomRightIn,
        outKeyframes: zoomRightOut
      },
      "zoom-up": {
        inKeyframes: zoomUpIn,
        outKeyframes: zoomUpOut
      },
      "zoom-down": {
        inKeyframes: zoomDownIn,
        outKeyframes: zoomDownOut
      }
    };
    const initZoomMotion = (token2, motionName) => {
      const {
        antCls
      } = token2;
      const motionCls = `${antCls}-${motionName}`;
      const {
        inKeyframes,
        outKeyframes
      } = zoomMotion[motionName];
      return [initMotion(motionCls, inKeyframes, outKeyframes, motionName === "zoom-big-fast" ? token2.motionDurationFast : token2.motionDurationMid), {
        [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
          transform: "scale(0)",
          opacity: 0,
          animationTimingFunction: token2.motionEaseOutCirc,
          "&-prepare": {
            transform: "none"
          }
        },
        [`${motionCls}-leave`]: {
          animationTimingFunction: token2.motionEaseInOutCirc
        }
      }];
    };
    const genCollapseMotion = (token2) => ({
      [token2.componentCls]: {
        // For common/openAnimation
        [`${token2.antCls}-motion-collapse-legacy`]: {
          overflow: "hidden",
          "&-active": {
            transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},
        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
          }
        },
        [`${token2.antCls}-motion-collapse`]: {
          overflow: "hidden",
          transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},
        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
        }
      }
    });
    const genCollapseMotion$1 = genCollapseMotion;
    function withPureRenderTheme(Component) {
      return (props) => /* @__PURE__ */ reactExports.createElement(ConfigProvider$1, {
        theme: {
          token: {
            motion: false,
            zIndexPopupBase: 0
          }
        }
      }, /* @__PURE__ */ reactExports.createElement(Component, Object.assign({}, props)));
    }
    const genPurePanel = (Component, defaultPrefixCls2, getDropdownCls, postProps) => {
      const PurePanel2 = (props) => {
        const {
          prefixCls: customizePrefixCls,
          style: style2
        } = props;
        const holderRef = reactExports.useRef(null);
        const [popupHeight, setPopupHeight] = reactExports.useState(0);
        const [popupWidth, setPopupWidth] = reactExports.useState(0);
        const [open, setOpen] = useMergedState(false, {
          value: props.open
        });
        const {
          getPrefixCls
        } = reactExports.useContext(ConfigContext);
        const prefixCls = getPrefixCls(defaultPrefixCls2 || "select", customizePrefixCls);
        reactExports.useEffect(() => {
          setOpen(true);
          if (typeof ResizeObserver !== "undefined") {
            const resizeObserver2 = new ResizeObserver((entries) => {
              const element = entries[0].target;
              setPopupHeight(element.offsetHeight + 8);
              setPopupWidth(element.offsetWidth);
            });
            const interval = setInterval(() => {
              var _a;
              const dropdownCls = getDropdownCls ? `.${getDropdownCls(prefixCls)}` : `.${prefixCls}-dropdown`;
              const popup = (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.querySelector(dropdownCls);
              if (popup) {
                clearInterval(interval);
                resizeObserver2.observe(popup);
              }
            }, 10);
            return () => {
              clearInterval(interval);
              resizeObserver2.disconnect();
            };
          }
        }, []);
        let mergedProps = Object.assign(Object.assign({}, props), {
          style: Object.assign(Object.assign({}, style2), {
            margin: 0
          }),
          open,
          visible: open,
          getPopupContainer: () => holderRef.current
        });
        if (postProps) {
          mergedProps = postProps(mergedProps);
        }
        const mergedStyle = {
          paddingBottom: popupHeight,
          position: "relative",
          minWidth: popupWidth
        };
        return /* @__PURE__ */ reactExports.createElement("div", {
          ref: holderRef,
          style: mergedStyle
        }, /* @__PURE__ */ reactExports.createElement(Component, Object.assign({}, mergedProps)));
      };
      return withPureRenderTheme(PurePanel2);
    };
    const genPurePanel$1 = genPurePanel;
    const isMobile = function() {
      if (typeof navigator === "undefined" || typeof window === "undefined") {
        return false;
      }
      var agent = navigator.userAgent || navigator.vendor || window.opera;
      return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(agent === null || agent === void 0 ? void 0 : agent.substr(0, 4));
    };
    var TransBtn = function TransBtn2(_ref) {
      var className = _ref.className, customizeIcon = _ref.customizeIcon, customizeIconProps = _ref.customizeIconProps, _onMouseDown = _ref.onMouseDown, onClick = _ref.onClick, children = _ref.children;
      var icon;
      if (typeof customizeIcon === "function") {
        icon = customizeIcon(customizeIconProps);
      } else {
        icon = customizeIcon;
      }
      return /* @__PURE__ */ reactExports.createElement("span", {
        className,
        onMouseDown: function onMouseDown(event) {
          event.preventDefault();
          if (_onMouseDown) {
            _onMouseDown(event);
          }
        },
        style: {
          userSelect: "none",
          WebkitUserSelect: "none"
        },
        unselectable: "on",
        onClick,
        "aria-hidden": true
      }, icon !== void 0 ? icon : /* @__PURE__ */ reactExports.createElement("span", {
        className: classNames(className.split(/\s+/).map(function(cls) {
          return "".concat(cls, "-icon");
        }))
      }, children));
    };
    function useAllowClear(prefixCls, onClearMouseDown, displayValues, allowClear, clearIcon) {
      var disabled = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
      var mergedSearchValue = arguments.length > 6 ? arguments[6] : void 0;
      var mode = arguments.length > 7 ? arguments[7] : void 0;
      var mergedClearIcon = React.useMemo(function() {
        if (_typeof(allowClear) === "object") {
          return allowClear.clearIcon;
        }
        if (!!clearIcon)
          return clearIcon;
      }, [allowClear, clearIcon]);
      var mergedAllowClear = React.useMemo(function() {
        if (!disabled && !!allowClear && (displayValues.length || mergedSearchValue) && !(mode === "combobox" && mergedSearchValue === "")) {
          return true;
        }
        return false;
      }, [allowClear, disabled, displayValues.length, mergedSearchValue, mode]);
      return {
        allowClear: mergedAllowClear,
        clearIcon: /* @__PURE__ */ React.createElement(TransBtn, {
          className: "".concat(prefixCls, "-clear"),
          onMouseDown: onClearMouseDown,
          customizeIcon: mergedClearIcon
        }, "×")
      };
    }
    var BaseSelectContext = /* @__PURE__ */ reactExports.createContext(null);
    function useBaseProps() {
      return reactExports.useContext(BaseSelectContext);
    }
    function useDelayReset() {
      var timeout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), bool = _React$useState2[0], setBool = _React$useState2[1];
      var delayRef = reactExports.useRef(null);
      var cancelLatest = function cancelLatest2() {
        window.clearTimeout(delayRef.current);
      };
      reactExports.useEffect(function() {
        return cancelLatest;
      }, []);
      var delaySetBool = function delaySetBool2(value, callback) {
        cancelLatest();
        delayRef.current = window.setTimeout(function() {
          setBool(value);
          if (callback) {
            callback();
          }
        }, timeout);
      };
      return [bool, delaySetBool, cancelLatest];
    }
    function useLock() {
      var duration = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 250;
      var lockRef = reactExports.useRef(null);
      var timeoutRef = reactExports.useRef(null);
      reactExports.useEffect(function() {
        return function() {
          window.clearTimeout(timeoutRef.current);
        };
      }, []);
      function doLock(locked) {
        if (locked || lockRef.current === null) {
          lockRef.current = locked;
        }
        window.clearTimeout(timeoutRef.current);
        timeoutRef.current = window.setTimeout(function() {
          lockRef.current = null;
        }, duration);
      }
      return [function() {
        return lockRef.current;
      }, doLock];
    }
    function useSelectTriggerControl(elements, open, triggerOpen, customizedTrigger) {
      var propsRef = reactExports.useRef(null);
      propsRef.current = {
        open,
        triggerOpen,
        customizedTrigger
      };
      reactExports.useEffect(function() {
        function onGlobalMouseDown(event) {
          var _propsRef$current;
          if ((_propsRef$current = propsRef.current) !== null && _propsRef$current !== void 0 && _propsRef$current.customizedTrigger) {
            return;
          }
          var target = event.target;
          if (target.shadowRoot && event.composed) {
            target = event.composedPath()[0] || target;
          }
          if (propsRef.current.open && elements().filter(function(element) {
            return element;
          }).every(function(element) {
            return !element.contains(target) && element !== target;
          })) {
            propsRef.current.triggerOpen(false);
          }
        }
        window.addEventListener("mousedown", onGlobalMouseDown);
        return function() {
          return window.removeEventListener("mousedown", onGlobalMouseDown);
        };
      }, []);
    }
    var _excluded$A = ["prefixCls", "invalidate", "item", "renderItem", "responsive", "responsiveDisabled", "registerSize", "itemKey", "className", "style", "children", "display", "order", "component"];
    var UNDEFINED = void 0;
    function InternalItem(props, ref) {
      var prefixCls = props.prefixCls, invalidate = props.invalidate, item = props.item, renderItem2 = props.renderItem, responsive = props.responsive, responsiveDisabled = props.responsiveDisabled, registerSize = props.registerSize, itemKey2 = props.itemKey, className = props.className, style2 = props.style, children = props.children, display = props.display, order = props.order, _props$component = props.component, Component = _props$component === void 0 ? "div" : _props$component, restProps = _objectWithoutProperties(props, _excluded$A);
      var mergedHidden = responsive && !display;
      function internalRegisterSize(width) {
        registerSize(itemKey2, width);
      }
      reactExports.useEffect(function() {
        return function() {
          internalRegisterSize(null);
        };
      }, []);
      var childNode = renderItem2 && item !== UNDEFINED ? renderItem2(item) : children;
      var overflowStyle;
      if (!invalidate) {
        overflowStyle = {
          opacity: mergedHidden ? 0 : 1,
          height: mergedHidden ? 0 : UNDEFINED,
          overflowY: mergedHidden ? "hidden" : UNDEFINED,
          order: responsive ? order : UNDEFINED,
          pointerEvents: mergedHidden ? "none" : UNDEFINED,
          position: mergedHidden ? "absolute" : UNDEFINED
        };
      }
      var overflowProps = {};
      if (mergedHidden) {
        overflowProps["aria-hidden"] = true;
      }
      var itemNode = /* @__PURE__ */ reactExports.createElement(Component, _extends$1({
        className: classNames(!invalidate && prefixCls, className),
        style: _objectSpread2(_objectSpread2({}, overflowStyle), style2)
      }, overflowProps, restProps, {
        ref
      }), childNode);
      if (responsive) {
        itemNode = /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
          onResize: function onResize2(_ref) {
            var offsetWidth = _ref.offsetWidth;
            internalRegisterSize(offsetWidth);
          },
          disabled: responsiveDisabled
        }, itemNode);
      }
      return itemNode;
    }
    var Item$5 = /* @__PURE__ */ reactExports.forwardRef(InternalItem);
    Item$5.displayName = "Item";
    function channelUpdate(callback) {
      if (typeof MessageChannel === "undefined") {
        wrapperRaf(callback);
      } else {
        var channel = new MessageChannel();
        channel.port1.onmessage = function() {
          return callback();
        };
        channel.port2.postMessage(void 0);
      }
    }
    function useBatcher() {
      var updateFuncRef = reactExports.useRef(null);
      var notifyEffectUpdate = function notifyEffectUpdate2(callback) {
        if (!updateFuncRef.current) {
          updateFuncRef.current = [];
          channelUpdate(function() {
            reactDomExports.unstable_batchedUpdates(function() {
              updateFuncRef.current.forEach(function(fn) {
                fn();
              });
              updateFuncRef.current = null;
            });
          });
        }
        updateFuncRef.current.push(callback);
      };
      return notifyEffectUpdate;
    }
    function useEffectState(notifyEffectUpdate, defaultValue) {
      var _React$useState = reactExports.useState(defaultValue), _React$useState2 = _slicedToArray(_React$useState, 2), stateValue = _React$useState2[0], setStateValue = _React$useState2[1];
      var setEffectVal = useEvent(function(nextValue) {
        notifyEffectUpdate(function() {
          setStateValue(nextValue);
        });
      });
      return [stateValue, setEffectVal];
    }
    var OverflowContext = /* @__PURE__ */ React.createContext(null);
    var _excluded$z = ["component"], _excluded2$5 = ["className"], _excluded3$1 = ["className"];
    var InternalRawItem = function InternalRawItem2(props, ref) {
      var context = reactExports.useContext(OverflowContext);
      if (!context) {
        var _props$component = props.component, Component = _props$component === void 0 ? "div" : _props$component, _restProps = _objectWithoutProperties(props, _excluded$z);
        return /* @__PURE__ */ reactExports.createElement(Component, _extends$1({}, _restProps, {
          ref
        }));
      }
      var contextClassName = context.className, restContext = _objectWithoutProperties(context, _excluded2$5);
      var className = props.className, restProps = _objectWithoutProperties(props, _excluded3$1);
      return /* @__PURE__ */ reactExports.createElement(OverflowContext.Provider, {
        value: null
      }, /* @__PURE__ */ reactExports.createElement(Item$5, _extends$1({
        ref,
        className: classNames(contextClassName, className)
      }, restContext, restProps)));
    };
    var RawItem = /* @__PURE__ */ reactExports.forwardRef(InternalRawItem);
    RawItem.displayName = "RawItem";
    var _excluded$y = ["prefixCls", "data", "renderItem", "renderRawItem", "itemKey", "itemWidth", "ssr", "style", "className", "maxCount", "renderRest", "renderRawRest", "suffix", "component", "itemComponent", "onVisibleChange"];
    var RESPONSIVE = "responsive";
    var INVALIDATE = "invalidate";
    function defaultRenderRest(omittedItems) {
      return "+ ".concat(omittedItems.length, " ...");
    }
    function Overflow(props, ref) {
      var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-overflow" : _props$prefixCls, _props$data = props.data, data = _props$data === void 0 ? [] : _props$data, renderItem2 = props.renderItem, renderRawItem = props.renderRawItem, itemKey2 = props.itemKey, _props$itemWidth = props.itemWidth, itemWidth = _props$itemWidth === void 0 ? 10 : _props$itemWidth, ssr = props.ssr, style2 = props.style, className = props.className, maxCount = props.maxCount, renderRest = props.renderRest, renderRawRest = props.renderRawRest, suffix = props.suffix, _props$component = props.component, Component = _props$component === void 0 ? "div" : _props$component, itemComponent = props.itemComponent, onVisibleChange = props.onVisibleChange, restProps = _objectWithoutProperties(props, _excluded$y);
      var fullySSR = ssr === "full";
      var notifyEffectUpdate = useBatcher();
      var _useEffectState = useEffectState(notifyEffectUpdate, null), _useEffectState2 = _slicedToArray(_useEffectState, 2), containerWidth = _useEffectState2[0], setContainerWidth = _useEffectState2[1];
      var mergedContainerWidth = containerWidth || 0;
      var _useEffectState3 = useEffectState(notifyEffectUpdate, /* @__PURE__ */ new Map()), _useEffectState4 = _slicedToArray(_useEffectState3, 2), itemWidths = _useEffectState4[0], setItemWidths = _useEffectState4[1];
      var _useEffectState5 = useEffectState(notifyEffectUpdate, 0), _useEffectState6 = _slicedToArray(_useEffectState5, 2), prevRestWidth = _useEffectState6[0], setPrevRestWidth = _useEffectState6[1];
      var _useEffectState7 = useEffectState(notifyEffectUpdate, 0), _useEffectState8 = _slicedToArray(_useEffectState7, 2), restWidth = _useEffectState8[0], setRestWidth = _useEffectState8[1];
      var _useEffectState9 = useEffectState(notifyEffectUpdate, 0), _useEffectState10 = _slicedToArray(_useEffectState9, 2), suffixWidth = _useEffectState10[0], setSuffixWidth = _useEffectState10[1];
      var _useState = reactExports.useState(null), _useState2 = _slicedToArray(_useState, 2), suffixFixedStart = _useState2[0], setSuffixFixedStart = _useState2[1];
      var _useState3 = reactExports.useState(null), _useState4 = _slicedToArray(_useState3, 2), displayCount = _useState4[0], setDisplayCount = _useState4[1];
      var mergedDisplayCount = reactExports.useMemo(function() {
        if (displayCount === null && fullySSR) {
          return Number.MAX_SAFE_INTEGER;
        }
        return displayCount || 0;
      }, [displayCount, containerWidth]);
      var _useState5 = reactExports.useState(false), _useState6 = _slicedToArray(_useState5, 2), restReady = _useState6[0], setRestReady = _useState6[1];
      var itemPrefixCls = "".concat(prefixCls, "-item");
      var mergedRestWidth = Math.max(prevRestWidth, restWidth);
      var isResponsive = maxCount === RESPONSIVE;
      var shouldResponsive = data.length && isResponsive;
      var invalidate = maxCount === INVALIDATE;
      var showRest = shouldResponsive || typeof maxCount === "number" && data.length > maxCount;
      var mergedData = reactExports.useMemo(function() {
        var items = data;
        if (shouldResponsive) {
          if (containerWidth === null && fullySSR) {
            items = data;
          } else {
            items = data.slice(0, Math.min(data.length, mergedContainerWidth / itemWidth));
          }
        } else if (typeof maxCount === "number") {
          items = data.slice(0, maxCount);
        }
        return items;
      }, [data, itemWidth, containerWidth, maxCount, shouldResponsive]);
      var omittedItems = reactExports.useMemo(function() {
        if (shouldResponsive) {
          return data.slice(mergedDisplayCount + 1);
        }
        return data.slice(mergedData.length);
      }, [data, mergedData, shouldResponsive, mergedDisplayCount]);
      var getKey2 = reactExports.useCallback(function(item, index2) {
        var _ref;
        if (typeof itemKey2 === "function") {
          return itemKey2(item);
        }
        return (_ref = itemKey2 && (item === null || item === void 0 ? void 0 : item[itemKey2])) !== null && _ref !== void 0 ? _ref : index2;
      }, [itemKey2]);
      var mergedRenderItem = reactExports.useCallback(renderItem2 || function(item) {
        return item;
      }, [renderItem2]);
      function updateDisplayCount(count, suffixFixedStartVal, notReady) {
        if (displayCount === count && (suffixFixedStartVal === void 0 || suffixFixedStartVal === suffixFixedStart)) {
          return;
        }
        setDisplayCount(count);
        if (!notReady) {
          setRestReady(count < data.length - 1);
          onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(count);
        }
        if (suffixFixedStartVal !== void 0) {
          setSuffixFixedStart(suffixFixedStartVal);
        }
      }
      function onOverflowResize(_, element) {
        setContainerWidth(element.clientWidth);
      }
      function registerSize(key, width) {
        setItemWidths(function(origin) {
          var clone2 = new Map(origin);
          if (width === null) {
            clone2.delete(key);
          } else {
            clone2.set(key, width);
          }
          return clone2;
        });
      }
      function registerOverflowSize(_, width) {
        setRestWidth(width);
        setPrevRestWidth(restWidth);
      }
      function registerSuffixSize(_, width) {
        setSuffixWidth(width);
      }
      function getItemWidth(index2) {
        return itemWidths.get(getKey2(mergedData[index2], index2));
      }
      useLayoutEffect$1(function() {
        if (mergedContainerWidth && typeof mergedRestWidth === "number" && mergedData) {
          var totalWidth = suffixWidth;
          var len = mergedData.length;
          var lastIndex = len - 1;
          if (!len) {
            updateDisplayCount(0, null);
            return;
          }
          for (var i = 0; i < len; i += 1) {
            var currentItemWidth = getItemWidth(i);
            if (fullySSR) {
              currentItemWidth = currentItemWidth || 0;
            }
            if (currentItemWidth === void 0) {
              updateDisplayCount(i - 1, void 0, true);
              break;
            }
            totalWidth += currentItemWidth;
            if (
              // Only one means `totalWidth` is the final width
              lastIndex === 0 && totalWidth <= mergedContainerWidth || // Last two width will be the final width
              i === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth
            ) {
              updateDisplayCount(lastIndex, null);
              break;
            } else if (totalWidth + mergedRestWidth > mergedContainerWidth) {
              updateDisplayCount(i - 1, totalWidth - currentItemWidth - suffixWidth + restWidth);
              break;
            }
          }
          if (suffix && getItemWidth(0) + suffixWidth > mergedContainerWidth) {
            setSuffixFixedStart(null);
          }
        }
      }, [mergedContainerWidth, itemWidths, restWidth, suffixWidth, getKey2, mergedData]);
      var displayRest = restReady && !!omittedItems.length;
      var suffixStyle = {};
      if (suffixFixedStart !== null && shouldResponsive) {
        suffixStyle = {
          position: "absolute",
          left: suffixFixedStart,
          top: 0
        };
      }
      var itemSharedProps = {
        prefixCls: itemPrefixCls,
        responsive: shouldResponsive,
        component: itemComponent,
        invalidate
      };
      var internalRenderItemNode = renderRawItem ? function(item, index2) {
        var key = getKey2(item, index2);
        return /* @__PURE__ */ reactExports.createElement(OverflowContext.Provider, {
          key,
          value: _objectSpread2(_objectSpread2({}, itemSharedProps), {}, {
            order: index2,
            item,
            itemKey: key,
            registerSize,
            display: index2 <= mergedDisplayCount
          })
        }, renderRawItem(item, index2));
      } : function(item, index2) {
        var key = getKey2(item, index2);
        return /* @__PURE__ */ reactExports.createElement(Item$5, _extends$1({}, itemSharedProps, {
          order: index2,
          key,
          item,
          renderItem: mergedRenderItem,
          itemKey: key,
          registerSize,
          display: index2 <= mergedDisplayCount
        }));
      };
      var restNode;
      var restContextProps = {
        order: displayRest ? mergedDisplayCount : Number.MAX_SAFE_INTEGER,
        className: "".concat(itemPrefixCls, "-rest"),
        registerSize: registerOverflowSize,
        display: displayRest
      };
      if (!renderRawRest) {
        var mergedRenderRest = renderRest || defaultRenderRest;
        restNode = /* @__PURE__ */ reactExports.createElement(Item$5, _extends$1({}, itemSharedProps, restContextProps), typeof mergedRenderRest === "function" ? mergedRenderRest(omittedItems) : mergedRenderRest);
      } else if (renderRawRest) {
        restNode = /* @__PURE__ */ reactExports.createElement(OverflowContext.Provider, {
          value: _objectSpread2(_objectSpread2({}, itemSharedProps), restContextProps)
        }, renderRawRest(omittedItems));
      }
      var overflowNode = /* @__PURE__ */ reactExports.createElement(Component, _extends$1({
        className: classNames(!invalidate && prefixCls, className),
        style: style2,
        ref
      }, restProps), mergedData.map(internalRenderItemNode), showRest ? restNode : null, suffix && /* @__PURE__ */ reactExports.createElement(Item$5, _extends$1({}, itemSharedProps, {
        responsive: isResponsive,
        responsiveDisabled: !shouldResponsive,
        order: mergedDisplayCount,
        className: "".concat(itemPrefixCls, "-suffix"),
        registerSize: registerSuffixSize,
        display: true,
        style: suffixStyle
      }), suffix));
      if (isResponsive) {
        overflowNode = /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
          onResize: onOverflowResize,
          disabled: !shouldResponsive
        }, overflowNode);
      }
      return overflowNode;
    }
    var ForwardOverflow = /* @__PURE__ */ reactExports.forwardRef(Overflow);
    ForwardOverflow.displayName = "Overflow";
    ForwardOverflow.Item = RawItem;
    ForwardOverflow.RESPONSIVE = RESPONSIVE;
    ForwardOverflow.INVALIDATE = INVALIDATE;
    var Input$4 = function Input2(_ref, ref) {
      var _inputNode2;
      var prefixCls = _ref.prefixCls, id2 = _ref.id, inputElement = _ref.inputElement, disabled = _ref.disabled, tabIndex = _ref.tabIndex, autoFocus = _ref.autoFocus, autoComplete = _ref.autoComplete, editable = _ref.editable, activeDescendantId = _ref.activeDescendantId, value = _ref.value, maxLength = _ref.maxLength, _onKeyDown = _ref.onKeyDown, _onMouseDown = _ref.onMouseDown, _onChange = _ref.onChange, onPaste = _ref.onPaste, _onCompositionStart = _ref.onCompositionStart, _onCompositionEnd = _ref.onCompositionEnd, open = _ref.open, attrs = _ref.attrs;
      var inputNode = inputElement || /* @__PURE__ */ reactExports.createElement("input", null);
      var _inputNode = inputNode, originRef = _inputNode.ref, originProps = _inputNode.props;
      var onOriginKeyDown = originProps.onKeyDown, onOriginChange = originProps.onChange, onOriginMouseDown = originProps.onMouseDown, onOriginCompositionStart = originProps.onCompositionStart, onOriginCompositionEnd = originProps.onCompositionEnd, style2 = originProps.style;
      warning$2(!("maxLength" in inputNode.props));
      inputNode = /* @__PURE__ */ reactExports.cloneElement(inputNode, _objectSpread2(_objectSpread2(_objectSpread2({
        type: "search"
      }, originProps), {}, {
        // Override over origin props
        id: id2,
        ref: composeRef(ref, originRef),
        disabled,
        tabIndex,
        autoComplete: autoComplete || "off",
        autoFocus,
        className: classNames("".concat(prefixCls, "-selection-search-input"), (_inputNode2 = inputNode) === null || _inputNode2 === void 0 || (_inputNode2 = _inputNode2.props) === null || _inputNode2 === void 0 ? void 0 : _inputNode2.className),
        role: "combobox",
        "aria-expanded": open || false,
        "aria-haspopup": "listbox",
        "aria-owns": "".concat(id2, "_list"),
        "aria-autocomplete": "list",
        "aria-controls": "".concat(id2, "_list"),
        "aria-activedescendant": open ? activeDescendantId : void 0
      }, attrs), {}, {
        value: editable ? value : "",
        maxLength,
        readOnly: !editable,
        unselectable: !editable ? "on" : null,
        style: _objectSpread2(_objectSpread2({}, style2), {}, {
          opacity: editable ? null : 0
        }),
        onKeyDown: function onKeyDown2(event) {
          _onKeyDown(event);
          if (onOriginKeyDown) {
            onOriginKeyDown(event);
          }
        },
        onMouseDown: function onMouseDown(event) {
          _onMouseDown(event);
          if (onOriginMouseDown) {
            onOriginMouseDown(event);
          }
        },
        onChange: function onChange(event) {
          _onChange(event);
          if (onOriginChange) {
            onOriginChange(event);
          }
        },
        onCompositionStart: function onCompositionStart(event) {
          _onCompositionStart(event);
          if (onOriginCompositionStart) {
            onOriginCompositionStart(event);
          }
        },
        onCompositionEnd: function onCompositionEnd(event) {
          _onCompositionEnd(event);
          if (onOriginCompositionEnd) {
            onOriginCompositionEnd(event);
          }
        },
        onPaste
      }));
      return inputNode;
    };
    var RefInput = /* @__PURE__ */ reactExports.forwardRef(Input$4);
    RefInput.displayName = "Input";
    function toArray$8(value) {
      if (Array.isArray(value)) {
        return value;
      }
      return value !== void 0 ? [value] : [];
    }
    var isClient = typeof window !== "undefined" && window.document && window.document.documentElement;
    var isBrowserClient$2 = isClient;
    function hasValue(value) {
      return value !== void 0 && value !== null;
    }
    function isComboNoValue(value) {
      return !value && value !== 0;
    }
    function isTitleType$1(title) {
      return ["string", "number"].includes(_typeof(title));
    }
    function getTitle(item) {
      var title = void 0;
      if (item) {
        if (isTitleType$1(item.title)) {
          title = item.title.toString();
        } else if (isTitleType$1(item.label)) {
          title = item.label.toString();
        }
      }
      return title;
    }
    function useLayoutEffect(effect, deps) {
      if (isBrowserClient$2) {
        reactExports.useLayoutEffect(effect, deps);
      } else {
        reactExports.useEffect(effect, deps);
      }
    }
    function itemKey$1(value) {
      var _value$key;
      return (_value$key = value.key) !== null && _value$key !== void 0 ? _value$key : value.value;
    }
    var onPreventMouseDown = function onPreventMouseDown2(event) {
      event.preventDefault();
      event.stopPropagation();
    };
    var SelectSelector = function SelectSelector2(props) {
      var id2 = props.id, prefixCls = props.prefixCls, values = props.values, open = props.open, searchValue = props.searchValue, autoClearSearchValue = props.autoClearSearchValue, inputRef = props.inputRef, placeholder = props.placeholder, disabled = props.disabled, mode = props.mode, showSearch = props.showSearch, autoFocus = props.autoFocus, autoComplete = props.autoComplete, activeDescendantId = props.activeDescendantId, tabIndex = props.tabIndex, removeIcon = props.removeIcon, maxTagCount = props.maxTagCount, maxTagTextLength = props.maxTagTextLength, _props$maxTagPlacehol = props.maxTagPlaceholder, maxTagPlaceholder = _props$maxTagPlacehol === void 0 ? function(omittedValues) {
        return "+ ".concat(omittedValues.length, " ...");
      } : _props$maxTagPlacehol, tagRender = props.tagRender, onToggleOpen = props.onToggleOpen, onRemove = props.onRemove, onInputChange = props.onInputChange, onInputPaste = props.onInputPaste, onInputKeyDown = props.onInputKeyDown, onInputMouseDown = props.onInputMouseDown, onInputCompositionStart = props.onInputCompositionStart, onInputCompositionEnd = props.onInputCompositionEnd;
      var measureRef = reactExports.useRef(null);
      var _useState = reactExports.useState(0), _useState2 = _slicedToArray(_useState, 2), inputWidth = _useState2[0], setInputWidth = _useState2[1];
      var _useState3 = reactExports.useState(false), _useState4 = _slicedToArray(_useState3, 2), focused = _useState4[0], setFocused = _useState4[1];
      var selectionPrefixCls = "".concat(prefixCls, "-selection");
      var inputValue = open || mode === "multiple" && autoClearSearchValue === false || mode === "tags" ? searchValue : "";
      var inputEditable = mode === "tags" || mode === "multiple" && autoClearSearchValue === false || showSearch && (open || focused);
      useLayoutEffect(function() {
        setInputWidth(measureRef.current.scrollWidth);
      }, [inputValue]);
      function defaultRenderSelector(item, content, itemDisabled, closable, onClose) {
        return /* @__PURE__ */ reactExports.createElement("span", {
          className: classNames("".concat(selectionPrefixCls, "-item"), _defineProperty({}, "".concat(selectionPrefixCls, "-item-disabled"), itemDisabled)),
          title: getTitle(item)
        }, /* @__PURE__ */ reactExports.createElement("span", {
          className: "".concat(selectionPrefixCls, "-item-content")
        }, content), closable && /* @__PURE__ */ reactExports.createElement(TransBtn, {
          className: "".concat(selectionPrefixCls, "-item-remove"),
          onMouseDown: onPreventMouseDown,
          onClick: onClose,
          customizeIcon: removeIcon
        }, "×"));
      }
      function customizeRenderSelector(value, content, itemDisabled, closable, onClose) {
        var onMouseDown = function onMouseDown2(e2) {
          onPreventMouseDown(e2);
          onToggleOpen(!open);
        };
        return /* @__PURE__ */ reactExports.createElement("span", {
          onMouseDown
        }, tagRender({
          label: content,
          value,
          disabled: itemDisabled,
          closable,
          onClose
        }));
      }
      function renderItem2(valueItem) {
        var itemDisabled = valueItem.disabled, label = valueItem.label, value = valueItem.value;
        var closable = !disabled && !itemDisabled;
        var displayLabel = label;
        if (typeof maxTagTextLength === "number") {
          if (typeof label === "string" || typeof label === "number") {
            var strLabel = String(displayLabel);
            if (strLabel.length > maxTagTextLength) {
              displayLabel = "".concat(strLabel.slice(0, maxTagTextLength), "...");
            }
          }
        }
        var onClose = function onClose2(event) {
          if (event)
            event.stopPropagation();
          onRemove(valueItem);
        };
        return typeof tagRender === "function" ? customizeRenderSelector(value, displayLabel, itemDisabled, closable, onClose) : defaultRenderSelector(valueItem, displayLabel, itemDisabled, closable, onClose);
      }
      function renderRest(omittedValues) {
        var content = typeof maxTagPlaceholder === "function" ? maxTagPlaceholder(omittedValues) : maxTagPlaceholder;
        return defaultRenderSelector({
          title: content
        }, content, false);
      }
      var inputNode = /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(selectionPrefixCls, "-search"),
        style: {
          width: inputWidth
        },
        onFocus: function onFocus() {
          setFocused(true);
        },
        onBlur: function onBlur() {
          setFocused(false);
        }
      }, /* @__PURE__ */ reactExports.createElement(RefInput, {
        ref: inputRef,
        open,
        prefixCls,
        id: id2,
        inputElement: null,
        disabled,
        autoFocus,
        autoComplete,
        editable: inputEditable,
        activeDescendantId,
        value: inputValue,
        onKeyDown: onInputKeyDown,
        onMouseDown: onInputMouseDown,
        onChange: onInputChange,
        onPaste: onInputPaste,
        onCompositionStart: onInputCompositionStart,
        onCompositionEnd: onInputCompositionEnd,
        tabIndex,
        attrs: pickAttrs(props, true)
      }), /* @__PURE__ */ reactExports.createElement("span", {
        ref: measureRef,
        className: "".concat(selectionPrefixCls, "-search-mirror"),
        "aria-hidden": true
      }, inputValue, " "));
      var selectionNode = /* @__PURE__ */ reactExports.createElement(ForwardOverflow, {
        prefixCls: "".concat(selectionPrefixCls, "-overflow"),
        data: values,
        renderItem: renderItem2,
        renderRest,
        suffix: inputNode,
        itemKey: itemKey$1,
        maxCount: maxTagCount
      });
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, selectionNode, !values.length && !inputValue && /* @__PURE__ */ reactExports.createElement("span", {
        className: "".concat(selectionPrefixCls, "-placeholder")
      }, placeholder));
    };
    var SingleSelector = function SingleSelector2(props) {
      var inputElement = props.inputElement, prefixCls = props.prefixCls, id2 = props.id, inputRef = props.inputRef, disabled = props.disabled, autoFocus = props.autoFocus, autoComplete = props.autoComplete, activeDescendantId = props.activeDescendantId, mode = props.mode, open = props.open, values = props.values, placeholder = props.placeholder, tabIndex = props.tabIndex, showSearch = props.showSearch, searchValue = props.searchValue, activeValue = props.activeValue, maxLength = props.maxLength, onInputKeyDown = props.onInputKeyDown, onInputMouseDown = props.onInputMouseDown, onInputChange = props.onInputChange, onInputPaste = props.onInputPaste, onInputCompositionStart = props.onInputCompositionStart, onInputCompositionEnd = props.onInputCompositionEnd, title = props.title;
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), inputChanged = _React$useState2[0], setInputChanged = _React$useState2[1];
      var combobox = mode === "combobox";
      var inputEditable = combobox || showSearch;
      var item = values[0];
      var inputValue = searchValue || "";
      if (combobox && activeValue && !inputChanged) {
        inputValue = activeValue;
      }
      reactExports.useEffect(function() {
        if (combobox) {
          setInputChanged(false);
        }
      }, [combobox, activeValue]);
      var hasTextInput = mode !== "combobox" && !open && !showSearch ? false : !!inputValue;
      var selectionTitle = title === void 0 ? getTitle(item) : title;
      var renderPlaceholder = function renderPlaceholder2() {
        if (item) {
          return null;
        }
        var hiddenStyle = hasTextInput ? {
          visibility: "hidden"
        } : void 0;
        return /* @__PURE__ */ reactExports.createElement("span", {
          className: "".concat(prefixCls, "-selection-placeholder"),
          style: hiddenStyle
        }, placeholder);
      };
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("span", {
        className: "".concat(prefixCls, "-selection-search")
      }, /* @__PURE__ */ reactExports.createElement(RefInput, {
        ref: inputRef,
        prefixCls,
        id: id2,
        open,
        inputElement,
        disabled,
        autoFocus,
        autoComplete,
        editable: inputEditable,
        activeDescendantId,
        value: inputValue,
        onKeyDown: onInputKeyDown,
        onMouseDown: onInputMouseDown,
        onChange: function onChange(e2) {
          setInputChanged(true);
          onInputChange(e2);
        },
        onPaste: onInputPaste,
        onCompositionStart: onInputCompositionStart,
        onCompositionEnd: onInputCompositionEnd,
        tabIndex,
        attrs: pickAttrs(props, true),
        maxLength: combobox ? maxLength : void 0
      })), !combobox && item ? /* @__PURE__ */ reactExports.createElement("span", {
        className: "".concat(prefixCls, "-selection-item"),
        title: selectionTitle,
        style: hasTextInput ? {
          visibility: "hidden"
        } : void 0
      }, item.label) : null, renderPlaceholder());
    };
    function isValidateOpenKey(currentKeyCode) {
      return ![
        // System function button
        KeyCode.ESC,
        KeyCode.SHIFT,
        KeyCode.BACKSPACE,
        KeyCode.TAB,
        KeyCode.WIN_KEY,
        KeyCode.ALT,
        KeyCode.META,
        KeyCode.WIN_KEY_RIGHT,
        KeyCode.CTRL,
        KeyCode.SEMICOLON,
        KeyCode.EQUALS,
        KeyCode.CAPS_LOCK,
        KeyCode.CONTEXT_MENU,
        // F1-F12
        KeyCode.F1,
        KeyCode.F2,
        KeyCode.F3,
        KeyCode.F4,
        KeyCode.F5,
        KeyCode.F6,
        KeyCode.F7,
        KeyCode.F8,
        KeyCode.F9,
        KeyCode.F10,
        KeyCode.F11,
        KeyCode.F12
      ].includes(currentKeyCode);
    }
    var Selector = function Selector2(props, ref) {
      var inputRef = reactExports.useRef(null);
      var compositionStatusRef = reactExports.useRef(false);
      var prefixCls = props.prefixCls, open = props.open, mode = props.mode, showSearch = props.showSearch, tokenWithEnter = props.tokenWithEnter, autoClearSearchValue = props.autoClearSearchValue, onSearch = props.onSearch, onSearchSubmit = props.onSearchSubmit, onToggleOpen = props.onToggleOpen, onInputKeyDown = props.onInputKeyDown, domRef = props.domRef;
      reactExports.useImperativeHandle(ref, function() {
        return {
          focus: function focus() {
            inputRef.current.focus();
          },
          blur: function blur() {
            inputRef.current.blur();
          }
        };
      });
      var _useLock = useLock(0), _useLock2 = _slicedToArray(_useLock, 2), getInputMouseDown = _useLock2[0], setInputMouseDown = _useLock2[1];
      var onInternalInputKeyDown = function onInternalInputKeyDown2(event) {
        var which = event.which;
        if (which === KeyCode.UP || which === KeyCode.DOWN) {
          event.preventDefault();
        }
        if (onInputKeyDown) {
          onInputKeyDown(event);
        }
        if (which === KeyCode.ENTER && mode === "tags" && !compositionStatusRef.current && !open) {
          onSearchSubmit === null || onSearchSubmit === void 0 || onSearchSubmit(event.target.value);
        }
        if (isValidateOpenKey(which)) {
          onToggleOpen(true);
        }
      };
      var onInternalInputMouseDown = function onInternalInputMouseDown2() {
        setInputMouseDown(true);
      };
      var pastedTextRef = reactExports.useRef(null);
      var triggerOnSearch = function triggerOnSearch2(value) {
        if (onSearch(value, true, compositionStatusRef.current) !== false) {
          onToggleOpen(true);
        }
      };
      var onInputCompositionStart = function onInputCompositionStart2() {
        compositionStatusRef.current = true;
      };
      var onInputCompositionEnd = function onInputCompositionEnd2(e2) {
        compositionStatusRef.current = false;
        if (mode !== "combobox") {
          triggerOnSearch(e2.target.value);
        }
      };
      var onInputChange = function onInputChange2(event) {
        var value = event.target.value;
        if (tokenWithEnter && pastedTextRef.current && /[\r\n]/.test(pastedTextRef.current)) {
          var replacedText = pastedTextRef.current.replace(/[\r\n]+$/, "").replace(/\r\n/g, " ").replace(/[\r\n]/g, " ");
          value = value.replace(replacedText, pastedTextRef.current);
        }
        pastedTextRef.current = null;
        triggerOnSearch(value);
      };
      var onInputPaste = function onInputPaste2(e2) {
        var clipboardData = e2.clipboardData;
        var value = clipboardData.getData("text");
        pastedTextRef.current = value;
      };
      var onClick = function onClick2(_ref) {
        var target = _ref.target;
        if (target !== inputRef.current) {
          var isIE = document.body.style.msTouchAction !== void 0;
          if (isIE) {
            setTimeout(function() {
              inputRef.current.focus();
            });
          } else {
            inputRef.current.focus();
          }
        }
      };
      var onMouseDown = function onMouseDown2(event) {
        var inputMouseDown = getInputMouseDown();
        if (event.target !== inputRef.current && !inputMouseDown && mode !== "combobox") {
          event.preventDefault();
        }
        if (mode !== "combobox" && (!showSearch || !inputMouseDown) || !open) {
          if (open && autoClearSearchValue !== false) {
            onSearch("", true, false);
          }
          onToggleOpen();
        }
      };
      var sharedProps = {
        inputRef,
        onInputKeyDown: onInternalInputKeyDown,
        onInputMouseDown: onInternalInputMouseDown,
        onInputChange,
        onInputPaste,
        onInputCompositionStart,
        onInputCompositionEnd
      };
      var selectNode = mode === "multiple" || mode === "tags" ? /* @__PURE__ */ reactExports.createElement(SelectSelector, _extends$1({}, props, sharedProps)) : /* @__PURE__ */ reactExports.createElement(SingleSelector, _extends$1({}, props, sharedProps));
      return /* @__PURE__ */ reactExports.createElement("div", {
        ref: domRef,
        className: "".concat(prefixCls, "-selector"),
        onClick,
        onMouseDown
      }, selectNode);
    };
    var ForwardSelector = /* @__PURE__ */ reactExports.forwardRef(Selector);
    ForwardSelector.displayName = "Selector";
    function Arrow(props) {
      var prefixCls = props.prefixCls, align = props.align, arrow = props.arrow, arrowPos = props.arrowPos;
      var _ref = arrow || {}, className = _ref.className, content = _ref.content;
      var _arrowPos$x = arrowPos.x, x2 = _arrowPos$x === void 0 ? 0 : _arrowPos$x, _arrowPos$y = arrowPos.y, y2 = _arrowPos$y === void 0 ? 0 : _arrowPos$y;
      var arrowRef = reactExports.useRef();
      if (!align || !align.points) {
        return null;
      }
      var alignStyle = {
        position: "absolute"
      };
      if (align.autoArrow !== false) {
        var popupPoints = align.points[0];
        var targetPoints = align.points[1];
        var popupTB = popupPoints[0];
        var popupLR = popupPoints[1];
        var targetTB = targetPoints[0];
        var targetLR = targetPoints[1];
        if (popupTB === targetTB || !["t", "b"].includes(popupTB)) {
          alignStyle.top = y2;
        } else if (popupTB === "t") {
          alignStyle.top = 0;
        } else {
          alignStyle.bottom = 0;
        }
        if (popupLR === targetLR || !["l", "r"].includes(popupLR)) {
          alignStyle.left = x2;
        } else if (popupLR === "l") {
          alignStyle.left = 0;
        } else {
          alignStyle.right = 0;
        }
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        ref: arrowRef,
        className: classNames("".concat(prefixCls, "-arrow"), className),
        style: alignStyle
      }, content);
    }
    function Mask(props) {
      var prefixCls = props.prefixCls, open = props.open, zIndex = props.zIndex, mask = props.mask, motion = props.motion;
      if (!mask) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(CSSMotion, _extends$1({}, motion, {
        motionAppear: true,
        visible: open,
        removeOnLeave: true
      }), function(_ref) {
        var className = _ref.className;
        return /* @__PURE__ */ reactExports.createElement("div", {
          style: {
            zIndex
          },
          className: classNames("".concat(prefixCls, "-mask"), className)
        });
      });
    }
    var PopupContent = /* @__PURE__ */ reactExports.memo(function(_ref) {
      var children = _ref.children;
      return children;
    }, function(_, next2) {
      return next2.cache;
    });
    var Popup$1 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var popup = props.popup, className = props.className, prefixCls = props.prefixCls, style2 = props.style, target = props.target, _onVisibleChanged = props.onVisibleChanged, open = props.open, keepDom = props.keepDom, fresh = props.fresh, onClick = props.onClick, mask = props.mask, arrow = props.arrow, arrowPos = props.arrowPos, align = props.align, motion = props.motion, maskMotion = props.maskMotion, forceRender = props.forceRender, getPopupContainer = props.getPopupContainer, autoDestroy = props.autoDestroy, Portal2 = props.portal, zIndex = props.zIndex, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onPointerEnter = props.onPointerEnter, ready = props.ready, offsetX = props.offsetX, offsetY = props.offsetY, offsetR = props.offsetR, offsetB = props.offsetB, onAlign = props.onAlign, onPrepare = props.onPrepare, stretch = props.stretch, targetWidth = props.targetWidth, targetHeight = props.targetHeight;
      var childNode = typeof popup === "function" ? popup() : popup;
      var isNodeVisible = open || keepDom;
      var getPopupContainerNeedParams = (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.length) > 0;
      var _React$useState = reactExports.useState(!getPopupContainer || !getPopupContainerNeedParams), _React$useState2 = _slicedToArray(_React$useState, 2), show = _React$useState2[0], setShow = _React$useState2[1];
      useLayoutEffect$1(function() {
        if (!show && getPopupContainerNeedParams && target) {
          setShow(true);
        }
      }, [show, getPopupContainerNeedParams, target]);
      if (!show) {
        return null;
      }
      var AUTO = "auto";
      var offsetStyle = {
        left: "-1000vw",
        top: "-1000vh",
        right: AUTO,
        bottom: AUTO
      };
      if (ready || !open) {
        var _experimental;
        var points = align.points;
        var dynamicInset = align.dynamicInset || ((_experimental = align._experimental) === null || _experimental === void 0 ? void 0 : _experimental.dynamicInset);
        var alignRight = dynamicInset && points[0][1] === "r";
        var alignBottom = dynamicInset && points[0][0] === "b";
        if (alignRight) {
          offsetStyle.right = offsetR;
          offsetStyle.left = AUTO;
        } else {
          offsetStyle.left = offsetX;
          offsetStyle.right = AUTO;
        }
        if (alignBottom) {
          offsetStyle.bottom = offsetB;
          offsetStyle.top = AUTO;
        } else {
          offsetStyle.top = offsetY;
          offsetStyle.bottom = AUTO;
        }
      }
      var miscStyle = {};
      if (stretch) {
        if (stretch.includes("height") && targetHeight) {
          miscStyle.height = targetHeight;
        } else if (stretch.includes("minHeight") && targetHeight) {
          miscStyle.minHeight = targetHeight;
        }
        if (stretch.includes("width") && targetWidth) {
          miscStyle.width = targetWidth;
        } else if (stretch.includes("minWidth") && targetWidth) {
          miscStyle.minWidth = targetWidth;
        }
      }
      if (!open) {
        miscStyle.pointerEvents = "none";
      }
      return /* @__PURE__ */ reactExports.createElement(Portal2, {
        open: forceRender || isNodeVisible,
        getContainer: getPopupContainer && function() {
          return getPopupContainer(target);
        },
        autoDestroy
      }, /* @__PURE__ */ reactExports.createElement(Mask, {
        prefixCls,
        open,
        zIndex,
        mask,
        motion: maskMotion
      }), /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
        onResize: onAlign,
        disabled: !open
      }, function(resizeObserverRef) {
        return /* @__PURE__ */ reactExports.createElement(CSSMotion, _extends$1({
          motionAppear: true,
          motionEnter: true,
          motionLeave: true,
          removeOnLeave: false,
          forceRender,
          leavedClassName: "".concat(prefixCls, "-hidden")
        }, motion, {
          onAppearPrepare: onPrepare,
          onEnterPrepare: onPrepare,
          visible: open,
          onVisibleChanged: function onVisibleChanged(nextVisible) {
            var _motion$onVisibleChan;
            motion === null || motion === void 0 || (_motion$onVisibleChan = motion.onVisibleChanged) === null || _motion$onVisibleChan === void 0 || _motion$onVisibleChan.call(motion, nextVisible);
            _onVisibleChanged(nextVisible);
          }
        }), function(_ref, motionRef) {
          var motionClassName = _ref.className, motionStyle = _ref.style;
          var cls = classNames(prefixCls, motionClassName, className);
          return /* @__PURE__ */ reactExports.createElement("div", {
            ref: composeRef(resizeObserverRef, ref, motionRef),
            className: cls,
            style: _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({
              "--arrow-x": "".concat(arrowPos.x || 0, "px"),
              "--arrow-y": "".concat(arrowPos.y || 0, "px")
            }, offsetStyle), miscStyle), motionStyle), {}, {
              boxSizing: "border-box",
              zIndex
            }, style2),
            onMouseEnter,
            onMouseLeave,
            onPointerEnter,
            onClick
          }, arrow && /* @__PURE__ */ reactExports.createElement(Arrow, {
            prefixCls,
            arrow,
            arrowPos,
            align
          }), /* @__PURE__ */ reactExports.createElement(PopupContent, {
            cache: !open && !fresh
          }, childNode));
        });
      }));
    });
    var TriggerWrapper = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var children = props.children, getTriggerDOMNode = props.getTriggerDOMNode;
      var canUseRef = supportRef(children);
      var setRef = reactExports.useCallback(function(node2) {
        fillRef(ref, getTriggerDOMNode ? getTriggerDOMNode(node2) : node2);
      }, [getTriggerDOMNode]);
      var mergedRef = useComposeRef(setRef, children.ref);
      return canUseRef ? /* @__PURE__ */ reactExports.cloneElement(children, {
        ref: mergedRef
      }) : children;
    });
    var TriggerContext = /* @__PURE__ */ reactExports.createContext(null);
    function toArray$7(val) {
      return val ? Array.isArray(val) ? val : [val] : [];
    }
    function useAction(mobile, action, showAction, hideAction) {
      return reactExports.useMemo(function() {
        var mergedShowAction = toArray$7(showAction !== null && showAction !== void 0 ? showAction : action);
        var mergedHideAction = toArray$7(hideAction !== null && hideAction !== void 0 ? hideAction : action);
        var showActionSet = new Set(mergedShowAction);
        var hideActionSet = new Set(mergedHideAction);
        if (mobile) {
          if (showActionSet.has("hover")) {
            showActionSet.delete("hover");
            showActionSet.add("click");
          }
          if (hideActionSet.has("hover")) {
            hideActionSet.delete("hover");
            hideActionSet.add("click");
          }
        }
        return [showActionSet, hideActionSet];
      }, [mobile, action, showAction, hideAction]);
    }
    function isPointsEq() {
      var a1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var a2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var isAlignPoint = arguments.length > 2 ? arguments[2] : void 0;
      if (isAlignPoint) {
        return a1[0] === a2[0];
      }
      return a1[0] === a2[0] && a1[1] === a2[1];
    }
    function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
      var points = align.points;
      var placements2 = Object.keys(builtinPlacements);
      for (var i = 0; i < placements2.length; i += 1) {
        var _builtinPlacements$pl;
        var placement = placements2[i];
        if (isPointsEq((_builtinPlacements$pl = builtinPlacements[placement]) === null || _builtinPlacements$pl === void 0 ? void 0 : _builtinPlacements$pl.points, points, isAlignPoint)) {
          return "".concat(prefixCls, "-placement-").concat(placement);
        }
      }
      return "";
    }
    function getMotion$1(prefixCls, motion, animation, transitionName) {
      if (motion) {
        return motion;
      }
      if (animation) {
        return {
          motionName: "".concat(prefixCls, "-").concat(animation)
        };
      }
      if (transitionName) {
        return {
          motionName: transitionName
        };
      }
      return null;
    }
    function getWin(ele) {
      return ele.ownerDocument.defaultView;
    }
    function collectScroller(ele) {
      var scrollerList = [];
      var current = ele === null || ele === void 0 ? void 0 : ele.parentElement;
      var scrollStyle = ["hidden", "scroll", "clip", "auto"];
      while (current) {
        var _getWin$getComputedSt = getWin(current).getComputedStyle(current), overflowX = _getWin$getComputedSt.overflowX, overflowY = _getWin$getComputedSt.overflowY, overflow = _getWin$getComputedSt.overflow;
        if ([overflowX, overflowY, overflow].some(function(o2) {
          return scrollStyle.includes(o2);
        })) {
          scrollerList.push(current);
        }
        current = current.parentElement;
      }
      return scrollerList;
    }
    function toNum(num) {
      var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      return Number.isNaN(num) ? defaultValue : num;
    }
    function getPxValue(val) {
      return toNum(parseFloat(val), 0);
    }
    function getVisibleArea(initArea, scrollerList) {
      var visibleArea = _objectSpread2({}, initArea);
      (scrollerList || []).forEach(function(ele) {
        if (ele instanceof HTMLBodyElement || ele instanceof HTMLHtmlElement) {
          return;
        }
        var _getWin$getComputedSt2 = getWin(ele).getComputedStyle(ele), overflow = _getWin$getComputedSt2.overflow, overflowClipMargin = _getWin$getComputedSt2.overflowClipMargin, borderTopWidth = _getWin$getComputedSt2.borderTopWidth, borderBottomWidth = _getWin$getComputedSt2.borderBottomWidth, borderLeftWidth = _getWin$getComputedSt2.borderLeftWidth, borderRightWidth = _getWin$getComputedSt2.borderRightWidth;
        var eleRect = ele.getBoundingClientRect();
        var eleOutHeight = ele.offsetHeight, eleInnerHeight = ele.clientHeight, eleOutWidth = ele.offsetWidth, eleInnerWidth = ele.clientWidth;
        var borderTopNum = getPxValue(borderTopWidth);
        var borderBottomNum = getPxValue(borderBottomWidth);
        var borderLeftNum = getPxValue(borderLeftWidth);
        var borderRightNum = getPxValue(borderRightWidth);
        var scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1e3) / 1e3);
        var scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1e3) / 1e3);
        var eleScrollWidth = (eleOutWidth - eleInnerWidth - borderLeftNum - borderRightNum) * scaleX;
        var eleScrollHeight = (eleOutHeight - eleInnerHeight - borderTopNum - borderBottomNum) * scaleY;
        var scaledBorderTopWidth = borderTopNum * scaleY;
        var scaledBorderBottomWidth = borderBottomNum * scaleY;
        var scaledBorderLeftWidth = borderLeftNum * scaleX;
        var scaledBorderRightWidth = borderRightNum * scaleX;
        var clipMarginWidth = 0;
        var clipMarginHeight = 0;
        if (overflow === "clip") {
          var clipNum = getPxValue(overflowClipMargin);
          clipMarginWidth = clipNum * scaleX;
          clipMarginHeight = clipNum * scaleY;
        }
        var eleLeft = eleRect.x + scaledBorderLeftWidth - clipMarginWidth;
        var eleTop = eleRect.y + scaledBorderTopWidth - clipMarginHeight;
        var eleRight = eleLeft + eleRect.width + 2 * clipMarginWidth - scaledBorderLeftWidth - scaledBorderRightWidth - eleScrollWidth;
        var eleBottom = eleTop + eleRect.height + 2 * clipMarginHeight - scaledBorderTopWidth - scaledBorderBottomWidth - eleScrollHeight;
        visibleArea.left = Math.max(visibleArea.left, eleLeft);
        visibleArea.top = Math.max(visibleArea.top, eleTop);
        visibleArea.right = Math.min(visibleArea.right, eleRight);
        visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);
      });
      return visibleArea;
    }
    function getUnitOffset(size) {
      var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var offsetStr = "".concat(offset2);
      var cells = offsetStr.match(/^(.*)\%$/);
      if (cells) {
        return size * (parseFloat(cells[1]) / 100);
      }
      return parseFloat(offsetStr);
    }
    function getNumberOffset(rect, offset2) {
      var _ref = offset2 || [], _ref2 = _slicedToArray(_ref, 2), offsetX = _ref2[0], offsetY = _ref2[1];
      return [getUnitOffset(rect.width, offsetX), getUnitOffset(rect.height, offsetY)];
    }
    function splitPoints() {
      var points = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      return [points[0], points[1]];
    }
    function getAlignPoint(rect, points) {
      var topBottom = points[0];
      var leftRight = points[1];
      var x2;
      var y2;
      if (topBottom === "t") {
        y2 = rect.y;
      } else if (topBottom === "b") {
        y2 = rect.y + rect.height;
      } else {
        y2 = rect.y + rect.height / 2;
      }
      if (leftRight === "l") {
        x2 = rect.x;
      } else if (leftRight === "r") {
        x2 = rect.x + rect.width;
      } else {
        x2 = rect.x + rect.width / 2;
      }
      return {
        x: x2,
        y: y2
      };
    }
    function reversePoints(points, index2) {
      var reverseMap = {
        t: "b",
        b: "t",
        l: "r",
        r: "l"
      };
      return points.map(function(point, i) {
        if (i === index2) {
          return reverseMap[point] || "c";
        }
        return point;
      }).join("");
    }
    function useAlign(open, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign) {
      var _React$useState = reactExports.useState({
        ready: false,
        offsetX: 0,
        offsetY: 0,
        offsetR: 0,
        offsetB: 0,
        arrowX: 0,
        arrowY: 0,
        scaleX: 1,
        scaleY: 1,
        align: builtinPlacements[placement] || {}
      }), _React$useState2 = _slicedToArray(_React$useState, 2), offsetInfo = _React$useState2[0], setOffsetInfo = _React$useState2[1];
      var alignCountRef = reactExports.useRef(0);
      var scrollerList = reactExports.useMemo(function() {
        if (!popupEle) {
          return [];
        }
        return collectScroller(popupEle);
      }, [popupEle]);
      var prevFlipRef = reactExports.useRef({});
      var resetFlipCache = function resetFlipCache2() {
        prevFlipRef.current = {};
      };
      if (!open) {
        resetFlipCache();
      }
      var onAlign = useEvent(function() {
        if (popupEle && target && open) {
          let getIntersectionVisibleArea2 = function(offsetX, offsetY) {
            var area = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : visibleArea;
            var l2 = popupRect.x + offsetX;
            var t2 = popupRect.y + offsetY;
            var r2 = l2 + popupWidth;
            var b2 = t2 + popupHeight;
            var visibleL = Math.max(l2, area.left);
            var visibleT = Math.max(t2, area.top);
            var visibleR = Math.min(r2, area.right);
            var visibleB = Math.min(b2, area.bottom);
            return Math.max(0, (visibleR - visibleL) * (visibleB - visibleT));
          }, syncNextPopupPosition2 = function() {
            nextPopupY = popupRect.y + nextOffsetY;
            nextPopupBottom = nextPopupY + popupHeight;
            nextPopupX = popupRect.x + nextOffsetX;
            nextPopupRight = nextPopupX + popupWidth;
          };
          var getIntersectionVisibleArea = getIntersectionVisibleArea2, syncNextPopupPosition = syncNextPopupPosition2;
          var _popupElement$parentE, _popupElement$parentE2;
          var popupElement = popupEle;
          var doc = popupElement.ownerDocument;
          var win = getWin(popupElement);
          var _win$getComputedStyle = win.getComputedStyle(popupElement), width = _win$getComputedStyle.width, height = _win$getComputedStyle.height, popupPosition = _win$getComputedStyle.position;
          var originLeft = popupElement.style.left;
          var originTop = popupElement.style.top;
          var originRight = popupElement.style.right;
          var originBottom = popupElement.style.bottom;
          var originOverflow = popupElement.style.overflow;
          var placementInfo = _objectSpread2(_objectSpread2({}, builtinPlacements[placement]), popupAlign);
          var placeholderElement = doc.createElement("div");
          (_popupElement$parentE = popupElement.parentElement) === null || _popupElement$parentE === void 0 || _popupElement$parentE.appendChild(placeholderElement);
          placeholderElement.style.left = "".concat(popupElement.offsetLeft, "px");
          placeholderElement.style.top = "".concat(popupElement.offsetTop, "px");
          placeholderElement.style.position = popupPosition;
          placeholderElement.style.height = "".concat(popupElement.offsetHeight, "px");
          placeholderElement.style.width = "".concat(popupElement.offsetWidth, "px");
          popupElement.style.left = "0";
          popupElement.style.top = "0";
          popupElement.style.right = "auto";
          popupElement.style.bottom = "auto";
          popupElement.style.overflow = "hidden";
          var targetRect;
          if (Array.isArray(target)) {
            targetRect = {
              x: target[0],
              y: target[1],
              width: 0,
              height: 0
            };
          } else {
            var rect = target.getBoundingClientRect();
            targetRect = {
              x: rect.x,
              y: rect.y,
              width: rect.width,
              height: rect.height
            };
          }
          var popupRect = popupElement.getBoundingClientRect();
          var _doc$documentElement = doc.documentElement, clientWidth = _doc$documentElement.clientWidth, clientHeight = _doc$documentElement.clientHeight, scrollWidth = _doc$documentElement.scrollWidth, scrollHeight = _doc$documentElement.scrollHeight, scrollTop = _doc$documentElement.scrollTop, scrollLeft = _doc$documentElement.scrollLeft;
          var popupHeight = popupRect.height;
          var popupWidth = popupRect.width;
          var targetHeight = targetRect.height;
          var targetWidth = targetRect.width;
          var visibleRegion = {
            left: 0,
            top: 0,
            right: clientWidth,
            bottom: clientHeight
          };
          var scrollRegion = {
            left: -scrollLeft,
            top: -scrollTop,
            right: scrollWidth - scrollLeft,
            bottom: scrollHeight - scrollTop
          };
          var htmlRegion = placementInfo.htmlRegion;
          var VISIBLE = "visible";
          var VISIBLE_FIRST = "visibleFirst";
          if (htmlRegion !== "scroll" && htmlRegion !== VISIBLE_FIRST) {
            htmlRegion = VISIBLE;
          }
          var isVisibleFirst = htmlRegion === VISIBLE_FIRST;
          var scrollRegionArea = getVisibleArea(scrollRegion, scrollerList);
          var visibleRegionArea = getVisibleArea(visibleRegion, scrollerList);
          var visibleArea = htmlRegion === VISIBLE ? visibleRegionArea : scrollRegionArea;
          var adjustCheckVisibleArea = isVisibleFirst ? visibleRegionArea : visibleArea;
          popupElement.style.left = "auto";
          popupElement.style.top = "auto";
          popupElement.style.right = "0";
          popupElement.style.bottom = "0";
          var popupMirrorRect = popupElement.getBoundingClientRect();
          popupElement.style.left = originLeft;
          popupElement.style.top = originTop;
          popupElement.style.right = originRight;
          popupElement.style.bottom = originBottom;
          popupElement.style.overflow = originOverflow;
          (_popupElement$parentE2 = popupElement.parentElement) === null || _popupElement$parentE2 === void 0 || _popupElement$parentE2.removeChild(placeholderElement);
          var _scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1e3) / 1e3);
          var _scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1e3) / 1e3);
          if (_scaleX === 0 || _scaleY === 0 || isDOM(target) && !isVisible(target)) {
            return;
          }
          var offset2 = placementInfo.offset, targetOffset2 = placementInfo.targetOffset;
          var _getNumberOffset = getNumberOffset(popupRect, offset2), _getNumberOffset2 = _slicedToArray(_getNumberOffset, 2), popupOffsetX = _getNumberOffset2[0], popupOffsetY = _getNumberOffset2[1];
          var _getNumberOffset3 = getNumberOffset(targetRect, targetOffset2), _getNumberOffset4 = _slicedToArray(_getNumberOffset3, 2), targetOffsetX = _getNumberOffset4[0], targetOffsetY = _getNumberOffset4[1];
          targetRect.x -= targetOffsetX;
          targetRect.y -= targetOffsetY;
          var _ref3 = placementInfo.points || [], _ref4 = _slicedToArray(_ref3, 2), popupPoint = _ref4[0], targetPoint = _ref4[1];
          var targetPoints = splitPoints(targetPoint);
          var popupPoints = splitPoints(popupPoint);
          var targetAlignPoint = getAlignPoint(targetRect, targetPoints);
          var popupAlignPoint = getAlignPoint(popupRect, popupPoints);
          var nextAlignInfo = _objectSpread2({}, placementInfo);
          var nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;
          var nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;
          var originIntersectionVisibleArea = getIntersectionVisibleArea2(nextOffsetX, nextOffsetY);
          var originIntersectionRecommendArea = getIntersectionVisibleArea2(nextOffsetX, nextOffsetY, visibleRegionArea);
          var targetAlignPointTL = getAlignPoint(targetRect, ["t", "l"]);
          var popupAlignPointTL = getAlignPoint(popupRect, ["t", "l"]);
          var targetAlignPointBR = getAlignPoint(targetRect, ["b", "r"]);
          var popupAlignPointBR = getAlignPoint(popupRect, ["b", "r"]);
          var overflow = placementInfo.overflow || {};
          var adjustX = overflow.adjustX, adjustY = overflow.adjustY, shiftX = overflow.shiftX, shiftY = overflow.shiftY;
          var supportAdjust = function supportAdjust2(val) {
            if (typeof val === "boolean") {
              return val;
            }
            return val >= 0;
          };
          var nextPopupY;
          var nextPopupBottom;
          var nextPopupX;
          var nextPopupRight;
          syncNextPopupPosition2();
          var needAdjustY = supportAdjust(adjustY);
          var sameTB = popupPoints[0] === targetPoints[0];
          if (needAdjustY && popupPoints[0] === "t" && (nextPopupBottom > adjustCheckVisibleArea.bottom || prevFlipRef.current.bt)) {
            var tmpNextOffsetY = nextOffsetY;
            if (sameTB) {
              tmpNextOffsetY -= popupHeight - targetHeight;
            } else {
              tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;
            }
            var newVisibleArea = getIntersectionVisibleArea2(nextOffsetX, tmpNextOffsetY);
            var newVisibleRecommendArea = getIntersectionVisibleArea2(nextOffsetX, tmpNextOffsetY, visibleRegionArea);
            if (
              // Of course use larger one
              newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
              newVisibleRecommendArea >= originIntersectionRecommendArea)
            ) {
              prevFlipRef.current.bt = true;
              nextOffsetY = tmpNextOffsetY;
              popupOffsetY = -popupOffsetY;
              nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];
            } else {
              prevFlipRef.current.bt = false;
            }
          }
          if (needAdjustY && popupPoints[0] === "b" && (nextPopupY < adjustCheckVisibleArea.top || prevFlipRef.current.tb)) {
            var _tmpNextOffsetY = nextOffsetY;
            if (sameTB) {
              _tmpNextOffsetY += popupHeight - targetHeight;
            } else {
              _tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;
            }
            var _newVisibleArea = getIntersectionVisibleArea2(nextOffsetX, _tmpNextOffsetY);
            var _newVisibleRecommendArea = getIntersectionVisibleArea2(nextOffsetX, _tmpNextOffsetY, visibleRegionArea);
            if (
              // Of course use larger one
              _newVisibleArea > originIntersectionVisibleArea || _newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
              _newVisibleRecommendArea >= originIntersectionRecommendArea)
            ) {
              prevFlipRef.current.tb = true;
              nextOffsetY = _tmpNextOffsetY;
              popupOffsetY = -popupOffsetY;
              nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];
            } else {
              prevFlipRef.current.tb = false;
            }
          }
          var needAdjustX = supportAdjust(adjustX);
          var sameLR = popupPoints[1] === targetPoints[1];
          if (needAdjustX && popupPoints[1] === "l" && (nextPopupRight > adjustCheckVisibleArea.right || prevFlipRef.current.rl)) {
            var tmpNextOffsetX = nextOffsetX;
            if (sameLR) {
              tmpNextOffsetX -= popupWidth - targetWidth;
            } else {
              tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;
            }
            var _newVisibleArea2 = getIntersectionVisibleArea2(tmpNextOffsetX, nextOffsetY);
            var _newVisibleRecommendArea2 = getIntersectionVisibleArea2(tmpNextOffsetX, nextOffsetY, visibleRegionArea);
            if (
              // Of course use larger one
              _newVisibleArea2 > originIntersectionVisibleArea || _newVisibleArea2 === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
              _newVisibleRecommendArea2 >= originIntersectionRecommendArea)
            ) {
              prevFlipRef.current.rl = true;
              nextOffsetX = tmpNextOffsetX;
              popupOffsetX = -popupOffsetX;
              nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];
            } else {
              prevFlipRef.current.rl = false;
            }
          }
          if (needAdjustX && popupPoints[1] === "r" && (nextPopupX < adjustCheckVisibleArea.left || prevFlipRef.current.lr)) {
            var _tmpNextOffsetX = nextOffsetX;
            if (sameLR) {
              _tmpNextOffsetX += popupWidth - targetWidth;
            } else {
              _tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;
            }
            var _newVisibleArea3 = getIntersectionVisibleArea2(_tmpNextOffsetX, nextOffsetY);
            var _newVisibleRecommendArea3 = getIntersectionVisibleArea2(_tmpNextOffsetX, nextOffsetY, visibleRegionArea);
            if (
              // Of course use larger one
              _newVisibleArea3 > originIntersectionVisibleArea || _newVisibleArea3 === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
              _newVisibleRecommendArea3 >= originIntersectionRecommendArea)
            ) {
              prevFlipRef.current.lr = true;
              nextOffsetX = _tmpNextOffsetX;
              popupOffsetX = -popupOffsetX;
              nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];
            } else {
              prevFlipRef.current.lr = false;
            }
          }
          syncNextPopupPosition2();
          var numShiftX = shiftX === true ? 0 : shiftX;
          if (typeof numShiftX === "number") {
            if (nextPopupX < visibleRegionArea.left) {
              nextOffsetX -= nextPopupX - visibleRegionArea.left - popupOffsetX;
              if (targetRect.x + targetWidth < visibleRegionArea.left + numShiftX) {
                nextOffsetX += targetRect.x - visibleRegionArea.left + targetWidth - numShiftX;
              }
            }
            if (nextPopupRight > visibleRegionArea.right) {
              nextOffsetX -= nextPopupRight - visibleRegionArea.right - popupOffsetX;
              if (targetRect.x > visibleRegionArea.right - numShiftX) {
                nextOffsetX += targetRect.x - visibleRegionArea.right + numShiftX;
              }
            }
          }
          var numShiftY = shiftY === true ? 0 : shiftY;
          if (typeof numShiftY === "number") {
            if (nextPopupY < visibleRegionArea.top) {
              nextOffsetY -= nextPopupY - visibleRegionArea.top - popupOffsetY;
              if (targetRect.y + targetHeight < visibleRegionArea.top + numShiftY) {
                nextOffsetY += targetRect.y - visibleRegionArea.top + targetHeight - numShiftY;
              }
            }
            if (nextPopupBottom > visibleRegionArea.bottom) {
              nextOffsetY -= nextPopupBottom - visibleRegionArea.bottom - popupOffsetY;
              if (targetRect.y > visibleRegionArea.bottom - numShiftY) {
                nextOffsetY += targetRect.y - visibleRegionArea.bottom + numShiftY;
              }
            }
          }
          var popupLeft = popupRect.x + nextOffsetX;
          var popupRight = popupLeft + popupWidth;
          var popupTop = popupRect.y + nextOffsetY;
          var popupBottom = popupTop + popupHeight;
          var targetLeft = targetRect.x;
          var targetRight = targetLeft + targetWidth;
          var targetTop = targetRect.y;
          var targetBottom = targetTop + targetHeight;
          var maxLeft = Math.max(popupLeft, targetLeft);
          var minRight = Math.min(popupRight, targetRight);
          var xCenter = (maxLeft + minRight) / 2;
          var nextArrowX = xCenter - popupLeft;
          var maxTop = Math.max(popupTop, targetTop);
          var minBottom = Math.min(popupBottom, targetBottom);
          var yCenter = (maxTop + minBottom) / 2;
          var nextArrowY = yCenter - popupTop;
          onPopupAlign === null || onPopupAlign === void 0 || onPopupAlign(popupEle, nextAlignInfo);
          var offsetX4Right = popupMirrorRect.right - popupRect.x - (nextOffsetX + popupRect.width);
          var offsetY4Bottom = popupMirrorRect.bottom - popupRect.y - (nextOffsetY + popupRect.height);
          setOffsetInfo({
            ready: true,
            offsetX: nextOffsetX / _scaleX,
            offsetY: nextOffsetY / _scaleY,
            offsetR: offsetX4Right / _scaleX,
            offsetB: offsetY4Bottom / _scaleY,
            arrowX: nextArrowX / _scaleX,
            arrowY: nextArrowY / _scaleY,
            scaleX: _scaleX,
            scaleY: _scaleY,
            align: nextAlignInfo
          });
        }
      });
      var triggerAlign = function triggerAlign2() {
        alignCountRef.current += 1;
        var id2 = alignCountRef.current;
        Promise.resolve().then(function() {
          if (alignCountRef.current === id2) {
            onAlign();
          }
        });
      };
      var resetReady = function resetReady2() {
        setOffsetInfo(function(ori) {
          return _objectSpread2(_objectSpread2({}, ori), {}, {
            ready: false
          });
        });
      };
      useLayoutEffect$1(resetReady, [placement]);
      useLayoutEffect$1(function() {
        if (!open) {
          resetReady();
        }
      }, [open]);
      return [offsetInfo.ready, offsetInfo.offsetX, offsetInfo.offsetY, offsetInfo.offsetR, offsetInfo.offsetB, offsetInfo.arrowX, offsetInfo.arrowY, offsetInfo.scaleX, offsetInfo.scaleY, offsetInfo.align, triggerAlign];
    }
    function useWatch(open, target, popup, onAlign, onScroll) {
      useLayoutEffect$1(function() {
        if (open && target && popup) {
          let notifyScroll2 = function() {
            onAlign();
            onScroll();
          };
          var notifyScroll = notifyScroll2;
          var targetElement = target;
          var popupElement = popup;
          var targetScrollList = collectScroller(targetElement);
          var popupScrollList = collectScroller(popupElement);
          var win = getWin(popupElement);
          var mergedList = new Set([win].concat(_toConsumableArray(targetScrollList), _toConsumableArray(popupScrollList)));
          mergedList.forEach(function(scroller) {
            scroller.addEventListener("scroll", notifyScroll2, {
              passive: true
            });
          });
          win.addEventListener("resize", notifyScroll2, {
            passive: true
          });
          onAlign();
          return function() {
            mergedList.forEach(function(scroller) {
              scroller.removeEventListener("scroll", notifyScroll2);
              win.removeEventListener("resize", notifyScroll2);
            });
          };
        }
      }, [open, target, popup]);
    }
    function useWinClick(open, clickToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen) {
      var openRef = reactExports.useRef(open);
      var lockRef = reactExports.useRef(false);
      if (openRef.current !== open) {
        lockRef.current = true;
        openRef.current = open;
      }
      reactExports.useEffect(function() {
        var id2 = wrapperRaf(function() {
          lockRef.current = false;
        });
        return function() {
          wrapperRaf.cancel(id2);
        };
      }, [open]);
      reactExports.useEffect(function() {
        if (clickToHide && popupEle && (!mask || maskClosable)) {
          var genClickEvents = function genClickEvents2() {
            var clickInside = false;
            var onWindowMouseDown = function onWindowMouseDown2(_ref) {
              var target = _ref.target;
              clickInside = inPopupOrChild(target);
            };
            var onWindowClick = function onWindowClick2(_ref2) {
              var target = _ref2.target;
              if (!lockRef.current && openRef.current && !clickInside && !inPopupOrChild(target)) {
                triggerOpen(false);
              }
            };
            return [onWindowMouseDown, onWindowClick];
          };
          var _genClickEvents = genClickEvents(), _genClickEvents2 = _slicedToArray(_genClickEvents, 2), onWinMouseDown = _genClickEvents2[0], onWinClick = _genClickEvents2[1];
          var _genClickEvents3 = genClickEvents(), _genClickEvents4 = _slicedToArray(_genClickEvents3, 2), onShadowMouseDown = _genClickEvents4[0], onShadowClick = _genClickEvents4[1];
          var win = getWin(popupEle);
          win.addEventListener("mousedown", onWinMouseDown, true);
          win.addEventListener("click", onWinClick, true);
          win.addEventListener("contextmenu", onWinClick, true);
          var targetShadowRoot = getShadowRoot(targetEle);
          if (targetShadowRoot) {
            targetShadowRoot.addEventListener("mousedown", onShadowMouseDown, true);
            targetShadowRoot.addEventListener("click", onShadowClick, true);
            targetShadowRoot.addEventListener("contextmenu", onShadowClick, true);
          }
          return function() {
            win.removeEventListener("mousedown", onWinMouseDown, true);
            win.removeEventListener("click", onWinClick, true);
            win.removeEventListener("contextmenu", onWinClick, true);
            if (targetShadowRoot) {
              targetShadowRoot.removeEventListener("mousedown", onShadowMouseDown, true);
              targetShadowRoot.removeEventListener("click", onShadowClick, true);
              targetShadowRoot.removeEventListener("contextmenu", onShadowClick, true);
            }
          };
        }
      }, [clickToHide, targetEle, popupEle, mask, maskClosable]);
    }
    var _excluded$x = ["prefixCls", "children", "action", "showAction", "hideAction", "popupVisible", "defaultPopupVisible", "onPopupVisibleChange", "afterPopupVisibleChange", "mouseEnterDelay", "mouseLeaveDelay", "focusDelay", "blurDelay", "mask", "maskClosable", "getPopupContainer", "forceRender", "autoDestroy", "destroyPopupOnHide", "popup", "popupClassName", "popupStyle", "popupPlacement", "builtinPlacements", "popupAlign", "zIndex", "stretch", "getPopupClassNameFromAlign", "fresh", "alignPoint", "onPopupClick", "onPopupAlign", "arrow", "popupMotion", "maskMotion", "popupTransitionName", "popupAnimation", "maskTransitionName", "maskAnimation", "className", "getTriggerDOMNode"];
    function generateTrigger() {
      var PortalComponent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Portal;
      var Trigger2 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
        var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-trigger-popup" : _props$prefixCls, children = props.children, _props$action = props.action, action = _props$action === void 0 ? "hover" : _props$action, showAction = props.showAction, hideAction = props.hideAction, popupVisible = props.popupVisible, defaultPopupVisible = props.defaultPopupVisible, onPopupVisibleChange = props.onPopupVisibleChange, afterPopupVisibleChange = props.afterPopupVisibleChange, mouseEnterDelay = props.mouseEnterDelay, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela, focusDelay = props.focusDelay, blurDelay = props.blurDelay, mask = props.mask, _props$maskClosable = props.maskClosable, maskClosable = _props$maskClosable === void 0 ? true : _props$maskClosable, getPopupContainer = props.getPopupContainer, forceRender = props.forceRender, autoDestroy = props.autoDestroy, destroyPopupOnHide = props.destroyPopupOnHide, popup = props.popup, popupClassName = props.popupClassName, popupStyle = props.popupStyle, popupPlacement = props.popupPlacement, _props$builtinPlaceme = props.builtinPlacements, builtinPlacements = _props$builtinPlaceme === void 0 ? {} : _props$builtinPlaceme, popupAlign = props.popupAlign, zIndex = props.zIndex, stretch = props.stretch, getPopupClassNameFromAlign = props.getPopupClassNameFromAlign, fresh = props.fresh, alignPoint = props.alignPoint, onPopupClick = props.onPopupClick, onPopupAlign = props.onPopupAlign, arrow = props.arrow, popupMotion = props.popupMotion, maskMotion = props.maskMotion, popupTransitionName = props.popupTransitionName, popupAnimation = props.popupAnimation, maskTransitionName = props.maskTransitionName, maskAnimation = props.maskAnimation, className = props.className, getTriggerDOMNode = props.getTriggerDOMNode, restProps = _objectWithoutProperties(props, _excluded$x);
        var mergedAutoDestroy = autoDestroy || destroyPopupOnHide || false;
        var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), mobile = _React$useState2[0], setMobile = _React$useState2[1];
        useLayoutEffect$1(function() {
          setMobile(isMobile());
        }, []);
        var subPopupElements = reactExports.useRef({});
        var parentContext = reactExports.useContext(TriggerContext);
        var context = reactExports.useMemo(function() {
          return {
            registerSubPopup: function registerSubPopup(id22, subPopupEle) {
              subPopupElements.current[id22] = subPopupEle;
              parentContext === null || parentContext === void 0 || parentContext.registerSubPopup(id22, subPopupEle);
            }
          };
        }, [parentContext]);
        var id2 = useId$2();
        var _React$useState3 = reactExports.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), popupEle = _React$useState4[0], setPopupEle = _React$useState4[1];
        var setPopupRef = useEvent(function(node2) {
          if (isDOM(node2) && popupEle !== node2) {
            setPopupEle(node2);
          }
          parentContext === null || parentContext === void 0 || parentContext.registerSubPopup(id2, node2);
        });
        var _React$useState5 = reactExports.useState(null), _React$useState6 = _slicedToArray(_React$useState5, 2), targetEle = _React$useState6[0], setTargetEle = _React$useState6[1];
        var externalForwardRef = reactExports.useRef(null);
        var setTargetRef = useEvent(function(node2) {
          if (isDOM(node2) && targetEle !== node2) {
            setTargetEle(node2);
            externalForwardRef.current = node2;
          }
        });
        var child = reactExports.Children.only(children);
        var originChildProps = (child === null || child === void 0 ? void 0 : child.props) || {};
        var cloneProps = {};
        var inPopupOrChild = useEvent(function(ele) {
          var _getShadowRoot, _getShadowRoot2;
          var childDOM = targetEle;
          return (childDOM === null || childDOM === void 0 ? void 0 : childDOM.contains(ele)) || ((_getShadowRoot = getShadowRoot(childDOM)) === null || _getShadowRoot === void 0 ? void 0 : _getShadowRoot.host) === ele || ele === childDOM || (popupEle === null || popupEle === void 0 ? void 0 : popupEle.contains(ele)) || ((_getShadowRoot2 = getShadowRoot(popupEle)) === null || _getShadowRoot2 === void 0 ? void 0 : _getShadowRoot2.host) === ele || ele === popupEle || Object.values(subPopupElements.current).some(function(subPopupEle) {
            return (subPopupEle === null || subPopupEle === void 0 ? void 0 : subPopupEle.contains(ele)) || ele === subPopupEle;
          });
        });
        var mergePopupMotion = getMotion$1(prefixCls, popupMotion, popupAnimation, popupTransitionName);
        var mergeMaskMotion = getMotion$1(prefixCls, maskMotion, maskAnimation, maskTransitionName);
        var _React$useState7 = reactExports.useState(defaultPopupVisible || false), _React$useState8 = _slicedToArray(_React$useState7, 2), internalOpen = _React$useState8[0], setInternalOpen = _React$useState8[1];
        var mergedOpen = popupVisible !== null && popupVisible !== void 0 ? popupVisible : internalOpen;
        var setMergedOpen = useEvent(function(nextOpen) {
          if (popupVisible === void 0) {
            setInternalOpen(nextOpen);
          }
        });
        useLayoutEffect$1(function() {
          setInternalOpen(popupVisible || false);
        }, [popupVisible]);
        var openRef = reactExports.useRef(mergedOpen);
        openRef.current = mergedOpen;
        var lastTriggerRef = reactExports.useRef([]);
        lastTriggerRef.current = [];
        var internalTriggerOpen = useEvent(function(nextOpen) {
          var _lastTriggerRef$curre;
          setMergedOpen(nextOpen);
          if (((_lastTriggerRef$curre = lastTriggerRef.current[lastTriggerRef.current.length - 1]) !== null && _lastTriggerRef$curre !== void 0 ? _lastTriggerRef$curre : mergedOpen) !== nextOpen) {
            lastTriggerRef.current.push(nextOpen);
            onPopupVisibleChange === null || onPopupVisibleChange === void 0 || onPopupVisibleChange(nextOpen);
          }
        });
        var delayRef = reactExports.useRef();
        var clearDelay = function clearDelay2() {
          clearTimeout(delayRef.current);
        };
        var triggerOpen = function triggerOpen2(nextOpen) {
          var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          clearDelay();
          if (delay === 0) {
            internalTriggerOpen(nextOpen);
          } else {
            delayRef.current = setTimeout(function() {
              internalTriggerOpen(nextOpen);
            }, delay * 1e3);
          }
        };
        reactExports.useEffect(function() {
          return clearDelay;
        }, []);
        var _React$useState9 = reactExports.useState(false), _React$useState10 = _slicedToArray(_React$useState9, 2), inMotion = _React$useState10[0], setInMotion = _React$useState10[1];
        useLayoutEffect$1(function(firstMount) {
          if (!firstMount || mergedOpen) {
            setInMotion(true);
          }
        }, [mergedOpen]);
        var _React$useState11 = reactExports.useState(null), _React$useState12 = _slicedToArray(_React$useState11, 2), motionPrepareResolve = _React$useState12[0], setMotionPrepareResolve = _React$useState12[1];
        var _React$useState13 = reactExports.useState([0, 0]), _React$useState14 = _slicedToArray(_React$useState13, 2), mousePos = _React$useState14[0], setMousePos = _React$useState14[1];
        var setMousePosByEvent = function setMousePosByEvent2(event) {
          setMousePos([event.clientX, event.clientY]);
        };
        var _useAlign = useAlign(mergedOpen, popupEle, alignPoint ? mousePos : targetEle, popupPlacement, builtinPlacements, popupAlign, onPopupAlign), _useAlign2 = _slicedToArray(_useAlign, 11), ready = _useAlign2[0], offsetX = _useAlign2[1], offsetY = _useAlign2[2], offsetR = _useAlign2[3], offsetB = _useAlign2[4], arrowX = _useAlign2[5], arrowY = _useAlign2[6], scaleX = _useAlign2[7], scaleY = _useAlign2[8], alignInfo = _useAlign2[9], onAlign = _useAlign2[10];
        var _useAction = useAction(mobile, action, showAction, hideAction), _useAction2 = _slicedToArray(_useAction, 2), showActions = _useAction2[0], hideActions = _useAction2[1];
        var clickToShow = showActions.has("click");
        var clickToHide = hideActions.has("click") || hideActions.has("contextMenu");
        var triggerAlign = useEvent(function() {
          if (!inMotion) {
            onAlign();
          }
        });
        var onScroll = function onScroll2() {
          if (openRef.current && alignPoint && clickToHide) {
            triggerOpen(false);
          }
        };
        useWatch(mergedOpen, targetEle, popupEle, triggerAlign, onScroll);
        useLayoutEffect$1(function() {
          triggerAlign();
        }, [mousePos, popupPlacement]);
        useLayoutEffect$1(function() {
          if (mergedOpen && !(builtinPlacements !== null && builtinPlacements !== void 0 && builtinPlacements[popupPlacement])) {
            triggerAlign();
          }
        }, [JSON.stringify(popupAlign)]);
        var alignedClassName = reactExports.useMemo(function() {
          var baseClassName = getAlignPopupClassName(builtinPlacements, prefixCls, alignInfo, alignPoint);
          return classNames(baseClassName, getPopupClassNameFromAlign === null || getPopupClassNameFromAlign === void 0 ? void 0 : getPopupClassNameFromAlign(alignInfo));
        }, [alignInfo, getPopupClassNameFromAlign, builtinPlacements, prefixCls, alignPoint]);
        reactExports.useImperativeHandle(ref, function() {
          return {
            nativeElement: externalForwardRef.current,
            forceAlign: triggerAlign
          };
        });
        var _React$useState15 = reactExports.useState(0), _React$useState16 = _slicedToArray(_React$useState15, 2), targetWidth = _React$useState16[0], setTargetWidth = _React$useState16[1];
        var _React$useState17 = reactExports.useState(0), _React$useState18 = _slicedToArray(_React$useState17, 2), targetHeight = _React$useState18[0], setTargetHeight = _React$useState18[1];
        var syncTargetSize = function syncTargetSize2() {
          if (stretch && targetEle) {
            var rect = targetEle.getBoundingClientRect();
            setTargetWidth(rect.width);
            setTargetHeight(rect.height);
          }
        };
        var onTargetResize = function onTargetResize2() {
          syncTargetSize();
          triggerAlign();
        };
        var onVisibleChanged = function onVisibleChanged2(visible) {
          setInMotion(false);
          onAlign();
          afterPopupVisibleChange === null || afterPopupVisibleChange === void 0 || afterPopupVisibleChange(visible);
        };
        var onPrepare = function onPrepare2() {
          return new Promise(function(resolve) {
            syncTargetSize();
            setMotionPrepareResolve(function() {
              return resolve;
            });
          });
        };
        useLayoutEffect$1(function() {
          if (motionPrepareResolve) {
            onAlign();
            motionPrepareResolve();
            setMotionPrepareResolve(null);
          }
        }, [motionPrepareResolve]);
        function wrapperAction(eventName, nextOpen, delay, preEvent) {
          cloneProps[eventName] = function(event) {
            var _originChildProps$eve;
            preEvent === null || preEvent === void 0 || preEvent(event);
            triggerOpen(nextOpen, delay);
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            (_originChildProps$eve = originChildProps[eventName]) === null || _originChildProps$eve === void 0 || _originChildProps$eve.call.apply(_originChildProps$eve, [originChildProps, event].concat(args));
          };
        }
        if (clickToShow || clickToHide) {
          cloneProps.onClick = function(event) {
            var _originChildProps$onC;
            if (openRef.current && clickToHide) {
              triggerOpen(false);
            } else if (!openRef.current && clickToShow) {
              setMousePosByEvent(event);
              triggerOpen(true);
            }
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            (_originChildProps$onC = originChildProps.onClick) === null || _originChildProps$onC === void 0 || _originChildProps$onC.call.apply(_originChildProps$onC, [originChildProps, event].concat(args));
          };
        }
        useWinClick(mergedOpen, clickToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen);
        var hoverToShow = showActions.has("hover");
        var hoverToHide = hideActions.has("hover");
        var onPopupMouseEnter;
        var onPopupMouseLeave;
        if (hoverToShow) {
          wrapperAction("onMouseEnter", true, mouseEnterDelay, function(event) {
            setMousePosByEvent(event);
          });
          wrapperAction("onPointerEnter", true, mouseEnterDelay, function(event) {
            setMousePosByEvent(event);
          });
          onPopupMouseEnter = function onPopupMouseEnter2() {
            if (mergedOpen || inMotion) {
              triggerOpen(true, mouseEnterDelay);
            }
          };
          if (alignPoint) {
            cloneProps.onMouseMove = function(event) {
              var _originChildProps$onM;
              (_originChildProps$onM = originChildProps.onMouseMove) === null || _originChildProps$onM === void 0 || _originChildProps$onM.call(originChildProps, event);
            };
          }
        }
        if (hoverToHide) {
          wrapperAction("onMouseLeave", false, mouseLeaveDelay);
          wrapperAction("onPointerLeave", false, mouseLeaveDelay);
          onPopupMouseLeave = function onPopupMouseLeave2() {
            triggerOpen(false, mouseLeaveDelay);
          };
        }
        if (showActions.has("focus")) {
          wrapperAction("onFocus", true, focusDelay);
        }
        if (hideActions.has("focus")) {
          wrapperAction("onBlur", false, blurDelay);
        }
        if (showActions.has("contextMenu")) {
          cloneProps.onContextMenu = function(event) {
            var _originChildProps$onC2;
            if (openRef.current && hideActions.has("contextMenu")) {
              triggerOpen(false);
            } else {
              setMousePosByEvent(event);
              triggerOpen(true);
            }
            event.preventDefault();
            for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
              args[_key3 - 1] = arguments[_key3];
            }
            (_originChildProps$onC2 = originChildProps.onContextMenu) === null || _originChildProps$onC2 === void 0 || _originChildProps$onC2.call.apply(_originChildProps$onC2, [originChildProps, event].concat(args));
          };
        }
        if (className) {
          cloneProps.className = classNames(originChildProps.className, className);
        }
        var mergedChildrenProps = _objectSpread2(_objectSpread2({}, originChildProps), cloneProps);
        var passedProps = {};
        var passedEventList = ["onContextMenu", "onClick", "onMouseDown", "onTouchStart", "onMouseEnter", "onMouseLeave", "onFocus", "onBlur"];
        passedEventList.forEach(function(eventName) {
          if (restProps[eventName]) {
            passedProps[eventName] = function() {
              var _mergedChildrenProps$;
              for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                args[_key4] = arguments[_key4];
              }
              (_mergedChildrenProps$ = mergedChildrenProps[eventName]) === null || _mergedChildrenProps$ === void 0 || _mergedChildrenProps$.call.apply(_mergedChildrenProps$, [mergedChildrenProps].concat(args));
              restProps[eventName].apply(restProps, args);
            };
          }
        });
        var triggerNode = /* @__PURE__ */ reactExports.cloneElement(child, _objectSpread2(_objectSpread2({}, mergedChildrenProps), passedProps));
        var arrowPos = {
          x: arrowX,
          y: arrowY
        };
        var innerArrow = arrow ? _objectSpread2({}, arrow !== true ? arrow : {}) : null;
        return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
          disabled: !mergedOpen,
          ref: setTargetRef,
          onResize: onTargetResize
        }, /* @__PURE__ */ reactExports.createElement(TriggerWrapper, {
          getTriggerDOMNode
        }, triggerNode)), /* @__PURE__ */ reactExports.createElement(TriggerContext.Provider, {
          value: context
        }, /* @__PURE__ */ reactExports.createElement(Popup$1, {
          portal: PortalComponent,
          ref: setPopupRef,
          prefixCls,
          popup,
          className: classNames(popupClassName, alignedClassName),
          style: popupStyle,
          target: targetEle,
          onMouseEnter: onPopupMouseEnter,
          onMouseLeave: onPopupMouseLeave,
          onPointerEnter: onPopupMouseEnter,
          zIndex,
          open: mergedOpen,
          keepDom: inMotion,
          fresh,
          onClick: onPopupClick,
          mask,
          motion: mergePopupMotion,
          maskMotion: mergeMaskMotion,
          onVisibleChanged,
          onPrepare,
          forceRender,
          autoDestroy: mergedAutoDestroy,
          getPopupContainer,
          align: alignInfo,
          arrow: innerArrow,
          arrowPos,
          ready,
          offsetX,
          offsetY,
          offsetR,
          offsetB,
          onAlign: triggerAlign,
          stretch,
          targetWidth: targetWidth / scaleX,
          targetHeight: targetHeight / scaleY
        })));
      });
      return Trigger2;
    }
    const Trigger = generateTrigger(Portal);
    var _excluded$w = ["prefixCls", "disabled", "visible", "children", "popupElement", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "direction", "placement", "builtinPlacements", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "getPopupContainer", "empty", "getTriggerDOMNode", "onPopupVisibleChange", "onPopupMouseEnter"];
    var getBuiltInPlacements$1 = function getBuiltInPlacements2(dropdownMatchSelectWidth) {
      var adjustX = dropdownMatchSelectWidth === true ? 0 : 1;
      return {
        bottomLeft: {
          points: ["tl", "bl"],
          offset: [0, 4],
          overflow: {
            adjustX,
            adjustY: 1
          },
          htmlRegion: "scroll"
        },
        bottomRight: {
          points: ["tr", "br"],
          offset: [0, 4],
          overflow: {
            adjustX,
            adjustY: 1
          },
          htmlRegion: "scroll"
        },
        topLeft: {
          points: ["bl", "tl"],
          offset: [0, -4],
          overflow: {
            adjustX,
            adjustY: 1
          },
          htmlRegion: "scroll"
        },
        topRight: {
          points: ["br", "tr"],
          offset: [0, -4],
          overflow: {
            adjustX,
            adjustY: 1
          },
          htmlRegion: "scroll"
        }
      };
    };
    var SelectTrigger = function SelectTrigger2(props, ref) {
      var prefixCls = props.prefixCls;
      props.disabled;
      var visible = props.visible, children = props.children, popupElement = props.popupElement, animation = props.animation, transitionName = props.transitionName, dropdownStyle = props.dropdownStyle, dropdownClassName = props.dropdownClassName, _props$direction = props.direction, direction = _props$direction === void 0 ? "ltr" : _props$direction, placement = props.placement, builtinPlacements = props.builtinPlacements, dropdownMatchSelectWidth = props.dropdownMatchSelectWidth, dropdownRender = props.dropdownRender, dropdownAlign = props.dropdownAlign, getPopupContainer = props.getPopupContainer, empty2 = props.empty, getTriggerDOMNode = props.getTriggerDOMNode, onPopupVisibleChange = props.onPopupVisibleChange, onPopupMouseEnter = props.onPopupMouseEnter, restProps = _objectWithoutProperties(props, _excluded$w);
      var dropdownPrefixCls = "".concat(prefixCls, "-dropdown");
      var popupNode = popupElement;
      if (dropdownRender) {
        popupNode = dropdownRender(popupElement);
      }
      var mergedBuiltinPlacements = reactExports.useMemo(function() {
        return builtinPlacements || getBuiltInPlacements$1(dropdownMatchSelectWidth);
      }, [builtinPlacements, dropdownMatchSelectWidth]);
      var mergedTransitionName = animation ? "".concat(dropdownPrefixCls, "-").concat(animation) : transitionName;
      var isNumberPopupWidth = typeof dropdownMatchSelectWidth === "number";
      var stretch = reactExports.useMemo(function() {
        if (isNumberPopupWidth) {
          return null;
        }
        return dropdownMatchSelectWidth === false ? "minWidth" : "width";
      }, [dropdownMatchSelectWidth, isNumberPopupWidth]);
      var popupStyle = dropdownStyle;
      if (isNumberPopupWidth) {
        popupStyle = _objectSpread2(_objectSpread2({}, popupStyle), {}, {
          width: dropdownMatchSelectWidth
        });
      }
      var popupRef = reactExports.useRef(null);
      reactExports.useImperativeHandle(ref, function() {
        return {
          getPopupElement: function getPopupElement() {
            return popupRef.current;
          }
        };
      });
      return /* @__PURE__ */ reactExports.createElement(Trigger, _extends$1({}, restProps, {
        showAction: onPopupVisibleChange ? ["click"] : [],
        hideAction: onPopupVisibleChange ? ["click"] : [],
        popupPlacement: placement || (direction === "rtl" ? "bottomRight" : "bottomLeft"),
        builtinPlacements: mergedBuiltinPlacements,
        prefixCls: dropdownPrefixCls,
        popupTransitionName: mergedTransitionName,
        popup: /* @__PURE__ */ reactExports.createElement("div", {
          ref: popupRef,
          onMouseEnter: onPopupMouseEnter
        }, popupNode),
        stretch,
        popupAlign: dropdownAlign,
        popupVisible: visible,
        getPopupContainer,
        popupClassName: classNames(dropdownClassName, _defineProperty({}, "".concat(dropdownPrefixCls, "-empty"), empty2)),
        popupStyle,
        getTriggerDOMNode,
        onPopupVisibleChange
      }), children);
    };
    var RefSelectTrigger = /* @__PURE__ */ reactExports.forwardRef(SelectTrigger);
    RefSelectTrigger.displayName = "SelectTrigger";
    function getKey$1(data, index2) {
      var key = data.key;
      var value;
      if ("value" in data) {
        value = data.value;
      }
      if (key !== null && key !== void 0) {
        return key;
      }
      if (value !== void 0) {
        return value;
      }
      return "rc-index-key-".concat(index2);
    }
    function fillFieldNames$1(fieldNames, childrenAsData) {
      var _ref = fieldNames || {}, label = _ref.label, value = _ref.value, options = _ref.options, groupLabel = _ref.groupLabel;
      var mergedLabel = label || (childrenAsData ? "children" : "label");
      return {
        label: mergedLabel,
        value: value || "value",
        options: options || "options",
        groupLabel: groupLabel || mergedLabel
      };
    }
    function flattenOptions(options) {
      var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, fieldNames = _ref2.fieldNames, childrenAsData = _ref2.childrenAsData;
      var flattenList = [];
      var _fillFieldNames = fillFieldNames$1(fieldNames, false), fieldLabel = _fillFieldNames.label, fieldValue = _fillFieldNames.value, fieldOptions = _fillFieldNames.options, groupLabel = _fillFieldNames.groupLabel;
      function dig(list, isGroupOption) {
        list.forEach(function(data) {
          if (isGroupOption || !(fieldOptions in data)) {
            var value = data[fieldValue];
            flattenList.push({
              key: getKey$1(data, flattenList.length),
              groupOption: isGroupOption,
              data,
              label: data[fieldLabel],
              value
            });
          } else {
            var grpLabel = data[groupLabel];
            if (grpLabel === void 0 && childrenAsData) {
              grpLabel = data.label;
            }
            flattenList.push({
              key: getKey$1(data, flattenList.length),
              group: true,
              data,
              label: grpLabel
            });
            dig(data[fieldOptions], true);
          }
        });
      }
      dig(options, false);
      return flattenList;
    }
    function injectPropsWithOption(option) {
      var newOption = _objectSpread2({}, option);
      if (!("props" in newOption)) {
        Object.defineProperty(newOption, "props", {
          get: function get2() {
            warningOnce(false, "Return type is option instead of Option instance. Please read value directly instead of reading from `props`.");
            return newOption;
          }
        });
      }
      return newOption;
    }
    function getSeparatedContent(text, tokens2) {
      if (!tokens2 || !tokens2.length) {
        return null;
      }
      var match5 = false;
      function separate(str, _ref3) {
        var _ref4 = _toArray(_ref3), token2 = _ref4[0], restTokens = _ref4.slice(1);
        if (!token2) {
          return [str];
        }
        var list2 = str.split(token2);
        match5 = match5 || list2.length > 1;
        return list2.reduce(function(prevList, unitStr) {
          return [].concat(_toConsumableArray(prevList), _toConsumableArray(separate(unitStr, restTokens)));
        }, []).filter(function(unit2) {
          return unit2;
        });
      }
      var list = separate(text, tokens2);
      return match5 ? list : null;
    }
    var _excluded$v = ["id", "prefixCls", "className", "showSearch", "tagRender", "direction", "omitDomProps", "displayValues", "onDisplayValuesChange", "emptyOptions", "notFoundContent", "onClear", "mode", "disabled", "loading", "getInputElement", "getRawInputElement", "open", "defaultOpen", "onDropdownVisibleChange", "activeValue", "onActiveValueChange", "activeDescendantId", "searchValue", "autoClearSearchValue", "onSearch", "onSearchSplit", "tokenSeparators", "allowClear", "suffixIcon", "clearIcon", "OptionList", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "placement", "builtinPlacements", "getPopupContainer", "showAction", "onFocus", "onBlur", "onKeyUp", "onKeyDown", "onMouseDown"];
    var DEFAULT_OMIT_PROPS = ["value", "onChange", "removeIcon", "placeholder", "autoFocus", "maxTagCount", "maxTagTextLength", "maxTagPlaceholder", "choiceTransitionName", "onInputKeyDown", "onPopupScroll", "tabIndex"];
    function isMultiple(mode) {
      return mode === "tags" || mode === "multiple";
    }
    var BaseSelect = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var _customizeRawInputEle, _classNames2;
      var id2 = props.id, prefixCls = props.prefixCls, className = props.className, showSearch = props.showSearch, tagRender = props.tagRender, direction = props.direction, omitDomProps = props.omitDomProps, displayValues = props.displayValues, onDisplayValuesChange = props.onDisplayValuesChange, emptyOptions = props.emptyOptions, _props$notFoundConten = props.notFoundContent, notFoundContent = _props$notFoundConten === void 0 ? "Not Found" : _props$notFoundConten, onClear = props.onClear, mode = props.mode, disabled = props.disabled, loading = props.loading, getInputElement = props.getInputElement, getRawInputElement = props.getRawInputElement, open = props.open, defaultOpen = props.defaultOpen, onDropdownVisibleChange = props.onDropdownVisibleChange, activeValue = props.activeValue, onActiveValueChange = props.onActiveValueChange, activeDescendantId = props.activeDescendantId, searchValue = props.searchValue, autoClearSearchValue = props.autoClearSearchValue, onSearch = props.onSearch, onSearchSplit = props.onSearchSplit, tokenSeparators = props.tokenSeparators, allowClear = props.allowClear, suffixIcon = props.suffixIcon, clearIcon = props.clearIcon, OptionList2 = props.OptionList, animation = props.animation, transitionName = props.transitionName, dropdownStyle = props.dropdownStyle, dropdownClassName = props.dropdownClassName, dropdownMatchSelectWidth = props.dropdownMatchSelectWidth, dropdownRender = props.dropdownRender, dropdownAlign = props.dropdownAlign, placement = props.placement, builtinPlacements = props.builtinPlacements, getPopupContainer = props.getPopupContainer, _props$showAction = props.showAction, showAction = _props$showAction === void 0 ? [] : _props$showAction, onFocus = props.onFocus, onBlur = props.onBlur, onKeyUp = props.onKeyUp, onKeyDown2 = props.onKeyDown, onMouseDown = props.onMouseDown, restProps = _objectWithoutProperties(props, _excluded$v);
      var multiple = isMultiple(mode);
      var mergedShowSearch = (showSearch !== void 0 ? showSearch : multiple) || mode === "combobox";
      var domProps = _objectSpread2({}, restProps);
      DEFAULT_OMIT_PROPS.forEach(function(propName) {
        delete domProps[propName];
      });
      omitDomProps === null || omitDomProps === void 0 || omitDomProps.forEach(function(propName) {
        delete domProps[propName];
      });
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), mobile = _React$useState2[0], setMobile = _React$useState2[1];
      reactExports.useEffect(function() {
        setMobile(isMobile());
      }, []);
      var containerRef = reactExports.useRef(null);
      var selectorDomRef = reactExports.useRef(null);
      var triggerRef = reactExports.useRef(null);
      var selectorRef = reactExports.useRef(null);
      var listRef = reactExports.useRef(null);
      var blurRef = reactExports.useRef(false);
      var _useDelayReset = useDelayReset(), _useDelayReset2 = _slicedToArray(_useDelayReset, 3), mockFocused = _useDelayReset2[0], setMockFocused = _useDelayReset2[1], cancelSetMockFocused = _useDelayReset2[2];
      reactExports.useImperativeHandle(ref, function() {
        var _selectorRef$current, _selectorRef$current2;
        return {
          focus: (_selectorRef$current = selectorRef.current) === null || _selectorRef$current === void 0 ? void 0 : _selectorRef$current.focus,
          blur: (_selectorRef$current2 = selectorRef.current) === null || _selectorRef$current2 === void 0 ? void 0 : _selectorRef$current2.blur,
          scrollTo: function scrollTo2(arg) {
            var _listRef$current;
            return (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.scrollTo(arg);
          }
        };
      });
      var mergedSearchValue = reactExports.useMemo(function() {
        var _displayValues$;
        if (mode !== "combobox") {
          return searchValue;
        }
        var val = (_displayValues$ = displayValues[0]) === null || _displayValues$ === void 0 ? void 0 : _displayValues$.value;
        return typeof val === "string" || typeof val === "number" ? String(val) : "";
      }, [searchValue, mode, displayValues]);
      var customizeInputElement = mode === "combobox" && typeof getInputElement === "function" && getInputElement() || null;
      var customizeRawInputElement = typeof getRawInputElement === "function" && getRawInputElement();
      var customizeRawInputRef = useComposeRef(selectorDomRef, customizeRawInputElement === null || customizeRawInputElement === void 0 || (_customizeRawInputEle = customizeRawInputElement.props) === null || _customizeRawInputEle === void 0 ? void 0 : _customizeRawInputEle.ref);
      var _React$useState3 = reactExports.useState(false), _React$useState4 = _slicedToArray(_React$useState3, 2), rendered = _React$useState4[0], setRendered = _React$useState4[1];
      useLayoutEffect$1(function() {
        setRendered(true);
      }, []);
      var _useMergedState = useMergedState(false, {
        defaultValue: defaultOpen,
        value: open
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), innerOpen = _useMergedState2[0], setInnerOpen = _useMergedState2[1];
      var mergedOpen = rendered ? innerOpen : false;
      var emptyListContent = !notFoundContent && emptyOptions;
      if (disabled || emptyListContent && mergedOpen && mode === "combobox") {
        mergedOpen = false;
      }
      var triggerOpen = emptyListContent ? false : mergedOpen;
      var onToggleOpen = reactExports.useCallback(function(newOpen) {
        var nextOpen = newOpen !== void 0 ? newOpen : !mergedOpen;
        if (!disabled) {
          setInnerOpen(nextOpen);
          if (mergedOpen !== nextOpen) {
            onDropdownVisibleChange === null || onDropdownVisibleChange === void 0 || onDropdownVisibleChange(nextOpen);
          }
        }
      }, [disabled, mergedOpen, setInnerOpen, onDropdownVisibleChange]);
      var tokenWithEnter = reactExports.useMemo(function() {
        return (tokenSeparators || []).some(function(tokenSeparator) {
          return ["\n", "\r\n"].includes(tokenSeparator);
        });
      }, [tokenSeparators]);
      var onInternalSearch = function onInternalSearch2(searchText, fromTyping, isCompositing) {
        var ret = true;
        var newSearchText = searchText;
        onActiveValueChange === null || onActiveValueChange === void 0 || onActiveValueChange(null);
        var patchLabels = isCompositing ? null : getSeparatedContent(searchText, tokenSeparators);
        if (mode !== "combobox" && patchLabels) {
          newSearchText = "";
          onSearchSplit === null || onSearchSplit === void 0 || onSearchSplit(patchLabels);
          onToggleOpen(false);
          ret = false;
        }
        if (onSearch && mergedSearchValue !== newSearchText) {
          onSearch(newSearchText, {
            source: fromTyping ? "typing" : "effect"
          });
        }
        return ret;
      };
      var onInternalSearchSubmit = function onInternalSearchSubmit2(searchText) {
        if (!searchText || !searchText.trim()) {
          return;
        }
        onSearch(searchText, {
          source: "submit"
        });
      };
      reactExports.useEffect(function() {
        if (!mergedOpen && !multiple && mode !== "combobox") {
          onInternalSearch("", false, false);
        }
      }, [mergedOpen]);
      reactExports.useEffect(function() {
        if (innerOpen && disabled) {
          setInnerOpen(false);
        }
        if (disabled && !blurRef.current) {
          setMockFocused(false);
        }
      }, [disabled]);
      var _useLock = useLock(), _useLock2 = _slicedToArray(_useLock, 2), getClearLock = _useLock2[0], setClearLock = _useLock2[1];
      var onInternalKeyDown = function onInternalKeyDown2(event) {
        var clearLock = getClearLock();
        var which = event.which;
        if (which === KeyCode.ENTER) {
          if (mode !== "combobox") {
            event.preventDefault();
          }
          if (!mergedOpen) {
            onToggleOpen(true);
          }
        }
        setClearLock(!!mergedSearchValue);
        if (which === KeyCode.BACKSPACE && !clearLock && multiple && !mergedSearchValue && displayValues.length) {
          var cloneDisplayValues = _toConsumableArray(displayValues);
          var removedDisplayValue = null;
          for (var i = cloneDisplayValues.length - 1; i >= 0; i -= 1) {
            var current = cloneDisplayValues[i];
            if (!current.disabled) {
              cloneDisplayValues.splice(i, 1);
              removedDisplayValue = current;
              break;
            }
          }
          if (removedDisplayValue) {
            onDisplayValuesChange(cloneDisplayValues, {
              type: "remove",
              values: [removedDisplayValue]
            });
          }
        }
        for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          rest[_key - 1] = arguments[_key];
        }
        if (mergedOpen && listRef.current) {
          var _listRef$current2;
          (_listRef$current2 = listRef.current).onKeyDown.apply(_listRef$current2, [event].concat(rest));
        }
        onKeyDown2 === null || onKeyDown2 === void 0 || onKeyDown2.apply(void 0, [event].concat(rest));
      };
      var onInternalKeyUp = function onInternalKeyUp2(event) {
        for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          rest[_key2 - 1] = arguments[_key2];
        }
        if (mergedOpen && listRef.current) {
          var _listRef$current3;
          (_listRef$current3 = listRef.current).onKeyUp.apply(_listRef$current3, [event].concat(rest));
        }
        onKeyUp === null || onKeyUp === void 0 || onKeyUp.apply(void 0, [event].concat(rest));
      };
      var onSelectorRemove = function onSelectorRemove2(val) {
        var newValues = displayValues.filter(function(i) {
          return i !== val;
        });
        onDisplayValuesChange(newValues, {
          type: "remove",
          values: [val]
        });
      };
      var focusRef = reactExports.useRef(false);
      var onContainerFocus = function onContainerFocus2() {
        setMockFocused(true);
        if (!disabled) {
          if (onFocus && !focusRef.current) {
            onFocus.apply(void 0, arguments);
          }
          if (showAction.includes("focus")) {
            onToggleOpen(true);
          }
        }
        focusRef.current = true;
      };
      var onContainerBlur = function onContainerBlur2() {
        blurRef.current = true;
        setMockFocused(false, function() {
          focusRef.current = false;
          blurRef.current = false;
          onToggleOpen(false);
        });
        if (disabled) {
          return;
        }
        if (mergedSearchValue) {
          if (mode === "tags") {
            onSearch(mergedSearchValue, {
              source: "submit"
            });
          } else if (mode === "multiple") {
            onSearch("", {
              source: "blur"
            });
          }
        }
        if (onBlur) {
          onBlur.apply(void 0, arguments);
        }
      };
      var activeTimeoutIds = [];
      reactExports.useEffect(function() {
        return function() {
          activeTimeoutIds.forEach(function(timeoutId) {
            return clearTimeout(timeoutId);
          });
          activeTimeoutIds.splice(0, activeTimeoutIds.length);
        };
      }, []);
      var onInternalMouseDown = function onInternalMouseDown2(event) {
        var _triggerRef$current;
        var target = event.target;
        var popupElement = (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : _triggerRef$current.getPopupElement();
        if (popupElement && popupElement.contains(target)) {
          var timeoutId = setTimeout(function() {
            var index2 = activeTimeoutIds.indexOf(timeoutId);
            if (index2 !== -1) {
              activeTimeoutIds.splice(index2, 1);
            }
            cancelSetMockFocused();
            if (!mobile && !popupElement.contains(document.activeElement)) {
              var _selectorRef$current3;
              (_selectorRef$current3 = selectorRef.current) === null || _selectorRef$current3 === void 0 || _selectorRef$current3.focus();
            }
          });
          activeTimeoutIds.push(timeoutId);
        }
        for (var _len3 = arguments.length, restArgs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          restArgs[_key3 - 1] = arguments[_key3];
        }
        onMouseDown === null || onMouseDown === void 0 || onMouseDown.apply(void 0, [event].concat(restArgs));
      };
      var _React$useState5 = reactExports.useState({}), _React$useState6 = _slicedToArray(_React$useState5, 2), forceUpdate = _React$useState6[1];
      function onPopupMouseEnter() {
        forceUpdate({});
      }
      var onTriggerVisibleChange;
      if (customizeRawInputElement) {
        onTriggerVisibleChange = function onTriggerVisibleChange2(newOpen) {
          onToggleOpen(newOpen);
        };
      }
      useSelectTriggerControl(function() {
        var _triggerRef$current2;
        return [containerRef.current, (_triggerRef$current2 = triggerRef.current) === null || _triggerRef$current2 === void 0 ? void 0 : _triggerRef$current2.getPopupElement()];
      }, triggerOpen, onToggleOpen, !!customizeRawInputElement);
      var baseSelectContext = reactExports.useMemo(function() {
        return _objectSpread2(_objectSpread2({}, props), {}, {
          notFoundContent,
          open: mergedOpen,
          triggerOpen,
          id: id2,
          showSearch: mergedShowSearch,
          multiple,
          toggleOpen: onToggleOpen
        });
      }, [props, notFoundContent, triggerOpen, mergedOpen, id2, mergedShowSearch, multiple, onToggleOpen]);
      var showSuffixIcon = !!suffixIcon || loading;
      var arrowNode;
      if (showSuffixIcon) {
        arrowNode = /* @__PURE__ */ reactExports.createElement(TransBtn, {
          className: classNames("".concat(prefixCls, "-arrow"), _defineProperty({}, "".concat(prefixCls, "-arrow-loading"), loading)),
          customizeIcon: suffixIcon,
          customizeIconProps: {
            loading,
            searchValue: mergedSearchValue,
            open: mergedOpen,
            focused: mockFocused,
            showSearch: mergedShowSearch
          }
        });
      }
      var onClearMouseDown = function onClearMouseDown2() {
        var _selectorRef$current4;
        onClear === null || onClear === void 0 || onClear();
        (_selectorRef$current4 = selectorRef.current) === null || _selectorRef$current4 === void 0 || _selectorRef$current4.focus();
        onDisplayValuesChange([], {
          type: "clear",
          values: displayValues
        });
        onInternalSearch("", false, false);
      };
      var _useAllowClear = useAllowClear(prefixCls, onClearMouseDown, displayValues, allowClear, clearIcon, disabled, mergedSearchValue, mode), mergedAllowClear = _useAllowClear.allowClear, clearNode = _useAllowClear.clearIcon;
      var optionList = /* @__PURE__ */ reactExports.createElement(OptionList2, {
        ref: listRef
      });
      var mergedClassName = classNames(prefixCls, className, (_classNames2 = {}, _defineProperty(_classNames2, "".concat(prefixCls, "-focused"), mockFocused), _defineProperty(_classNames2, "".concat(prefixCls, "-multiple"), multiple), _defineProperty(_classNames2, "".concat(prefixCls, "-single"), !multiple), _defineProperty(_classNames2, "".concat(prefixCls, "-allow-clear"), allowClear), _defineProperty(_classNames2, "".concat(prefixCls, "-show-arrow"), showSuffixIcon), _defineProperty(_classNames2, "".concat(prefixCls, "-disabled"), disabled), _defineProperty(_classNames2, "".concat(prefixCls, "-loading"), loading), _defineProperty(_classNames2, "".concat(prefixCls, "-open"), mergedOpen), _defineProperty(_classNames2, "".concat(prefixCls, "-customize-input"), customizeInputElement), _defineProperty(_classNames2, "".concat(prefixCls, "-show-search"), mergedShowSearch), _classNames2));
      var selectorNode = /* @__PURE__ */ reactExports.createElement(RefSelectTrigger, {
        ref: triggerRef,
        disabled,
        prefixCls,
        visible: triggerOpen,
        popupElement: optionList,
        animation,
        transitionName,
        dropdownStyle,
        dropdownClassName,
        direction,
        dropdownMatchSelectWidth,
        dropdownRender,
        dropdownAlign,
        placement,
        builtinPlacements,
        getPopupContainer,
        empty: emptyOptions,
        getTriggerDOMNode: function getTriggerDOMNode() {
          return selectorDomRef.current;
        },
        onPopupVisibleChange: onTriggerVisibleChange,
        onPopupMouseEnter
      }, customizeRawInputElement ? /* @__PURE__ */ reactExports.cloneElement(customizeRawInputElement, {
        ref: customizeRawInputRef
      }) : /* @__PURE__ */ reactExports.createElement(ForwardSelector, _extends$1({}, props, {
        domRef: selectorDomRef,
        prefixCls,
        inputElement: customizeInputElement,
        ref: selectorRef,
        id: id2,
        showSearch: mergedShowSearch,
        autoClearSearchValue,
        mode,
        activeDescendantId,
        tagRender,
        values: displayValues,
        open: mergedOpen,
        onToggleOpen,
        activeValue,
        searchValue: mergedSearchValue,
        onSearch: onInternalSearch,
        onSearchSubmit: onInternalSearchSubmit,
        onRemove: onSelectorRemove,
        tokenWithEnter
      })));
      var renderNode;
      if (customizeRawInputElement) {
        renderNode = selectorNode;
      } else {
        renderNode = /* @__PURE__ */ reactExports.createElement("div", _extends$1({
          className: mergedClassName
        }, domProps, {
          ref: containerRef,
          onMouseDown: onInternalMouseDown,
          onKeyDown: onInternalKeyDown,
          onKeyUp: onInternalKeyUp,
          onFocus: onContainerFocus,
          onBlur: onContainerBlur
        }), mockFocused && !mergedOpen && /* @__PURE__ */ reactExports.createElement("span", {
          style: {
            width: 0,
            height: 0,
            position: "absolute",
            overflow: "hidden",
            opacity: 0
          },
          "aria-live": "polite"
        }, "".concat(displayValues.map(function(_ref) {
          var label = _ref.label, value = _ref.value;
          return ["number", "string"].includes(_typeof(label)) ? label : value;
        }).join(", "))), selectorNode, arrowNode, mergedAllowClear && clearNode);
      }
      return /* @__PURE__ */ reactExports.createElement(BaseSelectContext.Provider, {
        value: baseSelectContext
      }, renderNode);
    });
    var OptGroup = function OptGroup2() {
      return null;
    };
    OptGroup.isSelectOptGroup = true;
    var Option = function Option2() {
      return null;
    };
    Option.isSelectOption = true;
    var Filler = /* @__PURE__ */ reactExports.forwardRef(function(_ref, ref) {
      var height = _ref.height, offsetY = _ref.offsetY, offsetX = _ref.offsetX, children = _ref.children, prefixCls = _ref.prefixCls, onInnerResize = _ref.onInnerResize, innerProps = _ref.innerProps, rtl = _ref.rtl, extra = _ref.extra;
      var outerStyle = {};
      var innerStyle = {
        display: "flex",
        flexDirection: "column"
      };
      if (offsetY !== void 0) {
        var _objectSpread2$1;
        outerStyle = {
          height,
          position: "relative",
          overflow: "hidden"
        };
        innerStyle = _objectSpread2(_objectSpread2({}, innerStyle), {}, (_objectSpread2$1 = {
          transform: "translateY(".concat(offsetY, "px)")
        }, _defineProperty(_objectSpread2$1, rtl ? "marginRight" : "marginLeft", -offsetX), _defineProperty(_objectSpread2$1, "position", "absolute"), _defineProperty(_objectSpread2$1, "left", 0), _defineProperty(_objectSpread2$1, "right", 0), _defineProperty(_objectSpread2$1, "top", 0), _objectSpread2$1));
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        style: outerStyle
      }, /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
        onResize: function onResize2(_ref2) {
          var offsetHeight = _ref2.offsetHeight;
          if (offsetHeight && onInnerResize) {
            onInnerResize();
          }
        }
      }, /* @__PURE__ */ reactExports.createElement("div", _extends$1({
        style: innerStyle,
        className: classNames(_defineProperty({}, "".concat(prefixCls, "-holder-inner"), prefixCls)),
        ref
      }, innerProps), children, extra)));
    });
    Filler.displayName = "Filler";
    function getPageXY(e2, horizontal) {
      var obj = "touches" in e2 ? e2.touches[0] : e2;
      return obj[horizontal ? "pageX" : "pageY"];
    }
    var ScrollBar = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var _classNames;
      var prefixCls = props.prefixCls, rtl = props.rtl, scrollOffset = props.scrollOffset, scrollRange = props.scrollRange, onStartMove = props.onStartMove, onStopMove = props.onStopMove, onScroll = props.onScroll, horizontal = props.horizontal, spinSize = props.spinSize, containerSize = props.containerSize, style2 = props.style, propsThumbStyle = props.thumbStyle;
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), dragging = _React$useState2[0], setDragging = _React$useState2[1];
      var _React$useState3 = reactExports.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), pageXY = _React$useState4[0], setPageXY = _React$useState4[1];
      var _React$useState5 = reactExports.useState(null), _React$useState6 = _slicedToArray(_React$useState5, 2), startTop = _React$useState6[0], setStartTop = _React$useState6[1];
      var isLTR = !rtl;
      var scrollbarRef = reactExports.useRef();
      var thumbRef = reactExports.useRef();
      var _React$useState7 = reactExports.useState(false), _React$useState8 = _slicedToArray(_React$useState7, 2), visible = _React$useState8[0], setVisible = _React$useState8[1];
      var visibleTimeoutRef = reactExports.useRef();
      var delayHidden = function delayHidden2() {
        clearTimeout(visibleTimeoutRef.current);
        setVisible(true);
        visibleTimeoutRef.current = setTimeout(function() {
          setVisible(false);
        }, 3e3);
      };
      var enableScrollRange = scrollRange - containerSize || 0;
      var enableOffsetRange = containerSize - spinSize || 0;
      var canScroll = enableScrollRange > 0;
      var top = reactExports.useMemo(function() {
        if (scrollOffset === 0 || enableScrollRange === 0) {
          return 0;
        }
        var ptg = scrollOffset / enableScrollRange;
        return ptg * enableOffsetRange;
      }, [scrollOffset, enableScrollRange, enableOffsetRange]);
      var onContainerMouseDown = function onContainerMouseDown2(e2) {
        e2.stopPropagation();
        e2.preventDefault();
      };
      var stateRef = reactExports.useRef({
        top,
        dragging,
        pageY: pageXY,
        startTop
      });
      stateRef.current = {
        top,
        dragging,
        pageY: pageXY,
        startTop
      };
      var onThumbMouseDown = function onThumbMouseDown2(e2) {
        setDragging(true);
        setPageXY(getPageXY(e2, horizontal));
        setStartTop(stateRef.current.top);
        onStartMove();
        e2.stopPropagation();
        e2.preventDefault();
      };
      reactExports.useEffect(function() {
        var onScrollbarTouchStart = function onScrollbarTouchStart2(e2) {
          e2.preventDefault();
        };
        var scrollbarEle = scrollbarRef.current;
        var thumbEle = thumbRef.current;
        scrollbarEle.addEventListener("touchstart", onScrollbarTouchStart);
        thumbEle.addEventListener("touchstart", onThumbMouseDown);
        return function() {
          scrollbarEle.removeEventListener("touchstart", onScrollbarTouchStart);
          thumbEle.removeEventListener("touchstart", onThumbMouseDown);
        };
      }, []);
      var enableScrollRangeRef = reactExports.useRef();
      enableScrollRangeRef.current = enableScrollRange;
      var enableOffsetRangeRef = reactExports.useRef();
      enableOffsetRangeRef.current = enableOffsetRange;
      reactExports.useEffect(function() {
        if (dragging) {
          var moveRafId;
          var onMouseMove = function onMouseMove2(e2) {
            var _stateRef$current = stateRef.current, stateDragging = _stateRef$current.dragging, statePageY = _stateRef$current.pageY, stateStartTop = _stateRef$current.startTop;
            wrapperRaf.cancel(moveRafId);
            if (stateDragging) {
              var offset2 = getPageXY(e2, horizontal) - statePageY;
              var newTop = stateStartTop;
              if (!isLTR && horizontal) {
                newTop -= offset2;
              } else {
                newTop += offset2;
              }
              var tmpEnableScrollRange = enableScrollRangeRef.current;
              var tmpEnableOffsetRange = enableOffsetRangeRef.current;
              var ptg = tmpEnableOffsetRange ? newTop / tmpEnableOffsetRange : 0;
              var newScrollTop = Math.ceil(ptg * tmpEnableScrollRange);
              newScrollTop = Math.max(newScrollTop, 0);
              newScrollTop = Math.min(newScrollTop, tmpEnableScrollRange);
              moveRafId = wrapperRaf(function() {
                onScroll(newScrollTop, horizontal);
              });
            }
          };
          var onMouseUp = function onMouseUp2() {
            setDragging(false);
            onStopMove();
          };
          window.addEventListener("mousemove", onMouseMove);
          window.addEventListener("touchmove", onMouseMove);
          window.addEventListener("mouseup", onMouseUp);
          window.addEventListener("touchend", onMouseUp);
          return function() {
            window.removeEventListener("mousemove", onMouseMove);
            window.removeEventListener("touchmove", onMouseMove);
            window.removeEventListener("mouseup", onMouseUp);
            window.removeEventListener("touchend", onMouseUp);
            wrapperRaf.cancel(moveRafId);
          };
        }
      }, [dragging]);
      reactExports.useEffect(function() {
        delayHidden();
      }, [scrollOffset]);
      reactExports.useImperativeHandle(ref, function() {
        return {
          delayHidden
        };
      });
      var scrollbarPrefixCls = "".concat(prefixCls, "-scrollbar");
      var containerStyle = {
        position: "absolute",
        visibility: visible && canScroll ? null : "hidden"
      };
      var thumbStyle = {
        position: "absolute",
        background: "rgba(0, 0, 0, 0.5)",
        borderRadius: 99,
        cursor: "pointer",
        userSelect: "none"
      };
      if (horizontal) {
        containerStyle.height = 8;
        containerStyle.left = 0;
        containerStyle.right = 0;
        containerStyle.bottom = 0;
        thumbStyle.height = "100%";
        thumbStyle.width = spinSize;
        if (isLTR) {
          thumbStyle.left = top;
        } else {
          thumbStyle.right = top;
        }
      } else {
        containerStyle.width = 8;
        containerStyle.top = 0;
        containerStyle.bottom = 0;
        if (isLTR) {
          containerStyle.right = 0;
        } else {
          containerStyle.left = 0;
        }
        thumbStyle.width = "100%";
        thumbStyle.height = spinSize;
        thumbStyle.top = top;
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        ref: scrollbarRef,
        className: classNames(scrollbarPrefixCls, (_classNames = {}, _defineProperty(_classNames, "".concat(scrollbarPrefixCls, "-horizontal"), horizontal), _defineProperty(_classNames, "".concat(scrollbarPrefixCls, "-vertical"), !horizontal), _defineProperty(_classNames, "".concat(scrollbarPrefixCls, "-visible"), visible), _classNames)),
        style: _objectSpread2(_objectSpread2({}, containerStyle), style2),
        onMouseDown: onContainerMouseDown,
        onMouseMove: delayHidden
      }, /* @__PURE__ */ reactExports.createElement("div", {
        ref: thumbRef,
        className: classNames("".concat(scrollbarPrefixCls, "-thumb"), _defineProperty({}, "".concat(scrollbarPrefixCls, "-thumb-moving"), dragging)),
        style: _objectSpread2(_objectSpread2({}, thumbStyle), propsThumbStyle),
        onMouseDown: onThumbMouseDown
      }));
    });
    function Item$4(_ref) {
      var children = _ref.children, setRef = _ref.setRef;
      var refFunc = reactExports.useCallback(function(node2) {
        setRef(node2);
      }, []);
      return /* @__PURE__ */ reactExports.cloneElement(children, {
        ref: refFunc
      });
    }
    function useChildren$1(list, startIndex, endIndex, scrollWidth, setNodeRef, renderFunc, _ref) {
      var getKey2 = _ref.getKey;
      return list.slice(startIndex, endIndex + 1).map(function(item, index2) {
        var eleIndex = startIndex + index2;
        var node2 = renderFunc(item, eleIndex, {
          style: {
            width: scrollWidth
          }
        });
        var key = getKey2(item);
        return /* @__PURE__ */ reactExports.createElement(Item$4, {
          key,
          setRef: function setRef(ele) {
            return setNodeRef(item, ele);
          }
        }, node2);
      });
    }
    var CacheMap = /* @__PURE__ */ function() {
      function CacheMap2() {
        _classCallCheck(this, CacheMap2);
        this.maps = void 0;
        this.id = 0;
        this.maps = /* @__PURE__ */ Object.create(null);
      }
      _createClass(CacheMap2, [{
        key: "set",
        value: function set2(key, value) {
          this.maps[key] = value;
          this.id += 1;
        }
      }, {
        key: "get",
        value: function get2(key) {
          return this.maps[key];
        }
      }]);
      return CacheMap2;
    }();
    function useHeights(getKey2, onItemAdd, onItemRemove) {
      var _React$useState = reactExports.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2), updatedMark = _React$useState2[0], setUpdatedMark = _React$useState2[1];
      var instanceRef = reactExports.useRef(/* @__PURE__ */ new Map());
      var heightsRef = reactExports.useRef(new CacheMap());
      var collectRafRef = reactExports.useRef();
      function cancelRaf() {
        wrapperRaf.cancel(collectRafRef.current);
      }
      function collectHeight() {
        var sync = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        cancelRaf();
        var doCollect = function doCollect2() {
          instanceRef.current.forEach(function(element, key) {
            if (element && element.offsetParent) {
              var htmlElement = findDOMNode(element);
              var offsetHeight = htmlElement.offsetHeight;
              if (heightsRef.current.get(key) !== offsetHeight) {
                heightsRef.current.set(key, htmlElement.offsetHeight);
              }
            }
          });
          setUpdatedMark(function(c2) {
            return c2 + 1;
          });
        };
        if (sync) {
          doCollect();
        } else {
          collectRafRef.current = wrapperRaf(doCollect);
        }
      }
      function setInstanceRef(item, instance) {
        var key = getKey2(item);
        var origin = instanceRef.current.get(key);
        if (instance) {
          instanceRef.current.set(key, instance);
          collectHeight();
        } else {
          instanceRef.current.delete(key);
        }
        if (!origin !== !instance) {
          if (instance) {
            onItemAdd === null || onItemAdd === void 0 ? void 0 : onItemAdd(item);
          } else {
            onItemRemove === null || onItemRemove === void 0 ? void 0 : onItemRemove(item);
          }
        }
      }
      reactExports.useEffect(function() {
        return cancelRaf;
      }, []);
      return [setInstanceRef, collectHeight, heightsRef.current, updatedMark];
    }
    var MAX_TIMES = 10;
    function useScrollTo(containerRef, data, heights, itemHeight, getKey2, collectHeight, syncScrollTop, triggerFlash) {
      var scrollRef = reactExports.useRef();
      var _React$useState = reactExports.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), syncState = _React$useState2[0], setSyncState = _React$useState2[1];
      useLayoutEffect$1(function() {
        if (syncState && syncState.times < MAX_TIMES) {
          if (!containerRef.current) {
            setSyncState(function(ori) {
              return _objectSpread2({}, ori);
            });
            return;
          }
          collectHeight();
          var targetAlign = syncState.targetAlign, originAlign = syncState.originAlign, index2 = syncState.index, offset2 = syncState.offset;
          var height = containerRef.current.clientHeight;
          var needCollectHeight = false;
          var newTargetAlign = targetAlign;
          var targetTop = null;
          if (height) {
            var mergedAlign = targetAlign || originAlign;
            var stackTop = 0;
            var itemTop = 0;
            var itemBottom = 0;
            var maxLen = Math.min(data.length - 1, index2);
            for (var i = 0; i <= maxLen; i += 1) {
              var key = getKey2(data[i]);
              itemTop = stackTop;
              var cacheHeight = heights.get(key);
              itemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
              stackTop = itemBottom;
            }
            var leftHeight = mergedAlign === "top" ? offset2 : height - offset2;
            for (var _i = maxLen; _i >= 0; _i -= 1) {
              var _key = getKey2(data[_i]);
              var _cacheHeight = heights.get(_key);
              if (_cacheHeight === void 0) {
                needCollectHeight = true;
                break;
              }
              leftHeight -= _cacheHeight;
              if (leftHeight <= 0) {
                break;
              }
            }
            switch (mergedAlign) {
              case "top":
                targetTop = itemTop - offset2;
                break;
              case "bottom":
                targetTop = itemBottom - height + offset2;
                break;
              default: {
                var scrollTop = containerRef.current.scrollTop;
                var scrollBottom = scrollTop + height;
                if (itemTop < scrollTop) {
                  newTargetAlign = "top";
                } else if (itemBottom > scrollBottom) {
                  newTargetAlign = "bottom";
                }
              }
            }
            if (targetTop !== null) {
              syncScrollTop(targetTop);
            }
            if (targetTop !== syncState.lastTop) {
              needCollectHeight = true;
            }
          }
          if (needCollectHeight) {
            setSyncState(_objectSpread2(_objectSpread2({}, syncState), {}, {
              times: syncState.times + 1,
              targetAlign: newTargetAlign,
              lastTop: targetTop
            }));
          }
        }
      }, [syncState, containerRef.current]);
      return function(arg) {
        if (arg === null || arg === void 0) {
          triggerFlash();
          return;
        }
        wrapperRaf.cancel(scrollRef.current);
        if (typeof arg === "number") {
          syncScrollTop(arg);
        } else if (arg && _typeof(arg) === "object") {
          var index2;
          var align = arg.align;
          if ("index" in arg) {
            index2 = arg.index;
          } else {
            index2 = data.findIndex(function(item) {
              return getKey2(item) === arg.key;
            });
          }
          var _arg$offset = arg.offset, offset2 = _arg$offset === void 0 ? 0 : _arg$offset;
          setSyncState({
            times: 0,
            index: index2,
            offset: offset2,
            originAlign: align
          });
        }
      };
    }
    function findListDiffIndex(originList, targetList, getKey2) {
      var originLen = originList.length;
      var targetLen = targetList.length;
      var shortList;
      var longList;
      if (originLen === 0 && targetLen === 0) {
        return null;
      }
      if (originLen < targetLen) {
        shortList = originList;
        longList = targetList;
      } else {
        shortList = targetList;
        longList = originList;
      }
      var notExistKey = {
        __EMPTY_ITEM__: true
      };
      function getItemKey(item) {
        if (item !== void 0) {
          return getKey2(item);
        }
        return notExistKey;
      }
      var diffIndex = null;
      var multiple = Math.abs(originLen - targetLen) !== 1;
      for (var i = 0; i < longList.length; i += 1) {
        var shortKey = getItemKey(shortList[i]);
        var longKey = getItemKey(longList[i]);
        if (shortKey !== longKey) {
          diffIndex = i;
          multiple = multiple || shortKey !== getItemKey(longList[i + 1]);
          break;
        }
      }
      return diffIndex === null ? null : {
        index: diffIndex,
        multiple
      };
    }
    function useDiffItem(data, getKey2, onDiff) {
      var _React$useState = reactExports.useState(data), _React$useState2 = _slicedToArray(_React$useState, 2), prevData = _React$useState2[0], setPrevData = _React$useState2[1];
      var _React$useState3 = reactExports.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), diffItem = _React$useState4[0], setDiffItem = _React$useState4[1];
      reactExports.useEffect(function() {
        var diff2 = findListDiffIndex(prevData || [], data || [], getKey2);
        if ((diff2 === null || diff2 === void 0 ? void 0 : diff2.index) !== void 0) {
          onDiff === null || onDiff === void 0 ? void 0 : onDiff(diff2.index);
          setDiffItem(data[diff2.index]);
        }
        setPrevData(data);
      }, [data]);
      return [diffItem];
    }
    var isFF = (typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) === "object" && /Firefox/i.test(navigator.userAgent);
    const useOriginScroll = function(isScrollAtTop, isScrollAtBottom) {
      var lockRef = reactExports.useRef(false);
      var lockTimeoutRef = reactExports.useRef(null);
      function lockScroll() {
        clearTimeout(lockTimeoutRef.current);
        lockRef.current = true;
        lockTimeoutRef.current = setTimeout(function() {
          lockRef.current = false;
        }, 50);
      }
      var scrollPingRef = reactExports.useRef({
        top: isScrollAtTop,
        bottom: isScrollAtBottom
      });
      scrollPingRef.current.top = isScrollAtTop;
      scrollPingRef.current.bottom = isScrollAtBottom;
      return function(deltaY) {
        var smoothOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var originScroll = (
          // Pass origin wheel when on the top
          deltaY < 0 && scrollPingRef.current.top || // Pass origin wheel when on the bottom
          deltaY > 0 && scrollPingRef.current.bottom
        );
        if (smoothOffset && originScroll) {
          clearTimeout(lockTimeoutRef.current);
          lockRef.current = false;
        } else if (!originScroll || lockRef.current) {
          lockScroll();
        }
        return !lockRef.current && originScroll;
      };
    };
    function useFrameWheel(inVirtual, isScrollAtTop, isScrollAtBottom, horizontalScroll, onWheelDelta) {
      var offsetRef = reactExports.useRef(0);
      var nextFrameRef = reactExports.useRef(null);
      var wheelValueRef = reactExports.useRef(null);
      var isMouseScrollRef = reactExports.useRef(false);
      var originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom);
      function onWheelY(event, deltaY) {
        wrapperRaf.cancel(nextFrameRef.current);
        offsetRef.current += deltaY;
        wheelValueRef.current = deltaY;
        if (originScroll(deltaY))
          return;
        if (!isFF) {
          event.preventDefault();
        }
        nextFrameRef.current = wrapperRaf(function() {
          var patchMultiple = isMouseScrollRef.current ? 10 : 1;
          onWheelDelta(offsetRef.current * patchMultiple);
          offsetRef.current = 0;
        });
      }
      function onWheelX(event, deltaX) {
        onWheelDelta(deltaX, true);
        if (!isFF) {
          event.preventDefault();
        }
      }
      var wheelDirectionRef = reactExports.useRef(null);
      var wheelDirectionCleanRef = reactExports.useRef(null);
      function onWheel(event) {
        if (!inVirtual)
          return;
        wrapperRaf.cancel(wheelDirectionCleanRef.current);
        wheelDirectionCleanRef.current = wrapperRaf(function() {
          wheelDirectionRef.current = null;
        }, 2);
        var deltaX = event.deltaX, deltaY = event.deltaY, shiftKey = event.shiftKey;
        var mergedDeltaX = deltaX;
        var mergedDeltaY = deltaY;
        if (wheelDirectionRef.current === "sx" || !wheelDirectionRef.current && (shiftKey || false) && deltaY && !deltaX) {
          mergedDeltaX = deltaY;
          mergedDeltaY = 0;
          wheelDirectionRef.current = "sx";
        }
        var absX = Math.abs(mergedDeltaX);
        var absY = Math.abs(mergedDeltaY);
        if (wheelDirectionRef.current === null) {
          wheelDirectionRef.current = horizontalScroll && absX > absY ? "x" : "y";
        }
        if (wheelDirectionRef.current === "y") {
          onWheelY(event, mergedDeltaY);
        } else {
          onWheelX(event, mergedDeltaX);
        }
      }
      function onFireFoxScroll(event) {
        if (!inVirtual)
          return;
        isMouseScrollRef.current = event.detail === wheelValueRef.current;
      }
      return [onWheel, onFireFoxScroll];
    }
    var SMOOTH_PTG = 14 / 15;
    function useMobileTouchMove(inVirtual, listRef, callback) {
      var touchedRef = reactExports.useRef(false);
      var touchYRef = reactExports.useRef(0);
      var elementRef = reactExports.useRef(null);
      var intervalRef = reactExports.useRef(null);
      var cleanUpEvents;
      var onTouchMove = function onTouchMove2(e2) {
        if (touchedRef.current) {
          var currentY = Math.ceil(e2.touches[0].pageY);
          var offsetY = touchYRef.current - currentY;
          touchYRef.current = currentY;
          if (callback(offsetY)) {
            e2.preventDefault();
          }
          clearInterval(intervalRef.current);
          intervalRef.current = setInterval(function() {
            offsetY *= SMOOTH_PTG;
            if (!callback(offsetY, true) || Math.abs(offsetY) <= 0.1) {
              clearInterval(intervalRef.current);
            }
          }, 16);
        }
      };
      var onTouchEnd = function onTouchEnd2() {
        touchedRef.current = false;
        cleanUpEvents();
      };
      var onTouchStart = function onTouchStart2(e2) {
        cleanUpEvents();
        if (e2.touches.length === 1 && !touchedRef.current) {
          touchedRef.current = true;
          touchYRef.current = Math.ceil(e2.touches[0].pageY);
          elementRef.current = e2.target;
          elementRef.current.addEventListener("touchmove", onTouchMove);
          elementRef.current.addEventListener("touchend", onTouchEnd);
        }
      };
      cleanUpEvents = function cleanUpEvents2() {
        if (elementRef.current) {
          elementRef.current.removeEventListener("touchmove", onTouchMove);
          elementRef.current.removeEventListener("touchend", onTouchEnd);
        }
      };
      useLayoutEffect$1(function() {
        if (inVirtual) {
          listRef.current.addEventListener("touchstart", onTouchStart);
        }
        return function() {
          var _listRef$current;
          (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.removeEventListener("touchstart", onTouchStart);
          cleanUpEvents();
          clearInterval(intervalRef.current);
        };
      }, [inVirtual]);
    }
    var MIN_SIZE = 20;
    function getSpinSize() {
      var containerSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var scrollRange = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var baseSize = containerSize / scrollRange * 100;
      if (isNaN(baseSize)) {
        baseSize = 0;
      }
      baseSize = Math.max(baseSize, MIN_SIZE);
      baseSize = Math.min(baseSize, containerSize / 2);
      return Math.floor(baseSize);
    }
    function useGetSize(mergedData, getKey2, heights, itemHeight) {
      var _React$useMemo = reactExports.useMemo(function() {
        return [/* @__PURE__ */ new Map(), []];
      }, [mergedData, heights.id, itemHeight]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), key2Index = _React$useMemo2[0], bottomList = _React$useMemo2[1];
      var getSize2 = function getSize3(startKey) {
        var endKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : startKey;
        var startIndex = key2Index.get(startKey);
        var endIndex = key2Index.get(endKey);
        if (startIndex === void 0 || endIndex === void 0) {
          var dataLen = mergedData.length;
          for (var i = bottomList.length; i < dataLen; i += 1) {
            var _heights$get;
            var item = mergedData[i];
            var key = getKey2(item);
            key2Index.set(key, i);
            var cacheHeight = (_heights$get = heights.get(key)) !== null && _heights$get !== void 0 ? _heights$get : itemHeight;
            bottomList[i] = (bottomList[i - 1] || 0) + cacheHeight;
            if (key === startKey) {
              startIndex = i;
            }
            if (key === endKey) {
              endIndex = i;
            }
            if (startIndex !== void 0 && endIndex !== void 0) {
              break;
            }
          }
        }
        return {
          top: bottomList[startIndex - 1] || 0,
          bottom: bottomList[endIndex]
        };
      };
      return getSize2;
    }
    var _excluded$u = ["prefixCls", "className", "height", "itemHeight", "fullHeight", "style", "data", "children", "itemKey", "virtual", "direction", "scrollWidth", "component", "onScroll", "onVirtualScroll", "onVisibleChange", "innerProps", "extraRender", "styles"];
    var EMPTY_DATA$1 = [];
    var ScrollStyle = {
      overflowY: "auto",
      overflowAnchor: "none"
    };
    function RawList(props, ref) {
      var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-virtual-list" : _props$prefixCls, className = props.className, height = props.height, itemHeight = props.itemHeight, _props$fullHeight = props.fullHeight, fullHeight = _props$fullHeight === void 0 ? true : _props$fullHeight, style2 = props.style, data = props.data, children = props.children, itemKey2 = props.itemKey, virtual = props.virtual, direction = props.direction, scrollWidth = props.scrollWidth, _props$component = props.component, Component = _props$component === void 0 ? "div" : _props$component, onScroll = props.onScroll, onVirtualScroll = props.onVirtualScroll, onVisibleChange = props.onVisibleChange, innerProps = props.innerProps, extraRender = props.extraRender, styles = props.styles, restProps = _objectWithoutProperties(props, _excluded$u);
      var useVirtual = !!(virtual !== false && height && itemHeight);
      var inVirtual = useVirtual && data && (itemHeight * data.length > height || !!scrollWidth);
      var isRTL = direction === "rtl";
      var mergedClassName = classNames(prefixCls, _defineProperty({}, "".concat(prefixCls, "-rtl"), isRTL), className);
      var mergedData = data || EMPTY_DATA$1;
      var componentRef = reactExports.useRef();
      var fillerInnerRef = reactExports.useRef();
      var _useState = reactExports.useState(0), _useState2 = _slicedToArray(_useState, 2), offsetTop = _useState2[0], setOffsetTop = _useState2[1];
      var _useState3 = reactExports.useState(0), _useState4 = _slicedToArray(_useState3, 2), offsetLeft = _useState4[0], setOffsetLeft = _useState4[1];
      var _useState5 = reactExports.useState(false), _useState6 = _slicedToArray(_useState5, 2), scrollMoving = _useState6[0], setScrollMoving = _useState6[1];
      var onScrollbarStartMove = function onScrollbarStartMove2() {
        setScrollMoving(true);
      };
      var onScrollbarStopMove = function onScrollbarStopMove2() {
        setScrollMoving(false);
      };
      var getKey2 = reactExports.useCallback(function(item) {
        if (typeof itemKey2 === "function") {
          return itemKey2(item);
        }
        return item === null || item === void 0 ? void 0 : item[itemKey2];
      }, [itemKey2]);
      var sharedConfig = {
        getKey: getKey2
      };
      function syncScrollTop(newTop) {
        setOffsetTop(function(origin) {
          var value;
          if (typeof newTop === "function") {
            value = newTop(origin);
          } else {
            value = newTop;
          }
          var alignedTop = keepInRange(value);
          componentRef.current.scrollTop = alignedTop;
          return alignedTop;
        });
      }
      var rangeRef = reactExports.useRef({
        start: 0,
        end: mergedData.length
      });
      var diffItemRef = reactExports.useRef();
      var _useDiffItem = useDiffItem(mergedData, getKey2), _useDiffItem2 = _slicedToArray(_useDiffItem, 1), diffItem = _useDiffItem2[0];
      diffItemRef.current = diffItem;
      var _useHeights = useHeights(getKey2, null, null), _useHeights2 = _slicedToArray(_useHeights, 4), setInstanceRef = _useHeights2[0], collectHeight = _useHeights2[1], heights = _useHeights2[2], heightUpdatedMark = _useHeights2[3];
      var _React$useMemo = reactExports.useMemo(function() {
        if (!useVirtual) {
          return {
            scrollHeight: void 0,
            start: 0,
            end: mergedData.length - 1,
            offset: void 0
          };
        }
        if (!inVirtual) {
          var _fillerInnerRef$curre;
          return {
            scrollHeight: ((_fillerInnerRef$curre = fillerInnerRef.current) === null || _fillerInnerRef$curre === void 0 ? void 0 : _fillerInnerRef$curre.offsetHeight) || 0,
            start: 0,
            end: mergedData.length - 1,
            offset: void 0
          };
        }
        var itemTop = 0;
        var startIndex;
        var startOffset;
        var endIndex;
        var dataLen = mergedData.length;
        for (var i = 0; i < dataLen; i += 1) {
          var item = mergedData[i];
          var key = getKey2(item);
          var cacheHeight = heights.get(key);
          var currentItemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
          if (currentItemBottom >= offsetTop && startIndex === void 0) {
            startIndex = i;
            startOffset = itemTop;
          }
          if (currentItemBottom > offsetTop + height && endIndex === void 0) {
            endIndex = i;
          }
          itemTop = currentItemBottom;
        }
        if (startIndex === void 0) {
          startIndex = 0;
          startOffset = 0;
          endIndex = Math.ceil(height / itemHeight);
        }
        if (endIndex === void 0) {
          endIndex = mergedData.length - 1;
        }
        endIndex = Math.min(endIndex + 1, mergedData.length - 1);
        return {
          scrollHeight: itemTop,
          start: startIndex,
          end: endIndex,
          offset: startOffset
        };
      }, [inVirtual, useVirtual, offsetTop, mergedData, heightUpdatedMark, height]), scrollHeight = _React$useMemo.scrollHeight, start = _React$useMemo.start, end = _React$useMemo.end, fillerOffset = _React$useMemo.offset;
      rangeRef.current.start = start;
      rangeRef.current.end = end;
      var _React$useState = reactExports.useState({
        width: 0,
        height
      }), _React$useState2 = _slicedToArray(_React$useState, 2), size = _React$useState2[0], setSize = _React$useState2[1];
      var onHolderResize = function onHolderResize2(sizeInfo) {
        setSize({
          width: sizeInfo.width || sizeInfo.offsetWidth,
          height: sizeInfo.height || sizeInfo.offsetHeight
        });
      };
      var verticalScrollBarRef = reactExports.useRef();
      var horizontalScrollBarRef = reactExports.useRef();
      var horizontalScrollBarSpinSize = reactExports.useMemo(function() {
        return getSpinSize(size.width, scrollWidth);
      }, [size.width, scrollWidth]);
      var verticalScrollBarSpinSize = reactExports.useMemo(function() {
        return getSpinSize(size.height, scrollHeight);
      }, [size.height, scrollHeight]);
      var maxScrollHeight = scrollHeight - height;
      var maxScrollHeightRef = reactExports.useRef(maxScrollHeight);
      maxScrollHeightRef.current = maxScrollHeight;
      function keepInRange(newScrollTop) {
        var newTop = newScrollTop;
        if (!Number.isNaN(maxScrollHeightRef.current)) {
          newTop = Math.min(newTop, maxScrollHeightRef.current);
        }
        newTop = Math.max(newTop, 0);
        return newTop;
      }
      var isScrollAtTop = offsetTop <= 0;
      var isScrollAtBottom = offsetTop >= maxScrollHeight;
      var originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom);
      var getVirtualScrollInfo = function getVirtualScrollInfo2() {
        return {
          x: isRTL ? -offsetLeft : offsetLeft,
          y: offsetTop
        };
      };
      var lastVirtualScrollInfoRef = reactExports.useRef(getVirtualScrollInfo());
      var triggerScroll = useEvent(function() {
        if (onVirtualScroll) {
          var nextInfo = getVirtualScrollInfo();
          if (lastVirtualScrollInfoRef.current.x !== nextInfo.x || lastVirtualScrollInfoRef.current.y !== nextInfo.y) {
            onVirtualScroll(nextInfo);
            lastVirtualScrollInfoRef.current = nextInfo;
          }
        }
      });
      function onScrollBar(newScrollOffset, horizontal) {
        var newOffset = newScrollOffset;
        if (horizontal) {
          reactDomExports.flushSync(function() {
            setOffsetLeft(newOffset);
          });
          triggerScroll();
        } else {
          syncScrollTop(newOffset);
        }
      }
      function onFallbackScroll(e2) {
        var newScrollTop = e2.currentTarget.scrollTop;
        if (newScrollTop !== offsetTop) {
          syncScrollTop(newScrollTop);
        }
        onScroll === null || onScroll === void 0 ? void 0 : onScroll(e2);
        triggerScroll();
      }
      var keepInHorizontalRange = function keepInHorizontalRange2(nextOffsetLeft) {
        var tmpOffsetLeft = nextOffsetLeft;
        var max2 = scrollWidth - size.width;
        tmpOffsetLeft = Math.max(tmpOffsetLeft, 0);
        tmpOffsetLeft = Math.min(tmpOffsetLeft, max2);
        return tmpOffsetLeft;
      };
      var onWheelDelta = useEvent(function(offsetXY, fromHorizontal) {
        if (fromHorizontal) {
          reactDomExports.flushSync(function() {
            setOffsetLeft(function(left) {
              var nextOffsetLeft = left + (isRTL ? -offsetXY : offsetXY);
              return keepInHorizontalRange(nextOffsetLeft);
            });
          });
          triggerScroll();
        } else {
          syncScrollTop(function(top) {
            var newTop = top + offsetXY;
            return newTop;
          });
        }
      });
      var _useFrameWheel = useFrameWheel(useVirtual, isScrollAtTop, isScrollAtBottom, !!scrollWidth, onWheelDelta), _useFrameWheel2 = _slicedToArray(_useFrameWheel, 2), onRawWheel = _useFrameWheel2[0], onFireFoxScroll = _useFrameWheel2[1];
      useMobileTouchMove(useVirtual, componentRef, function(deltaY, smoothOffset) {
        if (originScroll(deltaY, smoothOffset)) {
          return false;
        }
        onRawWheel({
          preventDefault: function preventDefault() {
          },
          deltaY
        });
        return true;
      });
      useLayoutEffect$1(function() {
        function onMozMousePixelScroll(e2) {
          if (useVirtual) {
            e2.preventDefault();
          }
        }
        var componentEle = componentRef.current;
        componentEle.addEventListener("wheel", onRawWheel);
        componentEle.addEventListener("DOMMouseScroll", onFireFoxScroll);
        componentEle.addEventListener("MozMousePixelScroll", onMozMousePixelScroll);
        return function() {
          componentEle.removeEventListener("wheel", onRawWheel);
          componentEle.removeEventListener("DOMMouseScroll", onFireFoxScroll);
          componentEle.removeEventListener("MozMousePixelScroll", onMozMousePixelScroll);
        };
      }, [useVirtual]);
      useLayoutEffect$1(function() {
        if (scrollWidth) {
          setOffsetLeft(function(left) {
            return keepInHorizontalRange(left);
          });
        }
      }, [size.width, scrollWidth]);
      var delayHideScrollBar = function delayHideScrollBar2() {
        var _verticalScrollBarRef, _horizontalScrollBarR;
        (_verticalScrollBarRef = verticalScrollBarRef.current) === null || _verticalScrollBarRef === void 0 ? void 0 : _verticalScrollBarRef.delayHidden();
        (_horizontalScrollBarR = horizontalScrollBarRef.current) === null || _horizontalScrollBarR === void 0 ? void 0 : _horizontalScrollBarR.delayHidden();
      };
      var _scrollTo = useScrollTo(componentRef, mergedData, heights, itemHeight, getKey2, function() {
        return collectHeight(true);
      }, syncScrollTop, delayHideScrollBar);
      reactExports.useImperativeHandle(ref, function() {
        return {
          getScrollInfo: getVirtualScrollInfo,
          scrollTo: function scrollTo2(config) {
            function isPosScroll(arg) {
              return arg && _typeof(arg) === "object" && ("left" in arg || "top" in arg);
            }
            if (isPosScroll(config)) {
              if (config.left !== void 0) {
                setOffsetLeft(keepInHorizontalRange(config.left));
              }
              _scrollTo(config.top);
            } else {
              _scrollTo(config);
            }
          }
        };
      });
      useLayoutEffect$1(function() {
        if (onVisibleChange) {
          var renderList = mergedData.slice(start, end + 1);
          onVisibleChange(renderList, mergedData);
        }
      }, [start, end, mergedData]);
      var getSize2 = useGetSize(mergedData, getKey2, heights, itemHeight);
      var extraContent = extraRender === null || extraRender === void 0 ? void 0 : extraRender({
        start,
        end,
        virtual: inVirtual,
        offsetX: offsetLeft,
        offsetY: fillerOffset,
        rtl: isRTL,
        getSize: getSize2
      });
      var listChildren = useChildren$1(mergedData, start, end, scrollWidth, setInstanceRef, children, sharedConfig);
      var componentStyle = null;
      if (height) {
        componentStyle = _objectSpread2(_defineProperty({}, fullHeight ? "height" : "maxHeight", height), ScrollStyle);
        if (useVirtual) {
          componentStyle.overflowY = "hidden";
          if (scrollWidth) {
            componentStyle.overflowX = "hidden";
          }
          if (scrollMoving) {
            componentStyle.pointerEvents = "none";
          }
        }
      }
      var containerProps = {};
      if (isRTL) {
        containerProps.dir = "rtl";
      }
      return /* @__PURE__ */ reactExports.createElement("div", _extends$1({
        style: _objectSpread2(_objectSpread2({}, style2), {}, {
          position: "relative"
        }),
        className: mergedClassName
      }, containerProps, restProps), /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
        onResize: onHolderResize
      }, /* @__PURE__ */ reactExports.createElement(Component, {
        className: "".concat(prefixCls, "-holder"),
        style: componentStyle,
        ref: componentRef,
        onScroll: onFallbackScroll,
        onMouseEnter: delayHideScrollBar
      }, /* @__PURE__ */ reactExports.createElement(Filler, {
        prefixCls,
        height: scrollHeight,
        offsetX: offsetLeft,
        offsetY: fillerOffset,
        scrollWidth,
        onInnerResize: collectHeight,
        ref: fillerInnerRef,
        innerProps,
        rtl: isRTL,
        extra: extraContent
      }, listChildren))), inVirtual && scrollHeight > height && /* @__PURE__ */ reactExports.createElement(ScrollBar, {
        ref: verticalScrollBarRef,
        prefixCls,
        scrollOffset: offsetTop,
        scrollRange: scrollHeight,
        rtl: isRTL,
        onScroll: onScrollBar,
        onStartMove: onScrollbarStartMove,
        onStopMove: onScrollbarStopMove,
        spinSize: verticalScrollBarSpinSize,
        containerSize: size.height,
        style: styles === null || styles === void 0 ? void 0 : styles.verticalScrollBar,
        thumbStyle: styles === null || styles === void 0 ? void 0 : styles.verticalScrollBarThumb
      }), inVirtual && scrollWidth && /* @__PURE__ */ reactExports.createElement(ScrollBar, {
        ref: horizontalScrollBarRef,
        prefixCls,
        scrollOffset: offsetLeft,
        scrollRange: scrollWidth,
        rtl: isRTL,
        onScroll: onScrollBar,
        onStartMove: onScrollbarStartMove,
        onStopMove: onScrollbarStopMove,
        spinSize: horizontalScrollBarSpinSize,
        containerSize: size.width,
        horizontal: true,
        style: styles === null || styles === void 0 ? void 0 : styles.horizontalScrollBar,
        thumbStyle: styles === null || styles === void 0 ? void 0 : styles.horizontalScrollBarThumb
      }));
    }
    var List$1 = /* @__PURE__ */ reactExports.forwardRef(RawList);
    List$1.displayName = "List";
    var SelectContext = /* @__PURE__ */ reactExports.createContext(null);
    function isPlatformMac() {
      return /(mac\sos|macintosh)/i.test(navigator.appVersion);
    }
    var _excluded$t = ["disabled", "title", "children", "style", "className"];
    function isTitleType(content) {
      return typeof content === "string" || typeof content === "number";
    }
    var OptionList = function OptionList2(_, ref) {
      var _useBaseProps = useBaseProps(), prefixCls = _useBaseProps.prefixCls, id2 = _useBaseProps.id, open = _useBaseProps.open, multiple = _useBaseProps.multiple, mode = _useBaseProps.mode, searchValue = _useBaseProps.searchValue, toggleOpen = _useBaseProps.toggleOpen, notFoundContent = _useBaseProps.notFoundContent, onPopupScroll = _useBaseProps.onPopupScroll;
      var _React$useContext = reactExports.useContext(SelectContext), flattenOptions2 = _React$useContext.flattenOptions, onActiveValue = _React$useContext.onActiveValue, defaultActiveFirstOption = _React$useContext.defaultActiveFirstOption, onSelect = _React$useContext.onSelect, menuItemSelectedIcon = _React$useContext.menuItemSelectedIcon, rawValues = _React$useContext.rawValues, fieldNames = _React$useContext.fieldNames, virtual = _React$useContext.virtual, direction = _React$useContext.direction, listHeight = _React$useContext.listHeight, listItemHeight = _React$useContext.listItemHeight, optionRender = _React$useContext.optionRender;
      var itemPrefixCls = "".concat(prefixCls, "-item");
      var memoFlattenOptions = useMemo(function() {
        return flattenOptions2;
      }, [open, flattenOptions2], function(prev2, next2) {
        return next2[0] && prev2[1] !== next2[1];
      });
      var listRef = reactExports.useRef(null);
      var onListMouseDown = function onListMouseDown2(event) {
        event.preventDefault();
      };
      var scrollIntoView = function scrollIntoView2(args) {
        if (listRef.current) {
          listRef.current.scrollTo(typeof args === "number" ? {
            index: args
          } : args);
        }
      };
      var getEnabledActiveIndex = function getEnabledActiveIndex2(index2) {
        var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        var len = memoFlattenOptions.length;
        for (var i = 0; i < len; i += 1) {
          var current = (index2 + i * offset2 + len) % len;
          var _memoFlattenOptions$c = memoFlattenOptions[current], group = _memoFlattenOptions$c.group, data = _memoFlattenOptions$c.data;
          if (!group && !data.disabled) {
            return current;
          }
        }
        return -1;
      };
      var _React$useState = reactExports.useState(function() {
        return getEnabledActiveIndex(0);
      }), _React$useState2 = _slicedToArray(_React$useState, 2), activeIndex = _React$useState2[0], setActiveIndex = _React$useState2[1];
      var setActive = function setActive2(index2) {
        var fromKeyboard = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        setActiveIndex(index2);
        var info = {
          source: fromKeyboard ? "keyboard" : "mouse"
        };
        var flattenItem = memoFlattenOptions[index2];
        if (!flattenItem) {
          onActiveValue(null, -1, info);
          return;
        }
        onActiveValue(flattenItem.value, index2, info);
      };
      reactExports.useEffect(function() {
        setActive(defaultActiveFirstOption !== false ? getEnabledActiveIndex(0) : -1);
      }, [memoFlattenOptions.length, searchValue]);
      var isSelected = reactExports.useCallback(function(value) {
        return rawValues.has(value) && mode !== "combobox";
      }, [mode, _toConsumableArray(rawValues).toString(), rawValues.size]);
      reactExports.useEffect(function() {
        var timeoutId = setTimeout(function() {
          if (!multiple && open && rawValues.size === 1) {
            var value = Array.from(rawValues)[0];
            var index2 = memoFlattenOptions.findIndex(function(_ref) {
              var data = _ref.data;
              return data.value === value;
            });
            if (index2 !== -1) {
              setActive(index2);
              scrollIntoView(index2);
            }
          }
        });
        if (open) {
          var _listRef$current;
          (_listRef$current = listRef.current) === null || _listRef$current === void 0 || _listRef$current.scrollTo(void 0);
        }
        return function() {
          return clearTimeout(timeoutId);
        };
      }, [open, searchValue]);
      var onSelectValue = function onSelectValue2(value) {
        if (value !== void 0) {
          onSelect(value, {
            selected: !rawValues.has(value)
          });
        }
        if (!multiple) {
          toggleOpen(false);
        }
      };
      reactExports.useImperativeHandle(ref, function() {
        return {
          onKeyDown: function onKeyDown2(event) {
            var which = event.which, ctrlKey = event.ctrlKey;
            switch (which) {
              case KeyCode.N:
              case KeyCode.P:
              case KeyCode.UP:
              case KeyCode.DOWN: {
                var offset2 = 0;
                if (which === KeyCode.UP) {
                  offset2 = -1;
                } else if (which === KeyCode.DOWN) {
                  offset2 = 1;
                } else if (isPlatformMac() && ctrlKey) {
                  if (which === KeyCode.N) {
                    offset2 = 1;
                  } else if (which === KeyCode.P) {
                    offset2 = -1;
                  }
                }
                if (offset2 !== 0) {
                  var nextActiveIndex = getEnabledActiveIndex(activeIndex + offset2, offset2);
                  scrollIntoView(nextActiveIndex);
                  setActive(nextActiveIndex, true);
                }
                break;
              }
              case KeyCode.ENTER: {
                var item = memoFlattenOptions[activeIndex];
                if (item && !item.data.disabled) {
                  onSelectValue(item.value);
                } else {
                  onSelectValue(void 0);
                }
                if (open) {
                  event.preventDefault();
                }
                break;
              }
              case KeyCode.ESC: {
                toggleOpen(false);
                if (open) {
                  event.stopPropagation();
                }
              }
            }
          },
          onKeyUp: function onKeyUp() {
          },
          scrollTo: function scrollTo2(index2) {
            scrollIntoView(index2);
          }
        };
      });
      if (memoFlattenOptions.length === 0) {
        return /* @__PURE__ */ reactExports.createElement("div", {
          role: "listbox",
          id: "".concat(id2, "_list"),
          className: "".concat(itemPrefixCls, "-empty"),
          onMouseDown: onListMouseDown
        }, notFoundContent);
      }
      var omitFieldNameList = Object.keys(fieldNames).map(function(key) {
        return fieldNames[key];
      });
      var getLabel = function getLabel2(item) {
        return item.label;
      };
      function getItemAriaProps(item, index2) {
        var group = item.group;
        return {
          role: group ? "presentation" : "option",
          id: "".concat(id2, "_list_").concat(index2)
        };
      }
      var renderItem2 = function renderItem3(index2) {
        var item = memoFlattenOptions[index2];
        if (!item)
          return null;
        var itemData = item.data || {};
        var value = itemData.value;
        var group = item.group;
        var attrs = pickAttrs(itemData, true);
        var mergedLabel = getLabel(item);
        return item ? /* @__PURE__ */ reactExports.createElement("div", _extends$1({
          "aria-label": typeof mergedLabel === "string" && !group ? mergedLabel : null
        }, attrs, {
          key: index2
        }, getItemAriaProps(item, index2), {
          "aria-selected": isSelected(value)
        }), value) : null;
      };
      var a11yProps = {
        role: "listbox",
        id: "".concat(id2, "_list")
      };
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, virtual && /* @__PURE__ */ reactExports.createElement("div", _extends$1({}, a11yProps, {
        style: {
          height: 0,
          width: 0,
          overflow: "hidden"
        }
      }), renderItem2(activeIndex - 1), renderItem2(activeIndex), renderItem2(activeIndex + 1)), /* @__PURE__ */ reactExports.createElement(List$1, {
        itemKey: "key",
        ref: listRef,
        data: memoFlattenOptions,
        height: listHeight,
        itemHeight: listItemHeight,
        fullHeight: false,
        onMouseDown: onListMouseDown,
        onScroll: onPopupScroll,
        virtual,
        direction,
        innerProps: virtual ? null : a11yProps
      }, function(item, itemIndex) {
        var _classNames;
        var group = item.group, groupOption = item.groupOption, data = item.data, label = item.label, value = item.value;
        var key = data.key;
        if (group) {
          var _data$title;
          var groupTitle = (_data$title = data.title) !== null && _data$title !== void 0 ? _data$title : isTitleType(label) ? label.toString() : void 0;
          return /* @__PURE__ */ reactExports.createElement("div", {
            className: classNames(itemPrefixCls, "".concat(itemPrefixCls, "-group")),
            title: groupTitle
          }, label !== void 0 ? label : key);
        }
        var disabled = data.disabled, title = data.title;
        data.children;
        var style2 = data.style, className = data.className, otherProps = _objectWithoutProperties(data, _excluded$t);
        var passedProps = omit(otherProps, omitFieldNameList);
        var selected = isSelected(value);
        var optionPrefixCls = "".concat(itemPrefixCls, "-option");
        var optionClassName = classNames(itemPrefixCls, optionPrefixCls, className, (_classNames = {}, _defineProperty(_classNames, "".concat(optionPrefixCls, "-grouped"), groupOption), _defineProperty(_classNames, "".concat(optionPrefixCls, "-active"), activeIndex === itemIndex && !disabled), _defineProperty(_classNames, "".concat(optionPrefixCls, "-disabled"), disabled), _defineProperty(_classNames, "".concat(optionPrefixCls, "-selected"), selected), _classNames));
        var mergedLabel = getLabel(item);
        var iconVisible = !menuItemSelectedIcon || typeof menuItemSelectedIcon === "function" || selected;
        var content = typeof mergedLabel === "number" ? mergedLabel : mergedLabel || value;
        var optionTitle = isTitleType(content) ? content.toString() : void 0;
        if (title !== void 0) {
          optionTitle = title;
        }
        return /* @__PURE__ */ reactExports.createElement("div", _extends$1({}, pickAttrs(passedProps), !virtual ? getItemAriaProps(item, itemIndex) : {}, {
          "aria-selected": selected,
          className: optionClassName,
          title: optionTitle,
          onMouseMove: function onMouseMove() {
            if (activeIndex === itemIndex || disabled) {
              return;
            }
            setActive(itemIndex);
          },
          onClick: function onClick() {
            if (!disabled) {
              onSelectValue(value);
            }
          },
          style: style2
        }), /* @__PURE__ */ reactExports.createElement("div", {
          className: "".concat(optionPrefixCls, "-content")
        }, typeof optionRender === "function" ? optionRender(item, {
          index: itemIndex
        }) : content), /* @__PURE__ */ reactExports.isValidElement(menuItemSelectedIcon) || selected, iconVisible && /* @__PURE__ */ reactExports.createElement(TransBtn, {
          className: "".concat(itemPrefixCls, "-option-state"),
          customizeIcon: menuItemSelectedIcon,
          customizeIconProps: {
            value,
            disabled,
            isSelected: selected
          }
        }, selected ? "✓" : null));
      }));
    };
    var RefOptionList = /* @__PURE__ */ reactExports.forwardRef(OptionList);
    RefOptionList.displayName = "OptionList";
    const useCache = function(labeledValues, valueOptions) {
      var cacheRef = reactExports.useRef({
        values: /* @__PURE__ */ new Map(),
        options: /* @__PURE__ */ new Map()
      });
      var filledLabeledValues = reactExports.useMemo(function() {
        var _cacheRef$current = cacheRef.current, prevValueCache = _cacheRef$current.values, prevOptionCache = _cacheRef$current.options;
        var patchedValues = labeledValues.map(function(item) {
          if (item.label === void 0) {
            var _prevValueCache$get;
            return _objectSpread2(_objectSpread2({}, item), {}, {
              label: (_prevValueCache$get = prevValueCache.get(item.value)) === null || _prevValueCache$get === void 0 ? void 0 : _prevValueCache$get.label
            });
          }
          return item;
        });
        var valueCache = /* @__PURE__ */ new Map();
        var optionCache = /* @__PURE__ */ new Map();
        patchedValues.forEach(function(item) {
          valueCache.set(item.value, item);
          optionCache.set(item.value, valueOptions.get(item.value) || prevOptionCache.get(item.value));
        });
        cacheRef.current.values = valueCache;
        cacheRef.current.options = optionCache;
        return patchedValues;
      }, [labeledValues, valueOptions]);
      var getOption = reactExports.useCallback(function(val) {
        return valueOptions.get(val) || cacheRef.current.options.get(val);
      }, [valueOptions]);
      return [filledLabeledValues, getOption];
    };
    function includes(test, search) {
      return toArray$8(test).join("").toUpperCase().includes(search);
    }
    const useFilterOptions = function(options, fieldNames, searchValue, filterOption, optionFilterProp) {
      return reactExports.useMemo(function() {
        if (!searchValue || filterOption === false) {
          return options;
        }
        var fieldOptions = fieldNames.options, fieldLabel = fieldNames.label, fieldValue = fieldNames.value;
        var filteredOptions = [];
        var customizeFilter = typeof filterOption === "function";
        var upperSearch = searchValue.toUpperCase();
        var filterFunc = customizeFilter ? filterOption : function(_, option) {
          if (optionFilterProp) {
            return includes(option[optionFilterProp], upperSearch);
          }
          if (option[fieldOptions]) {
            return includes(option[fieldLabel !== "children" ? fieldLabel : "label"], upperSearch);
          }
          return includes(option[fieldValue], upperSearch);
        };
        var wrapOption = customizeFilter ? function(opt) {
          return injectPropsWithOption(opt);
        } : function(opt) {
          return opt;
        };
        options.forEach(function(item) {
          if (item[fieldOptions]) {
            var matchGroup = filterFunc(searchValue, wrapOption(item));
            if (matchGroup) {
              filteredOptions.push(item);
            } else {
              var subOptions = item[fieldOptions].filter(function(subItem) {
                return filterFunc(searchValue, wrapOption(subItem));
              });
              if (subOptions.length) {
                filteredOptions.push(_objectSpread2(_objectSpread2({}, item), {}, _defineProperty({}, fieldOptions, subOptions)));
              }
            }
            return;
          }
          if (filterFunc(searchValue, wrapOption(item))) {
            filteredOptions.push(item);
          }
        });
        return filteredOptions;
      }, [options, filterOption, optionFilterProp, searchValue, fieldNames]);
    };
    var uuid$1 = 0;
    var isBrowserClient$1 = canUseDom();
    function getUUID$1() {
      var retId;
      if (isBrowserClient$1) {
        retId = uuid$1;
        uuid$1 += 1;
      } else {
        retId = "TEST_OR_SSR";
      }
      return retId;
    }
    function useId$1(id2) {
      var _React$useState = reactExports.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
      reactExports.useEffect(function() {
        setInnerId("rc_select_".concat(getUUID$1()));
      }, []);
      return id2 || innerId;
    }
    var _excluded$s = ["children", "value"], _excluded2$4 = ["children"];
    function convertNodeToOption(node2) {
      var _ref = node2, key = _ref.key, _ref$props = _ref.props, children = _ref$props.children, value = _ref$props.value, restProps = _objectWithoutProperties(_ref$props, _excluded$s);
      return _objectSpread2({
        key,
        value: value !== void 0 ? value : key,
        children
      }, restProps);
    }
    function convertChildrenToData(nodes) {
      var optionOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return toArray$a(nodes).map(function(node2, index2) {
        if (!/* @__PURE__ */ reactExports.isValidElement(node2) || !node2.type) {
          return null;
        }
        var _ref2 = node2, isSelectOptGroup = _ref2.type.isSelectOptGroup, key = _ref2.key, _ref2$props = _ref2.props, children = _ref2$props.children, restProps = _objectWithoutProperties(_ref2$props, _excluded2$4);
        if (optionOnly || !isSelectOptGroup) {
          return convertNodeToOption(node2);
        }
        return _objectSpread2(_objectSpread2({
          key: "__RC_SELECT_GRP__".concat(key === null ? index2 : key, "__"),
          label: key
        }, restProps), {}, {
          options: convertChildrenToData(children)
        });
      }).filter(function(data) {
        return data;
      });
    }
    function useOptions(options, children, fieldNames, optionFilterProp, optionLabelProp) {
      return reactExports.useMemo(function() {
        var mergedOptions = options;
        var childrenAsData = !options;
        if (childrenAsData) {
          mergedOptions = convertChildrenToData(children);
        }
        var valueOptions = /* @__PURE__ */ new Map();
        var labelOptions = /* @__PURE__ */ new Map();
        var setLabelOptions = function setLabelOptions2(labelOptionsMap, option, key) {
          if (key && typeof key === "string") {
            labelOptionsMap.set(option[key], option);
          }
        };
        function dig(optionList) {
          var isChildren = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          for (var i = 0; i < optionList.length; i += 1) {
            var option = optionList[i];
            if (!option[fieldNames.options] || isChildren) {
              valueOptions.set(option[fieldNames.value], option);
              setLabelOptions(labelOptions, option, fieldNames.label);
              setLabelOptions(labelOptions, option, optionFilterProp);
              setLabelOptions(labelOptions, option, optionLabelProp);
            } else {
              dig(option[fieldNames.options], true);
            }
          }
        }
        dig(mergedOptions);
        return {
          options: mergedOptions,
          valueOptions,
          labelOptions
        };
      }, [options, children, fieldNames, optionFilterProp, optionLabelProp]);
    }
    function useRefFunc(callback) {
      var funcRef = reactExports.useRef();
      funcRef.current = callback;
      var cacheFn = reactExports.useCallback(function() {
        return funcRef.current.apply(funcRef, arguments);
      }, []);
      return cacheFn;
    }
    var _excluded$r = ["id", "mode", "prefixCls", "backfill", "fieldNames", "inputValue", "searchValue", "onSearch", "autoClearSearchValue", "onSelect", "onDeselect", "dropdownMatchSelectWidth", "filterOption", "filterSort", "optionFilterProp", "optionLabelProp", "options", "optionRender", "children", "defaultActiveFirstOption", "menuItemSelectedIcon", "virtual", "direction", "listHeight", "listItemHeight", "value", "defaultValue", "labelInValue", "onChange"];
    var OMIT_DOM_PROPS = ["inputValue"];
    function isRawValue(value) {
      return !value || _typeof(value) !== "object";
    }
    var Select$2 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var id2 = props.id, mode = props.mode, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-select" : _props$prefixCls, backfill = props.backfill, fieldNames = props.fieldNames, inputValue = props.inputValue, searchValue = props.searchValue, onSearch = props.onSearch, _props$autoClearSearc = props.autoClearSearchValue, autoClearSearchValue = _props$autoClearSearc === void 0 ? true : _props$autoClearSearc, onSelect = props.onSelect, onDeselect = props.onDeselect, _props$dropdownMatchS = props.dropdownMatchSelectWidth, dropdownMatchSelectWidth = _props$dropdownMatchS === void 0 ? true : _props$dropdownMatchS, filterOption = props.filterOption, filterSort = props.filterSort, optionFilterProp = props.optionFilterProp, optionLabelProp = props.optionLabelProp, options = props.options, optionRender = props.optionRender, children = props.children, defaultActiveFirstOption = props.defaultActiveFirstOption, menuItemSelectedIcon = props.menuItemSelectedIcon, virtual = props.virtual, direction = props.direction, _props$listHeight = props.listHeight, listHeight = _props$listHeight === void 0 ? 200 : _props$listHeight, _props$listItemHeight = props.listItemHeight, listItemHeight = _props$listItemHeight === void 0 ? 20 : _props$listItemHeight, value = props.value, defaultValue = props.defaultValue, labelInValue = props.labelInValue, onChange = props.onChange, restProps = _objectWithoutProperties(props, _excluded$r);
      var mergedId = useId$1(id2);
      var multiple = isMultiple(mode);
      var childrenAsData = !!(!options && children);
      var mergedFilterOption = reactExports.useMemo(function() {
        if (filterOption === void 0 && mode === "combobox") {
          return false;
        }
        return filterOption;
      }, [filterOption, mode]);
      var mergedFieldNames = reactExports.useMemo(
        function() {
          return fillFieldNames$1(fieldNames, childrenAsData);
        },
        /* eslint-disable react-hooks/exhaustive-deps */
        [
          // We stringify fieldNames to avoid unnecessary re-renders.
          JSON.stringify(fieldNames),
          childrenAsData
        ]
        /* eslint-enable react-hooks/exhaustive-deps */
      );
      var _useMergedState = useMergedState("", {
        value: searchValue !== void 0 ? searchValue : inputValue,
        postState: function postState(search) {
          return search || "";
        }
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedSearchValue = _useMergedState2[0], setSearchValue = _useMergedState2[1];
      var parsedOptions = useOptions(options, children, mergedFieldNames, optionFilterProp, optionLabelProp);
      var valueOptions = parsedOptions.valueOptions, labelOptions = parsedOptions.labelOptions, mergedOptions = parsedOptions.options;
      var convert2LabelValues = reactExports.useCallback(function(draftValues) {
        var valueList = toArray$8(draftValues);
        return valueList.map(function(val) {
          var rawValue;
          var rawLabel;
          var rawKey;
          var rawDisabled;
          var rawTitle;
          if (isRawValue(val)) {
            rawValue = val;
          } else {
            var _val$value;
            rawKey = val.key;
            rawLabel = val.label;
            rawValue = (_val$value = val.value) !== null && _val$value !== void 0 ? _val$value : rawKey;
          }
          var option = valueOptions.get(rawValue);
          if (option) {
            var _option$key;
            if (rawLabel === void 0)
              rawLabel = option === null || option === void 0 ? void 0 : option[optionLabelProp || mergedFieldNames.label];
            if (rawKey === void 0)
              rawKey = (_option$key = option === null || option === void 0 ? void 0 : option.key) !== null && _option$key !== void 0 ? _option$key : rawValue;
            rawDisabled = option === null || option === void 0 ? void 0 : option.disabled;
            rawTitle = option === null || option === void 0 ? void 0 : option.title;
          }
          return {
            label: rawLabel,
            value: rawValue,
            key: rawKey,
            disabled: rawDisabled,
            title: rawTitle
          };
        });
      }, [mergedFieldNames, optionLabelProp, valueOptions]);
      var _useMergedState3 = useMergedState(defaultValue, {
        value
      }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), internalValue = _useMergedState4[0], setInternalValue = _useMergedState4[1];
      var rawLabeledValues = reactExports.useMemo(function() {
        var _values$;
        var values = convert2LabelValues(internalValue);
        if (mode === "combobox" && isComboNoValue((_values$ = values[0]) === null || _values$ === void 0 ? void 0 : _values$.value)) {
          return [];
        }
        return values;
      }, [internalValue, convert2LabelValues, mode]);
      var _useCache = useCache(rawLabeledValues, valueOptions), _useCache2 = _slicedToArray(_useCache, 2), mergedValues = _useCache2[0], getMixedOption = _useCache2[1];
      var displayValues = reactExports.useMemo(function() {
        if (!mode && mergedValues.length === 1) {
          var firstValue = mergedValues[0];
          if (firstValue.value === null && (firstValue.label === null || firstValue.label === void 0)) {
            return [];
          }
        }
        return mergedValues.map(function(item) {
          var _item$label;
          return _objectSpread2(_objectSpread2({}, item), {}, {
            label: (_item$label = item.label) !== null && _item$label !== void 0 ? _item$label : item.value
          });
        });
      }, [mode, mergedValues]);
      var rawValues = reactExports.useMemo(function() {
        return new Set(mergedValues.map(function(val) {
          return val.value;
        }));
      }, [mergedValues]);
      reactExports.useEffect(function() {
        if (mode === "combobox") {
          var _mergedValues$;
          var strValue = (_mergedValues$ = mergedValues[0]) === null || _mergedValues$ === void 0 ? void 0 : _mergedValues$.value;
          setSearchValue(hasValue(strValue) ? String(strValue) : "");
        }
      }, [mergedValues]);
      var createTagOption = useRefFunc(function(val, label) {
        var _ref;
        var mergedLabel = label !== null && label !== void 0 ? label : val;
        return _ref = {}, _defineProperty(_ref, mergedFieldNames.value, val), _defineProperty(_ref, mergedFieldNames.label, mergedLabel), _ref;
      });
      var filledTagOptions = reactExports.useMemo(function() {
        if (mode !== "tags") {
          return mergedOptions;
        }
        var cloneOptions = _toConsumableArray(mergedOptions);
        var existOptions = function existOptions2(val) {
          return valueOptions.has(val);
        };
        _toConsumableArray(mergedValues).sort(function(a, b2) {
          return a.value < b2.value ? -1 : 1;
        }).forEach(function(item) {
          var val = item.value;
          if (!existOptions(val)) {
            cloneOptions.push(createTagOption(val, item.label));
          }
        });
        return cloneOptions;
      }, [createTagOption, mergedOptions, valueOptions, mergedValues, mode]);
      var filteredOptions = useFilterOptions(filledTagOptions, mergedFieldNames, mergedSearchValue, mergedFilterOption, optionFilterProp);
      var filledSearchOptions = reactExports.useMemo(function() {
        if (mode !== "tags" || !mergedSearchValue || filteredOptions.some(function(item) {
          return item[optionFilterProp || "value"] === mergedSearchValue;
        })) {
          return filteredOptions;
        }
        if (filteredOptions.some(function(item) {
          return item[mergedFieldNames.value] === mergedSearchValue;
        })) {
          return filteredOptions;
        }
        return [createTagOption(mergedSearchValue)].concat(_toConsumableArray(filteredOptions));
      }, [createTagOption, optionFilterProp, mode, filteredOptions, mergedSearchValue, mergedFieldNames]);
      var orderedFilteredOptions = reactExports.useMemo(function() {
        if (!filterSort) {
          return filledSearchOptions;
        }
        return _toConsumableArray(filledSearchOptions).sort(function(a, b2) {
          return filterSort(a, b2);
        });
      }, [filledSearchOptions, filterSort]);
      var displayOptions = reactExports.useMemo(function() {
        return flattenOptions(orderedFilteredOptions, {
          fieldNames: mergedFieldNames,
          childrenAsData
        });
      }, [orderedFilteredOptions, mergedFieldNames, childrenAsData]);
      var triggerChange = function triggerChange2(values) {
        var labeledValues = convert2LabelValues(values);
        setInternalValue(labeledValues);
        if (onChange && // Trigger event only when value changed
        (labeledValues.length !== mergedValues.length || labeledValues.some(function(newVal, index2) {
          var _mergedValues$index;
          return ((_mergedValues$index = mergedValues[index2]) === null || _mergedValues$index === void 0 ? void 0 : _mergedValues$index.value) !== (newVal === null || newVal === void 0 ? void 0 : newVal.value);
        }))) {
          var returnValues = labelInValue ? labeledValues : labeledValues.map(function(v2) {
            return v2.value;
          });
          var returnOptions = labeledValues.map(function(v2) {
            return injectPropsWithOption(getMixedOption(v2.value));
          });
          onChange(
            // Value
            multiple ? returnValues : returnValues[0],
            // Option
            multiple ? returnOptions : returnOptions[0]
          );
        }
      };
      var _React$useState = reactExports.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), activeValue = _React$useState2[0], setActiveValue = _React$useState2[1];
      var _React$useState3 = reactExports.useState(0), _React$useState4 = _slicedToArray(_React$useState3, 2), accessibilityIndex = _React$useState4[0], setAccessibilityIndex = _React$useState4[1];
      var mergedDefaultActiveFirstOption = defaultActiveFirstOption !== void 0 ? defaultActiveFirstOption : mode !== "combobox";
      var onActiveValue = reactExports.useCallback(function(active, index2) {
        var _ref2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref2$source = _ref2.source, source = _ref2$source === void 0 ? "keyboard" : _ref2$source;
        setAccessibilityIndex(index2);
        if (backfill && mode === "combobox" && active !== null && source === "keyboard") {
          setActiveValue(String(active));
        }
      }, [backfill, mode]);
      var triggerSelect = function triggerSelect2(val, selected, type) {
        var getSelectEnt = function getSelectEnt2() {
          var _option$key2;
          var option = getMixedOption(val);
          return [labelInValue ? {
            label: option === null || option === void 0 ? void 0 : option[mergedFieldNames.label],
            value: val,
            key: (_option$key2 = option === null || option === void 0 ? void 0 : option.key) !== null && _option$key2 !== void 0 ? _option$key2 : val
          } : val, injectPropsWithOption(option)];
        };
        if (selected && onSelect) {
          var _getSelectEnt = getSelectEnt(), _getSelectEnt2 = _slicedToArray(_getSelectEnt, 2), wrappedValue = _getSelectEnt2[0], _option = _getSelectEnt2[1];
          onSelect(wrappedValue, _option);
        } else if (!selected && onDeselect && type !== "clear") {
          var _getSelectEnt3 = getSelectEnt(), _getSelectEnt4 = _slicedToArray(_getSelectEnt3, 2), _wrappedValue = _getSelectEnt4[0], _option2 = _getSelectEnt4[1];
          onDeselect(_wrappedValue, _option2);
        }
      };
      var onInternalSelect = useRefFunc(function(val, info) {
        var cloneValues;
        var mergedSelect = multiple ? info.selected : true;
        if (mergedSelect) {
          cloneValues = multiple ? [].concat(_toConsumableArray(mergedValues), [val]) : [val];
        } else {
          cloneValues = mergedValues.filter(function(v2) {
            return v2.value !== val;
          });
        }
        triggerChange(cloneValues);
        triggerSelect(val, mergedSelect);
        if (mode === "combobox") {
          setActiveValue("");
        } else if (!isMultiple || autoClearSearchValue) {
          setSearchValue("");
          setActiveValue("");
        }
      });
      var onDisplayValuesChange = function onDisplayValuesChange2(nextValues, info) {
        triggerChange(nextValues);
        var type = info.type, values = info.values;
        if (type === "remove" || type === "clear") {
          values.forEach(function(item) {
            triggerSelect(item.value, false, type);
          });
        }
      };
      var onInternalSearch = function onInternalSearch2(searchText, info) {
        setSearchValue(searchText);
        setActiveValue(null);
        if (info.source === "submit") {
          var formatted = (searchText || "").trim();
          if (formatted) {
            var newRawValues = Array.from(new Set([].concat(_toConsumableArray(rawValues), [formatted])));
            triggerChange(newRawValues);
            triggerSelect(formatted, true);
            setSearchValue("");
          }
          return;
        }
        if (info.source !== "blur") {
          if (mode === "combobox") {
            triggerChange(searchText);
          }
          onSearch === null || onSearch === void 0 || onSearch(searchText);
        }
      };
      var onInternalSearchSplit = function onInternalSearchSplit2(words) {
        var patchValues = words;
        if (mode !== "tags") {
          patchValues = words.map(function(word) {
            var opt = labelOptions.get(word);
            return opt === null || opt === void 0 ? void 0 : opt.value;
          }).filter(function(val) {
            return val !== void 0;
          });
        }
        var newRawValues = Array.from(new Set([].concat(_toConsumableArray(rawValues), _toConsumableArray(patchValues))));
        triggerChange(newRawValues);
        newRawValues.forEach(function(newRawValue) {
          triggerSelect(newRawValue, true);
        });
      };
      var selectContext = reactExports.useMemo(function() {
        var realVirtual = virtual !== false && dropdownMatchSelectWidth !== false;
        return _objectSpread2(_objectSpread2({}, parsedOptions), {}, {
          flattenOptions: displayOptions,
          onActiveValue,
          defaultActiveFirstOption: mergedDefaultActiveFirstOption,
          onSelect: onInternalSelect,
          menuItemSelectedIcon,
          rawValues,
          fieldNames: mergedFieldNames,
          virtual: realVirtual,
          direction,
          listHeight,
          listItemHeight,
          childrenAsData,
          optionRender
        });
      }, [parsedOptions, displayOptions, onActiveValue, mergedDefaultActiveFirstOption, onInternalSelect, menuItemSelectedIcon, rawValues, mergedFieldNames, virtual, dropdownMatchSelectWidth, listHeight, listItemHeight, childrenAsData, optionRender]);
      return /* @__PURE__ */ reactExports.createElement(SelectContext.Provider, {
        value: selectContext
      }, /* @__PURE__ */ reactExports.createElement(BaseSelect, _extends$1({}, restProps, {
        // >>> MISC
        id: mergedId,
        prefixCls,
        ref,
        omitDomProps: OMIT_DOM_PROPS,
        mode,
        displayValues,
        onDisplayValuesChange,
        direction,
        searchValue: mergedSearchValue,
        onSearch: onInternalSearch,
        autoClearSearchValue,
        onSearchSplit: onInternalSearchSplit,
        dropdownMatchSelectWidth,
        OptionList: RefOptionList,
        emptyOptions: !displayOptions.length,
        activeValue,
        activeDescendantId: "".concat(mergedId, "_list_").concat(accessibilityIndex)
      })));
    });
    var TypedSelect = Select$2;
    TypedSelect.Option = Option;
    TypedSelect.OptGroup = OptGroup;
    function getStatusClassNames(prefixCls, status, hasFeedback) {
      return classNames({
        [`${prefixCls}-status-success`]: status === "success",
        [`${prefixCls}-status-warning`]: status === "warning",
        [`${prefixCls}-status-error`]: status === "error",
        [`${prefixCls}-status-validating`]: status === "validating",
        [`${prefixCls}-has-feedback`]: hasFeedback
      });
    }
    const getMergedStatus = (contextStatus, customStatus) => customStatus || contextStatus;
    const Empty$2 = () => {
      const [, token2] = useToken$1();
      const bgColor = new TinyColor(token2.colorBgBase);
      const themeStyle = bgColor.toHsl().l < 0.5 ? {
        opacity: 0.65
      } : {};
      return /* @__PURE__ */ reactExports.createElement("svg", {
        style: themeStyle,
        width: "184",
        height: "152",
        viewBox: "0 0 184 152",
        xmlns: "http://www.w3.org/2000/svg"
      }, /* @__PURE__ */ reactExports.createElement("g", {
        fill: "none",
        fillRule: "evenodd"
      }, /* @__PURE__ */ reactExports.createElement("g", {
        transform: "translate(24 31.67)"
      }, /* @__PURE__ */ reactExports.createElement("ellipse", {
        fillOpacity: ".8",
        fill: "#F5F5F7",
        cx: "67.797",
        cy: "106.89",
        rx: "67.797",
        ry: "12.668"
      }), /* @__PURE__ */ reactExports.createElement("path", {
        d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z",
        fill: "#AEB8C2"
      }), /* @__PURE__ */ reactExports.createElement("path", {
        d: "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
        fill: "url(#linearGradient-1)",
        transform: "translate(13.56)"
      }), /* @__PURE__ */ reactExports.createElement("path", {
        d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z",
        fill: "#F5F5F7"
      }), /* @__PURE__ */ reactExports.createElement("path", {
        d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z",
        fill: "#DCE0E6"
      })), /* @__PURE__ */ reactExports.createElement("path", {
        d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z",
        fill: "#DCE0E6"
      }), /* @__PURE__ */ reactExports.createElement("g", {
        transform: "translate(149.65 15.383)",
        fill: "#FFF"
      }, /* @__PURE__ */ reactExports.createElement("ellipse", {
        cx: "20.654",
        cy: "3.167",
        rx: "2.849",
        ry: "2.815"
      }), /* @__PURE__ */ reactExports.createElement("path", {
        d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
      }))));
    };
    const DefaultEmptyImg = Empty$2;
    const Simple = () => {
      const [, token2] = useToken$1();
      const {
        colorFill,
        colorFillTertiary,
        colorFillQuaternary,
        colorBgContainer
      } = token2;
      const {
        borderColor,
        shadowColor,
        contentColor
      } = reactExports.useMemo(() => ({
        borderColor: new TinyColor(colorFill).onBackground(colorBgContainer).toHexShortString(),
        shadowColor: new TinyColor(colorFillTertiary).onBackground(colorBgContainer).toHexShortString(),
        contentColor: new TinyColor(colorFillQuaternary).onBackground(colorBgContainer).toHexShortString()
      }), [colorFill, colorFillTertiary, colorFillQuaternary, colorBgContainer]);
      return /* @__PURE__ */ reactExports.createElement("svg", {
        width: "64",
        height: "41",
        viewBox: "0 0 64 41",
        xmlns: "http://www.w3.org/2000/svg"
      }, /* @__PURE__ */ reactExports.createElement("g", {
        transform: "translate(0 1)",
        fill: "none",
        fillRule: "evenodd"
      }, /* @__PURE__ */ reactExports.createElement("ellipse", {
        fill: shadowColor,
        cx: "32",
        cy: "33",
        rx: "32",
        ry: "7"
      }), /* @__PURE__ */ reactExports.createElement("g", {
        fillRule: "nonzero",
        stroke: borderColor
      }, /* @__PURE__ */ reactExports.createElement("path", {
        d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
      }), /* @__PURE__ */ reactExports.createElement("path", {
        d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
        fill: contentColor
      }))));
    };
    const SimpleEmptyImg = Simple;
    const genSharedEmptyStyle = (token2) => {
      const {
        componentCls,
        margin,
        marginXS,
        marginXL,
        fontSize,
        lineHeight
      } = token2;
      return {
        [componentCls]: {
          marginInline: marginXS,
          fontSize,
          lineHeight,
          textAlign: "center",
          // 原来 &-image 没有父子结构，现在为了外层承担我们的hashId，改成父子结果
          [`${componentCls}-image`]: {
            height: token2.emptyImgHeight,
            marginBottom: marginXS,
            opacity: token2.opacityImage,
            img: {
              height: "100%"
            },
            svg: {
              maxWidth: "100%",
              height: "100%",
              margin: "auto"
            }
          },
          [`${componentCls}-description`]: {
            color: token2.colorText
          },
          // 原来 &-footer 没有父子结构，现在为了外层承担我们的hashId，改成父子结果
          [`${componentCls}-footer`]: {
            marginTop: margin
          },
          "&-normal": {
            marginBlock: marginXL,
            color: token2.colorTextDisabled,
            [`${componentCls}-description`]: {
              color: token2.colorTextDisabled
            },
            [`${componentCls}-image`]: {
              height: token2.emptyImgHeightMD
            }
          },
          "&-small": {
            marginBlock: marginXS,
            color: token2.colorTextDisabled,
            [`${componentCls}-image`]: {
              height: token2.emptyImgHeightSM
            }
          }
        }
      };
    };
    const useStyle$i = genStyleHooks("Empty", (token2) => {
      const {
        componentCls,
        controlHeightLG,
        calc
      } = token2;
      const emptyToken = merge$1(token2, {
        emptyImgCls: `${componentCls}-img`,
        emptyImgHeight: calc(controlHeightLG).mul(2.5).equal(),
        emptyImgHeightMD: controlHeightLG,
        emptyImgHeightSM: calc(controlHeightLG).mul(0.875).equal()
      });
      return [genSharedEmptyStyle(emptyToken)];
    });
    var __rest$B = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const defaultEmptyImg = /* @__PURE__ */ reactExports.createElement(DefaultEmptyImg, null);
    const simpleEmptyImg = /* @__PURE__ */ reactExports.createElement(SimpleEmptyImg, null);
    const Empty = (_a) => {
      var {
        className,
        rootClassName,
        prefixCls: customizePrefixCls,
        image = defaultEmptyImg,
        description,
        children,
        imageStyle,
        style: style2
      } = _a, restProps = __rest$B(_a, ["className", "rootClassName", "prefixCls", "image", "description", "children", "imageStyle", "style"]);
      const {
        getPrefixCls,
        direction,
        empty: empty2
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("empty", customizePrefixCls);
      const [wrapCSSVar, hashId] = useStyle$i(prefixCls);
      const [locale2] = useLocale$1("Empty");
      const des = typeof description !== "undefined" ? description : locale2 === null || locale2 === void 0 ? void 0 : locale2.description;
      const alt = typeof des === "string" ? des : "empty";
      let imageNode = null;
      if (typeof image === "string") {
        imageNode = /* @__PURE__ */ reactExports.createElement("img", {
          alt,
          src: image
        });
      } else {
        imageNode = image;
      }
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("div", Object.assign({
        className: classNames(hashId, prefixCls, empty2 === null || empty2 === void 0 ? void 0 : empty2.className, {
          [`${prefixCls}-normal`]: image === simpleEmptyImg,
          [`${prefixCls}-rtl`]: direction === "rtl"
        }, className, rootClassName),
        style: Object.assign(Object.assign({}, empty2 === null || empty2 === void 0 ? void 0 : empty2.style), style2)
      }, restProps), /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-image`,
        style: imageStyle
      }, imageNode), des && /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-description`
      }, des), children && /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-footer`
      }, children)));
    };
    Empty.PRESENTED_IMAGE_DEFAULT = defaultEmptyImg;
    Empty.PRESENTED_IMAGE_SIMPLE = simpleEmptyImg;
    const Empty$1 = Empty;
    const DefaultRenderEmpty = (props) => {
      const {
        componentName
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefix = getPrefixCls("empty");
      switch (componentName) {
        case "Table":
        case "List":
          return /* @__PURE__ */ React.createElement(Empty$1, {
            image: Empty$1.PRESENTED_IMAGE_SIMPLE
          });
        case "Select":
        case "TreeSelect":
        case "Cascader":
        case "Transfer":
        case "Mentions":
          return /* @__PURE__ */ React.createElement(Empty$1, {
            image: Empty$1.PRESENTED_IMAGE_SIMPLE,
            className: `${prefix}-small`
          });
        default:
          return /* @__PURE__ */ React.createElement(Empty$1, null);
      }
    };
    const DefaultRenderEmpty$1 = DefaultRenderEmpty;
    const genItemStyle = (token2) => {
      const {
        optionHeight,
        optionFontSize,
        optionLineHeight,
        optionPadding
      } = token2;
      return {
        position: "relative",
        display: "block",
        minHeight: optionHeight,
        padding: optionPadding,
        color: token2.colorText,
        fontWeight: "normal",
        fontSize: optionFontSize,
        lineHeight: optionLineHeight,
        boxSizing: "border-box"
      };
    };
    const genSingleStyle$1 = (token2) => {
      const {
        antCls,
        componentCls
      } = token2;
      const selectItemCls = `${componentCls}-item`;
      const slideUpEnterActive = `&${antCls}-slide-up-enter${antCls}-slide-up-enter-active`;
      const slideUpAppearActive = `&${antCls}-slide-up-appear${antCls}-slide-up-appear-active`;
      const slideUpLeaveActive = `&${antCls}-slide-up-leave${antCls}-slide-up-leave-active`;
      const dropdownPlacementCls = `${componentCls}-dropdown-placement-`;
      return [
        {
          [`${componentCls}-dropdown`]: Object.assign(Object.assign({}, resetComponent(token2)), {
            position: "absolute",
            top: -9999,
            zIndex: token2.zIndexPopup,
            boxSizing: "border-box",
            padding: token2.paddingXXS,
            overflow: "hidden",
            fontSize: token2.fontSize,
            // Fix select render lag of long text in chrome
            // https://github.com/ant-design/ant-design/issues/11456
            // https://github.com/ant-design/ant-design/issues/11843
            fontVariant: "initial",
            backgroundColor: token2.colorBgElevated,
            borderRadius: token2.borderRadiusLG,
            outline: "none",
            boxShadow: token2.boxShadowSecondary,
            [`
          ${slideUpEnterActive}${dropdownPlacementCls}bottomLeft,
          ${slideUpAppearActive}${dropdownPlacementCls}bottomLeft
        `]: {
              animationName: slideUpIn
            },
            [`
          ${slideUpEnterActive}${dropdownPlacementCls}topLeft,
          ${slideUpAppearActive}${dropdownPlacementCls}topLeft,
          ${slideUpEnterActive}${dropdownPlacementCls}topRight,
          ${slideUpAppearActive}${dropdownPlacementCls}topRight
        `]: {
              animationName: slideDownIn
            },
            [`${slideUpLeaveActive}${dropdownPlacementCls}bottomLeft`]: {
              animationName: slideUpOut
            },
            [`
          ${slideUpLeaveActive}${dropdownPlacementCls}topLeft,
          ${slideUpLeaveActive}${dropdownPlacementCls}topRight
        `]: {
              animationName: slideDownOut
            },
            "&-hidden": {
              display: "none"
            },
            [`${selectItemCls}`]: Object.assign(Object.assign({}, genItemStyle(token2)), {
              cursor: "pointer",
              transition: `background ${token2.motionDurationSlow} ease`,
              borderRadius: token2.borderRadiusSM,
              // =========== Group ============
              "&-group": {
                color: token2.colorTextDescription,
                fontSize: token2.fontSizeSM,
                cursor: "default"
              },
              // =========== Option ===========
              "&-option": {
                display: "flex",
                "&-content": Object.assign({
                  flex: "auto"
                }, textEllipsis),
                "&-state": {
                  flex: "none",
                  display: "flex",
                  alignItems: "center"
                },
                [`&-active:not(${selectItemCls}-option-disabled)`]: {
                  backgroundColor: token2.optionActiveBg
                },
                [`&-selected:not(${selectItemCls}-option-disabled)`]: {
                  color: token2.optionSelectedColor,
                  fontWeight: token2.optionSelectedFontWeight,
                  backgroundColor: token2.optionSelectedBg,
                  [`${selectItemCls}-option-state`]: {
                    color: token2.colorPrimary
                  }
                },
                "&-disabled": {
                  [`&${selectItemCls}-option-selected`]: {
                    backgroundColor: token2.colorBgContainerDisabled
                  },
                  color: token2.colorTextDisabled,
                  cursor: "not-allowed"
                },
                "&-grouped": {
                  paddingInlineStart: token2.calc(token2.controlPaddingHorizontal).mul(2).equal()
                }
              }
            }),
            // =========================== RTL ===========================
            "&-rtl": {
              direction: "rtl"
            }
          })
        },
        // Follow code may reuse in other components
        initSlideMotion(token2, "slide-up"),
        initSlideMotion(token2, "slide-down"),
        initMoveMotion(token2, "move-up"),
        initMoveMotion(token2, "move-down")
      ];
    };
    const genDropdownStyle = genSingleStyle$1;
    const FIXED_ITEM_MARGIN = 2;
    const getSelectItemStyle = (token2) => {
      const {
        multipleSelectItemHeight,
        selectHeight,
        lineWidth
      } = token2;
      const selectItemDist = token2.calc(selectHeight).sub(multipleSelectItemHeight).div(2).sub(lineWidth).equal();
      return selectItemDist;
    };
    function genSizeStyle$3(token2, suffix) {
      const {
        componentCls,
        iconCls
      } = token2;
      const selectOverflowPrefixCls = `${componentCls}-selection-overflow`;
      const selectItemHeight = token2.multipleSelectItemHeight;
      const selectItemDist = getSelectItemStyle(token2);
      const suffixCls = suffix ? `${componentCls}-${suffix}` : "";
      return {
        [`${componentCls}-multiple${suffixCls}`]: {
          fontSize: token2.fontSize,
          /**
           * Do not merge `height` & `line-height` under style with `selection` & `search`, since chrome
           * may update to redesign with its align logic.
           */
          // =========================== Overflow ===========================
          [selectOverflowPrefixCls]: {
            position: "relative",
            display: "flex",
            flex: "auto",
            flexWrap: "wrap",
            maxWidth: "100%",
            "&-item": {
              flex: "none",
              alignSelf: "center",
              maxWidth: "100%",
              display: "inline-flex"
            }
          },
          // ========================= Selector =========================
          [`${componentCls}-selector`]: {
            display: "flex",
            flexWrap: "wrap",
            alignItems: "center",
            height: "100%",
            // Multiple is little different that horizontal is follow the vertical
            padding: `${unit$1(token2.calc(selectItemDist).sub(FIXED_ITEM_MARGIN).equal())} ${unit$1(token2.calc(FIXED_ITEM_MARGIN).mul(2).equal())}`,
            borderRadius: token2.borderRadius,
            [`${componentCls}-show-search&`]: {
              cursor: "text"
            },
            [`${componentCls}-disabled&`]: {
              background: token2.multipleSelectorBgDisabled,
              cursor: "not-allowed"
            },
            "&:after": {
              display: "inline-block",
              width: 0,
              margin: `${unit$1(FIXED_ITEM_MARGIN)} 0`,
              lineHeight: unit$1(selectItemHeight),
              visibility: "hidden",
              content: '"\\a0"'
            }
          },
          [`
        &${componentCls}-show-arrow ${componentCls}-selector,
        &${componentCls}-allow-clear ${componentCls}-selector
      `]: {
            paddingInlineEnd: token2.calc(token2.fontSizeIcon).add(token2.controlPaddingHorizontal).equal()
          },
          // ======================== Selections ========================
          [`${componentCls}-selection-item`]: {
            display: "flex",
            alignSelf: "center",
            flex: "none",
            boxSizing: "border-box",
            maxWidth: "100%",
            height: selectItemHeight,
            marginTop: FIXED_ITEM_MARGIN,
            marginBottom: FIXED_ITEM_MARGIN,
            lineHeight: unit$1(token2.calc(selectItemHeight).sub(token2.calc(token2.lineWidth).mul(2)).equal()),
            background: token2.multipleItemBg,
            border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.multipleItemBorderColor}`,
            borderRadius: token2.borderRadiusSM,
            cursor: "default",
            transition: `font-size ${token2.motionDurationSlow}, line-height ${token2.motionDurationSlow}, height ${token2.motionDurationSlow}`,
            marginInlineEnd: token2.calc(FIXED_ITEM_MARGIN).mul(2).equal(),
            paddingInlineStart: token2.paddingXS,
            paddingInlineEnd: token2.calc(token2.paddingXS).div(2).equal(),
            [`${componentCls}-disabled&`]: {
              color: token2.multipleItemColorDisabled,
              borderColor: token2.multipleItemBorderColorDisabled,
              cursor: "not-allowed"
            },
            // It's ok not to do this, but 24px makes bottom narrow in view should adjust
            "&-content": {
              display: "inline-block",
              marginInlineEnd: token2.calc(token2.paddingXS).div(2).equal(),
              overflow: "hidden",
              whiteSpace: "pre",
              // fix whitespace wrapping. custom tags display all whitespace within.
              textOverflow: "ellipsis"
            },
            "&-remove": Object.assign(Object.assign({}, resetIcon()), {
              display: "inline-flex",
              alignItems: "center",
              color: token2.colorIcon,
              fontWeight: "bold",
              fontSize: 10,
              lineHeight: "inherit",
              cursor: "pointer",
              [`> ${iconCls}`]: {
                verticalAlign: "-0.2em"
              },
              "&:hover": {
                color: token2.colorIconHover
              }
            })
          },
          // ========================== Input ==========================
          [`${selectOverflowPrefixCls}-item + ${selectOverflowPrefixCls}-item`]: {
            [`${componentCls}-selection-search`]: {
              marginInlineStart: 0
            }
          },
          // https://github.com/ant-design/ant-design/issues/44754
          [`${selectOverflowPrefixCls}-item-suffix`]: {
            height: "100%"
          },
          [`${componentCls}-selection-search`]: {
            display: "inline-flex",
            position: "relative",
            maxWidth: "100%",
            marginInlineStart: token2.calc(token2.inputPaddingHorizontalBase).sub(selectItemDist).equal(),
            [`
          &-input,
          &-mirror
        `]: {
              height: selectItemHeight,
              fontFamily: token2.fontFamily,
              lineHeight: unit$1(selectItemHeight),
              transition: `all ${token2.motionDurationSlow}`
            },
            "&-input": {
              width: "100%",
              minWidth: 4.1
              // fix search cursor missing
            },
            "&-mirror": {
              position: "absolute",
              top: 0,
              insetInlineStart: 0,
              insetInlineEnd: "auto",
              zIndex: 999,
              whiteSpace: "pre",
              // fix whitespace wrapping caused width calculation bug
              visibility: "hidden"
            }
          },
          // ======================= Placeholder =======================
          [`${componentCls}-selection-placeholder`]: {
            position: "absolute",
            top: "50%",
            insetInlineStart: token2.inputPaddingHorizontalBase,
            insetInlineEnd: token2.inputPaddingHorizontalBase,
            transform: "translateY(-50%)",
            transition: `all ${token2.motionDurationSlow}`
          }
        }
      };
    }
    const genMultipleStyle = (token2) => {
      const {
        componentCls
      } = token2;
      const smallToken = merge$1(token2, {
        selectHeight: token2.controlHeightSM,
        multipleSelectItemHeight: token2.controlHeightXS,
        borderRadius: token2.borderRadiusSM,
        borderRadiusSM: token2.borderRadiusXS
      });
      const largeToken = merge$1(token2, {
        fontSize: token2.fontSizeLG,
        selectHeight: token2.controlHeightLG,
        multipleSelectItemHeight: token2.multipleItemHeightLG,
        borderRadius: token2.borderRadiusLG,
        borderRadiusSM: token2.borderRadius
      });
      return [
        genSizeStyle$3(token2),
        // ======================== Small ========================
        genSizeStyle$3(smallToken, "sm"),
        // Padding
        {
          [`${componentCls}-multiple${componentCls}-sm`]: {
            [`${componentCls}-selection-placeholder`]: {
              insetInline: token2.calc(token2.controlPaddingHorizontalSM).sub(token2.lineWidth).equal()
            },
            // https://github.com/ant-design/ant-design/issues/29559
            [`${componentCls}-selection-search`]: {
              marginInlineStart: 2
              // Magic Number
            }
          }
        },
        // ======================== Large ========================
        genSizeStyle$3(largeToken, "lg")
      ];
    };
    const genMultipleStyle$1 = genMultipleStyle;
    function genSizeStyle$2(token2, suffix) {
      const {
        componentCls,
        inputPaddingHorizontalBase,
        borderRadius
      } = token2;
      const selectHeightWithoutBorder = token2.calc(token2.controlHeight).sub(token2.calc(token2.lineWidth).mul(2)).equal();
      const suffixCls = suffix ? `${componentCls}-${suffix}` : "";
      return {
        [`${componentCls}-single${suffixCls}`]: {
          fontSize: token2.fontSize,
          height: token2.controlHeight,
          // ========================= Selector =========================
          [`${componentCls}-selector`]: Object.assign(Object.assign({}, resetComponent(token2, true)), {
            display: "flex",
            borderRadius,
            [`${componentCls}-selection-search`]: {
              position: "absolute",
              top: 0,
              insetInlineStart: inputPaddingHorizontalBase,
              insetInlineEnd: inputPaddingHorizontalBase,
              bottom: 0,
              "&-input": {
                width: "100%",
                WebkitAppearance: "textfield"
              }
            },
            [`
          ${componentCls}-selection-item,
          ${componentCls}-selection-placeholder
        `]: {
              padding: 0,
              lineHeight: unit$1(selectHeightWithoutBorder),
              transition: `all ${token2.motionDurationSlow}, visibility 0s`,
              alignSelf: "center"
            },
            [`${componentCls}-selection-placeholder`]: {
              transition: "none",
              pointerEvents: "none"
            },
            // For common baseline align
            [[
              "&:after",
              /* For '' value baseline align */
              `${componentCls}-selection-item:empty:after`,
              /* For undefined value baseline align */
              `${componentCls}-selection-placeholder:empty:after`
            ].join(",")]: {
              display: "inline-block",
              width: 0,
              visibility: "hidden",
              content: '"\\a0"'
            }
          }),
          [`
        &${componentCls}-show-arrow ${componentCls}-selection-item,
        &${componentCls}-show-arrow ${componentCls}-selection-placeholder
      `]: {
            paddingInlineEnd: token2.showArrowPaddingInlineEnd
          },
          // Opacity selection if open
          [`&${componentCls}-open ${componentCls}-selection-item`]: {
            color: token2.colorTextPlaceholder
          },
          // ========================== Input ==========================
          // We only change the style of non-customize input which is only support by `combobox` mode.
          // Not customize
          [`&:not(${componentCls}-customize-input)`]: {
            [`${componentCls}-selector`]: {
              width: "100%",
              height: "100%",
              padding: `0 ${unit$1(inputPaddingHorizontalBase)}`,
              [`${componentCls}-selection-search-input`]: {
                height: selectHeightWithoutBorder
              },
              "&:after": {
                lineHeight: unit$1(selectHeightWithoutBorder)
              }
            }
          },
          [`&${componentCls}-customize-input`]: {
            [`${componentCls}-selector`]: {
              "&:after": {
                display: "none"
              },
              [`${componentCls}-selection-search`]: {
                position: "static",
                width: "100%"
              },
              [`${componentCls}-selection-placeholder`]: {
                position: "absolute",
                insetInlineStart: 0,
                insetInlineEnd: 0,
                padding: `0 ${unit$1(inputPaddingHorizontalBase)}`,
                "&:after": {
                  display: "none"
                }
              }
            }
          }
        }
      };
    }
    function genSingleStyle(token2) {
      const {
        componentCls
      } = token2;
      const inputPaddingHorizontalSM = token2.calc(token2.controlPaddingHorizontalSM).sub(token2.lineWidth).equal();
      return [
        genSizeStyle$2(token2),
        // ======================== Small ========================
        // Shared
        genSizeStyle$2(merge$1(token2, {
          controlHeight: token2.controlHeightSM,
          borderRadius: token2.borderRadiusSM
        }), "sm"),
        // padding
        {
          [`${componentCls}-single${componentCls}-sm`]: {
            [`&:not(${componentCls}-customize-input)`]: {
              [`${componentCls}-selection-search`]: {
                insetInlineStart: inputPaddingHorizontalSM,
                insetInlineEnd: inputPaddingHorizontalSM
              },
              [`${componentCls}-selector`]: {
                padding: `0 ${unit$1(inputPaddingHorizontalSM)}`
              },
              // With arrow should provides `padding-right` to show the arrow
              [`&${componentCls}-show-arrow ${componentCls}-selection-search`]: {
                insetInlineEnd: token2.calc(inputPaddingHorizontalSM).add(token2.calc(token2.fontSize).mul(1.5)).equal()
              },
              [`
            &${componentCls}-show-arrow ${componentCls}-selection-item,
            &${componentCls}-show-arrow ${componentCls}-selection-placeholder
          `]: {
                paddingInlineEnd: token2.calc(token2.fontSize).mul(1.5).equal()
              }
            }
          }
        },
        // ======================== Large ========================
        // Shared
        genSizeStyle$2(merge$1(token2, {
          controlHeight: token2.singleItemHeightLG,
          fontSize: token2.fontSizeLG,
          borderRadius: token2.borderRadiusLG
        }), "lg")
      ];
    }
    const genSelectorStyle = (token2) => {
      const {
        componentCls,
        selectorBg
      } = token2;
      return {
        position: "relative",
        backgroundColor: selectorBg,
        border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
        transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
        input: {
          cursor: "pointer"
        },
        [`${componentCls}-show-search&`]: {
          cursor: "text",
          input: {
            cursor: "auto",
            color: "inherit",
            height: "100%"
          }
        },
        [`${componentCls}-disabled&`]: {
          color: token2.colorTextDisabled,
          background: token2.colorBgContainerDisabled,
          cursor: "not-allowed",
          [`${componentCls}-multiple&`]: {
            background: token2.multipleSelectorBgDisabled
          },
          input: {
            cursor: "not-allowed"
          }
        }
      };
    };
    const genStatusStyle$3 = function(rootSelectCls, token2) {
      let overwriteDefaultBorder = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      const {
        componentCls,
        borderHoverColor,
        antCls,
        borderActiveColor,
        outlineColor,
        controlOutlineWidth
      } = token2;
      const overwriteStyle = overwriteDefaultBorder ? {
        [`${componentCls}-selector`]: {
          borderColor: borderActiveColor
        }
      } : {};
      return {
        [rootSelectCls]: {
          [`&:not(${componentCls}-disabled):not(${componentCls}-customize-input):not(${antCls}-pagination-size-changer)`]: Object.assign(Object.assign({}, overwriteStyle), {
            [`&:hover ${componentCls}-selector`]: {
              borderColor: borderHoverColor
            },
            [`${componentCls}-focused& ${componentCls}-selector`]: {
              borderColor: borderActiveColor,
              boxShadow: `0 0 0 ${unit$1(controlOutlineWidth)} ${outlineColor}`,
              outline: 0
            }
          })
        }
      };
    };
    const getSearchInputWithoutBorderStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}-selection-search-input`]: {
          margin: 0,
          padding: 0,
          background: "transparent",
          border: "none",
          outline: "none",
          appearance: "none",
          fontFamily: "inherit",
          "&::-webkit-search-cancel-button": {
            display: "none",
            "-webkit-appearance": "none"
          }
        }
      };
    };
    const genBaseStyle$4 = (token2) => {
      const {
        antCls,
        componentCls,
        inputPaddingHorizontalBase,
        iconCls
      } = token2;
      return {
        [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
          position: "relative",
          display: "inline-block",
          cursor: "pointer",
          [`&:not(${componentCls}-customize-input) ${componentCls}-selector`]: Object.assign(Object.assign({}, genSelectorStyle(token2)), getSearchInputWithoutBorderStyle(token2)),
          // [`&:not(&-disabled):hover ${selectCls}-selector`]: {
          //   ...genHoverStyle(token),
          // },
          // ======================== Selection ========================
          [`${componentCls}-selection-item`]: Object.assign(Object.assign({
            flex: 1,
            fontWeight: "normal",
            position: "relative",
            userSelect: "none"
          }, textEllipsis), {
            // https://github.com/ant-design/ant-design/issues/40421
            [`> ${antCls}-typography`]: {
              display: "inline"
            }
          }),
          // ======================= Placeholder =======================
          [`${componentCls}-selection-placeholder`]: Object.assign(Object.assign({}, textEllipsis), {
            flex: 1,
            color: token2.colorTextPlaceholder,
            pointerEvents: "none"
          }),
          // ========================== Arrow ==========================
          [`${componentCls}-arrow`]: Object.assign(Object.assign({}, resetIcon()), {
            position: "absolute",
            top: "50%",
            insetInlineStart: "auto",
            insetInlineEnd: inputPaddingHorizontalBase,
            height: token2.fontSizeIcon,
            marginTop: token2.calc(token2.fontSizeIcon).mul(-1).div(2).equal(),
            color: token2.colorTextQuaternary,
            fontSize: token2.fontSizeIcon,
            lineHeight: 1,
            textAlign: "center",
            pointerEvents: "none",
            display: "flex",
            alignItems: "center",
            [iconCls]: {
              verticalAlign: "top",
              transition: `transform ${token2.motionDurationSlow}`,
              "> svg": {
                verticalAlign: "top"
              },
              [`&:not(${componentCls}-suffix)`]: {
                pointerEvents: "auto"
              }
            },
            [`${componentCls}-disabled &`]: {
              cursor: "not-allowed"
            },
            "> *:not(:last-child)": {
              marginInlineEnd: 8
              // FIXME: magic
            }
          }),
          // ========================== Clear ==========================
          [`${componentCls}-clear`]: {
            position: "absolute",
            top: "50%",
            insetInlineStart: "auto",
            insetInlineEnd: inputPaddingHorizontalBase,
            zIndex: 1,
            display: "inline-block",
            width: token2.fontSizeIcon,
            height: token2.fontSizeIcon,
            marginTop: token2.calc(token2.fontSizeIcon).mul(-1).div(2).equal(),
            color: token2.colorTextQuaternary,
            fontSize: token2.fontSizeIcon,
            fontStyle: "normal",
            lineHeight: 1,
            textAlign: "center",
            textTransform: "none",
            background: token2.clearBg,
            cursor: "pointer",
            opacity: 0,
            transition: `color ${token2.motionDurationMid} ease, opacity ${token2.motionDurationSlow} ease`,
            textRendering: "auto",
            "&:before": {
              display: "block"
            },
            "&:hover": {
              color: token2.colorTextTertiary
            }
          },
          "&:hover": {
            [`${componentCls}-clear`]: {
              opacity: 1
            }
          }
        }),
        // ========================= Feedback ==========================
        [`${componentCls}-has-feedback`]: {
          [`${componentCls}-clear`]: {
            insetInlineEnd: token2.calc(inputPaddingHorizontalBase).add(token2.fontSize).add(token2.paddingXS).equal()
          }
        }
      };
    };
    const genSelectStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return [
        {
          [componentCls]: {
            // ==================== BorderLess ====================
            [`&-borderless ${componentCls}-selector`]: {
              backgroundColor: `transparent !important`,
              borderColor: `transparent !important`,
              boxShadow: `none !important`
            },
            // ==================== In Form ====================
            [`&${componentCls}-in-form-item`]: {
              width: "100%"
            }
          }
        },
        // =====================================================
        // ==                       LTR                       ==
        // =====================================================
        // Base
        genBaseStyle$4(token2),
        // Single
        genSingleStyle(token2),
        // Multiple
        genMultipleStyle$1(token2),
        // Dropdown
        genDropdownStyle(token2),
        // =====================================================
        // ==                       RTL                       ==
        // =====================================================
        {
          [`${componentCls}-rtl`]: {
            direction: "rtl"
          }
        },
        // =====================================================
        // ==                     Status                      ==
        // =====================================================
        genStatusStyle$3(componentCls, merge$1(token2, {
          borderHoverColor: token2.colorPrimaryHover,
          borderActiveColor: token2.colorPrimary,
          outlineColor: token2.controlOutline
        })),
        genStatusStyle$3(`${componentCls}-status-error`, merge$1(token2, {
          borderHoverColor: token2.colorErrorHover,
          borderActiveColor: token2.colorError,
          outlineColor: token2.colorErrorOutline
        }), true),
        genStatusStyle$3(`${componentCls}-status-warning`, merge$1(token2, {
          borderHoverColor: token2.colorWarningHover,
          borderActiveColor: token2.colorWarning,
          outlineColor: token2.colorWarningOutline
        }), true),
        // =====================================================
        // ==             Space Compact                       ==
        // =====================================================
        genCompactItemStyle(token2, {
          borderElCls: `${componentCls}-selector`,
          focusElCls: `${componentCls}-focused`
        })
      ];
    };
    const prepareComponentToken$f = (token2) => {
      const {
        fontSize,
        lineHeight,
        controlHeight,
        controlPaddingHorizontal,
        zIndexPopupBase,
        colorText,
        fontWeightStrong,
        controlItemBgActive,
        controlItemBgHover,
        colorBgContainer,
        colorFillSecondary,
        controlHeightLG,
        controlHeightSM,
        colorBgContainerDisabled,
        colorTextDisabled
      } = token2;
      return {
        zIndexPopup: zIndexPopupBase + 50,
        optionSelectedColor: colorText,
        optionSelectedFontWeight: fontWeightStrong,
        optionSelectedBg: controlItemBgActive,
        optionActiveBg: controlItemBgHover,
        optionPadding: `${(controlHeight - fontSize * lineHeight) / 2}px ${controlPaddingHorizontal}px`,
        optionFontSize: fontSize,
        optionLineHeight: lineHeight,
        optionHeight: controlHeight,
        selectorBg: colorBgContainer,
        clearBg: colorBgContainer,
        singleItemHeightLG: controlHeightLG,
        multipleItemBg: colorFillSecondary,
        multipleItemBorderColor: "transparent",
        multipleItemHeight: controlHeightSM,
        multipleItemHeightLG: controlHeight,
        multipleSelectorBgDisabled: colorBgContainerDisabled,
        multipleItemColorDisabled: colorTextDisabled,
        multipleItemBorderColorDisabled: "transparent",
        showArrowPaddingInlineEnd: Math.ceil(token2.fontSize * 1.25)
      };
    };
    const useSelectStyle = genStyleHooks("Select", (token2, _ref) => {
      let {
        rootPrefixCls
      } = _ref;
      const selectToken = merge$1(token2, {
        rootPrefixCls,
        inputPaddingHorizontalBase: token2.calc(token2.paddingSM).sub(1).equal(),
        multipleSelectItemHeight: token2.multipleItemHeight,
        selectHeight: token2.controlHeight
      });
      return [genSelectStyle(selectToken)];
    }, prepareComponentToken$f, {
      unitless: {
        optionLineHeight: true,
        optionSelectedFontWeight: true
      }
    });
    const getBuiltInPlacements = (popupOverflow) => {
      const htmlRegion = popupOverflow === "scroll" ? "scroll" : "visible";
      const sharedConfig = {
        overflow: {
          adjustX: true,
          adjustY: true,
          shiftY: true
        },
        htmlRegion,
        dynamicInset: true
      };
      return {
        bottomLeft: Object.assign(Object.assign({}, sharedConfig), {
          points: ["tl", "bl"],
          offset: [0, 4]
        }),
        bottomRight: Object.assign(Object.assign({}, sharedConfig), {
          points: ["tr", "br"],
          offset: [0, 4]
        }),
        topLeft: Object.assign(Object.assign({}, sharedConfig), {
          points: ["bl", "tl"],
          offset: [0, -4]
        }),
        topRight: Object.assign(Object.assign({}, sharedConfig), {
          points: ["br", "tr"],
          offset: [0, -4]
        })
      };
    };
    function useBuiltinPlacements(buildInPlacements, popupOverflow) {
      return buildInPlacements || getBuiltInPlacements(popupOverflow);
    }
    var CheckOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" } }] }, "name": "check", "theme": "outlined" };
    const CheckOutlinedSvg = CheckOutlined$2;
    var CheckOutlined = function CheckOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: CheckOutlinedSvg
      }));
    };
    const CheckOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(CheckOutlined);
    var DownOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z" } }] }, "name": "down", "theme": "outlined" };
    const DownOutlinedSvg = DownOutlined$2;
    var DownOutlined = function DownOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: DownOutlinedSvg
      }));
    };
    const DownOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(DownOutlined);
    var SearchOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, "name": "search", "theme": "outlined" };
    const SearchOutlinedSvg = SearchOutlined$2;
    var SearchOutlined = function SearchOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: SearchOutlinedSvg
      }));
    };
    const SearchOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(SearchOutlined);
    function useIcons(_ref) {
      let {
        suffixIcon,
        clearIcon,
        menuItemSelectedIcon,
        removeIcon,
        loading,
        multiple,
        hasFeedback,
        prefixCls,
        showSuffixIcon,
        feedbackIcon,
        showArrow,
        componentName
      } = _ref;
      const mergedClearIcon = clearIcon !== null && clearIcon !== void 0 ? clearIcon : /* @__PURE__ */ reactExports.createElement(CloseCircleFilled$1, null);
      const getSuffixIconNode = (arrowIcon) => {
        if (suffixIcon === null && !hasFeedback && !showArrow) {
          return null;
        }
        return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, showSuffixIcon !== false && arrowIcon, hasFeedback && feedbackIcon);
      };
      let mergedSuffixIcon = null;
      if (suffixIcon !== void 0) {
        mergedSuffixIcon = getSuffixIconNode(suffixIcon);
      } else if (loading) {
        mergedSuffixIcon = getSuffixIconNode(/* @__PURE__ */ reactExports.createElement(LoadingOutlined$1, {
          spin: true
        }));
      } else {
        const iconCls = `${prefixCls}-suffix`;
        mergedSuffixIcon = (_ref2) => {
          let {
            open,
            showSearch
          } = _ref2;
          if (open && showSearch) {
            return getSuffixIconNode(/* @__PURE__ */ reactExports.createElement(SearchOutlined$1, {
              className: iconCls
            }));
          }
          return getSuffixIconNode(/* @__PURE__ */ reactExports.createElement(DownOutlined$1, {
            className: iconCls
          }));
        };
      }
      let mergedItemIcon = null;
      if (menuItemSelectedIcon !== void 0) {
        mergedItemIcon = menuItemSelectedIcon;
      } else if (multiple) {
        mergedItemIcon = /* @__PURE__ */ reactExports.createElement(CheckOutlined$1, null);
      } else {
        mergedItemIcon = null;
      }
      let mergedRemoveIcon = null;
      if (removeIcon !== void 0) {
        mergedRemoveIcon = removeIcon;
      } else {
        mergedRemoveIcon = /* @__PURE__ */ reactExports.createElement(CloseOutlined$1, null);
      }
      return {
        clearIcon: mergedClearIcon,
        suffixIcon: mergedSuffixIcon,
        itemIcon: mergedItemIcon,
        removeIcon: mergedRemoveIcon
      };
    }
    function useShowArrow(suffixIcon, showArrow) {
      return showArrow !== void 0 ? showArrow : suffixIcon !== null;
    }
    var __rest$A = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const SECRET_COMBOBOX_MODE_DO_NOT_USE = "SECRET_COMBOBOX_MODE_DO_NOT_USE";
    const InternalSelect = (_a, ref) => {
      var _b, _c;
      var {
        prefixCls: customizePrefixCls,
        bordered = true,
        className,
        rootClassName,
        getPopupContainer,
        popupClassName,
        dropdownClassName,
        listHeight = 256,
        placement,
        listItemHeight = 24,
        size: customizeSize,
        disabled: customDisabled,
        notFoundContent,
        status: customStatus,
        builtinPlacements,
        dropdownMatchSelectWidth,
        popupMatchSelectWidth,
        direction: propDirection,
        style: style2,
        allowClear
      } = _a, props = __rest$A(_a, ["prefixCls", "bordered", "className", "rootClassName", "getPopupContainer", "popupClassName", "dropdownClassName", "listHeight", "placement", "listItemHeight", "size", "disabled", "notFoundContent", "status", "builtinPlacements", "dropdownMatchSelectWidth", "popupMatchSelectWidth", "direction", "style", "allowClear"]);
      const {
        getPopupContainer: getContextPopupContainer,
        getPrefixCls,
        renderEmpty,
        direction: contextDirection,
        virtual,
        popupMatchSelectWidth: contextPopupMatchSelectWidth,
        popupOverflow,
        select
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("select", customizePrefixCls);
      const rootPrefixCls = getPrefixCls();
      const direction = propDirection !== null && propDirection !== void 0 ? propDirection : contextDirection;
      const {
        compactSize,
        compactItemClassnames
      } = useCompactItemContext(prefixCls, direction);
      const rootCls = useCSSVarCls$1(prefixCls);
      const [wrapCSSVar, hashId] = useSelectStyle(prefixCls, rootCls);
      const mode = reactExports.useMemo(() => {
        const {
          mode: m2
        } = props;
        if (m2 === "combobox") {
          return void 0;
        }
        if (m2 === SECRET_COMBOBOX_MODE_DO_NOT_USE) {
          return "combobox";
        }
        return m2;
      }, [props.mode]);
      const isMultiple2 = mode === "multiple" || mode === "tags";
      const showSuffixIcon = useShowArrow(props.suffixIcon, props.showArrow);
      const mergedPopupMatchSelectWidth = (_b = popupMatchSelectWidth !== null && popupMatchSelectWidth !== void 0 ? popupMatchSelectWidth : dropdownMatchSelectWidth) !== null && _b !== void 0 ? _b : contextPopupMatchSelectWidth;
      const {
        status: contextStatus,
        hasFeedback,
        isFormItemInput,
        feedbackIcon
      } = reactExports.useContext(FormItemInputContext);
      const mergedStatus = getMergedStatus(contextStatus, customStatus);
      let mergedNotFound;
      if (notFoundContent !== void 0) {
        mergedNotFound = notFoundContent;
      } else if (mode === "combobox") {
        mergedNotFound = null;
      } else {
        mergedNotFound = (renderEmpty === null || renderEmpty === void 0 ? void 0 : renderEmpty("Select")) || /* @__PURE__ */ reactExports.createElement(DefaultRenderEmpty$1, {
          componentName: "Select"
        });
      }
      const {
        suffixIcon,
        itemIcon,
        removeIcon,
        clearIcon
      } = useIcons(Object.assign(Object.assign({}, props), {
        multiple: isMultiple2,
        hasFeedback,
        feedbackIcon,
        showSuffixIcon,
        prefixCls,
        showArrow: props.showArrow,
        componentName: "Select"
      }));
      const mergedAllowClear = allowClear === true ? {
        clearIcon
      } : allowClear;
      const selectProps = omit(props, ["suffixIcon", "itemIcon"]);
      const mergedPopupClassName = classNames(popupClassName || dropdownClassName, {
        [`${prefixCls}-dropdown-${direction}`]: direction === "rtl"
      }, rootClassName, rootCls, hashId);
      const mergedSize = useSize$1((ctx) => {
        var _a2;
        return (_a2 = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a2 !== void 0 ? _a2 : ctx;
      });
      const disabled = reactExports.useContext(DisabledContext$1);
      const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
      const mergedClassName = classNames({
        [`${prefixCls}-lg`]: mergedSize === "large",
        [`${prefixCls}-sm`]: mergedSize === "small",
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-borderless`]: !bordered,
        [`${prefixCls}-in-form-item`]: isFormItemInput
      }, getStatusClassNames(prefixCls, mergedStatus, hasFeedback), compactItemClassnames, select === null || select === void 0 ? void 0 : select.className, className, rootClassName, rootCls, hashId);
      const memoPlacement = reactExports.useMemo(() => {
        if (placement !== void 0) {
          return placement;
        }
        return direction === "rtl" ? "bottomRight" : "bottomLeft";
      }, [placement, direction]);
      const mergedBuiltinPlacements = useBuiltinPlacements(builtinPlacements, popupOverflow);
      const [zIndex] = useZIndex("SelectLike", (_c = props.dropdownStyle) === null || _c === void 0 ? void 0 : _c.zIndex);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(TypedSelect, Object.assign({
        ref,
        virtual,
        showSearch: select === null || select === void 0 ? void 0 : select.showSearch
      }, selectProps, {
        style: Object.assign(Object.assign({}, select === null || select === void 0 ? void 0 : select.style), style2),
        dropdownMatchSelectWidth: mergedPopupMatchSelectWidth,
        builtinPlacements: mergedBuiltinPlacements,
        transitionName: getTransitionName(rootPrefixCls, "slide-up", props.transitionName),
        listHeight,
        listItemHeight,
        mode,
        prefixCls,
        placement: memoPlacement,
        direction,
        suffixIcon,
        menuItemSelectedIcon: itemIcon,
        removeIcon,
        allowClear: mergedAllowClear,
        notFoundContent: mergedNotFound,
        className: mergedClassName,
        getPopupContainer: getPopupContainer || getContextPopupContainer,
        dropdownClassName: mergedPopupClassName,
        disabled: mergedDisabled,
        dropdownStyle: Object.assign(Object.assign({}, props === null || props === void 0 ? void 0 : props.dropdownStyle), {
          zIndex
        })
      })));
    };
    const Select = /* @__PURE__ */ reactExports.forwardRef(InternalSelect);
    const PurePanel$4 = genPurePanel$1(Select);
    Select.SECRET_COMBOBOX_MODE_DO_NOT_USE = SECRET_COMBOBOX_MODE_DO_NOT_USE;
    Select.Option = Option;
    Select.OptGroup = OptGroup;
    Select._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$4;
    const Select$1 = Select;
    const responsiveArray = ["xxl", "xl", "lg", "md", "sm", "xs"];
    const getResponsiveMap = (token2) => ({
      xs: `(max-width: ${token2.screenXSMax}px)`,
      sm: `(min-width: ${token2.screenSM}px)`,
      md: `(min-width: ${token2.screenMD}px)`,
      lg: `(min-width: ${token2.screenLG}px)`,
      xl: `(min-width: ${token2.screenXL}px)`,
      xxl: `(min-width: ${token2.screenXXL}px)`
    });
    const validateBreakpoints = (token2) => {
      const indexableToken = token2;
      const revBreakpoints = [].concat(responsiveArray).reverse();
      revBreakpoints.forEach((breakpoint, i) => {
        const breakpointUpper = breakpoint.toUpperCase();
        const screenMin = `screen${breakpointUpper}Min`;
        const screen = `screen${breakpointUpper}`;
        if (!(indexableToken[screenMin] <= indexableToken[screen])) {
          throw new Error(`${screenMin}<=${screen} fails : !(${indexableToken[screenMin]}<=${indexableToken[screen]})`);
        }
        if (i < revBreakpoints.length - 1) {
          const screenMax = `screen${breakpointUpper}Max`;
          if (!(indexableToken[screen] <= indexableToken[screenMax])) {
            throw new Error(`${screen}<=${screenMax} fails : !(${indexableToken[screen]}<=${indexableToken[screenMax]})`);
          }
          const nextBreakpointUpperMin = revBreakpoints[i + 1].toUpperCase();
          const nextScreenMin = `screen${nextBreakpointUpperMin}Min`;
          if (!(indexableToken[screenMax] <= indexableToken[nextScreenMin])) {
            throw new Error(`${screenMax}<=${nextScreenMin} fails : !(${indexableToken[screenMax]}<=${indexableToken[nextScreenMin]})`);
          }
        }
      });
      return token2;
    };
    function useResponsiveObserver() {
      const [, token2] = useToken$1();
      const responsiveMap = getResponsiveMap(validateBreakpoints(token2));
      return React.useMemo(() => {
        const subscribers = /* @__PURE__ */ new Map();
        let subUid = -1;
        let screens = {};
        return {
          matchHandlers: {},
          dispatch(pointMap) {
            screens = pointMap;
            subscribers.forEach((func) => func(screens));
            return subscribers.size >= 1;
          },
          subscribe(func) {
            if (!subscribers.size)
              this.register();
            subUid += 1;
            subscribers.set(subUid, func);
            func(screens);
            return subUid;
          },
          unsubscribe(paramToken) {
            subscribers.delete(paramToken);
            if (!subscribers.size)
              this.unregister();
          },
          unregister() {
            Object.keys(responsiveMap).forEach((screen) => {
              const matchMediaQuery = responsiveMap[screen];
              const handler = this.matchHandlers[matchMediaQuery];
              handler === null || handler === void 0 ? void 0 : handler.mql.removeListener(handler === null || handler === void 0 ? void 0 : handler.listener);
            });
            subscribers.clear();
          },
          register() {
            Object.keys(responsiveMap).forEach((screen) => {
              const matchMediaQuery = responsiveMap[screen];
              const listener = (_ref) => {
                let {
                  matches
                } = _ref;
                this.dispatch(Object.assign(Object.assign({}, screens), {
                  [screen]: matches
                }));
              };
              const mql = window.matchMedia(matchMediaQuery);
              mql.addListener(listener);
              this.matchHandlers[matchMediaQuery] = {
                mql,
                listener
              };
              listener(mql);
            });
          },
          responsiveMap
        };
      }, [token2]);
    }
    function useForceUpdate() {
      const [, forceUpdate] = reactExports.useReducer((x2) => x2 + 1, 0);
      return forceUpdate;
    }
    function useBreakpoint() {
      let refreshOnChange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      const screensRef = reactExports.useRef({});
      const forceUpdate = useForceUpdate();
      const responsiveObserver = useResponsiveObserver();
      useLayoutEffect$1(() => {
        const token2 = responsiveObserver.subscribe((supportScreens) => {
          screensRef.current = supportScreens;
          if (refreshOnChange) {
            forceUpdate();
          }
        });
        return () => responsiveObserver.unsubscribe(token2);
      }, []);
      return screensRef.current;
    }
    function Popup(props) {
      var children = props.children, prefixCls = props.prefixCls, id2 = props.id, overlayInnerStyle = props.overlayInnerStyle, className = props.className, style2 = props.style;
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames("".concat(prefixCls, "-content"), className),
        style: style2
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-inner"),
        id: id2,
        role: "tooltip",
        style: overlayInnerStyle
      }, typeof children === "function" ? children() : children));
    }
    var autoAdjustOverflowTopBottom = {
      shiftX: 64,
      adjustY: 1
    };
    var autoAdjustOverflowLeftRight = {
      adjustX: 1,
      shiftY: true
    };
    var targetOffset$1 = [0, 0];
    var placements$2 = {
      left: {
        points: ["cr", "cl"],
        overflow: autoAdjustOverflowLeftRight,
        offset: [-4, 0],
        targetOffset: targetOffset$1
      },
      right: {
        points: ["cl", "cr"],
        overflow: autoAdjustOverflowLeftRight,
        offset: [4, 0],
        targetOffset: targetOffset$1
      },
      top: {
        points: ["bc", "tc"],
        overflow: autoAdjustOverflowTopBottom,
        offset: [0, -4],
        targetOffset: targetOffset$1
      },
      bottom: {
        points: ["tc", "bc"],
        overflow: autoAdjustOverflowTopBottom,
        offset: [0, 4],
        targetOffset: targetOffset$1
      },
      topLeft: {
        points: ["bl", "tl"],
        overflow: autoAdjustOverflowTopBottom,
        offset: [0, -4],
        targetOffset: targetOffset$1
      },
      leftTop: {
        points: ["tr", "tl"],
        overflow: autoAdjustOverflowLeftRight,
        offset: [-4, 0],
        targetOffset: targetOffset$1
      },
      topRight: {
        points: ["br", "tr"],
        overflow: autoAdjustOverflowTopBottom,
        offset: [0, -4],
        targetOffset: targetOffset$1
      },
      rightTop: {
        points: ["tl", "tr"],
        overflow: autoAdjustOverflowLeftRight,
        offset: [4, 0],
        targetOffset: targetOffset$1
      },
      bottomRight: {
        points: ["tr", "br"],
        overflow: autoAdjustOverflowTopBottom,
        offset: [0, 4],
        targetOffset: targetOffset$1
      },
      rightBottom: {
        points: ["bl", "br"],
        overflow: autoAdjustOverflowLeftRight,
        offset: [4, 0],
        targetOffset: targetOffset$1
      },
      bottomLeft: {
        points: ["tl", "bl"],
        overflow: autoAdjustOverflowTopBottom,
        offset: [0, 4],
        targetOffset: targetOffset$1
      },
      leftBottom: {
        points: ["br", "bl"],
        overflow: autoAdjustOverflowLeftRight,
        offset: [-4, 0],
        targetOffset: targetOffset$1
      }
    };
    var _excluded$q = ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "children", "onVisibleChange", "afterVisibleChange", "transitionName", "animation", "motion", "placement", "align", "destroyTooltipOnHide", "defaultVisible", "getTooltipContainer", "overlayInnerStyle", "arrowContent", "overlay", "id", "showArrow"];
    var Tooltip$2 = function Tooltip2(props, ref) {
      var overlayClassName = props.overlayClassName, _props$trigger = props.trigger, trigger = _props$trigger === void 0 ? ["hover"] : _props$trigger, _props$mouseEnterDela = props.mouseEnterDelay, mouseEnterDelay = _props$mouseEnterDela === void 0 ? 0 : _props$mouseEnterDela, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela, overlayStyle = props.overlayStyle, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-tooltip" : _props$prefixCls, children = props.children, onVisibleChange = props.onVisibleChange, afterVisibleChange = props.afterVisibleChange, transitionName = props.transitionName, animation = props.animation, motion = props.motion, _props$placement = props.placement, placement = _props$placement === void 0 ? "right" : _props$placement, _props$align = props.align, align = _props$align === void 0 ? {} : _props$align, _props$destroyTooltip = props.destroyTooltipOnHide, destroyTooltipOnHide = _props$destroyTooltip === void 0 ? false : _props$destroyTooltip, defaultVisible = props.defaultVisible, getTooltipContainer = props.getTooltipContainer, overlayInnerStyle = props.overlayInnerStyle;
      props.arrowContent;
      var overlay = props.overlay, id2 = props.id, _props$showArrow = props.showArrow, showArrow = _props$showArrow === void 0 ? true : _props$showArrow, restProps = _objectWithoutProperties(props, _excluded$q);
      var triggerRef = reactExports.useRef(null);
      reactExports.useImperativeHandle(ref, function() {
        return triggerRef.current;
      });
      var extraProps = _objectSpread2({}, restProps);
      if ("visible" in props) {
        extraProps.popupVisible = props.visible;
      }
      var getPopupElement = function getPopupElement2() {
        return /* @__PURE__ */ reactExports.createElement(Popup, {
          key: "content",
          prefixCls,
          id: id2,
          overlayInnerStyle
        }, overlay);
      };
      return /* @__PURE__ */ reactExports.createElement(Trigger, _extends$1({
        popupClassName: overlayClassName,
        prefixCls,
        popup: getPopupElement,
        action: trigger,
        builtinPlacements: placements$2,
        popupPlacement: placement,
        ref: triggerRef,
        popupAlign: align,
        getPopupContainer: getTooltipContainer,
        onPopupVisibleChange: onVisibleChange,
        afterPopupVisibleChange: afterVisibleChange,
        popupTransitionName: transitionName,
        popupAnimation: animation,
        popupMotion: motion,
        defaultPopupVisible: defaultVisible,
        autoDestroy: destroyTooltipOnHide,
        mouseLeaveDelay,
        popupStyle: overlayStyle,
        mouseEnterDelay,
        arrow: showArrow
      }, extraProps), children);
    };
    const Tooltip$3 = /* @__PURE__ */ reactExports.forwardRef(Tooltip$2);
    function getArrowToken(token2) {
      const {
        sizePopupArrow,
        borderRadiusXS,
        borderRadiusOuter
      } = token2;
      const unitWidth = sizePopupArrow / 2;
      const ax = 0;
      const ay = unitWidth;
      const bx = borderRadiusOuter * 1 / Math.sqrt(2);
      const by = unitWidth - borderRadiusOuter * (1 - 1 / Math.sqrt(2));
      const cx = unitWidth - borderRadiusXS * (1 / Math.sqrt(2));
      const cy = borderRadiusOuter * (Math.sqrt(2) - 1) + borderRadiusXS * (1 / Math.sqrt(2));
      const dx = 2 * unitWidth - cx;
      const dy = cy;
      const ex = 2 * unitWidth - bx;
      const ey = by;
      const fx = 2 * unitWidth - ax;
      const fy = ay;
      const shadowWidth = unitWidth * Math.sqrt(2) + borderRadiusOuter * (Math.sqrt(2) - 2);
      const polygonOffset = borderRadiusOuter * (Math.sqrt(2) - 1);
      const arrowPolygon = `polygon(${polygonOffset}px 100%, 50% ${polygonOffset}px, ${2 * unitWidth - polygonOffset}px 100%, ${polygonOffset}px 100%)`;
      const arrowPath = `path('M ${ax} ${ay} A ${borderRadiusOuter} ${borderRadiusOuter} 0 0 0 ${bx} ${by} L ${cx} ${cy} A ${borderRadiusXS} ${borderRadiusXS} 0 0 1 ${dx} ${dy} L ${ex} ${ey} A ${borderRadiusOuter} ${borderRadiusOuter} 0 0 0 ${fx} ${fy} Z')`;
      return {
        arrowShadowWidth: shadowWidth,
        arrowPath,
        arrowPolygon
      };
    }
    const genRoundedArrow = (token2, bgColor, boxShadow) => {
      const {
        sizePopupArrow,
        arrowPolygon,
        arrowPath,
        arrowShadowWidth,
        borderRadiusXS,
        calc
      } = token2;
      return {
        pointerEvents: "none",
        width: sizePopupArrow,
        height: sizePopupArrow,
        overflow: "hidden",
        "&::before": {
          position: "absolute",
          bottom: 0,
          insetInlineStart: 0,
          width: sizePopupArrow,
          height: calc(sizePopupArrow).div(2).equal(),
          background: bgColor,
          clipPath: {
            _multi_value_: true,
            value: [arrowPolygon, arrowPath]
          },
          content: '""'
        },
        "&::after": {
          content: '""',
          position: "absolute",
          width: arrowShadowWidth,
          height: arrowShadowWidth,
          bottom: 0,
          insetInline: 0,
          margin: "auto",
          borderRadius: {
            _skip_check_: true,
            value: `0 0 ${unit$1(borderRadiusXS)} 0`
          },
          transform: "translateY(50%) rotate(-135deg)",
          boxShadow,
          zIndex: 0,
          background: "transparent"
        }
      };
    };
    const MAX_VERTICAL_CONTENT_RADIUS = 8;
    function getArrowOffsetToken(options) {
      const {
        contentRadius,
        limitVerticalRadius
      } = options;
      const arrowOffset = contentRadius > 12 ? contentRadius + 2 : 12;
      const arrowOffsetVertical = limitVerticalRadius ? MAX_VERTICAL_CONTENT_RADIUS : arrowOffset;
      return {
        arrowOffsetHorizontal: arrowOffset,
        arrowOffsetVertical
      };
    }
    function isInject(valid, code) {
      if (!valid)
        return {};
      return code;
    }
    function getArrowStyle(token2, colorBg, options) {
      const {
        componentCls,
        boxShadowPopoverArrow,
        arrowOffsetVertical,
        arrowOffsetHorizontal
      } = token2;
      const {
        arrowDistance = 0,
        arrowPlacement = {
          left: true,
          right: true,
          top: true,
          bottom: true
        }
      } = options || {};
      return {
        [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({
          // ============================ Basic ============================
          [`${componentCls}-arrow`]: [Object.assign(Object.assign({
            position: "absolute",
            zIndex: 1,
            display: "block"
          }, genRoundedArrow(token2, colorBg, boxShadowPopoverArrow)), {
            "&:before": {
              background: colorBg
            }
          })]
        }, isInject(!!arrowPlacement.top, {
          [[`&-placement-top ${componentCls}-arrow`, `&-placement-topLeft ${componentCls}-arrow`, `&-placement-topRight ${componentCls}-arrow`].join(",")]: {
            bottom: arrowDistance,
            transform: "translateY(100%) rotate(180deg)"
          },
          [`&-placement-top ${componentCls}-arrow`]: {
            left: {
              _skip_check_: true,
              value: "50%"
            },
            transform: "translateX(-50%) translateY(100%) rotate(180deg)"
          },
          [`&-placement-topLeft ${componentCls}-arrow`]: {
            left: {
              _skip_check_: true,
              value: arrowOffsetHorizontal
            }
          },
          [`&-placement-topRight ${componentCls}-arrow`]: {
            right: {
              _skip_check_: true,
              value: arrowOffsetHorizontal
            }
          }
        })), isInject(!!arrowPlacement.bottom, {
          [[`&-placement-bottom ${componentCls}-arrow`, `&-placement-bottomLeft ${componentCls}-arrow`, `&-placement-bottomRight ${componentCls}-arrow`].join(",")]: {
            top: arrowDistance,
            transform: `translateY(-100%)`
          },
          [`&-placement-bottom ${componentCls}-arrow`]: {
            left: {
              _skip_check_: true,
              value: "50%"
            },
            transform: `translateX(-50%) translateY(-100%)`
          },
          [`&-placement-bottomLeft ${componentCls}-arrow`]: {
            left: {
              _skip_check_: true,
              value: arrowOffsetHorizontal
            }
          },
          [`&-placement-bottomRight ${componentCls}-arrow`]: {
            right: {
              _skip_check_: true,
              value: arrowOffsetHorizontal
            }
          }
        })), isInject(!!arrowPlacement.left, {
          [[`&-placement-left ${componentCls}-arrow`, `&-placement-leftTop ${componentCls}-arrow`, `&-placement-leftBottom ${componentCls}-arrow`].join(",")]: {
            right: {
              _skip_check_: true,
              value: arrowDistance
            },
            transform: "translateX(100%) rotate(90deg)"
          },
          [`&-placement-left ${componentCls}-arrow`]: {
            top: {
              _skip_check_: true,
              value: "50%"
            },
            transform: "translateY(-50%) translateX(100%) rotate(90deg)"
          },
          [`&-placement-leftTop ${componentCls}-arrow`]: {
            top: arrowOffsetVertical
          },
          [`&-placement-leftBottom ${componentCls}-arrow`]: {
            bottom: arrowOffsetVertical
          }
        })), isInject(!!arrowPlacement.right, {
          [[`&-placement-right ${componentCls}-arrow`, `&-placement-rightTop ${componentCls}-arrow`, `&-placement-rightBottom ${componentCls}-arrow`].join(",")]: {
            left: {
              _skip_check_: true,
              value: arrowDistance
            },
            transform: "translateX(-100%) rotate(-90deg)"
          },
          [`&-placement-right ${componentCls}-arrow`]: {
            top: {
              _skip_check_: true,
              value: "50%"
            },
            transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
          },
          [`&-placement-rightTop ${componentCls}-arrow`]: {
            top: arrowOffsetVertical
          },
          [`&-placement-rightBottom ${componentCls}-arrow`]: {
            bottom: arrowOffsetVertical
          }
        }))
      };
    }
    function getOverflowOptions(placement, arrowOffset, arrowWidth, autoAdjustOverflow2) {
      if (autoAdjustOverflow2 === false) {
        return {
          adjustX: false,
          adjustY: false
        };
      }
      const overflow = autoAdjustOverflow2 && typeof autoAdjustOverflow2 === "object" ? autoAdjustOverflow2 : {};
      const baseOverflow = {};
      switch (placement) {
        case "top":
        case "bottom":
          baseOverflow.shiftX = arrowOffset.arrowOffsetHorizontal * 2 + arrowWidth;
          baseOverflow.shiftY = true;
          baseOverflow.adjustY = true;
          break;
        case "left":
        case "right":
          baseOverflow.shiftY = arrowOffset.arrowOffsetVertical * 2 + arrowWidth;
          baseOverflow.shiftX = true;
          baseOverflow.adjustX = true;
          break;
      }
      const mergedOverflow = Object.assign(Object.assign({}, baseOverflow), overflow);
      if (!mergedOverflow.shiftX) {
        mergedOverflow.adjustX = true;
      }
      if (!mergedOverflow.shiftY) {
        mergedOverflow.adjustY = true;
      }
      return mergedOverflow;
    }
    const PlacementAlignMap = {
      left: {
        points: ["cr", "cl"]
      },
      right: {
        points: ["cl", "cr"]
      },
      top: {
        points: ["bc", "tc"]
      },
      bottom: {
        points: ["tc", "bc"]
      },
      topLeft: {
        points: ["bl", "tl"]
      },
      leftTop: {
        points: ["tr", "tl"]
      },
      topRight: {
        points: ["br", "tr"]
      },
      rightTop: {
        points: ["tl", "tr"]
      },
      bottomRight: {
        points: ["tr", "br"]
      },
      rightBottom: {
        points: ["bl", "br"]
      },
      bottomLeft: {
        points: ["tl", "bl"]
      },
      leftBottom: {
        points: ["br", "bl"]
      }
    };
    const ArrowCenterPlacementAlignMap = {
      topLeft: {
        points: ["bl", "tc"]
      },
      leftTop: {
        points: ["tr", "cl"]
      },
      topRight: {
        points: ["br", "tc"]
      },
      rightTop: {
        points: ["tl", "cr"]
      },
      bottomRight: {
        points: ["tr", "bc"]
      },
      rightBottom: {
        points: ["bl", "cr"]
      },
      bottomLeft: {
        points: ["tl", "bc"]
      },
      leftBottom: {
        points: ["br", "cl"]
      }
    };
    const DisableAutoArrowList = /* @__PURE__ */ new Set(["topLeft", "topRight", "bottomLeft", "bottomRight", "leftTop", "leftBottom", "rightTop", "rightBottom"]);
    function getPlacements(config) {
      const {
        arrowWidth,
        autoAdjustOverflow: autoAdjustOverflow2,
        arrowPointAtCenter,
        offset: offset2,
        borderRadius,
        visibleFirst
      } = config;
      const halfArrowWidth = arrowWidth / 2;
      const placementMap = {};
      Object.keys(PlacementAlignMap).forEach((key) => {
        const template = arrowPointAtCenter && ArrowCenterPlacementAlignMap[key] || PlacementAlignMap[key];
        const placementInfo = Object.assign(Object.assign({}, template), {
          offset: [0, 0],
          dynamicInset: true
        });
        placementMap[key] = placementInfo;
        if (DisableAutoArrowList.has(key)) {
          placementInfo.autoArrow = false;
        }
        switch (key) {
          case "top":
          case "topLeft":
          case "topRight":
            placementInfo.offset[1] = -halfArrowWidth - offset2;
            break;
          case "bottom":
          case "bottomLeft":
          case "bottomRight":
            placementInfo.offset[1] = halfArrowWidth + offset2;
            break;
          case "left":
          case "leftTop":
          case "leftBottom":
            placementInfo.offset[0] = -halfArrowWidth - offset2;
            break;
          case "right":
          case "rightTop":
          case "rightBottom":
            placementInfo.offset[0] = halfArrowWidth + offset2;
            break;
        }
        const arrowOffset = getArrowOffsetToken({
          contentRadius: borderRadius,
          limitVerticalRadius: true
        });
        if (arrowPointAtCenter) {
          switch (key) {
            case "topLeft":
            case "bottomLeft":
              placementInfo.offset[0] = -arrowOffset.arrowOffsetHorizontal - halfArrowWidth;
              break;
            case "topRight":
            case "bottomRight":
              placementInfo.offset[0] = arrowOffset.arrowOffsetHorizontal + halfArrowWidth;
              break;
            case "leftTop":
            case "rightTop":
              placementInfo.offset[1] = -arrowOffset.arrowOffsetHorizontal - halfArrowWidth;
              break;
            case "leftBottom":
            case "rightBottom":
              placementInfo.offset[1] = arrowOffset.arrowOffsetHorizontal + halfArrowWidth;
              break;
          }
        }
        placementInfo.overflow = getOverflowOptions(key, arrowOffset, arrowWidth, autoAdjustOverflow2);
        if (visibleFirst) {
          placementInfo.htmlRegion = "visibleFirst";
        }
      });
      return placementMap;
    }
    const genTooltipStyle = (token2) => {
      const {
        componentCls,
        // ant-tooltip
        tooltipMaxWidth,
        tooltipColor,
        tooltipBg,
        tooltipBorderRadius,
        zIndexPopup,
        controlHeight,
        boxShadowSecondary,
        paddingSM,
        paddingXS
      } = token2;
      return [
        {
          [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
            position: "absolute",
            zIndex: zIndexPopup,
            display: "block",
            width: "max-content",
            maxWidth: tooltipMaxWidth,
            visibility: "visible",
            transformOrigin: `var(--arrow-x, 50%) var(--arrow-y, 50%)`,
            "&-hidden": {
              display: "none"
            },
            "--antd-arrow-background-color": tooltipBg,
            // Wrapper for the tooltip content
            [`${componentCls}-inner`]: {
              minWidth: controlHeight,
              minHeight: controlHeight,
              padding: `${unit$1(token2.calc(paddingSM).div(2).equal())} ${unit$1(paddingXS)}`,
              color: tooltipColor,
              textAlign: "start",
              textDecoration: "none",
              wordWrap: "break-word",
              backgroundColor: tooltipBg,
              borderRadius: tooltipBorderRadius,
              boxShadow: boxShadowSecondary,
              boxSizing: "border-box"
            },
            // Limit left and right placement radius
            [[`&-placement-left`, `&-placement-leftTop`, `&-placement-leftBottom`, `&-placement-right`, `&-placement-rightTop`, `&-placement-rightBottom`].join(",")]: {
              [`${componentCls}-inner`]: {
                borderRadius: token2.min(tooltipBorderRadius, MAX_VERTICAL_CONTENT_RADIUS)
              }
            },
            [`${componentCls}-content`]: {
              position: "relative"
            }
          }), genPresetColor(token2, (colorKey, _ref) => {
            let {
              darkColor
            } = _ref;
            return {
              [`&${componentCls}-${colorKey}`]: {
                [`${componentCls}-inner`]: {
                  backgroundColor: darkColor
                },
                [`${componentCls}-arrow`]: {
                  "--antd-arrow-background-color": darkColor
                }
              }
            };
          })), {
            // RTL
            "&-rtl": {
              direction: "rtl"
            }
          })
        },
        // Arrow Style
        getArrowStyle(token2, "var(--antd-arrow-background-color)"),
        // Pure Render
        {
          [`${componentCls}-pure`]: {
            position: "relative",
            maxWidth: "none",
            margin: token2.sizePopupArrow
          }
        }
      ];
    };
    const prepareComponentToken$e = (token2) => Object.assign(Object.assign({
      zIndexPopup: token2.zIndexPopupBase + 70
    }, getArrowOffsetToken({
      contentRadius: token2.borderRadius,
      limitVerticalRadius: true
    })), getArrowToken(merge$1(token2, {
      borderRadiusOuter: Math.min(token2.borderRadiusOuter, 4)
    })));
    const useStyle$h = function(prefixCls) {
      let injectStyle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      const useStyle2 = genStyleHooks("Tooltip", (token2) => {
        const {
          borderRadius,
          colorTextLightSolid,
          colorBgSpotlight
        } = token2;
        const TooltipToken = merge$1(token2, {
          // default variables
          tooltipMaxWidth: 250,
          tooltipColor: colorTextLightSolid,
          tooltipBorderRadius: borderRadius,
          tooltipBg: colorBgSpotlight
        });
        return [genTooltipStyle(TooltipToken), initZoomMotion(token2, "zoom-big-fast")];
      }, prepareComponentToken$e, {
        resetStyle: false,
        // Popover use Tooltip as internal component. We do not need to handle this.
        injectStyle
      });
      return useStyle2(prefixCls);
    };
    const inverseColors = PresetColors.map((color) => `${color}-inverse`);
    function isPresetColor(color) {
      let includeInverse = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (includeInverse) {
        return [].concat(_toConsumableArray(inverseColors), _toConsumableArray(PresetColors)).includes(color);
      }
      return PresetColors.includes(color);
    }
    function parseColor(prefixCls, color) {
      const isInternalColor = isPresetColor(color);
      const className = classNames({
        [`${prefixCls}-${color}`]: color && isInternalColor
      });
      const overlayStyle = {};
      const arrowStyle = {};
      if (color && !isInternalColor) {
        overlayStyle.background = color;
        arrowStyle["--antd-arrow-background-color"] = color;
      }
      return {
        className,
        overlayStyle,
        arrowStyle
      };
    }
    const PurePanel$2 = (props) => {
      const {
        prefixCls: customizePrefixCls,
        className,
        placement = "top",
        title,
        color,
        overlayInnerStyle
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
      const [wrapCSSVar, hashId] = useStyle$h(prefixCls);
      const colorInfo = parseColor(prefixCls, color);
      const arrowContentStyle = colorInfo.arrowStyle;
      const formattedOverlayInnerStyle = Object.assign(Object.assign({}, overlayInnerStyle), colorInfo.overlayStyle);
      const cls = classNames(hashId, prefixCls, `${prefixCls}-pure`, `${prefixCls}-placement-${placement}`, className, colorInfo.className);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("div", {
        className: cls,
        style: arrowContentStyle
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-arrow`
      }), /* @__PURE__ */ reactExports.createElement(Popup, Object.assign({}, props, {
        className: hashId,
        prefixCls,
        overlayInnerStyle: formattedOverlayInnerStyle
      }), title)));
    };
    const PurePanel$3 = PurePanel$2;
    var __rest$z = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const Tooltip = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      var _a, _b;
      const {
        prefixCls: customizePrefixCls,
        openClassName,
        getTooltipContainer,
        overlayClassName,
        color,
        overlayInnerStyle,
        children,
        afterOpenChange,
        afterVisibleChange,
        destroyTooltipOnHide,
        arrow = true,
        title,
        overlay,
        builtinPlacements,
        arrowPointAtCenter = false,
        autoAdjustOverflow: autoAdjustOverflow2 = true
      } = props;
      const mergedShowArrow = !!arrow;
      const [, token2] = useToken$1();
      const {
        getPopupContainer: getContextPopupContainer,
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const warning2 = devUseWarning();
      const tooltipRef = reactExports.useRef(null);
      const forceAlign = () => {
        var _a2;
        (_a2 = tooltipRef.current) === null || _a2 === void 0 ? void 0 : _a2.forceAlign();
      };
      reactExports.useImperativeHandle(ref, () => ({
        forceAlign,
        forcePopupAlign: () => {
          warning2.deprecated(false, "forcePopupAlign", "forceAlign");
          forceAlign();
        }
      }));
      const [open, setOpen] = useMergedState(false, {
        value: (_a = props.open) !== null && _a !== void 0 ? _a : props.visible,
        defaultValue: (_b = props.defaultOpen) !== null && _b !== void 0 ? _b : props.defaultVisible
      });
      const noTitle = !title && !overlay && title !== 0;
      const onOpenChange = (vis) => {
        var _a2, _b2;
        setOpen(noTitle ? false : vis);
        if (!noTitle) {
          (_a2 = props.onOpenChange) === null || _a2 === void 0 ? void 0 : _a2.call(props, vis);
          (_b2 = props.onVisibleChange) === null || _b2 === void 0 ? void 0 : _b2.call(props, vis);
        }
      };
      const tooltipPlacements = reactExports.useMemo(() => {
        var _a2, _b2;
        let mergedArrowPointAtCenter = arrowPointAtCenter;
        if (typeof arrow === "object") {
          mergedArrowPointAtCenter = (_b2 = (_a2 = arrow.pointAtCenter) !== null && _a2 !== void 0 ? _a2 : arrow.arrowPointAtCenter) !== null && _b2 !== void 0 ? _b2 : arrowPointAtCenter;
        }
        return builtinPlacements || getPlacements({
          arrowPointAtCenter: mergedArrowPointAtCenter,
          autoAdjustOverflow: autoAdjustOverflow2,
          arrowWidth: mergedShowArrow ? token2.sizePopupArrow : 0,
          borderRadius: token2.borderRadius,
          offset: token2.marginXXS,
          visibleFirst: true
        });
      }, [arrowPointAtCenter, arrow, builtinPlacements, token2]);
      const memoOverlay = reactExports.useMemo(() => {
        if (title === 0) {
          return title;
        }
        return overlay || title || "";
      }, [overlay, title]);
      const memoOverlayWrapper = /* @__PURE__ */ reactExports.createElement(NoCompactStyle, null, typeof memoOverlay === "function" ? memoOverlay() : memoOverlay);
      const {
        getPopupContainer,
        placement = "top",
        mouseEnterDelay = 0.1,
        mouseLeaveDelay = 0.1,
        overlayStyle,
        rootClassName
      } = props, otherProps = __rest$z(props, ["getPopupContainer", "placement", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "rootClassName"]);
      const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
      const rootPrefixCls = getPrefixCls();
      const injectFromPopover = props["data-popover-inject"];
      let tempOpen = open;
      if (!("open" in props) && !("visible" in props) && noTitle) {
        tempOpen = false;
      }
      const child = isValidElement(children) && !isFragment(children) ? children : /* @__PURE__ */ reactExports.createElement("span", null, children);
      const childProps = child.props;
      const childCls = !childProps.className || typeof childProps.className === "string" ? classNames(childProps.className, openClassName || `${prefixCls}-open`) : childProps.className;
      const [wrapCSSVar, hashId] = useStyle$h(prefixCls, !injectFromPopover);
      const colorInfo = parseColor(prefixCls, color);
      const arrowContentStyle = colorInfo.arrowStyle;
      const formattedOverlayInnerStyle = Object.assign(Object.assign({}, overlayInnerStyle), colorInfo.overlayStyle);
      const customOverlayClassName = classNames(overlayClassName, {
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, colorInfo.className, rootClassName, hashId);
      const [zIndex, contextZIndex] = useZIndex("Tooltip", otherProps.zIndex);
      const content = /* @__PURE__ */ reactExports.createElement(Tooltip$3, Object.assign({}, otherProps, {
        zIndex,
        showArrow: mergedShowArrow,
        placement,
        mouseEnterDelay,
        mouseLeaveDelay,
        prefixCls,
        overlayClassName: customOverlayClassName,
        overlayStyle: Object.assign(Object.assign({}, arrowContentStyle), overlayStyle),
        getTooltipContainer: getPopupContainer || getTooltipContainer || getContextPopupContainer,
        ref: tooltipRef,
        builtinPlacements: tooltipPlacements,
        overlay: memoOverlayWrapper,
        visible: tempOpen,
        onVisibleChange: onOpenChange,
        afterVisibleChange: afterOpenChange !== null && afterOpenChange !== void 0 ? afterOpenChange : afterVisibleChange,
        overlayInnerStyle: formattedOverlayInnerStyle,
        arrowContent: /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-arrow-content`
        }),
        motion: {
          motionName: getTransitionName(rootPrefixCls, "zoom-big-fast", props.transitionName),
          motionDeadline: 1e3
        },
        destroyTooltipOnHide: !!destroyTooltipOnHide
      }), tempOpen ? cloneElement(child, {
        className: childCls
      }) : child);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(zIndexContext$1.Provider, {
        value: contextZIndex
      }, content));
    });
    Tooltip._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$3;
    const Tooltip$1 = Tooltip;
    const antStatusProcessing = new Keyframe("antStatusProcessing", {
      "0%": {
        transform: "scale(0.8)",
        opacity: 0.5
      },
      "100%": {
        transform: "scale(2.4)",
        opacity: 0
      }
    });
    const antZoomBadgeIn = new Keyframe("antZoomBadgeIn", {
      "0%": {
        transform: "scale(0) translate(50%, -50%)",
        opacity: 0
      },
      "100%": {
        transform: "scale(1) translate(50%, -50%)"
      }
    });
    const antZoomBadgeOut = new Keyframe("antZoomBadgeOut", {
      "0%": {
        transform: "scale(1) translate(50%, -50%)"
      },
      "100%": {
        transform: "scale(0) translate(50%, -50%)",
        opacity: 0
      }
    });
    const antNoWrapperZoomBadgeIn = new Keyframe("antNoWrapperZoomBadgeIn", {
      "0%": {
        transform: "scale(0)",
        opacity: 0
      },
      "100%": {
        transform: "scale(1)"
      }
    });
    const antNoWrapperZoomBadgeOut = new Keyframe("antNoWrapperZoomBadgeOut", {
      "0%": {
        transform: "scale(1)"
      },
      "100%": {
        transform: "scale(0)",
        opacity: 0
      }
    });
    const antBadgeLoadingCircle = new Keyframe("antBadgeLoadingCircle", {
      "0%": {
        transformOrigin: "50%"
      },
      "100%": {
        transform: "translate(50%, -50%) rotate(360deg)",
        transformOrigin: "50%"
      }
    });
    const genSharedBadgeStyle = (token2) => {
      const {
        componentCls,
        iconCls,
        antCls,
        badgeShadowSize,
        motionDurationSlow,
        textFontSize,
        textFontSizeSM,
        statusSize,
        dotSize,
        textFontWeight,
        indicatorHeight,
        indicatorHeightSM,
        marginXS,
        calc
      } = token2;
      const numberPrefixCls = `${antCls}-scroll-number`;
      const colorPreset = genPresetColor(token2, (colorKey, _ref) => {
        let {
          darkColor
        } = _ref;
        return {
          [`&${componentCls} ${componentCls}-color-${colorKey}`]: {
            background: darkColor,
            [`&:not(${componentCls}-count)`]: {
              color: darkColor
            }
          }
        };
      });
      return {
        [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
          position: "relative",
          display: "inline-block",
          width: "fit-content",
          lineHeight: 1,
          [`${componentCls}-count`]: {
            zIndex: token2.indicatorZIndex,
            minWidth: indicatorHeight,
            height: indicatorHeight,
            color: token2.badgeTextColor,
            fontWeight: textFontWeight,
            fontSize: textFontSize,
            lineHeight: unit$1(indicatorHeight),
            whiteSpace: "nowrap",
            textAlign: "center",
            background: token2.badgeColor,
            borderRadius: calc(indicatorHeight).div(2).equal(),
            boxShadow: `0 0 0 ${unit$1(badgeShadowSize)} ${token2.badgeShadowColor}`,
            transition: `background ${token2.motionDurationMid}`,
            a: {
              color: token2.badgeTextColor
            },
            "a:hover": {
              color: token2.badgeTextColor
            },
            "a:hover &": {
              background: token2.badgeColorHover
            }
          },
          [`${componentCls}-count-sm`]: {
            minWidth: indicatorHeightSM,
            height: indicatorHeightSM,
            fontSize: textFontSizeSM,
            lineHeight: unit$1(indicatorHeightSM),
            borderRadius: calc(indicatorHeightSM).div(2).equal()
          },
          [`${componentCls}-multiple-words`]: {
            padding: `0 ${unit$1(token2.paddingXS)}`,
            bdi: {
              unicodeBidi: "plaintext"
            }
          },
          [`${componentCls}-dot`]: {
            zIndex: token2.indicatorZIndex,
            width: dotSize,
            minWidth: dotSize,
            height: dotSize,
            background: token2.badgeColor,
            borderRadius: "100%",
            boxShadow: `0 0 0 ${unit$1(badgeShadowSize)} ${token2.badgeShadowColor}`
          },
          [`${componentCls}-dot${numberPrefixCls}`]: {
            transition: `background ${motionDurationSlow}`
          },
          [`${componentCls}-count, ${componentCls}-dot, ${numberPrefixCls}-custom-component`]: {
            position: "absolute",
            top: 0,
            insetInlineEnd: 0,
            transform: "translate(50%, -50%)",
            transformOrigin: "100% 0%",
            [`&${iconCls}-spin`]: {
              animationName: antBadgeLoadingCircle,
              animationDuration: "1s",
              animationIterationCount: "infinite",
              animationTimingFunction: "linear"
            }
          },
          [`&${componentCls}-status`]: {
            lineHeight: "inherit",
            verticalAlign: "baseline",
            [`${componentCls}-status-dot`]: {
              position: "relative",
              top: -1,
              // Magic number, but seems better experience
              display: "inline-block",
              width: statusSize,
              height: statusSize,
              verticalAlign: "middle",
              borderRadius: "50%"
            },
            [`${componentCls}-status-success`]: {
              backgroundColor: token2.colorSuccess
            },
            [`${componentCls}-status-processing`]: {
              overflow: "visible",
              color: token2.colorPrimary,
              backgroundColor: token2.colorPrimary,
              "&::after": {
                position: "absolute",
                top: 0,
                insetInlineStart: 0,
                width: "100%",
                height: "100%",
                borderWidth: badgeShadowSize,
                borderStyle: "solid",
                borderColor: "inherit",
                borderRadius: "50%",
                animationName: antStatusProcessing,
                animationDuration: token2.badgeProcessingDuration,
                animationIterationCount: "infinite",
                animationTimingFunction: "ease-in-out",
                content: '""'
              }
            },
            [`${componentCls}-status-default`]: {
              backgroundColor: token2.colorTextPlaceholder
            },
            [`${componentCls}-status-error`]: {
              backgroundColor: token2.colorError
            },
            [`${componentCls}-status-warning`]: {
              backgroundColor: token2.colorWarning
            },
            [`${componentCls}-status-text`]: {
              marginInlineStart: marginXS,
              color: token2.colorText,
              fontSize: token2.fontSize
            }
          }
        }), colorPreset), {
          [`${componentCls}-zoom-appear, ${componentCls}-zoom-enter`]: {
            animationName: antZoomBadgeIn,
            animationDuration: token2.motionDurationSlow,
            animationTimingFunction: token2.motionEaseOutBack,
            animationFillMode: "both"
          },
          [`${componentCls}-zoom-leave`]: {
            animationName: antZoomBadgeOut,
            animationDuration: token2.motionDurationSlow,
            animationTimingFunction: token2.motionEaseOutBack,
            animationFillMode: "both"
          },
          [`&${componentCls}-not-a-wrapper`]: {
            [`${componentCls}-zoom-appear, ${componentCls}-zoom-enter`]: {
              animationName: antNoWrapperZoomBadgeIn,
              animationDuration: token2.motionDurationSlow,
              animationTimingFunction: token2.motionEaseOutBack
            },
            [`${componentCls}-zoom-leave`]: {
              animationName: antNoWrapperZoomBadgeOut,
              animationDuration: token2.motionDurationSlow,
              animationTimingFunction: token2.motionEaseOutBack
            },
            [`&:not(${componentCls}-status)`]: {
              verticalAlign: "middle"
            },
            [`${numberPrefixCls}-custom-component, ${componentCls}-count`]: {
              transform: "none"
            },
            [`${numberPrefixCls}-custom-component, ${numberPrefixCls}`]: {
              position: "relative",
              top: "auto",
              display: "block",
              transformOrigin: "50% 50%"
            }
          },
          [`${numberPrefixCls}`]: {
            overflow: "hidden",
            [`${numberPrefixCls}-only`]: {
              position: "relative",
              display: "inline-block",
              height: indicatorHeight,
              transition: `all ${token2.motionDurationSlow} ${token2.motionEaseOutBack}`,
              WebkitTransformStyle: "preserve-3d",
              WebkitBackfaceVisibility: "hidden",
              [`> p${numberPrefixCls}-only-unit`]: {
                height: indicatorHeight,
                margin: 0,
                WebkitTransformStyle: "preserve-3d",
                WebkitBackfaceVisibility: "hidden"
              }
            },
            [`${numberPrefixCls}-symbol`]: {
              verticalAlign: "top"
            }
          },
          // ====================== RTL =======================
          "&-rtl": {
            direction: "rtl",
            [`${componentCls}-count, ${componentCls}-dot, ${numberPrefixCls}-custom-component`]: {
              transform: "translate(-50%, -50%)"
            }
          }
        })
      };
    };
    const prepareToken$2 = (token2) => {
      const {
        fontHeight,
        lineWidth,
        marginXS,
        colorBorderBg
      } = token2;
      const badgeFontHeight = fontHeight;
      const badgeShadowSize = lineWidth;
      const badgeTextColor = token2.colorBgContainer;
      const badgeColor = token2.colorError;
      const badgeColorHover = token2.colorErrorHover;
      const badgeToken = merge$1(token2, {
        badgeFontHeight,
        badgeShadowSize,
        badgeTextColor,
        badgeColor,
        badgeColorHover,
        badgeShadowColor: colorBorderBg,
        badgeProcessingDuration: "1.2s",
        badgeRibbonOffset: marginXS,
        // Follow token just by Design. Not related with token
        badgeRibbonCornerTransform: "scaleY(0.75)",
        badgeRibbonCornerFilter: `brightness(75%)`
      });
      return badgeToken;
    };
    const prepareComponentToken$d = (token2) => {
      const {
        fontSize,
        lineHeight,
        fontSizeSM,
        lineWidth
      } = token2;
      return {
        indicatorZIndex: "auto",
        indicatorHeight: Math.round(fontSize * lineHeight) - 2 * lineWidth,
        indicatorHeightSM: fontSize,
        dotSize: fontSizeSM / 2,
        textFontSize: fontSizeSM,
        textFontSizeSM: fontSizeSM,
        textFontWeight: "normal",
        statusSize: fontSizeSM / 2
      };
    };
    const useStyle$g = genStyleHooks("Badge", (token2) => {
      const badgeToken = prepareToken$2(token2);
      return genSharedBadgeStyle(badgeToken);
    }, prepareComponentToken$d);
    const genRibbonStyle = (token2) => {
      const {
        antCls,
        badgeFontHeight,
        marginXS,
        badgeRibbonOffset,
        calc
      } = token2;
      const ribbonPrefixCls = `${antCls}-ribbon`;
      const ribbonWrapperPrefixCls = `${antCls}-ribbon-wrapper`;
      const statusRibbonPreset = genPresetColor(token2, (colorKey, _ref) => {
        let {
          darkColor
        } = _ref;
        return {
          [`&${ribbonPrefixCls}-color-${colorKey}`]: {
            background: darkColor,
            color: darkColor
          }
        };
      });
      return {
        [`${ribbonWrapperPrefixCls}`]: {
          position: "relative"
        },
        [`${ribbonPrefixCls}`]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
          position: "absolute",
          top: marginXS,
          padding: `0 ${unit$1(token2.paddingXS)}`,
          color: token2.colorPrimary,
          lineHeight: unit$1(badgeFontHeight),
          whiteSpace: "nowrap",
          backgroundColor: token2.colorPrimary,
          borderRadius: token2.borderRadiusSM,
          [`${ribbonPrefixCls}-text`]: {
            color: token2.colorTextLightSolid
          },
          [`${ribbonPrefixCls}-corner`]: {
            position: "absolute",
            top: "100%",
            width: badgeRibbonOffset,
            height: badgeRibbonOffset,
            color: "currentcolor",
            border: `${unit$1(calc(badgeRibbonOffset).div(2).equal())} solid`,
            transform: token2.badgeRibbonCornerTransform,
            transformOrigin: "top",
            filter: token2.badgeRibbonCornerFilter
          }
        }), statusRibbonPreset), {
          [`&${ribbonPrefixCls}-placement-end`]: {
            insetInlineEnd: calc(badgeRibbonOffset).mul(-1).equal(),
            borderEndEndRadius: 0,
            [`${ribbonPrefixCls}-corner`]: {
              insetInlineEnd: 0,
              borderInlineEndColor: "transparent",
              borderBlockEndColor: "transparent"
            }
          },
          [`&${ribbonPrefixCls}-placement-start`]: {
            insetInlineStart: calc(badgeRibbonOffset).mul(-1).equal(),
            borderEndStartRadius: 0,
            [`${ribbonPrefixCls}-corner`]: {
              insetInlineStart: 0,
              borderBlockEndColor: "transparent",
              borderInlineStartColor: "transparent"
            }
          },
          // ====================== RTL =======================
          "&-rtl": {
            direction: "rtl"
          }
        })
      };
    };
    const useStyle$f = genComponentStyleHook(["Badge", "Ribbon"], (token2) => {
      const badgeToken = prepareToken$2(token2);
      return genRibbonStyle(badgeToken);
    }, prepareComponentToken$d);
    const Ribbon = (props) => {
      const {
        className,
        prefixCls: customizePrefixCls,
        style: style2,
        color,
        children,
        text,
        placement = "end",
        rootClassName
      } = props;
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("ribbon", customizePrefixCls);
      const [wrapCSSVar, hashId] = useStyle$f(prefixCls);
      const colorInPreset = isPresetColor(color, false);
      const ribbonCls = classNames(prefixCls, `${prefixCls}-placement-${placement}`, {
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-color-${color}`]: colorInPreset
      }, className);
      const colorStyle = {};
      const cornerColorStyle = {};
      if (color && !colorInPreset) {
        colorStyle.background = color;
        cornerColorStyle.color = color;
      }
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(`${prefixCls}-wrapper`, rootClassName, hashId)
      }, children, /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(ribbonCls, hashId),
        style: Object.assign(Object.assign({}, colorStyle), style2)
      }, /* @__PURE__ */ reactExports.createElement("span", {
        className: `${prefixCls}-text`
      }, text), /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-corner`,
        style: cornerColorStyle
      }))));
    };
    const Ribbon$1 = Ribbon;
    function UnitNumber(_ref) {
      let {
        prefixCls,
        value,
        current,
        offset: offset2 = 0
      } = _ref;
      let style2;
      if (offset2) {
        style2 = {
          position: "absolute",
          top: `${offset2}00%`,
          left: 0
        };
      }
      return /* @__PURE__ */ reactExports.createElement("span", {
        style: style2,
        className: classNames(`${prefixCls}-only-unit`, {
          current
        })
      }, value);
    }
    function getOffset$2(start, end, unit2) {
      let index2 = start;
      let offset2 = 0;
      while ((index2 + 10) % 10 !== end) {
        index2 += unit2;
        offset2 += unit2;
      }
      return offset2;
    }
    function SingleNumber(props) {
      const {
        prefixCls,
        count: originCount,
        value: originValue
      } = props;
      const value = Number(originValue);
      const count = Math.abs(originCount);
      const [prevValue, setPrevValue] = reactExports.useState(value);
      const [prevCount, setPrevCount] = reactExports.useState(count);
      const onTransitionEnd = () => {
        setPrevValue(value);
        setPrevCount(count);
      };
      reactExports.useEffect(() => {
        const timeout = setTimeout(() => {
          onTransitionEnd();
        }, 1e3);
        return () => {
          clearTimeout(timeout);
        };
      }, [value]);
      let unitNodes;
      let offsetStyle;
      if (prevValue === value || Number.isNaN(value) || Number.isNaN(prevValue)) {
        unitNodes = [/* @__PURE__ */ reactExports.createElement(UnitNumber, Object.assign({}, props, {
          key: value,
          current: true
        }))];
        offsetStyle = {
          transition: "none"
        };
      } else {
        unitNodes = [];
        const end = value + 10;
        const unitNumberList = [];
        for (let index2 = value; index2 <= end; index2 += 1) {
          unitNumberList.push(index2);
        }
        const prevIndex = unitNumberList.findIndex((n2) => n2 % 10 === prevValue);
        unitNodes = unitNumberList.map((n2, index2) => {
          const singleUnit = n2 % 10;
          return /* @__PURE__ */ reactExports.createElement(UnitNumber, Object.assign({}, props, {
            key: n2,
            value: singleUnit,
            offset: index2 - prevIndex,
            current: index2 === prevIndex
          }));
        });
        const unit2 = prevCount < count ? 1 : -1;
        offsetStyle = {
          transform: `translateY(${-getOffset$2(prevValue, value, unit2)}00%)`
        };
      }
      return /* @__PURE__ */ reactExports.createElement("span", {
        className: `${prefixCls}-only`,
        style: offsetStyle,
        onTransitionEnd
      }, unitNodes);
    }
    var __rest$y = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const ScrollNumber = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        prefixCls: customizePrefixCls,
        count,
        className,
        motionClassName,
        style: style2,
        title,
        show,
        component: Component = "sup",
        children
      } = props, restProps = __rest$y(props, ["prefixCls", "count", "className", "motionClassName", "style", "title", "show", "component", "children"]);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("scroll-number", customizePrefixCls);
      const newProps = Object.assign(Object.assign({}, restProps), {
        "data-show": show,
        style: style2,
        className: classNames(prefixCls, className, motionClassName),
        title
      });
      let numberNodes = count;
      if (count && Number(count) % 1 === 0) {
        const numberList = String(count).split("");
        numberNodes = /* @__PURE__ */ reactExports.createElement("bdi", null, numberList.map((num, i) => /* @__PURE__ */ reactExports.createElement(SingleNumber, {
          prefixCls,
          count: Number(count),
          value: num,
          // eslint-disable-next-line react/no-array-index-key
          key: numberList.length - i
        })));
      }
      if (style2 && style2.borderColor) {
        newProps.style = Object.assign(Object.assign({}, style2), {
          boxShadow: `0 0 0 1px ${style2.borderColor} inset`
        });
      }
      if (children) {
        return cloneElement(children, (oriProps) => ({
          className: classNames(`${prefixCls}-custom-component`, oriProps === null || oriProps === void 0 ? void 0 : oriProps.className, motionClassName)
        }));
      }
      return /* @__PURE__ */ reactExports.createElement(Component, Object.assign({}, newProps, {
        ref
      }), numberNodes);
    });
    const ScrollNumber$1 = ScrollNumber;
    var __rest$x = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const InternalBadge = (props, ref) => {
      var _a, _b, _c, _d, _e;
      const {
        prefixCls: customizePrefixCls,
        scrollNumberPrefixCls: customizeScrollNumberPrefixCls,
        children,
        status,
        text,
        color,
        count = null,
        overflowCount = 99,
        dot = false,
        size = "default",
        title,
        offset: offset2,
        style: style2,
        className,
        rootClassName,
        classNames: classNames$1,
        styles,
        showZero = false
      } = props, restProps = __rest$x(props, ["prefixCls", "scrollNumberPrefixCls", "children", "status", "text", "color", "count", "overflowCount", "dot", "size", "title", "offset", "style", "className", "rootClassName", "classNames", "styles", "showZero"]);
      const {
        getPrefixCls,
        direction,
        badge
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("badge", customizePrefixCls);
      const [wrapCSSVar, hashId] = useStyle$g(prefixCls);
      const numberedDisplayCount = count > overflowCount ? `${overflowCount}+` : count;
      const isZero = numberedDisplayCount === "0" || numberedDisplayCount === 0;
      const ignoreCount = count === null || isZero && !showZero;
      const hasStatus = (status !== null && status !== void 0 || color !== null && color !== void 0) && ignoreCount;
      const showAsDot = dot && !isZero;
      const mergedCount = showAsDot ? "" : numberedDisplayCount;
      const isHidden = reactExports.useMemo(() => {
        const isEmpty = mergedCount === null || mergedCount === void 0 || mergedCount === "";
        return (isEmpty || isZero && !showZero) && !showAsDot;
      }, [mergedCount, isZero, showZero, showAsDot]);
      const countRef = reactExports.useRef(count);
      if (!isHidden) {
        countRef.current = count;
      }
      const livingCount = countRef.current;
      const displayCountRef = reactExports.useRef(mergedCount);
      if (!isHidden) {
        displayCountRef.current = mergedCount;
      }
      const displayCount = displayCountRef.current;
      const isDotRef = reactExports.useRef(showAsDot);
      if (!isHidden) {
        isDotRef.current = showAsDot;
      }
      const mergedStyle = reactExports.useMemo(() => {
        if (!offset2) {
          return Object.assign(Object.assign({}, badge === null || badge === void 0 ? void 0 : badge.style), style2);
        }
        const offsetStyle = {
          marginTop: offset2[1]
        };
        if (direction === "rtl") {
          offsetStyle.left = parseInt(offset2[0], 10);
        } else {
          offsetStyle.right = -parseInt(offset2[0], 10);
        }
        return Object.assign(Object.assign(Object.assign({}, offsetStyle), badge === null || badge === void 0 ? void 0 : badge.style), style2);
      }, [direction, offset2, style2, badge === null || badge === void 0 ? void 0 : badge.style]);
      const titleNode = title !== null && title !== void 0 ? title : typeof livingCount === "string" || typeof livingCount === "number" ? livingCount : void 0;
      const statusTextNode = isHidden || !text ? null : /* @__PURE__ */ reactExports.createElement("span", {
        className: `${prefixCls}-status-text`
      }, text);
      const displayNode = !livingCount || typeof livingCount !== "object" ? void 0 : cloneElement(livingCount, (oriProps) => ({
        style: Object.assign(Object.assign({}, mergedStyle), oriProps.style)
      }));
      const isInternalColor = isPresetColor(color, false);
      const statusCls = classNames(classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.indicator, (_a = badge === null || badge === void 0 ? void 0 : badge.classNames) === null || _a === void 0 ? void 0 : _a.indicator, {
        [`${prefixCls}-status-dot`]: hasStatus,
        [`${prefixCls}-status-${status}`]: !!status,
        [`${prefixCls}-color-${color}`]: isInternalColor
      });
      const statusStyle = {};
      if (color && !isInternalColor) {
        statusStyle.color = color;
        statusStyle.background = color;
      }
      const badgeClassName = classNames(prefixCls, {
        [`${prefixCls}-status`]: hasStatus,
        [`${prefixCls}-not-a-wrapper`]: !children,
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, className, rootClassName, badge === null || badge === void 0 ? void 0 : badge.className, (_b = badge === null || badge === void 0 ? void 0 : badge.classNames) === null || _b === void 0 ? void 0 : _b.root, classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.root, hashId);
      if (!children && hasStatus) {
        const statusTextColor = mergedStyle.color;
        return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("span", Object.assign({}, restProps, {
          className: badgeClassName,
          style: Object.assign(Object.assign(Object.assign({}, styles === null || styles === void 0 ? void 0 : styles.root), (_c = badge === null || badge === void 0 ? void 0 : badge.styles) === null || _c === void 0 ? void 0 : _c.root), mergedStyle)
        }), /* @__PURE__ */ reactExports.createElement("span", {
          className: statusCls,
          style: Object.assign(Object.assign(Object.assign({}, styles === null || styles === void 0 ? void 0 : styles.indicator), (_d = badge === null || badge === void 0 ? void 0 : badge.styles) === null || _d === void 0 ? void 0 : _d.indicator), statusStyle)
        }), text && /* @__PURE__ */ reactExports.createElement("span", {
          style: {
            color: statusTextColor
          },
          className: `${prefixCls}-status-text`
        }, text)));
      }
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("span", Object.assign({
        ref
      }, restProps, {
        className: badgeClassName,
        style: Object.assign(Object.assign({}, (_e = badge === null || badge === void 0 ? void 0 : badge.styles) === null || _e === void 0 ? void 0 : _e.root), styles === null || styles === void 0 ? void 0 : styles.root)
      }), children, /* @__PURE__ */ reactExports.createElement(CSSMotion, {
        visible: !isHidden,
        motionName: `${prefixCls}-zoom`,
        motionAppear: false,
        motionDeadline: 1e3
      }, (_ref) => {
        let {
          className: motionClassName,
          ref: scrollNumberRef
        } = _ref;
        var _a2, _b2;
        const scrollNumberPrefixCls = getPrefixCls("scroll-number", customizeScrollNumberPrefixCls);
        const isDot = isDotRef.current;
        const scrollNumberCls = classNames(classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.indicator, (_a2 = badge === null || badge === void 0 ? void 0 : badge.classNames) === null || _a2 === void 0 ? void 0 : _a2.indicator, {
          [`${prefixCls}-dot`]: isDot,
          [`${prefixCls}-count`]: !isDot,
          [`${prefixCls}-count-sm`]: size === "small",
          [`${prefixCls}-multiple-words`]: !isDot && displayCount && displayCount.toString().length > 1,
          [`${prefixCls}-status-${status}`]: !!status,
          [`${prefixCls}-color-${color}`]: isInternalColor
        });
        let scrollNumberStyle = Object.assign(Object.assign(Object.assign({}, styles === null || styles === void 0 ? void 0 : styles.indicator), (_b2 = badge === null || badge === void 0 ? void 0 : badge.styles) === null || _b2 === void 0 ? void 0 : _b2.indicator), mergedStyle);
        if (color && !isInternalColor) {
          scrollNumberStyle = scrollNumberStyle || {};
          scrollNumberStyle.background = color;
        }
        return /* @__PURE__ */ reactExports.createElement(ScrollNumber$1, {
          prefixCls: scrollNumberPrefixCls,
          show: !isHidden,
          motionClassName,
          className: scrollNumberCls,
          count: displayCount,
          title: titleNode,
          style: scrollNumberStyle,
          key: "scrollNumber",
          ref: scrollNumberRef
        }, displayNode);
      }), statusTextNode));
    };
    const Badge = /* @__PURE__ */ reactExports.forwardRef(InternalBadge);
    Badge.Ribbon = Ribbon$1;
    const Badge$1 = Badge;
    var RightOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z" } }] }, "name": "right", "theme": "outlined" };
    const RightOutlinedSvg = RightOutlined$2;
    var RightOutlined = function RightOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: RightOutlinedSvg
      }));
    };
    const RightOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(RightOutlined);
    var ESC$1 = KeyCode.ESC, TAB = KeyCode.TAB;
    function useAccessibility$1(_ref) {
      var visible = _ref.visible, triggerRef = _ref.triggerRef, onVisibleChange = _ref.onVisibleChange, autoFocus = _ref.autoFocus, overlayRef = _ref.overlayRef;
      var focusMenuRef = reactExports.useRef(false);
      var handleCloseMenuAndReturnFocus = function handleCloseMenuAndReturnFocus2() {
        if (visible) {
          var _triggerRef$current, _triggerRef$current$f;
          (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : (_triggerRef$current$f = _triggerRef$current.focus) === null || _triggerRef$current$f === void 0 ? void 0 : _triggerRef$current$f.call(_triggerRef$current);
          onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(false);
        }
      };
      var focusMenu = function focusMenu2() {
        var _overlayRef$current;
        if ((_overlayRef$current = overlayRef.current) !== null && _overlayRef$current !== void 0 && _overlayRef$current.focus) {
          overlayRef.current.focus();
          focusMenuRef.current = true;
          return true;
        }
        return false;
      };
      var handleKeyDown = function handleKeyDown2(event) {
        switch (event.keyCode) {
          case ESC$1:
            handleCloseMenuAndReturnFocus();
            break;
          case TAB: {
            var focusResult = false;
            if (!focusMenuRef.current) {
              focusResult = focusMenu();
            }
            if (focusResult) {
              event.preventDefault();
            } else {
              handleCloseMenuAndReturnFocus();
            }
            break;
          }
        }
      };
      reactExports.useEffect(function() {
        if (visible) {
          window.addEventListener("keydown", handleKeyDown);
          if (autoFocus) {
            wrapperRaf(focusMenu, 3);
          }
          return function() {
            window.removeEventListener("keydown", handleKeyDown);
            focusMenuRef.current = false;
          };
        }
        return function() {
          focusMenuRef.current = false;
        };
      }, [visible]);
    }
    var Overlay = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var overlay = props.overlay, arrow = props.arrow, prefixCls = props.prefixCls;
      var overlayNode = reactExports.useMemo(function() {
        var overlayElement;
        if (typeof overlay === "function") {
          overlayElement = overlay();
        } else {
          overlayElement = overlay;
        }
        return overlayElement;
      }, [overlay]);
      var composedRef = composeRef(ref, overlayNode === null || overlayNode === void 0 ? void 0 : overlayNode.ref);
      return /* @__PURE__ */ React.createElement(React.Fragment, null, arrow && /* @__PURE__ */ React.createElement("div", {
        className: "".concat(prefixCls, "-arrow")
      }), /* @__PURE__ */ React.cloneElement(overlayNode, {
        ref: supportRef(overlayNode) ? composedRef : void 0
      }));
    });
    var autoAdjustOverflow$1 = {
      adjustX: 1,
      adjustY: 1
    };
    var targetOffset = [0, 0];
    var placements$1 = {
      topLeft: {
        points: ["bl", "tl"],
        overflow: autoAdjustOverflow$1,
        offset: [0, -4],
        targetOffset
      },
      top: {
        points: ["bc", "tc"],
        overflow: autoAdjustOverflow$1,
        offset: [0, -4],
        targetOffset
      },
      topRight: {
        points: ["br", "tr"],
        overflow: autoAdjustOverflow$1,
        offset: [0, -4],
        targetOffset
      },
      bottomLeft: {
        points: ["tl", "bl"],
        overflow: autoAdjustOverflow$1,
        offset: [0, 4],
        targetOffset
      },
      bottom: {
        points: ["tc", "bc"],
        overflow: autoAdjustOverflow$1,
        offset: [0, 4],
        targetOffset
      },
      bottomRight: {
        points: ["tr", "br"],
        overflow: autoAdjustOverflow$1,
        offset: [0, 4],
        targetOffset
      }
    };
    var _excluded$p = ["arrow", "prefixCls", "transitionName", "animation", "align", "placement", "placements", "getPopupContainer", "showAction", "hideAction", "overlayClassName", "overlayStyle", "visible", "trigger", "autoFocus", "overlay", "children", "onVisibleChange"];
    function Dropdown$3(props, ref) {
      var _children$props;
      var _props$arrow = props.arrow, arrow = _props$arrow === void 0 ? false : _props$arrow, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-dropdown" : _props$prefixCls, transitionName = props.transitionName, animation = props.animation, align = props.align, _props$placement = props.placement, placement = _props$placement === void 0 ? "bottomLeft" : _props$placement, _props$placements = props.placements, placements2 = _props$placements === void 0 ? placements$1 : _props$placements, getPopupContainer = props.getPopupContainer, showAction = props.showAction, hideAction = props.hideAction, overlayClassName = props.overlayClassName, overlayStyle = props.overlayStyle, visible = props.visible, _props$trigger = props.trigger, trigger = _props$trigger === void 0 ? ["hover"] : _props$trigger, autoFocus = props.autoFocus, overlay = props.overlay, children = props.children, onVisibleChange = props.onVisibleChange, otherProps = _objectWithoutProperties(props, _excluded$p);
      var _React$useState = React.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), triggerVisible = _React$useState2[0], setTriggerVisible = _React$useState2[1];
      var mergedVisible = "visible" in props ? visible : triggerVisible;
      var triggerRef = React.useRef(null);
      var overlayRef = React.useRef(null);
      var childRef = React.useRef(null);
      React.useImperativeHandle(ref, function() {
        return triggerRef.current;
      });
      var handleVisibleChange = function handleVisibleChange2(newVisible) {
        setTriggerVisible(newVisible);
        onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(newVisible);
      };
      useAccessibility$1({
        visible: mergedVisible,
        triggerRef: childRef,
        onVisibleChange: handleVisibleChange,
        autoFocus,
        overlayRef
      });
      var onClick = function onClick2(e2) {
        var onOverlayClick = props.onOverlayClick;
        setTriggerVisible(false);
        if (onOverlayClick) {
          onOverlayClick(e2);
        }
      };
      var getMenuElement = function getMenuElement2() {
        return /* @__PURE__ */ React.createElement(Overlay, {
          ref: overlayRef,
          overlay,
          prefixCls,
          arrow
        });
      };
      var getMenuElementOrLambda = function getMenuElementOrLambda2() {
        if (typeof overlay === "function") {
          return getMenuElement;
        }
        return getMenuElement();
      };
      var getMinOverlayWidthMatchTrigger = function getMinOverlayWidthMatchTrigger2() {
        var minOverlayWidthMatchTrigger = props.minOverlayWidthMatchTrigger, alignPoint = props.alignPoint;
        if ("minOverlayWidthMatchTrigger" in props) {
          return minOverlayWidthMatchTrigger;
        }
        return !alignPoint;
      };
      var getOpenClassName = function getOpenClassName2() {
        var openClassName = props.openClassName;
        if (openClassName !== void 0) {
          return openClassName;
        }
        return "".concat(prefixCls, "-open");
      };
      var childrenNode = /* @__PURE__ */ React.cloneElement(children, {
        className: classNames((_children$props = children.props) === null || _children$props === void 0 ? void 0 : _children$props.className, mergedVisible && getOpenClassName()),
        ref: supportRef(children) ? composeRef(childRef, children.ref) : void 0
      });
      var triggerHideAction = hideAction;
      if (!triggerHideAction && trigger.indexOf("contextMenu") !== -1) {
        triggerHideAction = ["click"];
      }
      return /* @__PURE__ */ React.createElement(Trigger, _extends$1({
        builtinPlacements: placements2
      }, otherProps, {
        prefixCls,
        ref: triggerRef,
        popupClassName: classNames(overlayClassName, _defineProperty({}, "".concat(prefixCls, "-show-arrow"), arrow)),
        popupStyle: overlayStyle,
        action: trigger,
        showAction,
        hideAction: triggerHideAction,
        popupPlacement: placement,
        popupAlign: align,
        popupTransitionName: transitionName,
        popupAnimation: animation,
        popupVisible: mergedVisible,
        stretch: getMinOverlayWidthMatchTrigger() ? "minWidth" : "",
        popup: getMenuElementOrLambda(),
        onPopupVisibleChange: handleVisibleChange,
        onPopupClick: onClick,
        getPopupContainer
      }), childrenNode);
    }
    const Dropdown$4 = /* @__PURE__ */ React.forwardRef(Dropdown$3);
    var IdContext = /* @__PURE__ */ reactExports.createContext(null);
    function getMenuId(uuid2, eventKey) {
      if (uuid2 === void 0) {
        return null;
      }
      return "".concat(uuid2, "-").concat(eventKey);
    }
    function useMenuId(eventKey) {
      var id2 = reactExports.useContext(IdContext);
      return getMenuId(id2, eventKey);
    }
    var _excluded$o = ["children", "locked"];
    var MenuContext$2 = /* @__PURE__ */ reactExports.createContext(null);
    function mergeProps(origin, target) {
      var clone2 = _objectSpread2({}, origin);
      Object.keys(target).forEach(function(key) {
        var value = target[key];
        if (value !== void 0) {
          clone2[key] = value;
        }
      });
      return clone2;
    }
    function InheritableContextProvider(_ref) {
      var children = _ref.children, locked = _ref.locked, restProps = _objectWithoutProperties(_ref, _excluded$o);
      var context = reactExports.useContext(MenuContext$2);
      var inheritableContext = useMemo(function() {
        return mergeProps(context, restProps);
      }, [context, restProps], function(prev2, next2) {
        return !locked && (prev2[0] !== next2[0] || !isEqual$1(prev2[1], next2[1], true));
      });
      return /* @__PURE__ */ reactExports.createElement(MenuContext$2.Provider, {
        value: inheritableContext
      }, children);
    }
    var EmptyList = [];
    var PathRegisterContext = /* @__PURE__ */ reactExports.createContext(null);
    function useMeasure() {
      return reactExports.useContext(PathRegisterContext);
    }
    var PathTrackerContext = /* @__PURE__ */ reactExports.createContext(EmptyList);
    function useFullPath(eventKey) {
      var parentKeyPath = reactExports.useContext(PathTrackerContext);
      return reactExports.useMemo(function() {
        return eventKey !== void 0 ? [].concat(_toConsumableArray(parentKeyPath), [eventKey]) : parentKeyPath;
      }, [parentKeyPath, eventKey]);
    }
    var PathUserContext = /* @__PURE__ */ reactExports.createContext(null);
    var PrivateContext = /* @__PURE__ */ reactExports.createContext({});
    function focusable(node2) {
      var includePositive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (isVisible(node2)) {
        var nodeName = node2.nodeName.toLowerCase();
        var isFocusableElement = (
          // Focusable element
          ["input", "select", "textarea", "button"].includes(nodeName) || // Editable element
          node2.isContentEditable || // Anchor with href element
          nodeName === "a" && !!node2.getAttribute("href")
        );
        var tabIndexAttr = node2.getAttribute("tabindex");
        var tabIndexNum = Number(tabIndexAttr);
        var tabIndex = null;
        if (tabIndexAttr && !Number.isNaN(tabIndexNum)) {
          tabIndex = tabIndexNum;
        } else if (isFocusableElement && tabIndex === null) {
          tabIndex = 0;
        }
        if (isFocusableElement && node2.disabled) {
          tabIndex = null;
        }
        return tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);
      }
      return false;
    }
    function getFocusNodeList(node2) {
      var includePositive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var res = _toConsumableArray(node2.querySelectorAll("*")).filter(function(child) {
        return focusable(child, includePositive);
      });
      if (focusable(node2, includePositive)) {
        res.unshift(node2);
      }
      return res;
    }
    var LEFT = KeyCode.LEFT, RIGHT = KeyCode.RIGHT, UP = KeyCode.UP, DOWN = KeyCode.DOWN, ENTER = KeyCode.ENTER, ESC = KeyCode.ESC, HOME = KeyCode.HOME, END = KeyCode.END;
    var ArrowKeys = [UP, DOWN, LEFT, RIGHT];
    function getOffset$1(mode, isRootLevel, isRtl, which) {
      var _inline, _horizontal, _vertical, _offsets;
      var prev2 = "prev";
      var next2 = "next";
      var children = "children";
      var parent = "parent";
      if (mode === "inline" && which === ENTER) {
        return {
          inlineTrigger: true
        };
      }
      var inline2 = (_inline = {}, _defineProperty(_inline, UP, prev2), _defineProperty(_inline, DOWN, next2), _inline);
      var horizontal = (_horizontal = {}, _defineProperty(_horizontal, LEFT, isRtl ? next2 : prev2), _defineProperty(_horizontal, RIGHT, isRtl ? prev2 : next2), _defineProperty(_horizontal, DOWN, children), _defineProperty(_horizontal, ENTER, children), _horizontal);
      var vertical = (_vertical = {}, _defineProperty(_vertical, UP, prev2), _defineProperty(_vertical, DOWN, next2), _defineProperty(_vertical, ENTER, children), _defineProperty(_vertical, ESC, parent), _defineProperty(_vertical, LEFT, isRtl ? children : parent), _defineProperty(_vertical, RIGHT, isRtl ? parent : children), _vertical);
      var offsets = {
        inline: inline2,
        horizontal,
        vertical,
        inlineSub: inline2,
        horizontalSub: vertical,
        verticalSub: vertical
      };
      var type = (_offsets = offsets["".concat(mode).concat(isRootLevel ? "" : "Sub")]) === null || _offsets === void 0 ? void 0 : _offsets[which];
      switch (type) {
        case prev2:
          return {
            offset: -1,
            sibling: true
          };
        case next2:
          return {
            offset: 1,
            sibling: true
          };
        case parent:
          return {
            offset: -1,
            sibling: false
          };
        case children:
          return {
            offset: 1,
            sibling: false
          };
        default:
          return null;
      }
    }
    function findContainerUL(element) {
      var current = element;
      while (current) {
        if (current.getAttribute("data-menu-list")) {
          return current;
        }
        current = current.parentElement;
      }
      return null;
    }
    function getFocusElement(activeElement, elements) {
      var current = activeElement || document.activeElement;
      while (current) {
        if (elements.has(current)) {
          return current;
        }
        current = current.parentElement;
      }
      return null;
    }
    function getFocusableElements(container, elements) {
      var list = getFocusNodeList(container, true);
      return list.filter(function(ele) {
        return elements.has(ele);
      });
    }
    function getNextFocusElement(parentQueryContainer, elements, focusMenuElement) {
      var offset2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
      if (!parentQueryContainer) {
        return null;
      }
      var sameLevelFocusableMenuElementList = getFocusableElements(parentQueryContainer, elements);
      var count = sameLevelFocusableMenuElementList.length;
      var focusIndex = sameLevelFocusableMenuElementList.findIndex(function(ele) {
        return focusMenuElement === ele;
      });
      if (offset2 < 0) {
        if (focusIndex === -1) {
          focusIndex = count - 1;
        } else {
          focusIndex -= 1;
        }
      } else if (offset2 > 0) {
        focusIndex += 1;
      }
      focusIndex = (focusIndex + count) % count;
      return sameLevelFocusableMenuElementList[focusIndex];
    }
    var refreshElements = function refreshElements2(keys2, id2) {
      var elements = /* @__PURE__ */ new Set();
      var key2element = /* @__PURE__ */ new Map();
      var element2key = /* @__PURE__ */ new Map();
      keys2.forEach(function(key) {
        var element = document.querySelector("[data-menu-id='".concat(getMenuId(id2, key), "']"));
        if (element) {
          elements.add(element);
          element2key.set(element, key);
          key2element.set(key, element);
        }
      });
      return {
        elements,
        key2element,
        element2key
      };
    };
    function useAccessibility(mode, activeKey, isRtl, id2, containerRef, getKeys, getKeyPath, triggerActiveKey, triggerAccessibilityOpen, originOnKeyDown) {
      var rafRef = reactExports.useRef();
      var activeRef = reactExports.useRef();
      activeRef.current = activeKey;
      var cleanRaf = function cleanRaf2() {
        wrapperRaf.cancel(rafRef.current);
      };
      reactExports.useEffect(function() {
        return function() {
          cleanRaf();
        };
      }, []);
      return function(e2) {
        var which = e2.which;
        if ([].concat(ArrowKeys, [ENTER, ESC, HOME, END]).includes(which)) {
          var keys2 = getKeys();
          var refreshedElements = refreshElements(keys2, id2);
          var _refreshedElements = refreshedElements, elements = _refreshedElements.elements, key2element = _refreshedElements.key2element, element2key = _refreshedElements.element2key;
          var activeElement = key2element.get(activeKey);
          var focusMenuElement = getFocusElement(activeElement, elements);
          var focusMenuKey = element2key.get(focusMenuElement);
          var offsetObj = getOffset$1(mode, getKeyPath(focusMenuKey, true).length === 1, isRtl, which);
          if (!offsetObj && which !== HOME && which !== END) {
            return;
          }
          if (ArrowKeys.includes(which) || [HOME, END].includes(which)) {
            e2.preventDefault();
          }
          var tryFocus = function tryFocus2(menuElement) {
            if (menuElement) {
              var focusTargetElement = menuElement;
              var link = menuElement.querySelector("a");
              if (link !== null && link !== void 0 && link.getAttribute("href")) {
                focusTargetElement = link;
              }
              var targetKey = element2key.get(menuElement);
              triggerActiveKey(targetKey);
              cleanRaf();
              rafRef.current = wrapperRaf(function() {
                if (activeRef.current === targetKey) {
                  focusTargetElement.focus();
                }
              });
            }
          };
          if ([HOME, END].includes(which) || offsetObj.sibling || !focusMenuElement) {
            var parentQueryContainer;
            if (!focusMenuElement || mode === "inline") {
              parentQueryContainer = containerRef.current;
            } else {
              parentQueryContainer = findContainerUL(focusMenuElement);
            }
            var targetElement;
            var focusableElements = getFocusableElements(parentQueryContainer, elements);
            if (which === HOME) {
              targetElement = focusableElements[0];
            } else if (which === END) {
              targetElement = focusableElements[focusableElements.length - 1];
            } else {
              targetElement = getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offsetObj.offset);
            }
            tryFocus(targetElement);
          } else if (offsetObj.inlineTrigger) {
            triggerAccessibilityOpen(focusMenuKey);
          } else if (offsetObj.offset > 0) {
            triggerAccessibilityOpen(focusMenuKey, true);
            cleanRaf();
            rafRef.current = wrapperRaf(function() {
              refreshedElements = refreshElements(keys2, id2);
              var controlId = focusMenuElement.getAttribute("aria-controls");
              var subQueryContainer = document.getElementById(controlId);
              var targetElement2 = getNextFocusElement(subQueryContainer, refreshedElements.elements);
              tryFocus(targetElement2);
            }, 5);
          } else if (offsetObj.offset < 0) {
            var keyPath = getKeyPath(focusMenuKey, true);
            var parentKey = keyPath[keyPath.length - 2];
            var parentMenuElement = key2element.get(parentKey);
            triggerAccessibilityOpen(parentKey, false);
            tryFocus(parentMenuElement);
          }
        }
        originOnKeyDown === null || originOnKeyDown === void 0 || originOnKeyDown(e2);
      };
    }
    function nextSlice(callback) {
      Promise.resolve().then(callback);
    }
    var PATH_SPLIT = "__RC_UTIL_PATH_SPLIT__";
    var getPathStr = function getPathStr2(keyPath) {
      return keyPath.join(PATH_SPLIT);
    };
    var getPathKeys = function getPathKeys2(keyPathStr) {
      return keyPathStr.split(PATH_SPLIT);
    };
    var OVERFLOW_KEY = "rc-menu-more";
    function useKeyRecords() {
      var _React$useState = reactExports.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), internalForceUpdate = _React$useState2[1];
      var key2pathRef = reactExports.useRef(/* @__PURE__ */ new Map());
      var path2keyRef = reactExports.useRef(/* @__PURE__ */ new Map());
      var _React$useState3 = reactExports.useState([]), _React$useState4 = _slicedToArray(_React$useState3, 2), overflowKeys = _React$useState4[0], setOverflowKeys = _React$useState4[1];
      var updateRef = reactExports.useRef(0);
      var destroyRef = reactExports.useRef(false);
      var forceUpdate = function forceUpdate2() {
        if (!destroyRef.current) {
          internalForceUpdate({});
        }
      };
      var registerPath = reactExports.useCallback(function(key, keyPath) {
        var connectedPath = getPathStr(keyPath);
        path2keyRef.current.set(connectedPath, key);
        key2pathRef.current.set(key, connectedPath);
        updateRef.current += 1;
        var id2 = updateRef.current;
        nextSlice(function() {
          if (id2 === updateRef.current) {
            forceUpdate();
          }
        });
      }, []);
      var unregisterPath = reactExports.useCallback(function(key, keyPath) {
        var connectedPath = getPathStr(keyPath);
        path2keyRef.current.delete(connectedPath);
        key2pathRef.current.delete(key);
      }, []);
      var refreshOverflowKeys = reactExports.useCallback(function(keys2) {
        setOverflowKeys(keys2);
      }, []);
      var getKeyPath = reactExports.useCallback(function(eventKey, includeOverflow) {
        var fullPath = key2pathRef.current.get(eventKey) || "";
        var keys2 = getPathKeys(fullPath);
        if (includeOverflow && overflowKeys.includes(keys2[0])) {
          keys2.unshift(OVERFLOW_KEY);
        }
        return keys2;
      }, [overflowKeys]);
      var isSubPathKey = reactExports.useCallback(function(pathKeys, eventKey) {
        return pathKeys.some(function(pathKey) {
          var pathKeyList = getKeyPath(pathKey, true);
          return pathKeyList.includes(eventKey);
        });
      }, [getKeyPath]);
      var getKeys = function getKeys2() {
        var keys2 = _toConsumableArray(key2pathRef.current.keys());
        if (overflowKeys.length) {
          keys2.push(OVERFLOW_KEY);
        }
        return keys2;
      };
      var getSubPathKeys = reactExports.useCallback(function(key) {
        var connectedPath = "".concat(key2pathRef.current.get(key)).concat(PATH_SPLIT);
        var pathKeys = /* @__PURE__ */ new Set();
        _toConsumableArray(path2keyRef.current.keys()).forEach(function(pathKey) {
          if (pathKey.startsWith(connectedPath)) {
            pathKeys.add(path2keyRef.current.get(pathKey));
          }
        });
        return pathKeys;
      }, []);
      reactExports.useEffect(function() {
        return function() {
          destroyRef.current = true;
        };
      }, []);
      return {
        // Register
        registerPath,
        unregisterPath,
        refreshOverflowKeys,
        // Util
        isSubPathKey,
        getKeyPath,
        getKeys,
        getSubPathKeys
      };
    }
    function useMemoCallback(func) {
      var funRef = reactExports.useRef(func);
      funRef.current = func;
      var callback = reactExports.useCallback(function() {
        var _funRef$current;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return (_funRef$current = funRef.current) === null || _funRef$current === void 0 ? void 0 : _funRef$current.call.apply(_funRef$current, [funRef].concat(args));
      }, []);
      return func ? callback : void 0;
    }
    var uniquePrefix = Math.random().toFixed(5).toString().slice(2);
    var internalId = 0;
    function useUUID(id2) {
      var _useMergedState = useMergedState(id2, {
        value: id2
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), uuid2 = _useMergedState2[0], setUUID = _useMergedState2[1];
      reactExports.useEffect(function() {
        internalId += 1;
        var newId = "".concat(uniquePrefix, "-").concat(internalId);
        setUUID("rc-menu-uuid-".concat(newId));
      }, []);
      return uuid2;
    }
    function useActive(eventKey, disabled, onMouseEnter, onMouseLeave) {
      var _React$useContext = reactExports.useContext(MenuContext$2), activeKey = _React$useContext.activeKey, onActive = _React$useContext.onActive, onInactive = _React$useContext.onInactive;
      var ret = {
        active: activeKey === eventKey
      };
      if (!disabled) {
        ret.onMouseEnter = function(domEvent) {
          onMouseEnter === null || onMouseEnter === void 0 || onMouseEnter({
            key: eventKey,
            domEvent
          });
          onActive(eventKey);
        };
        ret.onMouseLeave = function(domEvent) {
          onMouseLeave === null || onMouseLeave === void 0 || onMouseLeave({
            key: eventKey,
            domEvent
          });
          onInactive(eventKey);
        };
      }
      return ret;
    }
    function useDirectionStyle(level) {
      var _React$useContext = reactExports.useContext(MenuContext$2), mode = _React$useContext.mode, rtl = _React$useContext.rtl, inlineIndent = _React$useContext.inlineIndent;
      if (mode !== "inline") {
        return null;
      }
      var len = level;
      return rtl ? {
        paddingRight: len * inlineIndent
      } : {
        paddingLeft: len * inlineIndent
      };
    }
    function Icon(_ref) {
      var icon = _ref.icon, props = _ref.props, children = _ref.children;
      var iconNode;
      if (icon === null || icon === false) {
        return null;
      }
      if (typeof icon === "function") {
        iconNode = /* @__PURE__ */ reactExports.createElement(icon, _objectSpread2({}, props));
      } else if (typeof icon !== "boolean") {
        iconNode = icon;
      }
      return iconNode || children || null;
    }
    var _excluded$n = ["item"];
    function warnItemProp(_ref) {
      var item = _ref.item, restInfo = _objectWithoutProperties(_ref, _excluded$n);
      Object.defineProperty(restInfo, "item", {
        get: function get2() {
          warningOnce(false, "`info.item` is deprecated since we will move to function component that not provides React Node instance in future.");
          return item;
        }
      });
      return restInfo;
    }
    var _excluded$m = ["title", "attribute", "elementRef"], _excluded2$3 = ["style", "className", "eventKey", "warnKey", "disabled", "itemIcon", "children", "role", "onMouseEnter", "onMouseLeave", "onClick", "onKeyDown", "onFocus"], _excluded3 = ["active"];
    var LegacyMenuItem = /* @__PURE__ */ function(_React$Component) {
      _inherits(LegacyMenuItem2, _React$Component);
      var _super = _createSuper(LegacyMenuItem2);
      function LegacyMenuItem2() {
        _classCallCheck(this, LegacyMenuItem2);
        return _super.apply(this, arguments);
      }
      _createClass(LegacyMenuItem2, [{
        key: "render",
        value: function render2() {
          var _this$props = this.props, title = _this$props.title, attribute = _this$props.attribute, elementRef = _this$props.elementRef, restProps = _objectWithoutProperties(_this$props, _excluded$m);
          var passedProps = omit(restProps, ["eventKey", "popupClassName", "popupOffset", "onTitleClick"]);
          warningOnce(!attribute, "`attribute` of Menu.Item is deprecated. Please pass attribute directly.");
          return /* @__PURE__ */ reactExports.createElement(ForwardOverflow.Item, _extends$1({}, attribute, {
            title: typeof title === "string" ? title : void 0
          }, passedProps, {
            ref: elementRef
          }));
        }
      }]);
      return LegacyMenuItem2;
    }(reactExports.Component);
    var InternalMenuItem = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var _classNames;
      var style2 = props.style, className = props.className, eventKey = props.eventKey;
      props.warnKey;
      var disabled = props.disabled, itemIcon = props.itemIcon, children = props.children, role = props.role, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onClick = props.onClick, onKeyDown2 = props.onKeyDown, onFocus = props.onFocus, restProps = _objectWithoutProperties(props, _excluded2$3);
      var domDataId = useMenuId(eventKey);
      var _React$useContext = reactExports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls, onItemClick = _React$useContext.onItemClick, contextDisabled = _React$useContext.disabled, overflowDisabled = _React$useContext.overflowDisabled, contextItemIcon = _React$useContext.itemIcon, selectedKeys = _React$useContext.selectedKeys, onActive = _React$useContext.onActive;
      var _React$useContext2 = reactExports.useContext(PrivateContext), _internalRenderMenuItem = _React$useContext2._internalRenderMenuItem;
      var itemCls = "".concat(prefixCls, "-item");
      var legacyMenuItemRef = reactExports.useRef();
      var elementRef = reactExports.useRef();
      var mergedDisabled = contextDisabled || disabled;
      var mergedEleRef = useComposeRef(ref, elementRef);
      var connectedKeys = useFullPath(eventKey);
      var getEventInfo = function getEventInfo2(e2) {
        return {
          key: eventKey,
          // Note: For legacy code is reversed which not like other antd component
          keyPath: _toConsumableArray(connectedKeys).reverse(),
          item: legacyMenuItemRef.current,
          domEvent: e2
        };
      };
      var mergedItemIcon = itemIcon || contextItemIcon;
      var _useActive = useActive(eventKey, mergedDisabled, onMouseEnter, onMouseLeave), active = _useActive.active, activeProps = _objectWithoutProperties(_useActive, _excluded3);
      var selected = selectedKeys.includes(eventKey);
      var directionStyle = useDirectionStyle(connectedKeys.length);
      var onInternalClick = function onInternalClick2(e2) {
        if (mergedDisabled) {
          return;
        }
        var info = getEventInfo(e2);
        onClick === null || onClick === void 0 || onClick(warnItemProp(info));
        onItemClick(info);
      };
      var onInternalKeyDown = function onInternalKeyDown2(e2) {
        onKeyDown2 === null || onKeyDown2 === void 0 || onKeyDown2(e2);
        if (e2.which === KeyCode.ENTER) {
          var info = getEventInfo(e2);
          onClick === null || onClick === void 0 || onClick(warnItemProp(info));
          onItemClick(info);
        }
      };
      var onInternalFocus = function onInternalFocus2(e2) {
        onActive(eventKey);
        onFocus === null || onFocus === void 0 || onFocus(e2);
      };
      var optionRoleProps = {};
      if (props.role === "option") {
        optionRoleProps["aria-selected"] = selected;
      }
      var renderNode = /* @__PURE__ */ reactExports.createElement(LegacyMenuItem, _extends$1({
        ref: legacyMenuItemRef,
        elementRef: mergedEleRef,
        role: role === null ? "none" : role || "menuitem",
        tabIndex: disabled ? null : -1,
        "data-menu-id": overflowDisabled && domDataId ? null : domDataId
      }, restProps, activeProps, optionRoleProps, {
        component: "li",
        "aria-disabled": disabled,
        style: _objectSpread2(_objectSpread2({}, directionStyle), style2),
        className: classNames(itemCls, (_classNames = {}, _defineProperty(_classNames, "".concat(itemCls, "-active"), active), _defineProperty(_classNames, "".concat(itemCls, "-selected"), selected), _defineProperty(_classNames, "".concat(itemCls, "-disabled"), mergedDisabled), _classNames), className),
        onClick: onInternalClick,
        onKeyDown: onInternalKeyDown,
        onFocus: onInternalFocus
      }), children, /* @__PURE__ */ reactExports.createElement(Icon, {
        props: _objectSpread2(_objectSpread2({}, props), {}, {
          isSelected: selected
        }),
        icon: mergedItemIcon
      }));
      if (_internalRenderMenuItem) {
        renderNode = _internalRenderMenuItem(renderNode, props, {
          selected
        });
      }
      return renderNode;
    });
    function MenuItem$1(props, ref) {
      var eventKey = props.eventKey;
      var measure = useMeasure();
      var connectedKeyPath = useFullPath(eventKey);
      reactExports.useEffect(function() {
        if (measure) {
          measure.registerPath(eventKey, connectedKeyPath);
          return function() {
            measure.unregisterPath(eventKey, connectedKeyPath);
          };
        }
      }, [connectedKeyPath]);
      if (measure) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(InternalMenuItem, _extends$1({}, props, {
        ref
      }));
    }
    const MenuItem$2 = /* @__PURE__ */ reactExports.forwardRef(MenuItem$1);
    var _excluded$l = ["className", "children"];
    var InternalSubMenuList = function InternalSubMenuList2(_ref, ref) {
      var className = _ref.className, children = _ref.children, restProps = _objectWithoutProperties(_ref, _excluded$l);
      var _React$useContext = reactExports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls, mode = _React$useContext.mode, rtl = _React$useContext.rtl;
      return /* @__PURE__ */ reactExports.createElement("ul", _extends$1({
        className: classNames(prefixCls, rtl && "".concat(prefixCls, "-rtl"), "".concat(prefixCls, "-sub"), "".concat(prefixCls, "-").concat(mode === "inline" ? "inline" : "vertical"), className),
        role: "menu"
      }, restProps, {
        "data-menu-list": true,
        ref
      }), children);
    };
    var SubMenuList = /* @__PURE__ */ reactExports.forwardRef(InternalSubMenuList);
    SubMenuList.displayName = "SubMenuList";
    function parseChildren(children, keyPath) {
      return toArray$a(children).map(function(child, index2) {
        if (/* @__PURE__ */ reactExports.isValidElement(child)) {
          var _eventKey, _child$props;
          var key = child.key;
          var eventKey = (_eventKey = (_child$props = child.props) === null || _child$props === void 0 ? void 0 : _child$props.eventKey) !== null && _eventKey !== void 0 ? _eventKey : key;
          var emptyKey = eventKey === null || eventKey === void 0;
          if (emptyKey) {
            eventKey = "tmp_key-".concat([].concat(_toConsumableArray(keyPath), [index2]).join("-"));
          }
          var cloneProps = {
            key: eventKey,
            eventKey
          };
          return /* @__PURE__ */ reactExports.cloneElement(child, cloneProps);
        }
        return child;
      });
    }
    var autoAdjustOverflow = {
      adjustX: 1,
      adjustY: 1
    };
    var placements = {
      topLeft: {
        points: ["bl", "tl"],
        overflow: autoAdjustOverflow
      },
      topRight: {
        points: ["br", "tr"],
        overflow: autoAdjustOverflow
      },
      bottomLeft: {
        points: ["tl", "bl"],
        overflow: autoAdjustOverflow
      },
      bottomRight: {
        points: ["tr", "br"],
        overflow: autoAdjustOverflow
      },
      leftTop: {
        points: ["tr", "tl"],
        overflow: autoAdjustOverflow
      },
      leftBottom: {
        points: ["br", "bl"],
        overflow: autoAdjustOverflow
      },
      rightTop: {
        points: ["tl", "tr"],
        overflow: autoAdjustOverflow
      },
      rightBottom: {
        points: ["bl", "br"],
        overflow: autoAdjustOverflow
      }
    };
    var placementsRtl = {
      topLeft: {
        points: ["bl", "tl"],
        overflow: autoAdjustOverflow
      },
      topRight: {
        points: ["br", "tr"],
        overflow: autoAdjustOverflow
      },
      bottomLeft: {
        points: ["tl", "bl"],
        overflow: autoAdjustOverflow
      },
      bottomRight: {
        points: ["tr", "br"],
        overflow: autoAdjustOverflow
      },
      rightTop: {
        points: ["tr", "tl"],
        overflow: autoAdjustOverflow
      },
      rightBottom: {
        points: ["br", "bl"],
        overflow: autoAdjustOverflow
      },
      leftTop: {
        points: ["tl", "tr"],
        overflow: autoAdjustOverflow
      },
      leftBottom: {
        points: ["bl", "br"],
        overflow: autoAdjustOverflow
      }
    };
    function getMotion(mode, motion, defaultMotions) {
      if (motion) {
        return motion;
      }
      if (defaultMotions) {
        return defaultMotions[mode] || defaultMotions.other;
      }
      return void 0;
    }
    var popupPlacementMap = {
      horizontal: "bottomLeft",
      vertical: "rightTop",
      "vertical-left": "rightTop",
      "vertical-right": "leftTop"
    };
    function PopupTrigger(_ref) {
      var prefixCls = _ref.prefixCls, visible = _ref.visible, children = _ref.children, popup = _ref.popup, popupStyle = _ref.popupStyle, popupClassName = _ref.popupClassName, popupOffset = _ref.popupOffset, disabled = _ref.disabled, mode = _ref.mode, onVisibleChange = _ref.onVisibleChange;
      var _React$useContext = reactExports.useContext(MenuContext$2), getPopupContainer = _React$useContext.getPopupContainer, rtl = _React$useContext.rtl, subMenuOpenDelay = _React$useContext.subMenuOpenDelay, subMenuCloseDelay = _React$useContext.subMenuCloseDelay, builtinPlacements = _React$useContext.builtinPlacements, triggerSubMenuAction = _React$useContext.triggerSubMenuAction, forceSubMenuRender = _React$useContext.forceSubMenuRender, rootClassName = _React$useContext.rootClassName, motion = _React$useContext.motion, defaultMotions = _React$useContext.defaultMotions;
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), innerVisible = _React$useState2[0], setInnerVisible = _React$useState2[1];
      var placement = rtl ? _objectSpread2(_objectSpread2({}, placementsRtl), builtinPlacements) : _objectSpread2(_objectSpread2({}, placements), builtinPlacements);
      var popupPlacement = popupPlacementMap[mode];
      var targetMotion = getMotion(mode, motion, defaultMotions);
      var targetMotionRef = reactExports.useRef(targetMotion);
      if (mode !== "inline") {
        targetMotionRef.current = targetMotion;
      }
      var mergedMotion = _objectSpread2(_objectSpread2({}, targetMotionRef.current), {}, {
        leavedClassName: "".concat(prefixCls, "-hidden"),
        removeOnLeave: false,
        motionAppear: true
      });
      var visibleRef = reactExports.useRef();
      reactExports.useEffect(function() {
        visibleRef.current = wrapperRaf(function() {
          setInnerVisible(visible);
        });
        return function() {
          wrapperRaf.cancel(visibleRef.current);
        };
      }, [visible]);
      return /* @__PURE__ */ reactExports.createElement(Trigger, {
        prefixCls,
        popupClassName: classNames("".concat(prefixCls, "-popup"), _defineProperty({}, "".concat(prefixCls, "-rtl"), rtl), popupClassName, rootClassName),
        stretch: mode === "horizontal" ? "minWidth" : null,
        getPopupContainer,
        builtinPlacements: placement,
        popupPlacement,
        popupVisible: innerVisible,
        popup,
        popupStyle,
        popupAlign: popupOffset && {
          offset: popupOffset
        },
        action: disabled ? [] : [triggerSubMenuAction],
        mouseEnterDelay: subMenuOpenDelay,
        mouseLeaveDelay: subMenuCloseDelay,
        onPopupVisibleChange: onVisibleChange,
        forceRender: forceSubMenuRender,
        popupMotion: mergedMotion,
        fresh: true
      }, children);
    }
    function InlineSubMenuList(_ref) {
      var id2 = _ref.id, open = _ref.open, keyPath = _ref.keyPath, children = _ref.children;
      var fixedMode = "inline";
      var _React$useContext = reactExports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls, forceSubMenuRender = _React$useContext.forceSubMenuRender, motion = _React$useContext.motion, defaultMotions = _React$useContext.defaultMotions, mode = _React$useContext.mode;
      var sameModeRef = reactExports.useRef(false);
      sameModeRef.current = mode === fixedMode;
      var _React$useState = reactExports.useState(!sameModeRef.current), _React$useState2 = _slicedToArray(_React$useState, 2), destroy = _React$useState2[0], setDestroy = _React$useState2[1];
      var mergedOpen = sameModeRef.current ? open : false;
      reactExports.useEffect(function() {
        if (sameModeRef.current) {
          setDestroy(false);
        }
      }, [mode]);
      var mergedMotion = _objectSpread2({}, getMotion(fixedMode, motion, defaultMotions));
      if (keyPath.length > 1) {
        mergedMotion.motionAppear = false;
      }
      var originOnVisibleChanged = mergedMotion.onVisibleChanged;
      mergedMotion.onVisibleChanged = function(newVisible) {
        if (!sameModeRef.current && !newVisible) {
          setDestroy(true);
        }
        return originOnVisibleChanged === null || originOnVisibleChanged === void 0 ? void 0 : originOnVisibleChanged(newVisible);
      };
      if (destroy) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(InheritableContextProvider, {
        mode: fixedMode,
        locked: !sameModeRef.current
      }, /* @__PURE__ */ reactExports.createElement(CSSMotion, _extends$1({
        visible: mergedOpen
      }, mergedMotion, {
        forceRender: forceSubMenuRender,
        removeOnLeave: false,
        leavedClassName: "".concat(prefixCls, "-hidden")
      }), function(_ref2) {
        var motionClassName = _ref2.className, motionStyle = _ref2.style;
        return /* @__PURE__ */ reactExports.createElement(SubMenuList, {
          id: id2,
          className: motionClassName,
          style: motionStyle
        }, children);
      }));
    }
    var _excluded$k = ["style", "className", "title", "eventKey", "warnKey", "disabled", "internalPopupClose", "children", "itemIcon", "expandIcon", "popupClassName", "popupOffset", "popupStyle", "onClick", "onMouseEnter", "onMouseLeave", "onTitleClick", "onTitleMouseEnter", "onTitleMouseLeave"], _excluded2$2 = ["active"];
    var InternalSubMenu = function InternalSubMenu2(props) {
      var _classNames;
      var style2 = props.style, className = props.className, title = props.title, eventKey = props.eventKey;
      props.warnKey;
      var disabled = props.disabled, internalPopupClose = props.internalPopupClose, children = props.children, itemIcon = props.itemIcon, expandIcon = props.expandIcon, popupClassName = props.popupClassName, popupOffset = props.popupOffset, popupStyle = props.popupStyle, onClick = props.onClick, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onTitleClick = props.onTitleClick, onTitleMouseEnter = props.onTitleMouseEnter, onTitleMouseLeave = props.onTitleMouseLeave, restProps = _objectWithoutProperties(props, _excluded$k);
      var domDataId = useMenuId(eventKey);
      var _React$useContext = reactExports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls, mode = _React$useContext.mode, openKeys = _React$useContext.openKeys, contextDisabled = _React$useContext.disabled, overflowDisabled = _React$useContext.overflowDisabled, activeKey = _React$useContext.activeKey, selectedKeys = _React$useContext.selectedKeys, contextItemIcon = _React$useContext.itemIcon, contextExpandIcon = _React$useContext.expandIcon, onItemClick = _React$useContext.onItemClick, onOpenChange = _React$useContext.onOpenChange, onActive = _React$useContext.onActive;
      var _React$useContext2 = reactExports.useContext(PrivateContext), _internalRenderSubMenuItem = _React$useContext2._internalRenderSubMenuItem;
      var _React$useContext3 = reactExports.useContext(PathUserContext), isSubPathKey = _React$useContext3.isSubPathKey;
      var connectedPath = useFullPath();
      var subMenuPrefixCls = "".concat(prefixCls, "-submenu");
      var mergedDisabled = contextDisabled || disabled;
      var elementRef = reactExports.useRef();
      var popupRef = reactExports.useRef();
      var mergedItemIcon = itemIcon !== null && itemIcon !== void 0 ? itemIcon : contextItemIcon;
      var mergedExpandIcon = expandIcon !== null && expandIcon !== void 0 ? expandIcon : contextExpandIcon;
      var originOpen = openKeys.includes(eventKey);
      var open = !overflowDisabled && originOpen;
      var childrenSelected = isSubPathKey(selectedKeys, eventKey);
      var _useActive = useActive(eventKey, mergedDisabled, onTitleMouseEnter, onTitleMouseLeave), active = _useActive.active, activeProps = _objectWithoutProperties(_useActive, _excluded2$2);
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), childrenActive = _React$useState2[0], setChildrenActive = _React$useState2[1];
      var triggerChildrenActive = function triggerChildrenActive2(newActive) {
        if (!mergedDisabled) {
          setChildrenActive(newActive);
        }
      };
      var onInternalMouseEnter = function onInternalMouseEnter2(domEvent) {
        triggerChildrenActive(true);
        onMouseEnter === null || onMouseEnter === void 0 || onMouseEnter({
          key: eventKey,
          domEvent
        });
      };
      var onInternalMouseLeave = function onInternalMouseLeave2(domEvent) {
        triggerChildrenActive(false);
        onMouseLeave === null || onMouseLeave === void 0 || onMouseLeave({
          key: eventKey,
          domEvent
        });
      };
      var mergedActive = reactExports.useMemo(function() {
        if (active) {
          return active;
        }
        if (mode !== "inline") {
          return childrenActive || isSubPathKey([activeKey], eventKey);
        }
        return false;
      }, [mode, active, activeKey, childrenActive, eventKey, isSubPathKey]);
      var directionStyle = useDirectionStyle(connectedPath.length);
      var onInternalTitleClick = function onInternalTitleClick2(e2) {
        if (mergedDisabled) {
          return;
        }
        onTitleClick === null || onTitleClick === void 0 || onTitleClick({
          key: eventKey,
          domEvent: e2
        });
        if (mode === "inline") {
          onOpenChange(eventKey, !originOpen);
        }
      };
      var onMergedItemClick = useMemoCallback(function(info) {
        onClick === null || onClick === void 0 || onClick(warnItemProp(info));
        onItemClick(info);
      });
      var onPopupVisibleChange = function onPopupVisibleChange2(newVisible) {
        if (mode !== "inline") {
          onOpenChange(eventKey, newVisible);
        }
      };
      var onInternalFocus = function onInternalFocus2() {
        onActive(eventKey);
      };
      var popupId = domDataId && "".concat(domDataId, "-popup");
      var titleNode = /* @__PURE__ */ reactExports.createElement("div", _extends$1({
        role: "menuitem",
        style: directionStyle,
        className: "".concat(subMenuPrefixCls, "-title"),
        tabIndex: mergedDisabled ? null : -1,
        ref: elementRef,
        title: typeof title === "string" ? title : null,
        "data-menu-id": overflowDisabled && domDataId ? null : domDataId,
        "aria-expanded": open,
        "aria-haspopup": true,
        "aria-controls": popupId,
        "aria-disabled": mergedDisabled,
        onClick: onInternalTitleClick,
        onFocus: onInternalFocus
      }, activeProps), title, /* @__PURE__ */ reactExports.createElement(Icon, {
        icon: mode !== "horizontal" ? mergedExpandIcon : void 0,
        props: _objectSpread2(_objectSpread2({}, props), {}, {
          isOpen: open,
          // [Legacy] Not sure why need this mark
          isSubMenu: true
        })
      }, /* @__PURE__ */ reactExports.createElement("i", {
        className: "".concat(subMenuPrefixCls, "-arrow")
      })));
      var triggerModeRef = reactExports.useRef(mode);
      if (mode !== "inline" && connectedPath.length > 1) {
        triggerModeRef.current = "vertical";
      } else {
        triggerModeRef.current = mode;
      }
      if (!overflowDisabled) {
        var triggerMode = triggerModeRef.current;
        titleNode = /* @__PURE__ */ reactExports.createElement(PopupTrigger, {
          mode: triggerMode,
          prefixCls: subMenuPrefixCls,
          visible: !internalPopupClose && open && mode !== "inline",
          popupClassName,
          popupOffset,
          popupStyle,
          popup: /* @__PURE__ */ reactExports.createElement(
            InheritableContextProvider,
            {
              mode: triggerMode === "horizontal" ? "vertical" : triggerMode
            },
            /* @__PURE__ */ reactExports.createElement(SubMenuList, {
              id: popupId,
              ref: popupRef
            }, children)
          ),
          disabled: mergedDisabled,
          onVisibleChange: onPopupVisibleChange
        }, titleNode);
      }
      var listNode = /* @__PURE__ */ reactExports.createElement(ForwardOverflow.Item, _extends$1({
        role: "none"
      }, restProps, {
        component: "li",
        style: style2,
        className: classNames(subMenuPrefixCls, "".concat(subMenuPrefixCls, "-").concat(mode), className, (_classNames = {}, _defineProperty(_classNames, "".concat(subMenuPrefixCls, "-open"), open), _defineProperty(_classNames, "".concat(subMenuPrefixCls, "-active"), mergedActive), _defineProperty(_classNames, "".concat(subMenuPrefixCls, "-selected"), childrenSelected), _defineProperty(_classNames, "".concat(subMenuPrefixCls, "-disabled"), mergedDisabled), _classNames)),
        onMouseEnter: onInternalMouseEnter,
        onMouseLeave: onInternalMouseLeave
      }), titleNode, !overflowDisabled && /* @__PURE__ */ reactExports.createElement(InlineSubMenuList, {
        id: popupId,
        open,
        keyPath: connectedPath
      }, children));
      if (_internalRenderSubMenuItem) {
        listNode = _internalRenderSubMenuItem(listNode, props, {
          selected: childrenSelected,
          active: mergedActive,
          open,
          disabled: mergedDisabled
        });
      }
      return /* @__PURE__ */ reactExports.createElement(InheritableContextProvider, {
        onItemClick: onMergedItemClick,
        mode: mode === "horizontal" ? "vertical" : mode,
        itemIcon: mergedItemIcon,
        expandIcon: mergedExpandIcon
      }, listNode);
    };
    function SubMenu$2(props) {
      var eventKey = props.eventKey, children = props.children;
      var connectedKeyPath = useFullPath(eventKey);
      var childList = parseChildren(children, connectedKeyPath);
      var measure = useMeasure();
      reactExports.useEffect(function() {
        if (measure) {
          measure.registerPath(eventKey, connectedKeyPath);
          return function() {
            measure.unregisterPath(eventKey, connectedKeyPath);
          };
        }
      }, [connectedKeyPath]);
      var renderNode;
      if (measure) {
        renderNode = childList;
      } else {
        renderNode = /* @__PURE__ */ reactExports.createElement(InternalSubMenu, props, childList);
      }
      return /* @__PURE__ */ reactExports.createElement(PathTrackerContext.Provider, {
        value: connectedKeyPath
      }, renderNode);
    }
    var _excluded$j = ["className", "title", "eventKey", "children"], _excluded2$1 = ["children"];
    var InternalMenuItemGroup = function InternalMenuItemGroup2(_ref) {
      var className = _ref.className, title = _ref.title;
      _ref.eventKey;
      var children = _ref.children, restProps = _objectWithoutProperties(_ref, _excluded$j);
      var _React$useContext = reactExports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls;
      var groupPrefixCls = "".concat(prefixCls, "-item-group");
      return /* @__PURE__ */ reactExports.createElement("li", _extends$1({
        role: "presentation"
      }, restProps, {
        onClick: function onClick(e2) {
          return e2.stopPropagation();
        },
        className: classNames(groupPrefixCls, className)
      }), /* @__PURE__ */ reactExports.createElement("div", {
        role: "presentation",
        className: "".concat(groupPrefixCls, "-title"),
        title: typeof title === "string" ? title : void 0
      }, title), /* @__PURE__ */ reactExports.createElement("ul", {
        role: "group",
        className: "".concat(groupPrefixCls, "-list")
      }, children));
    };
    function MenuItemGroup(_ref2) {
      var children = _ref2.children, props = _objectWithoutProperties(_ref2, _excluded2$1);
      var connectedKeyPath = useFullPath(props.eventKey);
      var childList = parseChildren(children, connectedKeyPath);
      var measure = useMeasure();
      if (measure) {
        return childList;
      }
      return /* @__PURE__ */ reactExports.createElement(InternalMenuItemGroup, omit(props, ["warnKey"]), childList);
    }
    function Divider(_ref) {
      var className = _ref.className, style2 = _ref.style;
      var _React$useContext = reactExports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls;
      var measure = useMeasure();
      if (measure) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement("li", {
        role: "separator",
        className: classNames("".concat(prefixCls, "-item-divider"), className),
        style: style2
      });
    }
    var _excluded$i = ["label", "children", "key", "type"];
    function convertItemsToNodes$1(list) {
      return (list || []).map(function(opt, index2) {
        if (opt && _typeof(opt) === "object") {
          var _ref = opt, label = _ref.label, children = _ref.children, key = _ref.key, type = _ref.type, restProps = _objectWithoutProperties(_ref, _excluded$i);
          var mergedKey = key !== null && key !== void 0 ? key : "tmp-".concat(index2);
          if (children || type === "group") {
            if (type === "group") {
              return /* @__PURE__ */ reactExports.createElement(MenuItemGroup, _extends$1({
                key: mergedKey
              }, restProps, {
                title: label
              }), convertItemsToNodes$1(children));
            }
            return /* @__PURE__ */ reactExports.createElement(SubMenu$2, _extends$1({
              key: mergedKey
            }, restProps, {
              title: label
            }), convertItemsToNodes$1(children));
          }
          if (type === "divider") {
            return /* @__PURE__ */ reactExports.createElement(Divider, _extends$1({
              key: mergedKey
            }, restProps));
          }
          return /* @__PURE__ */ reactExports.createElement(MenuItem$2, _extends$1({
            key: mergedKey
          }, restProps), label);
        }
        return null;
      }).filter(function(opt) {
        return opt;
      });
    }
    function parseItems(children, items, keyPath) {
      var childNodes = children;
      if (items) {
        childNodes = convertItemsToNodes$1(items);
      }
      return parseChildren(childNodes, keyPath);
    }
    var _excluded$h = ["prefixCls", "rootClassName", "style", "className", "tabIndex", "items", "children", "direction", "id", "mode", "inlineCollapsed", "disabled", "disabledOverflow", "subMenuOpenDelay", "subMenuCloseDelay", "forceSubMenuRender", "defaultOpenKeys", "openKeys", "activeKey", "defaultActiveFirst", "selectable", "multiple", "defaultSelectedKeys", "selectedKeys", "onSelect", "onDeselect", "inlineIndent", "motion", "defaultMotions", "triggerSubMenuAction", "builtinPlacements", "itemIcon", "expandIcon", "overflowedIndicator", "overflowedIndicatorPopupClassName", "getPopupContainer", "onClick", "onOpenChange", "onKeyDown", "openAnimation", "openTransitionName", "_internalRenderMenuItem", "_internalRenderSubMenuItem"];
    var EMPTY_LIST$3 = [];
    var Menu$2 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var _childList$, _classNames;
      var _ref = props, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-menu" : _ref$prefixCls, rootClassName = _ref.rootClassName, style2 = _ref.style, className = _ref.className, _ref$tabIndex = _ref.tabIndex, tabIndex = _ref$tabIndex === void 0 ? 0 : _ref$tabIndex, items = _ref.items, children = _ref.children, direction = _ref.direction, id2 = _ref.id, _ref$mode = _ref.mode, mode = _ref$mode === void 0 ? "vertical" : _ref$mode, inlineCollapsed = _ref.inlineCollapsed, disabled = _ref.disabled, disabledOverflow = _ref.disabledOverflow, _ref$subMenuOpenDelay = _ref.subMenuOpenDelay, subMenuOpenDelay = _ref$subMenuOpenDelay === void 0 ? 0.1 : _ref$subMenuOpenDelay, _ref$subMenuCloseDela = _ref.subMenuCloseDelay, subMenuCloseDelay = _ref$subMenuCloseDela === void 0 ? 0.1 : _ref$subMenuCloseDela, forceSubMenuRender = _ref.forceSubMenuRender, defaultOpenKeys = _ref.defaultOpenKeys, openKeys = _ref.openKeys, activeKey = _ref.activeKey, defaultActiveFirst = _ref.defaultActiveFirst, _ref$selectable = _ref.selectable, selectable = _ref$selectable === void 0 ? true : _ref$selectable, _ref$multiple = _ref.multiple, multiple = _ref$multiple === void 0 ? false : _ref$multiple, defaultSelectedKeys = _ref.defaultSelectedKeys, selectedKeys = _ref.selectedKeys, onSelect = _ref.onSelect, onDeselect = _ref.onDeselect, _ref$inlineIndent = _ref.inlineIndent, inlineIndent = _ref$inlineIndent === void 0 ? 24 : _ref$inlineIndent, motion = _ref.motion, defaultMotions = _ref.defaultMotions, _ref$triggerSubMenuAc = _ref.triggerSubMenuAction, triggerSubMenuAction = _ref$triggerSubMenuAc === void 0 ? "hover" : _ref$triggerSubMenuAc, builtinPlacements = _ref.builtinPlacements, itemIcon = _ref.itemIcon, expandIcon = _ref.expandIcon, _ref$overflowedIndica = _ref.overflowedIndicator, overflowedIndicator = _ref$overflowedIndica === void 0 ? "..." : _ref$overflowedIndica, overflowedIndicatorPopupClassName = _ref.overflowedIndicatorPopupClassName, getPopupContainer = _ref.getPopupContainer, onClick = _ref.onClick, onOpenChange = _ref.onOpenChange, onKeyDown2 = _ref.onKeyDown;
      _ref.openAnimation;
      _ref.openTransitionName;
      var _internalRenderMenuItem = _ref._internalRenderMenuItem, _internalRenderSubMenuItem = _ref._internalRenderSubMenuItem, restProps = _objectWithoutProperties(_ref, _excluded$h);
      var childList = reactExports.useMemo(function() {
        return parseItems(children, items, EMPTY_LIST$3);
      }, [children, items]);
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), mounted = _React$useState2[0], setMounted = _React$useState2[1];
      var containerRef = reactExports.useRef();
      var uuid2 = useUUID(id2);
      var isRtl = direction === "rtl";
      var _useMergedState = useMergedState(defaultOpenKeys, {
        value: openKeys,
        postState: function postState(keys2) {
          return keys2 || EMPTY_LIST$3;
        }
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedOpenKeys = _useMergedState2[0], setMergedOpenKeys = _useMergedState2[1];
      var triggerOpenKeys = function triggerOpenKeys2(keys2) {
        var forceFlush = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        function doUpdate() {
          setMergedOpenKeys(keys2);
          onOpenChange === null || onOpenChange === void 0 || onOpenChange(keys2);
        }
        if (forceFlush) {
          reactDomExports.flushSync(doUpdate);
        } else {
          doUpdate();
        }
      };
      var _React$useState3 = reactExports.useState(mergedOpenKeys), _React$useState4 = _slicedToArray(_React$useState3, 2), inlineCacheOpenKeys = _React$useState4[0], setInlineCacheOpenKeys = _React$useState4[1];
      var mountRef = reactExports.useRef(false);
      var _React$useMemo = reactExports.useMemo(function() {
        if ((mode === "inline" || mode === "vertical") && inlineCollapsed) {
          return ["vertical", inlineCollapsed];
        }
        return [mode, false];
      }, [mode, inlineCollapsed]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), mergedMode = _React$useMemo2[0], mergedInlineCollapsed = _React$useMemo2[1];
      var isInlineMode = mergedMode === "inline";
      var _React$useState5 = reactExports.useState(mergedMode), _React$useState6 = _slicedToArray(_React$useState5, 2), internalMode = _React$useState6[0], setInternalMode = _React$useState6[1];
      var _React$useState7 = reactExports.useState(mergedInlineCollapsed), _React$useState8 = _slicedToArray(_React$useState7, 2), internalInlineCollapsed = _React$useState8[0], setInternalInlineCollapsed = _React$useState8[1];
      reactExports.useEffect(function() {
        setInternalMode(mergedMode);
        setInternalInlineCollapsed(mergedInlineCollapsed);
        if (!mountRef.current) {
          return;
        }
        if (isInlineMode) {
          setMergedOpenKeys(inlineCacheOpenKeys);
        } else {
          triggerOpenKeys(EMPTY_LIST$3);
        }
      }, [mergedMode, mergedInlineCollapsed]);
      var _React$useState9 = reactExports.useState(0), _React$useState10 = _slicedToArray(_React$useState9, 2), lastVisibleIndex = _React$useState10[0], setLastVisibleIndex = _React$useState10[1];
      var allVisible = lastVisibleIndex >= childList.length - 1 || internalMode !== "horizontal" || disabledOverflow;
      reactExports.useEffect(function() {
        if (isInlineMode) {
          setInlineCacheOpenKeys(mergedOpenKeys);
        }
      }, [mergedOpenKeys]);
      reactExports.useEffect(function() {
        mountRef.current = true;
        return function() {
          mountRef.current = false;
        };
      }, []);
      var _useKeyRecords = useKeyRecords(), registerPath = _useKeyRecords.registerPath, unregisterPath = _useKeyRecords.unregisterPath, refreshOverflowKeys = _useKeyRecords.refreshOverflowKeys, isSubPathKey = _useKeyRecords.isSubPathKey, getKeyPath = _useKeyRecords.getKeyPath, getKeys = _useKeyRecords.getKeys, getSubPathKeys = _useKeyRecords.getSubPathKeys;
      var registerPathContext = reactExports.useMemo(function() {
        return {
          registerPath,
          unregisterPath
        };
      }, [registerPath, unregisterPath]);
      var pathUserContext = reactExports.useMemo(function() {
        return {
          isSubPathKey
        };
      }, [isSubPathKey]);
      reactExports.useEffect(function() {
        refreshOverflowKeys(allVisible ? EMPTY_LIST$3 : childList.slice(lastVisibleIndex + 1).map(function(child) {
          return child.key;
        }));
      }, [lastVisibleIndex, allVisible]);
      var _useMergedState3 = useMergedState(activeKey || defaultActiveFirst && ((_childList$ = childList[0]) === null || _childList$ === void 0 ? void 0 : _childList$.key), {
        value: activeKey
      }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), mergedActiveKey = _useMergedState4[0], setMergedActiveKey = _useMergedState4[1];
      var onActive = useMemoCallback(function(key) {
        setMergedActiveKey(key);
      });
      var onInactive = useMemoCallback(function() {
        setMergedActiveKey(void 0);
      });
      reactExports.useImperativeHandle(ref, function() {
        return {
          list: containerRef.current,
          focus: function focus(options) {
            var _childList$find;
            var keys2 = getKeys();
            var _refreshElements = refreshElements(keys2, uuid2), elements = _refreshElements.elements, key2element = _refreshElements.key2element, element2key = _refreshElements.element2key;
            var focusableElements = getFocusableElements(containerRef.current, elements);
            var shouldFocusKey = mergedActiveKey !== null && mergedActiveKey !== void 0 ? mergedActiveKey : focusableElements[0] ? element2key.get(focusableElements[0]) : (_childList$find = childList.find(function(node2) {
              return !node2.props.disabled;
            })) === null || _childList$find === void 0 ? void 0 : _childList$find.key;
            var elementToFocus = key2element.get(shouldFocusKey);
            if (shouldFocusKey && elementToFocus) {
              var _elementToFocus$focus;
              elementToFocus === null || elementToFocus === void 0 || (_elementToFocus$focus = elementToFocus.focus) === null || _elementToFocus$focus === void 0 || _elementToFocus$focus.call(elementToFocus, options);
            }
          }
        };
      });
      var _useMergedState5 = useMergedState(defaultSelectedKeys || [], {
        value: selectedKeys,
        // Legacy convert key to array
        postState: function postState(keys2) {
          if (Array.isArray(keys2)) {
            return keys2;
          }
          if (keys2 === null || keys2 === void 0) {
            return EMPTY_LIST$3;
          }
          return [keys2];
        }
      }), _useMergedState6 = _slicedToArray(_useMergedState5, 2), mergedSelectKeys = _useMergedState6[0], setMergedSelectKeys = _useMergedState6[1];
      var triggerSelection = function triggerSelection2(info) {
        if (selectable) {
          var targetKey = info.key;
          var exist = mergedSelectKeys.includes(targetKey);
          var newSelectKeys;
          if (multiple) {
            if (exist) {
              newSelectKeys = mergedSelectKeys.filter(function(key) {
                return key !== targetKey;
              });
            } else {
              newSelectKeys = [].concat(_toConsumableArray(mergedSelectKeys), [targetKey]);
            }
          } else {
            newSelectKeys = [targetKey];
          }
          setMergedSelectKeys(newSelectKeys);
          var selectInfo = _objectSpread2(_objectSpread2({}, info), {}, {
            selectedKeys: newSelectKeys
          });
          if (exist) {
            onDeselect === null || onDeselect === void 0 || onDeselect(selectInfo);
          } else {
            onSelect === null || onSelect === void 0 || onSelect(selectInfo);
          }
        }
        if (!multiple && mergedOpenKeys.length && internalMode !== "inline") {
          triggerOpenKeys(EMPTY_LIST$3);
        }
      };
      var onInternalClick = useMemoCallback(function(info) {
        onClick === null || onClick === void 0 || onClick(warnItemProp(info));
        triggerSelection(info);
      });
      var onInternalOpenChange = useMemoCallback(function(key, open) {
        var newOpenKeys = mergedOpenKeys.filter(function(k2) {
          return k2 !== key;
        });
        if (open) {
          newOpenKeys.push(key);
        } else if (internalMode !== "inline") {
          var subPathKeys = getSubPathKeys(key);
          newOpenKeys = newOpenKeys.filter(function(k2) {
            return !subPathKeys.has(k2);
          });
        }
        if (!isEqual$1(mergedOpenKeys, newOpenKeys, true)) {
          triggerOpenKeys(newOpenKeys, true);
        }
      });
      var triggerAccessibilityOpen = function triggerAccessibilityOpen2(key, open) {
        var nextOpen = open !== null && open !== void 0 ? open : !mergedOpenKeys.includes(key);
        onInternalOpenChange(key, nextOpen);
      };
      var onInternalKeyDown = useAccessibility(internalMode, mergedActiveKey, isRtl, uuid2, containerRef, getKeys, getKeyPath, setMergedActiveKey, triggerAccessibilityOpen, onKeyDown2);
      reactExports.useEffect(function() {
        setMounted(true);
      }, []);
      var privateContext = reactExports.useMemo(function() {
        return {
          _internalRenderMenuItem,
          _internalRenderSubMenuItem
        };
      }, [_internalRenderMenuItem, _internalRenderSubMenuItem]);
      var wrappedChildList = internalMode !== "horizontal" || disabledOverflow ? childList : (
        // Need wrap for overflow dropdown that do not response for open
        childList.map(function(child, index2) {
          return (
            // Always wrap provider to avoid sub node re-mount
            /* @__PURE__ */ reactExports.createElement(InheritableContextProvider, {
              key: child.key,
              overflowDisabled: index2 > lastVisibleIndex
            }, child)
          );
        })
      );
      var container = /* @__PURE__ */ reactExports.createElement(ForwardOverflow, _extends$1({
        id: id2,
        ref: containerRef,
        prefixCls: "".concat(prefixCls, "-overflow"),
        component: "ul",
        itemComponent: MenuItem$2,
        className: classNames(prefixCls, "".concat(prefixCls, "-root"), "".concat(prefixCls, "-").concat(internalMode), className, (_classNames = {}, _defineProperty(_classNames, "".concat(prefixCls, "-inline-collapsed"), internalInlineCollapsed), _defineProperty(_classNames, "".concat(prefixCls, "-rtl"), isRtl), _classNames), rootClassName),
        dir: direction,
        style: style2,
        role: "menu",
        tabIndex,
        data: wrappedChildList,
        renderRawItem: function renderRawItem(node2) {
          return node2;
        },
        renderRawRest: function renderRawRest(omitItems) {
          var len = omitItems.length;
          var originOmitItems = len ? childList.slice(-len) : null;
          return /* @__PURE__ */ reactExports.createElement(SubMenu$2, {
            eventKey: OVERFLOW_KEY,
            title: overflowedIndicator,
            disabled: allVisible,
            internalPopupClose: len === 0,
            popupClassName: overflowedIndicatorPopupClassName
          }, originOmitItems);
        },
        maxCount: internalMode !== "horizontal" || disabledOverflow ? ForwardOverflow.INVALIDATE : ForwardOverflow.RESPONSIVE,
        ssr: "full",
        "data-menu-list": true,
        onVisibleChange: function onVisibleChange(newLastIndex) {
          setLastVisibleIndex(newLastIndex);
        },
        onKeyDown: onInternalKeyDown
      }, restProps));
      return /* @__PURE__ */ reactExports.createElement(PrivateContext.Provider, {
        value: privateContext
      }, /* @__PURE__ */ reactExports.createElement(IdContext.Provider, {
        value: uuid2
      }, /* @__PURE__ */ reactExports.createElement(InheritableContextProvider, {
        prefixCls,
        rootClassName,
        mode: internalMode,
        openKeys: mergedOpenKeys,
        rtl: isRtl,
        disabled,
        motion: mounted ? motion : null,
        defaultMotions: mounted ? defaultMotions : null,
        activeKey: mergedActiveKey,
        onActive,
        onInactive,
        selectedKeys: mergedSelectKeys,
        inlineIndent,
        subMenuOpenDelay,
        subMenuCloseDelay,
        forceSubMenuRender,
        builtinPlacements,
        triggerSubMenuAction,
        getPopupContainer,
        itemIcon,
        expandIcon,
        onItemClick: onInternalClick,
        onOpenChange: onInternalOpenChange
      }, /* @__PURE__ */ reactExports.createElement(PathUserContext.Provider, {
        value: pathUserContext
      }, container), /* @__PURE__ */ reactExports.createElement("div", {
        style: {
          display: "none"
        },
        "aria-hidden": true
      }, /* @__PURE__ */ reactExports.createElement(PathRegisterContext.Provider, {
        value: registerPathContext
      }, childList)))));
    });
    var ExportMenu = Menu$2;
    ExportMenu.Item = MenuItem$2;
    ExportMenu.SubMenu = SubMenu$2;
    ExportMenu.ItemGroup = MenuItemGroup;
    ExportMenu.Divider = Divider;
    var LeftOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z" } }] }, "name": "left", "theme": "outlined" };
    const LeftOutlinedSvg = LeftOutlined$2;
    var LeftOutlined = function LeftOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: LeftOutlinedSvg
      }));
    };
    const LeftOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(LeftOutlined);
    const SiderContext = /* @__PURE__ */ reactExports.createContext({});
    var __rest$w = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const MenuDivider = (props) => {
      const {
        prefixCls: customizePrefixCls,
        className,
        dashed
      } = props, restProps = __rest$w(props, ["prefixCls", "className", "dashed"]);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("menu", customizePrefixCls);
      const classString = classNames({
        [`${prefixCls}-item-divider-dashed`]: !!dashed
      }, className);
      return /* @__PURE__ */ reactExports.createElement(Divider, Object.assign({
        className: classString
      }, restProps));
    };
    const MenuDivider$1 = MenuDivider;
    const MenuContext = /* @__PURE__ */ reactExports.createContext({
      prefixCls: "",
      firstLevel: true,
      inlineCollapsed: false
    });
    const MenuContext$1 = MenuContext;
    const MenuItem = (props) => {
      var _a;
      const {
        className,
        children,
        icon,
        title,
        danger
      } = props;
      const {
        prefixCls,
        firstLevel,
        direction,
        disableMenuItemTitleTooltip,
        inlineCollapsed: isInlineCollapsed
      } = reactExports.useContext(MenuContext$1);
      const renderItemChildren = (inlineCollapsed) => {
        const wrapNode = /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-title-content`
        }, children);
        if (!icon || isValidElement(children) && children.type === "span") {
          if (children && inlineCollapsed && firstLevel && typeof children === "string") {
            return /* @__PURE__ */ reactExports.createElement("div", {
              className: `${prefixCls}-inline-collapsed-noicon`
            }, children.charAt(0));
          }
        }
        return wrapNode;
      };
      const {
        siderCollapsed
      } = reactExports.useContext(SiderContext);
      let tooltipTitle = title;
      if (typeof title === "undefined") {
        tooltipTitle = firstLevel ? children : "";
      } else if (title === false) {
        tooltipTitle = "";
      }
      const tooltipProps = {
        title: tooltipTitle
      };
      if (!siderCollapsed && !isInlineCollapsed) {
        tooltipProps.title = null;
        tooltipProps.open = false;
      }
      const childrenLength = toArray$a(children).length;
      let returnNode = /* @__PURE__ */ reactExports.createElement(MenuItem$2, Object.assign({}, omit(props, ["title", "icon", "danger"]), {
        className: classNames({
          [`${prefixCls}-item-danger`]: danger,
          [`${prefixCls}-item-only-child`]: (icon ? childrenLength + 1 : childrenLength) === 1
        }, className),
        title: typeof title === "string" ? title : void 0
      }), cloneElement(icon, {
        className: classNames(isValidElement(icon) ? (_a = icon.props) === null || _a === void 0 ? void 0 : _a.className : "", `${prefixCls}-item-icon`)
      }), renderItemChildren(isInlineCollapsed));
      if (!disableMenuItemTitleTooltip) {
        returnNode = /* @__PURE__ */ reactExports.createElement(Tooltip$1, Object.assign({}, tooltipProps, {
          placement: direction === "rtl" ? "left" : "right",
          overlayClassName: `${prefixCls}-inline-collapsed-tooltip`
        }), returnNode);
      }
      return returnNode;
    };
    const Item$3 = MenuItem;
    const SubMenu = (props) => {
      var _a;
      const {
        popupClassName,
        icon,
        title,
        theme: customTheme
      } = props;
      const context = reactExports.useContext(MenuContext$1);
      const {
        prefixCls,
        inlineCollapsed,
        theme: contextTheme
      } = context;
      const parentPath = useFullPath();
      let titleNode;
      if (!icon) {
        titleNode = inlineCollapsed && !parentPath.length && title && typeof title === "string" ? /* @__PURE__ */ reactExports.createElement("div", {
          className: `${prefixCls}-inline-collapsed-noicon`
        }, title.charAt(0)) : /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-title-content`
        }, title);
      } else {
        const titleIsSpan = isValidElement(title) && title.type === "span";
        titleNode = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, cloneElement(icon, {
          className: classNames(isValidElement(icon) ? (_a = icon.props) === null || _a === void 0 ? void 0 : _a.className : "", `${prefixCls}-item-icon`)
        }), titleIsSpan ? title : /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-title-content`
        }, title));
      }
      const contextValue = reactExports.useMemo(() => Object.assign(Object.assign({}, context), {
        firstLevel: false
      }), [context]);
      const [zIndex] = useZIndex("Menu");
      return /* @__PURE__ */ reactExports.createElement(MenuContext$1.Provider, {
        value: contextValue
      }, /* @__PURE__ */ reactExports.createElement(SubMenu$2, Object.assign({}, omit(props, ["icon"]), {
        title: titleNode,
        popupClassName: classNames(prefixCls, popupClassName, `${prefixCls}-${customTheme || contextTheme}`),
        popupStyle: {
          zIndex
        }
      })));
    };
    const SubMenu$1 = SubMenu;
    var EllipsisOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "ellipsis", "theme": "outlined" };
    const EllipsisOutlinedSvg = EllipsisOutlined$2;
    var EllipsisOutlined = function EllipsisOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: EllipsisOutlinedSvg
      }));
    };
    const EllipsisOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(EllipsisOutlined);
    var __rest$v = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    function convertItemsToNodes(list) {
      return (list || []).map((opt, index2) => {
        if (opt && typeof opt === "object") {
          const _a = opt, {
            label,
            children,
            key,
            type
          } = _a, restProps = __rest$v(_a, ["label", "children", "key", "type"]);
          const mergedKey = key !== null && key !== void 0 ? key : `tmp-${index2}`;
          if (children || type === "group") {
            if (type === "group") {
              return /* @__PURE__ */ reactExports.createElement(MenuItemGroup, Object.assign({
                key: mergedKey
              }, restProps, {
                title: label
              }), convertItemsToNodes(children));
            }
            return /* @__PURE__ */ reactExports.createElement(SubMenu$1, Object.assign({
              key: mergedKey
            }, restProps, {
              title: label
            }), convertItemsToNodes(children));
          }
          if (type === "divider") {
            return /* @__PURE__ */ reactExports.createElement(MenuDivider$1, Object.assign({
              key: mergedKey
            }, restProps));
          }
          return /* @__PURE__ */ reactExports.createElement(Item$3, Object.assign({
            key: mergedKey
          }, restProps), label);
        }
        return null;
      }).filter((opt) => opt);
    }
    function useItems$1(items) {
      return reactExports.useMemo(() => {
        if (!items) {
          return items;
        }
        return convertItemsToNodes(items);
      }, [items]);
    }
    var __rest$u = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const OverrideContext = /* @__PURE__ */ reactExports.createContext(null);
    const OverrideProvider = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        children
      } = props, restProps = __rest$u(props, ["children"]);
      const override = reactExports.useContext(OverrideContext);
      const context = reactExports.useMemo(() => Object.assign(Object.assign({}, override), restProps), [
        override,
        restProps.prefixCls,
        // restProps.expandIcon, Not mark as deps since this is a ReactNode
        restProps.mode,
        restProps.selectable,
        restProps.rootClassName
        // restProps.validator, Not mark as deps since this is a function
      ]);
      const canRef = supportNodeRef(children);
      const mergedRef = useComposeRef(ref, canRef ? children.ref : null);
      return /* @__PURE__ */ reactExports.createElement(OverrideContext.Provider, {
        value: context
      }, /* @__PURE__ */ reactExports.createElement(NoCompactStyle, null, canRef ? /* @__PURE__ */ reactExports.cloneElement(children, {
        ref: mergedRef
      }) : children));
    });
    const OverrideContext$1 = OverrideContext;
    const getHorizontalStyle = (token2) => {
      const {
        componentCls,
        motionDurationSlow,
        horizontalLineHeight,
        colorSplit,
        lineWidth,
        lineType,
        itemPaddingInline
      } = token2;
      return {
        [`${componentCls}-horizontal`]: {
          lineHeight: horizontalLineHeight,
          border: 0,
          borderBottom: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`,
          boxShadow: "none",
          "&::after": {
            display: "block",
            clear: "both",
            height: 0,
            content: '"\\20"'
          },
          // ======================= Item =======================
          [`${componentCls}-item, ${componentCls}-submenu`]: {
            position: "relative",
            display: "inline-block",
            verticalAlign: "bottom",
            paddingInline: itemPaddingInline
          },
          [`> ${componentCls}-item:hover,
        > ${componentCls}-item-active,
        > ${componentCls}-submenu ${componentCls}-submenu-title:hover`]: {
            backgroundColor: "transparent"
          },
          [`${componentCls}-item, ${componentCls}-submenu-title`]: {
            transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`].join(",")
          },
          // ===================== Sub Menu =====================
          [`${componentCls}-submenu-arrow`]: {
            display: "none"
          }
        }
      };
    };
    const getHorizontalStyle$1 = getHorizontalStyle;
    const getRTLStyle = (_ref) => {
      let {
        componentCls,
        menuArrowOffset,
        calc
      } = _ref;
      return {
        [`${componentCls}-rtl`]: {
          direction: "rtl"
        },
        [`${componentCls}-submenu-rtl`]: {
          transformOrigin: "100% 0"
        },
        // Vertical Arrow
        [`${componentCls}-rtl${componentCls}-vertical,
    ${componentCls}-submenu-rtl ${componentCls}-vertical`]: {
          [`${componentCls}-submenu-arrow`]: {
            "&::before": {
              transform: `rotate(-45deg) translateY(${unit$1(calc(menuArrowOffset).mul(-1).equal())})`
            },
            "&::after": {
              transform: `rotate(45deg) translateY(${unit$1(menuArrowOffset)})`
            }
          }
        }
      };
    };
    const getRTLStyle$1 = getRTLStyle;
    const accessibilityFocus = (token2) => Object.assign({}, genFocusOutline(token2));
    const getThemeStyle = (token2, themeSuffix) => {
      const {
        componentCls,
        itemColor,
        itemSelectedColor,
        groupTitleColor,
        itemBg,
        subMenuItemBg,
        itemSelectedBg,
        activeBarHeight,
        activeBarWidth,
        activeBarBorderWidth,
        motionDurationSlow,
        motionEaseInOut,
        motionEaseOut,
        itemPaddingInline,
        motionDurationMid,
        itemHoverColor,
        lineType,
        colorSplit,
        // Disabled
        itemDisabledColor,
        // Danger
        dangerItemColor,
        dangerItemHoverColor,
        dangerItemSelectedColor,
        dangerItemActiveBg,
        dangerItemSelectedBg,
        itemHoverBg,
        itemActiveBg,
        menuSubMenuBg,
        // Horizontal
        horizontalItemSelectedColor,
        horizontalItemSelectedBg,
        horizontalItemBorderRadius,
        horizontalItemHoverBg,
        popupBg
      } = token2;
      return {
        [`${componentCls}-${themeSuffix}, ${componentCls}-${themeSuffix} > ${componentCls}`]: {
          color: itemColor,
          background: itemBg,
          [`&${componentCls}-root:focus-visible`]: Object.assign({}, accessibilityFocus(token2)),
          // ======================== Item ========================
          [`${componentCls}-item-group-title`]: {
            color: groupTitleColor
          },
          [`${componentCls}-submenu-selected`]: {
            [`> ${componentCls}-submenu-title`]: {
              color: itemSelectedColor
            }
          },
          // Disabled
          [`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: {
            color: `${itemDisabledColor} !important`
          },
          // Hover
          [`${componentCls}-item:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: {
            [`&:hover, > ${componentCls}-submenu-title:hover`]: {
              color: itemHoverColor
            }
          },
          [`&:not(${componentCls}-horizontal)`]: {
            [`${componentCls}-item:not(${componentCls}-item-selected)`]: {
              "&:hover": {
                backgroundColor: itemHoverBg
              },
              "&:active": {
                backgroundColor: itemActiveBg
              }
            },
            [`${componentCls}-submenu-title`]: {
              "&:hover": {
                backgroundColor: itemHoverBg
              },
              "&:active": {
                backgroundColor: itemActiveBg
              }
            }
          },
          // Danger - only Item has
          [`${componentCls}-item-danger`]: {
            color: dangerItemColor,
            [`&${componentCls}-item:hover`]: {
              [`&:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: {
                color: dangerItemHoverColor
              }
            },
            [`&${componentCls}-item:active`]: {
              background: dangerItemActiveBg
            }
          },
          [`${componentCls}-item a`]: {
            "&, &:hover": {
              color: "inherit"
            }
          },
          [`${componentCls}-item-selected`]: {
            color: itemSelectedColor,
            // Danger
            [`&${componentCls}-item-danger`]: {
              color: dangerItemSelectedColor
            },
            [`a, a:hover`]: {
              color: "inherit"
            }
          },
          [`& ${componentCls}-item-selected`]: {
            backgroundColor: itemSelectedBg,
            // Danger
            [`&${componentCls}-item-danger`]: {
              backgroundColor: dangerItemSelectedBg
            }
          },
          [`${componentCls}-item, ${componentCls}-submenu-title`]: {
            [`&:not(${componentCls}-item-disabled):focus-visible`]: Object.assign({}, accessibilityFocus(token2))
          },
          [`&${componentCls}-submenu > ${componentCls}`]: {
            backgroundColor: menuSubMenuBg
          },
          [`&${componentCls}-popup > ${componentCls}`]: {
            backgroundColor: popupBg
          },
          // ====================== Horizontal ======================
          [`&${componentCls}-horizontal`]: Object.assign(Object.assign({}, themeSuffix === "dark" ? {
            borderBottom: 0
          } : {}), {
            [`> ${componentCls}-item, > ${componentCls}-submenu`]: {
              top: activeBarBorderWidth,
              marginTop: token2.calc(activeBarBorderWidth).mul(-1).equal(),
              marginBottom: 0,
              borderRadius: horizontalItemBorderRadius,
              "&::after": {
                position: "absolute",
                insetInline: itemPaddingInline,
                bottom: 0,
                borderBottom: `${unit$1(activeBarHeight)} solid transparent`,
                transition: `border-color ${motionDurationSlow} ${motionEaseInOut}`,
                content: '""'
              },
              [`&:hover, &-active, &-open`]: {
                background: horizontalItemHoverBg,
                "&::after": {
                  borderBottomWidth: activeBarHeight,
                  borderBottomColor: horizontalItemSelectedColor
                }
              },
              [`&-selected`]: {
                color: horizontalItemSelectedColor,
                backgroundColor: horizontalItemSelectedBg,
                "&:hover": {
                  backgroundColor: horizontalItemSelectedBg
                },
                "&::after": {
                  borderBottomWidth: activeBarHeight,
                  borderBottomColor: horizontalItemSelectedColor
                }
              }
            }
          }),
          // ================== Inline & Vertical ===================
          //
          [`&${componentCls}-root`]: {
            [`&${componentCls}-inline, &${componentCls}-vertical`]: {
              borderInlineEnd: `${unit$1(activeBarBorderWidth)} ${lineType} ${colorSplit}`
            }
          },
          // ======================== Inline ========================
          [`&${componentCls}-inline`]: {
            // Sub
            [`${componentCls}-sub${componentCls}-inline`]: {
              background: subMenuItemBg
            },
            [`${componentCls}-item`]: {
              position: "relative",
              "&::after": {
                position: "absolute",
                insetBlock: 0,
                insetInlineEnd: 0,
                borderInlineEnd: `${unit$1(activeBarWidth)} solid ${itemSelectedColor}`,
                transform: "scaleY(0.0001)",
                opacity: 0,
                transition: [`transform ${motionDurationMid} ${motionEaseOut}`, `opacity ${motionDurationMid} ${motionEaseOut}`].join(","),
                content: '""'
              },
              // Danger
              [`&${componentCls}-item-danger`]: {
                "&::after": {
                  borderInlineEndColor: dangerItemSelectedColor
                }
              }
            },
            [`${componentCls}-selected, ${componentCls}-item-selected`]: {
              "&::after": {
                transform: "scaleY(1)",
                opacity: 1,
                transition: [`transform ${motionDurationMid} ${motionEaseInOut}`, `opacity ${motionDurationMid} ${motionEaseInOut}`].join(",")
              }
            }
          }
        }
      };
    };
    const getThemeStyle$1 = getThemeStyle;
    const getVerticalInlineStyle = (token2) => {
      const {
        componentCls,
        itemHeight,
        itemMarginInline,
        padding,
        menuArrowSize,
        marginXS,
        itemMarginBlock,
        itemWidth
      } = token2;
      const paddingWithArrow = token2.calc(menuArrowSize).add(padding).add(marginXS).equal();
      return {
        [`${componentCls}-item`]: {
          position: "relative",
          overflow: "hidden"
        },
        [`${componentCls}-item, ${componentCls}-submenu-title`]: {
          height: itemHeight,
          lineHeight: unit$1(itemHeight),
          paddingInline: padding,
          overflow: "hidden",
          textOverflow: "ellipsis",
          marginInline: itemMarginInline,
          marginBlock: itemMarginBlock,
          width: itemWidth
        },
        [`> ${componentCls}-item,
            > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
          height: itemHeight,
          lineHeight: unit$1(itemHeight)
        },
        [`${componentCls}-item-group-list ${componentCls}-submenu-title,
            ${componentCls}-submenu-title`]: {
          paddingInlineEnd: paddingWithArrow
        }
      };
    };
    const getVerticalStyle = (token2) => {
      const {
        componentCls,
        iconCls,
        itemHeight,
        colorTextLightSolid,
        dropdownWidth,
        controlHeightLG,
        motionDurationMid,
        motionEaseOut,
        paddingXL,
        itemMarginInline,
        fontSizeLG,
        motionDurationSlow,
        paddingXS,
        boxShadowSecondary,
        collapsedWidth,
        collapsedIconSize
      } = token2;
      const inlineItemStyle = {
        height: itemHeight,
        lineHeight: unit$1(itemHeight),
        listStylePosition: "inside",
        listStyleType: "disc"
      };
      return [
        {
          [componentCls]: {
            [`&-inline, &-vertical`]: Object.assign({
              [`&${componentCls}-root`]: {
                boxShadow: "none"
              }
            }, getVerticalInlineStyle(token2))
          },
          [`${componentCls}-submenu-popup`]: {
            [`${componentCls}-vertical`]: Object.assign(Object.assign({}, getVerticalInlineStyle(token2)), {
              boxShadow: boxShadowSecondary
            })
          }
        },
        // Vertical only
        {
          [`${componentCls}-submenu-popup ${componentCls}-vertical${componentCls}-sub`]: {
            minWidth: dropdownWidth,
            maxHeight: `calc(100vh - ${unit$1(token2.calc(controlHeightLG).mul(2.5).equal())})`,
            padding: "0",
            overflow: "hidden",
            borderInlineEnd: 0,
            // https://github.com/ant-design/ant-design/issues/22244
            // https://github.com/ant-design/ant-design/issues/26812
            "&:not([class*='-active'])": {
              overflowX: "hidden",
              overflowY: "auto"
            }
          }
        },
        // Inline Only
        {
          [`${componentCls}-inline`]: {
            width: "100%",
            // Motion enhance for first level
            [`&${componentCls}-root`]: {
              [`${componentCls}-item, ${componentCls}-submenu-title`]: {
                display: "flex",
                alignItems: "center",
                transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`, `padding ${motionDurationMid} ${motionEaseOut}`].join(","),
                [`> ${componentCls}-title-content`]: {
                  flex: "auto",
                  minWidth: 0,
                  overflow: "hidden",
                  textOverflow: "ellipsis"
                },
                "> *": {
                  flex: "none"
                }
              }
            },
            // >>>>> Sub
            [`${componentCls}-sub${componentCls}-inline`]: {
              padding: 0,
              border: 0,
              borderRadius: 0,
              boxShadow: "none",
              [`& > ${componentCls}-submenu > ${componentCls}-submenu-title`]: inlineItemStyle,
              [`& ${componentCls}-item-group-title`]: {
                paddingInlineStart: paddingXL
              }
            },
            // >>>>> Item
            [`${componentCls}-item`]: inlineItemStyle
          }
        },
        // Inline Collapse Only
        {
          [`${componentCls}-inline-collapsed`]: {
            width: collapsedWidth,
            [`&${componentCls}-root`]: {
              [`${componentCls}-item, ${componentCls}-submenu ${componentCls}-submenu-title`]: {
                [`> ${componentCls}-inline-collapsed-noicon`]: {
                  fontSize: fontSizeLG,
                  textAlign: "center"
                }
              }
            },
            [`> ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-submenu > ${componentCls}-submenu-title,
          > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
              insetInlineStart: 0,
              paddingInline: `calc(50% - ${unit$1(token2.calc(fontSizeLG).div(2).equal())} - ${unit$1(itemMarginInline)})`,
              textOverflow: "clip",
              [`
            ${componentCls}-submenu-arrow,
            ${componentCls}-submenu-expand-icon
          `]: {
                opacity: 0
              },
              [`${componentCls}-item-icon, ${iconCls}`]: {
                margin: 0,
                fontSize: collapsedIconSize,
                lineHeight: unit$1(itemHeight),
                "+ span": {
                  display: "inline-block",
                  opacity: 0
                }
              }
            },
            [`${componentCls}-item-icon, ${iconCls}`]: {
              display: "inline-block"
            },
            "&-tooltip": {
              pointerEvents: "none",
              [`${componentCls}-item-icon, ${iconCls}`]: {
                display: "none"
              },
              "a, a:hover": {
                color: colorTextLightSolid
              }
            },
            [`${componentCls}-item-group-title`]: Object.assign(Object.assign({}, textEllipsis), {
              paddingInline: paddingXS
            })
          }
        }
      ];
    };
    const getVerticalStyle$1 = getVerticalStyle;
    const genMenuItemStyle = (token2) => {
      const {
        componentCls,
        motionDurationSlow,
        motionDurationMid,
        motionEaseInOut,
        motionEaseOut,
        iconCls,
        iconSize,
        iconMarginInlineEnd
      } = token2;
      return {
        // >>>>> Item
        [`${componentCls}-item, ${componentCls}-submenu-title`]: {
          position: "relative",
          display: "block",
          margin: 0,
          whiteSpace: "nowrap",
          cursor: "pointer",
          transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`, `padding ${motionDurationSlow} ${motionEaseInOut}`].join(","),
          [`${componentCls}-item-icon, ${iconCls}`]: {
            minWidth: iconSize,
            fontSize: iconSize,
            transition: [`font-size ${motionDurationMid} ${motionEaseOut}`, `margin ${motionDurationSlow} ${motionEaseInOut}`, `color ${motionDurationSlow}`].join(","),
            "+ span": {
              marginInlineStart: iconMarginInlineEnd,
              opacity: 1,
              transition: [`opacity ${motionDurationSlow} ${motionEaseInOut}`, `margin ${motionDurationSlow}`, `color ${motionDurationSlow}`].join(",")
            }
          },
          [`${componentCls}-item-icon`]: Object.assign({}, resetIcon()),
          [`&${componentCls}-item-only-child`]: {
            [`> ${iconCls}, > ${componentCls}-item-icon`]: {
              marginInlineEnd: 0
            }
          }
        },
        // Disabled state sets text to gray and nukes hover/tab effects
        [`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: {
          background: "none !important",
          cursor: "not-allowed",
          "&::after": {
            borderColor: "transparent !important"
          },
          a: {
            color: "inherit !important"
          },
          [`> ${componentCls}-submenu-title`]: {
            color: "inherit !important",
            cursor: "not-allowed"
          }
        }
      };
    };
    const genSubMenuArrowStyle = (token2) => {
      const {
        componentCls,
        motionDurationSlow,
        motionEaseInOut,
        borderRadius,
        menuArrowSize,
        menuArrowOffset
      } = token2;
      return {
        [`${componentCls}-submenu`]: {
          [`&-expand-icon, &-arrow`]: {
            position: "absolute",
            top: "50%",
            insetInlineEnd: token2.margin,
            width: menuArrowSize,
            color: "currentcolor",
            transform: "translateY(-50%)",
            transition: `transform ${motionDurationSlow} ${motionEaseInOut}, opacity ${motionDurationSlow}`
          },
          "&-arrow": {
            // →
            "&::before, &::after": {
              position: "absolute",
              width: token2.calc(menuArrowSize).mul(0.6).equal(),
              height: token2.calc(menuArrowSize).mul(0.15).equal(),
              backgroundColor: "currentcolor",
              borderRadius,
              transition: [`background ${motionDurationSlow} ${motionEaseInOut}`, `transform ${motionDurationSlow} ${motionEaseInOut}`, `top ${motionDurationSlow} ${motionEaseInOut}`, `color ${motionDurationSlow} ${motionEaseInOut}`].join(","),
              content: '""'
            },
            "&::before": {
              transform: `rotate(45deg) translateY(${unit$1(token2.calc(menuArrowOffset).mul(-1).equal())})`
            },
            "&::after": {
              transform: `rotate(-45deg) translateY(${unit$1(menuArrowOffset)})`
            }
          }
        }
      };
    };
    const getBaseStyle = (token2) => {
      const {
        antCls,
        componentCls,
        fontSize,
        motionDurationSlow,
        motionDurationMid,
        motionEaseInOut,
        paddingXS,
        padding,
        colorSplit,
        lineWidth,
        zIndexPopup,
        borderRadiusLG,
        subMenuItemBorderRadius,
        menuArrowSize,
        menuArrowOffset,
        lineType,
        menuPanelMaskInset,
        groupTitleLineHeight,
        groupTitleFontSize
      } = token2;
      return [
        // Misc
        {
          "": {
            [`${componentCls}`]: Object.assign(Object.assign({}, clearFix()), {
              // Hidden
              [`&-hidden`]: {
                display: "none"
              }
            })
          },
          [`${componentCls}-submenu-hidden`]: {
            display: "none"
          }
        },
        {
          [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), clearFix()), {
            marginBottom: 0,
            paddingInlineStart: 0,
            // Override default ul/ol
            fontSize,
            lineHeight: 0,
            listStyle: "none",
            outline: "none",
            // Magic cubic here but smooth transition
            transition: `width ${motionDurationSlow} cubic-bezier(0.2, 0, 0, 1) 0s`,
            [`ul, ol`]: {
              margin: 0,
              padding: 0,
              listStyle: "none"
            },
            // Overflow ellipsis
            [`&-overflow`]: {
              display: "flex",
              [`${componentCls}-item`]: {
                flex: "none"
              }
            },
            [`${componentCls}-item, ${componentCls}-submenu, ${componentCls}-submenu-title`]: {
              borderRadius: token2.itemBorderRadius
            },
            [`${componentCls}-item-group-title`]: {
              padding: `${unit$1(paddingXS)} ${unit$1(padding)}`,
              fontSize: groupTitleFontSize,
              lineHeight: groupTitleLineHeight,
              transition: `all ${motionDurationSlow}`
            },
            [`&-horizontal ${componentCls}-submenu`]: {
              transition: [`border-color ${motionDurationSlow} ${motionEaseInOut}`, `background ${motionDurationSlow} ${motionEaseInOut}`].join(",")
            },
            [`${componentCls}-submenu, ${componentCls}-submenu-inline`]: {
              transition: [`border-color ${motionDurationSlow} ${motionEaseInOut}`, `background ${motionDurationSlow} ${motionEaseInOut}`, `padding ${motionDurationMid} ${motionEaseInOut}`].join(",")
            },
            [`${componentCls}-submenu ${componentCls}-sub`]: {
              cursor: "initial",
              transition: [`background ${motionDurationSlow} ${motionEaseInOut}`, `padding ${motionDurationSlow} ${motionEaseInOut}`].join(",")
            },
            [`${componentCls}-title-content`]: {
              transition: `color ${motionDurationSlow}`,
              // https://github.com/ant-design/ant-design/issues/41143
              [`> ${antCls}-typography-ellipsis-single-line`]: {
                display: "inline",
                verticalAlign: "unset"
              }
            },
            [`${componentCls}-item a`]: {
              "&::before": {
                position: "absolute",
                inset: 0,
                backgroundColor: "transparent",
                content: '""'
              }
            },
            // Removed a Badge related style seems it's safe
            // https://github.com/ant-design/ant-design/issues/19809
            // >>>>> Divider
            [`${componentCls}-item-divider`]: {
              overflow: "hidden",
              lineHeight: 0,
              borderColor: colorSplit,
              borderStyle: lineType,
              borderWidth: 0,
              borderTopWidth: lineWidth,
              marginBlock: lineWidth,
              padding: 0,
              "&-dashed": {
                borderStyle: "dashed"
              }
            }
          }), genMenuItemStyle(token2)), {
            [`${componentCls}-item-group`]: {
              [`${componentCls}-item-group-list`]: {
                margin: 0,
                padding: 0,
                [`${componentCls}-item, ${componentCls}-submenu-title`]: {
                  paddingInline: `${unit$1(token2.calc(fontSize).mul(2).equal())} ${unit$1(padding)}`
                }
              }
            },
            // ======================= Sub Menu =======================
            "&-submenu": {
              "&-popup": {
                position: "absolute",
                zIndex: zIndexPopup,
                borderRadius: borderRadiusLG,
                boxShadow: "none",
                transformOrigin: "0 0",
                [`&${componentCls}-submenu`]: {
                  background: "transparent"
                },
                // https://github.com/ant-design/ant-design/issues/13955
                "&::before": {
                  position: "absolute",
                  inset: `${unit$1(menuPanelMaskInset)} 0 0`,
                  zIndex: -1,
                  width: "100%",
                  height: "100%",
                  opacity: 0,
                  content: '""'
                }
              },
              // https://github.com/ant-design/ant-design/issues/13955
              "&-placement-rightTop::before": {
                top: 0,
                insetInlineStart: menuPanelMaskInset
              },
              [`
          &-placement-leftTop,
          &-placement-bottomRight,
          `]: {
                transformOrigin: "100% 0"
              },
              [`
          &-placement-leftBottom,
          &-placement-topRight,
          `]: {
                transformOrigin: "100% 100%"
              },
              [`
          &-placement-rightBottom,
          &-placement-topLeft,
          `]: {
                transformOrigin: "0 100%"
              },
              [`
          &-placement-bottomLeft,
          &-placement-rightTop,
          `]: {
                transformOrigin: "0 0"
              },
              [`
          &-placement-leftTop,
          &-placement-leftBottom
          `]: {
                paddingInlineEnd: token2.paddingXS
              },
              [`
          &-placement-rightTop,
          &-placement-rightBottom
          `]: {
                paddingInlineStart: token2.paddingXS
              },
              [`
          &-placement-topRight,
          &-placement-topLeft
          `]: {
                paddingBottom: token2.paddingXS
              },
              [`
          &-placement-bottomRight,
          &-placement-bottomLeft
          `]: {
                paddingTop: token2.paddingXS
              },
              [`> ${componentCls}`]: Object.assign(Object.assign(Object.assign({
                borderRadius: borderRadiusLG
              }, genMenuItemStyle(token2)), genSubMenuArrowStyle(token2)), {
                [`${componentCls}-item, ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
                  borderRadius: subMenuItemBorderRadius
                },
                [`${componentCls}-submenu-title::after`]: {
                  transition: `transform ${motionDurationSlow} ${motionEaseInOut}`
                }
              })
            }
          }), genSubMenuArrowStyle(token2)), {
            [`&-inline-collapsed ${componentCls}-submenu-arrow,
        &-inline ${componentCls}-submenu-arrow`]: {
              // ↓
              "&::before": {
                transform: `rotate(-45deg) translateX(${unit$1(menuArrowOffset)})`
              },
              "&::after": {
                transform: `rotate(45deg) translateX(${unit$1(token2.calc(menuArrowOffset).mul(-1).equal())})`
              }
            },
            [`${componentCls}-submenu-open${componentCls}-submenu-inline > ${componentCls}-submenu-title > ${componentCls}-submenu-arrow`]: {
              // ↑
              transform: `translateY(${unit$1(token2.calc(menuArrowSize).mul(0.2).mul(-1).equal())})`,
              "&::after": {
                transform: `rotate(-45deg) translateX(${unit$1(token2.calc(menuArrowOffset).mul(-1).equal())})`
              },
              "&::before": {
                transform: `rotate(45deg) translateX(${unit$1(menuArrowOffset)})`
              }
            }
          })
        },
        // Integration with header element so menu items have the same height
        {
          [`${antCls}-layout-header`]: {
            [componentCls]: {
              lineHeight: "inherit"
            }
          }
        }
      ];
    };
    const prepareComponentToken$c = (token2) => {
      const {
        colorPrimary,
        colorError,
        colorTextDisabled,
        colorErrorBg,
        colorText,
        colorTextDescription,
        colorBgContainer,
        colorFillAlter,
        colorFillContent,
        lineWidth,
        lineWidthBold,
        controlItemBgActive,
        colorBgTextHover,
        controlHeightLG,
        lineHeight,
        colorBgElevated,
        marginXXS,
        padding,
        fontSize,
        controlHeightSM,
        fontSizeLG,
        colorTextLightSolid,
        colorErrorHover
      } = token2;
      const colorTextDark = new TinyColor(colorTextLightSolid).setAlpha(0.65).toRgbString();
      return {
        dropdownWidth: 160,
        zIndexPopup: token2.zIndexPopupBase + 50,
        radiusItem: token2.borderRadiusLG,
        itemBorderRadius: token2.borderRadiusLG,
        radiusSubMenuItem: token2.borderRadiusSM,
        subMenuItemBorderRadius: token2.borderRadiusSM,
        colorItemText: colorText,
        itemColor: colorText,
        colorItemTextHover: colorText,
        itemHoverColor: colorText,
        colorItemTextHoverHorizontal: colorPrimary,
        horizontalItemHoverColor: colorPrimary,
        colorGroupTitle: colorTextDescription,
        groupTitleColor: colorTextDescription,
        colorItemTextSelected: colorPrimary,
        itemSelectedColor: colorPrimary,
        colorItemTextSelectedHorizontal: colorPrimary,
        horizontalItemSelectedColor: colorPrimary,
        colorItemBg: colorBgContainer,
        itemBg: colorBgContainer,
        colorItemBgHover: colorBgTextHover,
        itemHoverBg: colorBgTextHover,
        colorItemBgActive: colorFillContent,
        itemActiveBg: controlItemBgActive,
        colorSubItemBg: colorFillAlter,
        subMenuItemBg: colorFillAlter,
        colorItemBgSelected: controlItemBgActive,
        itemSelectedBg: controlItemBgActive,
        colorItemBgSelectedHorizontal: "transparent",
        horizontalItemSelectedBg: "transparent",
        colorActiveBarWidth: 0,
        activeBarWidth: 0,
        colorActiveBarHeight: lineWidthBold,
        activeBarHeight: lineWidthBold,
        colorActiveBarBorderSize: lineWidth,
        activeBarBorderWidth: lineWidth,
        // Disabled
        colorItemTextDisabled: colorTextDisabled,
        itemDisabledColor: colorTextDisabled,
        // Danger
        colorDangerItemText: colorError,
        dangerItemColor: colorError,
        colorDangerItemTextHover: colorError,
        dangerItemHoverColor: colorError,
        colorDangerItemTextSelected: colorError,
        dangerItemSelectedColor: colorError,
        colorDangerItemBgActive: colorErrorBg,
        dangerItemActiveBg: colorErrorBg,
        colorDangerItemBgSelected: colorErrorBg,
        dangerItemSelectedBg: colorErrorBg,
        itemMarginInline: token2.marginXXS,
        horizontalItemBorderRadius: 0,
        horizontalItemHoverBg: "transparent",
        itemHeight: controlHeightLG,
        groupTitleLineHeight: lineHeight,
        collapsedWidth: controlHeightLG * 2,
        popupBg: colorBgElevated,
        itemMarginBlock: marginXXS,
        itemPaddingInline: padding,
        horizontalLineHeight: `${controlHeightLG * 1.15}px`,
        iconSize: fontSize,
        iconMarginInlineEnd: controlHeightSM - fontSize,
        collapsedIconSize: fontSizeLG,
        groupTitleFontSize: fontSize,
        // Disabled
        darkItemDisabledColor: new TinyColor(colorTextLightSolid).setAlpha(0.25).toRgbString(),
        // Dark
        darkItemColor: colorTextDark,
        darkDangerItemColor: colorError,
        darkItemBg: "#001529",
        darkPopupBg: "#001529",
        darkSubMenuItemBg: "#000c17",
        darkItemSelectedColor: colorTextLightSolid,
        darkItemSelectedBg: colorPrimary,
        darkDangerItemSelectedBg: colorError,
        darkItemHoverBg: "transparent",
        darkGroupTitleColor: colorTextDark,
        darkItemHoverColor: colorTextLightSolid,
        darkDangerItemHoverColor: colorErrorHover,
        darkDangerItemSelectedColor: colorTextLightSolid,
        darkDangerItemActiveBg: colorError,
        // internal
        itemWidth: ""
      };
    };
    const formatComponentToken = (token2) => Object.assign(Object.assign({}, token2), {
      itemWidth: token2.activeBarWidth ? `calc(100% + ${token2.activeBarBorderWidth}px)` : `calc(100% - ${token2.itemMarginInline * 2}px)`
    });
    const useStyle$e = function(prefixCls) {
      let rootCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : prefixCls;
      let injectStyle = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      const useStyle2 = genStyleHooks("Menu", (token2) => {
        const {
          colorBgElevated,
          colorPrimary,
          colorTextLightSolid,
          controlHeightLG,
          fontSize,
          darkItemColor,
          darkDangerItemColor,
          darkItemBg,
          darkSubMenuItemBg,
          darkItemSelectedColor,
          darkItemSelectedBg,
          darkDangerItemSelectedBg,
          darkItemHoverBg,
          darkGroupTitleColor,
          darkItemHoverColor,
          darkItemDisabledColor,
          darkDangerItemHoverColor,
          darkDangerItemSelectedColor,
          darkDangerItemActiveBg
        } = token2;
        const menuArrowSize = token2.calc(fontSize).div(7).mul(5).equal();
        const menuToken = merge$1(token2, {
          menuArrowSize,
          menuHorizontalHeight: token2.calc(controlHeightLG).mul(1.15).equal(),
          menuArrowOffset: token2.calc(menuArrowSize).mul(0.25).equal(),
          menuPanelMaskInset: -7,
          // Still a hardcode here since it's offset by rc-align
          menuSubMenuBg: colorBgElevated,
          calc: token2.calc
        });
        const menuDarkToken = merge$1(menuToken, {
          itemColor: darkItemColor,
          itemHoverColor: darkItemHoverColor,
          groupTitleColor: darkGroupTitleColor,
          itemSelectedColor: darkItemSelectedColor,
          itemBg: darkItemBg,
          popupBg: darkItemBg,
          subMenuItemBg: darkSubMenuItemBg,
          itemActiveBg: "transparent",
          itemSelectedBg: darkItemSelectedBg,
          activeBarHeight: 0,
          activeBarBorderWidth: 0,
          itemHoverBg: darkItemHoverBg,
          // Disabled
          itemDisabledColor: darkItemDisabledColor,
          // Danger
          dangerItemColor: darkDangerItemColor,
          dangerItemHoverColor: darkDangerItemHoverColor,
          dangerItemSelectedColor: darkDangerItemSelectedColor,
          dangerItemActiveBg: darkDangerItemActiveBg,
          dangerItemSelectedBg: darkDangerItemSelectedBg,
          menuSubMenuBg: darkSubMenuItemBg,
          // Horizontal
          horizontalItemSelectedColor: colorTextLightSolid,
          horizontalItemSelectedBg: colorPrimary
        });
        return [
          // Basic
          getBaseStyle(menuToken),
          // Horizontal
          getHorizontalStyle$1(menuToken),
          // Hard code for some light style
          // Vertical
          getVerticalStyle$1(menuToken),
          // Hard code for some light style
          // Theme
          getThemeStyle$1(menuToken, "light"),
          getThemeStyle$1(menuDarkToken, "dark"),
          // RTL
          getRTLStyle$1(menuToken),
          // Motion
          genCollapseMotion$1(menuToken),
          initSlideMotion(menuToken, "slide-up"),
          initSlideMotion(menuToken, "slide-down"),
          initZoomMotion(menuToken, "zoom-big")
        ];
      }, prepareComponentToken$c, {
        deprecatedTokens: [["colorGroupTitle", "groupTitleColor"], ["radiusItem", "itemBorderRadius"], ["radiusSubMenuItem", "subMenuItemBorderRadius"], ["colorItemText", "itemColor"], ["colorItemTextHover", "itemHoverColor"], ["colorItemTextHoverHorizontal", "horizontalItemHoverColor"], ["colorItemTextSelected", "itemSelectedColor"], ["colorItemTextSelectedHorizontal", "horizontalItemSelectedColor"], ["colorItemTextDisabled", "itemDisabledColor"], ["colorDangerItemText", "dangerItemColor"], ["colorDangerItemTextHover", "dangerItemHoverColor"], ["colorDangerItemTextSelected", "dangerItemSelectedColor"], ["colorDangerItemBgActive", "dangerItemActiveBg"], ["colorDangerItemBgSelected", "dangerItemSelectedBg"], ["colorItemBg", "itemBg"], ["colorItemBgHover", "itemHoverBg"], ["colorSubItemBg", "subMenuItemBg"], ["colorItemBgActive", "itemActiveBg"], ["colorItemBgSelectedHorizontal", "horizontalItemSelectedBg"], ["colorActiveBarWidth", "activeBarWidth"], ["colorActiveBarHeight", "activeBarHeight"], ["colorActiveBarBorderSize", "activeBarBorderWidth"], ["colorItemBgSelected", "itemSelectedBg"]],
        format: formatComponentToken,
        // Dropdown will handle menu style self. We do not need to handle this.
        injectStyle,
        unitless: {
          groupTitleLineHeight: true
        }
      });
      return useStyle2(prefixCls, rootCls);
    };
    var __rest$t = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const InternalMenu = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      var _a, _b;
      const override = reactExports.useContext(OverrideContext$1);
      const overrideObj = override || {};
      const {
        getPrefixCls,
        getPopupContainer,
        direction,
        menu
      } = reactExports.useContext(ConfigContext);
      const rootPrefixCls = getPrefixCls();
      const {
        prefixCls: customizePrefixCls,
        className,
        style: style2,
        theme = "light",
        expandIcon,
        _internalDisableMenuItemTitleTooltip,
        inlineCollapsed,
        siderCollapsed,
        items,
        children,
        rootClassName,
        mode,
        selectable,
        onClick,
        overflowedIndicatorPopupClassName
      } = props, restProps = __rest$t(props, ["prefixCls", "className", "style", "theme", "expandIcon", "_internalDisableMenuItemTitleTooltip", "inlineCollapsed", "siderCollapsed", "items", "children", "rootClassName", "mode", "selectable", "onClick", "overflowedIndicatorPopupClassName"]);
      const passedProps = omit(restProps, ["collapsedWidth"]);
      const mergedChildren = useItems$1(items) || children;
      (_a = overrideObj.validator) === null || _a === void 0 ? void 0 : _a.call(overrideObj, {
        mode
      });
      const onItemClick = useEvent(function() {
        var _a2;
        onClick === null || onClick === void 0 ? void 0 : onClick.apply(void 0, arguments);
        (_a2 = overrideObj.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(overrideObj);
      });
      const mergedMode = overrideObj.mode || mode;
      const mergedSelectable = selectable !== null && selectable !== void 0 ? selectable : overrideObj.selectable;
      const mergedInlineCollapsed = reactExports.useMemo(() => {
        if (siderCollapsed !== void 0) {
          return siderCollapsed;
        }
        return inlineCollapsed;
      }, [inlineCollapsed, siderCollapsed]);
      const defaultMotions = {
        horizontal: {
          motionName: `${rootPrefixCls}-slide-up`
        },
        inline: initCollapseMotion(rootPrefixCls),
        other: {
          motionName: `${rootPrefixCls}-zoom-big`
        }
      };
      const prefixCls = getPrefixCls("menu", customizePrefixCls || overrideObj.prefixCls);
      const rootCls = useCSSVarCls$1(prefixCls);
      const [wrapCSSVar, hashId] = useStyle$e(prefixCls, rootCls, !override);
      const menuClassName = classNames(`${prefixCls}-${theme}`, menu === null || menu === void 0 ? void 0 : menu.className, className);
      let mergedExpandIcon;
      if (typeof expandIcon === "function") {
        mergedExpandIcon = expandIcon;
      } else if (expandIcon === null || expandIcon === false) {
        mergedExpandIcon = null;
      } else if (overrideObj.expandIcon === null || overrideObj.expandIcon === false) {
        mergedExpandIcon = null;
      } else {
        const beClone = expandIcon !== null && expandIcon !== void 0 ? expandIcon : overrideObj.expandIcon;
        mergedExpandIcon = cloneElement(beClone, {
          className: classNames(`${prefixCls}-submenu-expand-icon`, isValidElement(beClone) ? (_b = beClone.props) === null || _b === void 0 ? void 0 : _b.className : "")
        });
      }
      const contextValue = reactExports.useMemo(() => ({
        prefixCls,
        inlineCollapsed: mergedInlineCollapsed || false,
        direction,
        firstLevel: true,
        theme,
        mode: mergedMode,
        disableMenuItemTitleTooltip: _internalDisableMenuItemTitleTooltip
      }), [prefixCls, mergedInlineCollapsed, direction, _internalDisableMenuItemTitleTooltip, theme]);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(OverrideContext$1.Provider, {
        value: null
      }, /* @__PURE__ */ reactExports.createElement(MenuContext$1.Provider, {
        value: contextValue
      }, /* @__PURE__ */ reactExports.createElement(ExportMenu, Object.assign({
        getPopupContainer,
        overflowedIndicator: /* @__PURE__ */ reactExports.createElement(EllipsisOutlined$1, null),
        overflowedIndicatorPopupClassName: classNames(prefixCls, `${prefixCls}-${theme}`, overflowedIndicatorPopupClassName),
        mode: mergedMode,
        selectable: mergedSelectable,
        onClick: onItemClick
      }, passedProps, {
        inlineCollapsed: mergedInlineCollapsed,
        style: Object.assign(Object.assign({}, menu === null || menu === void 0 ? void 0 : menu.style), style2),
        className: menuClassName,
        prefixCls,
        direction,
        defaultMotions,
        expandIcon: mergedExpandIcon,
        ref,
        rootClassName: classNames(rootClassName, hashId, overrideObj.rootClassName, rootCls)
      }), mergedChildren))));
    });
    const InternalMenu$1 = InternalMenu;
    const Menu = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const menuRef = reactExports.useRef(null);
      const context = reactExports.useContext(SiderContext);
      reactExports.useImperativeHandle(ref, () => ({
        menu: menuRef.current,
        focus: (options) => {
          var _a;
          (_a = menuRef.current) === null || _a === void 0 ? void 0 : _a.focus(options);
        }
      }));
      return /* @__PURE__ */ reactExports.createElement(InternalMenu$1, Object.assign({
        ref: menuRef
      }, props, context));
    });
    Menu.Item = Item$3;
    Menu.SubMenu = SubMenu$1;
    Menu.Divider = MenuDivider$1;
    Menu.ItemGroup = MenuItemGroup;
    const Menu$1 = Menu;
    const genStatusStyle$1 = (token2) => {
      const {
        componentCls,
        menuCls,
        colorError,
        colorTextLightSolid
      } = token2;
      const itemCls = `${menuCls}-item`;
      return {
        [`${componentCls}, ${componentCls}-menu-submenu`]: {
          [`${menuCls} ${itemCls}`]: {
            [`&${itemCls}-danger:not(${itemCls}-disabled)`]: {
              color: colorError,
              "&:hover": {
                color: colorTextLightSolid,
                backgroundColor: colorError
              }
            }
          }
        }
      };
    };
    const genStatusStyle$2 = genStatusStyle$1;
    const genBaseStyle$3 = (token2) => {
      const {
        componentCls,
        menuCls,
        zIndexPopup,
        dropdownArrowDistance,
        sizePopupArrow,
        antCls,
        iconCls,
        motionDurationMid,
        paddingBlock,
        fontSize,
        dropdownEdgeChildPadding,
        colorTextDisabled,
        fontSizeIcon,
        controlPaddingHorizontal,
        colorBgElevated
      } = token2;
      return [
        {
          [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
            position: "absolute",
            top: -9999,
            left: {
              _skip_check_: true,
              value: -9999
            },
            zIndex: zIndexPopup,
            display: "block",
            // A placeholder out of dropdown visible range to avoid close when user moving
            "&::before": {
              position: "absolute",
              insetBlock: token2.calc(sizePopupArrow).div(2).sub(dropdownArrowDistance).equal(),
              // insetInlineStart: -7, // FIXME: Seems not work for hidden element
              zIndex: -9999,
              opacity: 1e-4,
              content: '""'
            },
            [`&-trigger${antCls}-btn`]: {
              [`& > ${iconCls}-down, & > ${antCls}-btn-icon > ${iconCls}-down`]: {
                fontSize: fontSizeIcon
              }
            },
            [`${componentCls}-wrap`]: {
              position: "relative",
              [`${antCls}-btn > ${iconCls}-down`]: {
                fontSize: fontSizeIcon
              },
              [`${iconCls}-down::before`]: {
                transition: `transform ${motionDurationMid}`
              }
            },
            [`${componentCls}-wrap-open`]: {
              [`${iconCls}-down::before`]: {
                transform: `rotate(180deg)`
              }
            },
            [`
        &-hidden,
        &-menu-hidden,
        &-menu-submenu-hidden
      `]: {
              display: "none"
            },
            // =============================================================
            // ==                         Motion                          ==
            // =============================================================
            // When position is not enough for dropdown, the placement will revert.
            // We will handle this with revert motion name.
            [`&${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottomRight,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottomRight`]: {
              animationName: slideUpIn
            },
            [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-top,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-top,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-topRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-topRight`]: {
              animationName: slideDownIn
            },
            [`&${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottomRight`]: {
              animationName: slideUpOut
            },
            [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-top,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-topRight`]: {
              animationName: slideDownOut
            }
          })
        },
        // =============================================================
        // ==                        Arrow style                      ==
        // =============================================================
        getArrowStyle(token2, colorBgElevated, {
          arrowPlacement: {
            top: true,
            bottom: true
          }
        }),
        {
          // =============================================================
          // ==                          Menu                           ==
          // =============================================================
          [`${componentCls} ${menuCls}`]: {
            position: "relative",
            margin: 0
          },
          [`${menuCls}-submenu-popup`]: {
            position: "absolute",
            zIndex: zIndexPopup,
            background: "transparent",
            boxShadow: "none",
            transformOrigin: "0 0",
            "ul, li": {
              listStyle: "none",
              margin: 0
            }
          },
          [`${componentCls}, ${componentCls}-menu-submenu`]: {
            [menuCls]: Object.assign(Object.assign({
              padding: dropdownEdgeChildPadding,
              listStyleType: "none",
              backgroundColor: colorBgElevated,
              backgroundClip: "padding-box",
              borderRadius: token2.borderRadiusLG,
              outline: "none",
              boxShadow: token2.boxShadowSecondary
            }, genFocusStyle(token2)), {
              [`${menuCls}-item-group-title`]: {
                padding: `${unit$1(paddingBlock)} ${unit$1(controlPaddingHorizontal)}`,
                color: token2.colorTextDescription,
                transition: `all ${motionDurationMid}`
              },
              // ======================= Item Content =======================
              [`${menuCls}-item`]: {
                position: "relative",
                display: "flex",
                alignItems: "center"
              },
              [`${menuCls}-item-icon`]: {
                minWidth: fontSize,
                marginInlineEnd: token2.marginXS,
                fontSize: token2.fontSizeSM
              },
              [`${menuCls}-title-content`]: {
                flex: "auto",
                "> a": {
                  color: "inherit",
                  transition: `all ${motionDurationMid}`,
                  "&:hover": {
                    color: "inherit"
                  },
                  "&::after": {
                    position: "absolute",
                    inset: 0,
                    content: '""'
                  }
                }
              },
              // =========================== Item ===========================
              [`${menuCls}-item, ${menuCls}-submenu-title`]: Object.assign(Object.assign({
                clear: "both",
                margin: 0,
                padding: `${unit$1(paddingBlock)} ${unit$1(controlPaddingHorizontal)}`,
                color: token2.colorText,
                fontWeight: "normal",
                fontSize,
                lineHeight: token2.lineHeight,
                cursor: "pointer",
                transition: `all ${motionDurationMid}`,
                borderRadius: token2.borderRadiusSM,
                [`&:hover, &-active`]: {
                  backgroundColor: token2.controlItemBgHover
                }
              }, genFocusStyle(token2)), {
                "&-selected": {
                  color: token2.colorPrimary,
                  backgroundColor: token2.controlItemBgActive,
                  "&:hover, &-active": {
                    backgroundColor: token2.controlItemBgActiveHover
                  }
                },
                "&-disabled": {
                  color: colorTextDisabled,
                  cursor: "not-allowed",
                  "&:hover": {
                    color: colorTextDisabled,
                    backgroundColor: colorBgElevated,
                    cursor: "not-allowed"
                  },
                  a: {
                    pointerEvents: "none"
                  }
                },
                "&-divider": {
                  height: 1,
                  // By design
                  margin: `${unit$1(token2.marginXXS)} 0`,
                  overflow: "hidden",
                  lineHeight: 0,
                  backgroundColor: token2.colorSplit
                },
                [`${componentCls}-menu-submenu-expand-icon`]: {
                  position: "absolute",
                  insetInlineEnd: token2.paddingXS,
                  [`${componentCls}-menu-submenu-arrow-icon`]: {
                    marginInlineEnd: "0 !important",
                    color: token2.colorTextDescription,
                    fontSize: fontSizeIcon,
                    fontStyle: "normal"
                  }
                }
              }),
              [`${menuCls}-item-group-list`]: {
                margin: `0 ${unit$1(token2.marginXS)}`,
                padding: 0,
                listStyle: "none"
              },
              [`${menuCls}-submenu-title`]: {
                paddingInlineEnd: token2.calc(controlPaddingHorizontal).add(token2.fontSizeSM).equal()
              },
              [`${menuCls}-submenu-vertical`]: {
                position: "relative"
              },
              [`${menuCls}-submenu${menuCls}-submenu-disabled ${componentCls}-menu-submenu-title`]: {
                [`&, ${componentCls}-menu-submenu-arrow-icon`]: {
                  color: colorTextDisabled,
                  backgroundColor: colorBgElevated,
                  cursor: "not-allowed"
                }
              },
              // https://github.com/ant-design/ant-design/issues/19264
              [`${menuCls}-submenu-selected ${componentCls}-menu-submenu-title`]: {
                color: token2.colorPrimary
              }
            })
          }
        },
        // Follow code may reuse in other components
        [initSlideMotion(token2, "slide-up"), initSlideMotion(token2, "slide-down"), initMoveMotion(token2, "move-up"), initMoveMotion(token2, "move-down"), initZoomMotion(token2, "zoom-big")]
      ];
    };
    const prepareComponentToken$b = (token2) => Object.assign(Object.assign({
      zIndexPopup: token2.zIndexPopupBase + 50,
      paddingBlock: (token2.controlHeight - token2.fontSize * token2.lineHeight) / 2
    }, getArrowOffsetToken({
      contentRadius: token2.borderRadiusLG,
      limitVerticalRadius: true
    })), getArrowToken(token2));
    const useStyle$d = genStyleHooks("Dropdown", (token2) => {
      const {
        marginXXS,
        sizePopupArrow,
        paddingXXS,
        componentCls
      } = token2;
      const dropdownToken = merge$1(token2, {
        menuCls: `${componentCls}-menu`,
        dropdownArrowDistance: token2.calc(sizePopupArrow).div(2).add(marginXXS).equal(),
        dropdownEdgeChildPadding: paddingXXS
      });
      return [genBaseStyle$3(dropdownToken), genStatusStyle$2(dropdownToken)];
    }, prepareComponentToken$b);
    const Dropdown$2 = (props) => {
      const {
        menu,
        arrow,
        prefixCls: customizePrefixCls,
        children,
        trigger,
        disabled,
        dropdownRender,
        getPopupContainer,
        overlayClassName,
        rootClassName,
        overlayStyle,
        open,
        onOpenChange,
        // Deprecated
        visible,
        onVisibleChange,
        mouseEnterDelay = 0.15,
        mouseLeaveDelay = 0.1,
        autoAdjustOverflow: autoAdjustOverflow2 = true,
        placement = "",
        overlay,
        transitionName
      } = props;
      const {
        getPopupContainer: getContextPopupContainer,
        getPrefixCls,
        direction,
        dropdown
      } = reactExports.useContext(ConfigContext);
      devUseWarning();
      const memoTransitionName = reactExports.useMemo(() => {
        const rootPrefixCls = getPrefixCls();
        if (transitionName !== void 0) {
          return transitionName;
        }
        if (placement.includes("top")) {
          return `${rootPrefixCls}-slide-down`;
        }
        return `${rootPrefixCls}-slide-up`;
      }, [getPrefixCls, placement, transitionName]);
      const memoPlacement = reactExports.useMemo(() => {
        if (!placement) {
          return direction === "rtl" ? "bottomRight" : "bottomLeft";
        }
        if (placement.includes("Center")) {
          return placement.slice(0, placement.indexOf("Center"));
        }
        return placement;
      }, [placement, direction]);
      const prefixCls = getPrefixCls("dropdown", customizePrefixCls);
      const rootCls = useCSSVarCls$1(prefixCls);
      const [wrapCSSVar, hashId] = useStyle$d(prefixCls, rootCls);
      const [, token2] = useToken$1();
      const child = reactExports.Children.only(children);
      const dropdownTrigger = cloneElement(child, {
        className: classNames(`${prefixCls}-trigger`, {
          [`${prefixCls}-rtl`]: direction === "rtl"
        }, child.props.className),
        disabled
      });
      const triggerActions = disabled ? [] : trigger;
      let alignPoint;
      if (triggerActions && triggerActions.includes("contextMenu")) {
        alignPoint = true;
      }
      const [mergedOpen, setOpen] = useMergedState(false, {
        value: open !== null && open !== void 0 ? open : visible
      });
      const onInnerOpenChange = useEvent((nextOpen) => {
        onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(nextOpen, {
          source: "trigger"
        });
        onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(nextOpen);
        setOpen(nextOpen);
      });
      const overlayClassNameCustomized = classNames(overlayClassName, rootClassName, hashId, rootCls, dropdown === null || dropdown === void 0 ? void 0 : dropdown.className, {
        [`${prefixCls}-rtl`]: direction === "rtl"
      });
      const builtinPlacements = getPlacements({
        arrowPointAtCenter: typeof arrow === "object" && arrow.pointAtCenter,
        autoAdjustOverflow: autoAdjustOverflow2,
        offset: token2.marginXXS,
        arrowWidth: arrow ? token2.sizePopupArrow : 0,
        borderRadius: token2.borderRadius
      });
      const onMenuClick = reactExports.useCallback(() => {
        if ((menu === null || menu === void 0 ? void 0 : menu.selectable) && (menu === null || menu === void 0 ? void 0 : menu.multiple)) {
          return;
        }
        onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(false, {
          source: "menu"
        });
        setOpen(false);
      }, [menu === null || menu === void 0 ? void 0 : menu.selectable, menu === null || menu === void 0 ? void 0 : menu.multiple]);
      const renderOverlay = () => {
        let overlayNode;
        if (menu === null || menu === void 0 ? void 0 : menu.items) {
          overlayNode = /* @__PURE__ */ reactExports.createElement(Menu$1, Object.assign({}, menu));
        } else if (typeof overlay === "function") {
          overlayNode = overlay();
        } else {
          overlayNode = overlay;
        }
        if (dropdownRender) {
          overlayNode = dropdownRender(overlayNode);
        }
        overlayNode = reactExports.Children.only(typeof overlayNode === "string" ? /* @__PURE__ */ reactExports.createElement("span", null, overlayNode) : overlayNode);
        return /* @__PURE__ */ reactExports.createElement(OverrideProvider, {
          prefixCls: `${prefixCls}-menu`,
          rootClassName: rootCls,
          expandIcon: /* @__PURE__ */ reactExports.createElement("span", {
            className: `${prefixCls}-menu-submenu-arrow`
          }, /* @__PURE__ */ reactExports.createElement(RightOutlined$1, {
            className: `${prefixCls}-menu-submenu-arrow-icon`
          })),
          mode: "vertical",
          selectable: false,
          onClick: onMenuClick,
          validator: (_ref3) => {
          }
        }, overlayNode);
      };
      const [zIndex, contextZIndex] = useZIndex("Dropdown", overlayStyle === null || overlayStyle === void 0 ? void 0 : overlayStyle.zIndex);
      let renderNode = /* @__PURE__ */ reactExports.createElement(Dropdown$4, Object.assign({
        alignPoint
      }, omit(props, ["rootClassName"]), {
        mouseEnterDelay,
        mouseLeaveDelay,
        visible: mergedOpen,
        builtinPlacements,
        arrow: !!arrow,
        overlayClassName: overlayClassNameCustomized,
        prefixCls,
        getPopupContainer: getPopupContainer || getContextPopupContainer,
        transitionName: memoTransitionName,
        trigger: triggerActions,
        overlay: renderOverlay,
        placement: memoPlacement,
        onVisibleChange: onInnerOpenChange,
        overlayStyle: Object.assign(Object.assign(Object.assign({}, dropdown === null || dropdown === void 0 ? void 0 : dropdown.style), overlayStyle), {
          zIndex
        })
      }), dropdownTrigger);
      if (zIndex) {
        renderNode = /* @__PURE__ */ reactExports.createElement(zIndexContext$1.Provider, {
          value: contextZIndex
        }, renderNode);
      }
      return wrapCSSVar(renderNode);
    };
    function postPureProps$1(props) {
      return Object.assign(Object.assign({}, props), {
        align: {
          overflow: {
            adjustX: false,
            adjustY: false
          }
        }
      });
    }
    const PurePanel$1 = genPurePanel$1(Dropdown$2, "dropdown", (prefixCls) => prefixCls, postPureProps$1);
    const WrapPurePanel = (props) => /* @__PURE__ */ reactExports.createElement(PurePanel$1, Object.assign({}, props), /* @__PURE__ */ reactExports.createElement("span", null));
    Dropdown$2._InternalPanelDoNotUseOrYouWillBeFired = WrapPurePanel;
    const InternalDropdown = Dropdown$2;
    const BreadcrumbSeparator = (_ref) => {
      let {
        children
      } = _ref;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("breadcrumb");
      return /* @__PURE__ */ reactExports.createElement("li", {
        className: `${prefixCls}-separator`,
        "aria-hidden": "true"
      }, children === "" ? children : children || "/");
    };
    BreadcrumbSeparator.__ANT_BREADCRUMB_SEPARATOR = true;
    const BreadcrumbSeparator$1 = BreadcrumbSeparator;
    var __rest$s = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    function getBreadcrumbName(route, params) {
      if (route.title === void 0 || route.title === null) {
        return null;
      }
      const paramsKeys = Object.keys(params).join("|");
      return typeof route.title === "object" ? route.title : String(route.title).replace(new RegExp(`:(${paramsKeys})`, "g"), (replacement, key) => params[key] || replacement);
    }
    function renderItem(prefixCls, item, children, href) {
      if (children === null || children === void 0) {
        return null;
      }
      const {
        className,
        onClick
      } = item, restItem = __rest$s(item, ["className", "onClick"]);
      const passedProps = Object.assign(Object.assign({}, pickAttrs(restItem, {
        data: true,
        aria: true
      })), {
        onClick
      });
      if (href !== void 0) {
        return /* @__PURE__ */ reactExports.createElement("a", Object.assign({}, passedProps, {
          className: classNames(`${prefixCls}-link`, className),
          href
        }), children);
      }
      return /* @__PURE__ */ reactExports.createElement("span", Object.assign({}, passedProps, {
        className: classNames(`${prefixCls}-link`, className)
      }), children);
    }
    function useItemRender(prefixCls, itemRender) {
      const mergedItemRender = (item, params, routes, path, href) => {
        if (itemRender) {
          return itemRender(item, params, routes, path);
        }
        const name = getBreadcrumbName(item, params);
        return renderItem(prefixCls, item, name, href);
      };
      return mergedItemRender;
    }
    var __rest$r = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const InternalBreadcrumbItem = (props) => {
      const {
        prefixCls,
        separator = "/",
        children,
        menu,
        overlay,
        dropdownProps,
        href
      } = props;
      const renderBreadcrumbNode = (breadcrumbItem) => {
        if (menu || overlay) {
          const mergeDropDownProps = Object.assign({}, dropdownProps);
          if (menu) {
            const _a = menu || {}, {
              items
            } = _a, menuProps = __rest$r(_a, ["items"]);
            mergeDropDownProps.menu = Object.assign(Object.assign({}, menuProps), {
              items: items === null || items === void 0 ? void 0 : items.map((_a2, index2) => {
                var {
                  key,
                  title,
                  label,
                  path
                } = _a2, itemProps = __rest$r(_a2, ["key", "title", "label", "path"]);
                let mergedLabel = label !== null && label !== void 0 ? label : title;
                if (path) {
                  mergedLabel = /* @__PURE__ */ reactExports.createElement("a", {
                    href: `${href}${path}`
                  }, mergedLabel);
                }
                return Object.assign(Object.assign({}, itemProps), {
                  key: key !== null && key !== void 0 ? key : index2,
                  label: mergedLabel
                });
              })
            });
          } else if (overlay) {
            mergeDropDownProps.overlay = overlay;
          }
          return /* @__PURE__ */ reactExports.createElement(InternalDropdown, Object.assign({
            placement: "bottom"
          }, mergeDropDownProps), /* @__PURE__ */ reactExports.createElement("span", {
            className: `${prefixCls}-overlay-link`
          }, breadcrumbItem, /* @__PURE__ */ reactExports.createElement(DownOutlined$1, null)));
        }
        return breadcrumbItem;
      };
      const link = renderBreadcrumbNode(children);
      if (link !== void 0 && link !== null) {
        return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("li", null, link), separator && /* @__PURE__ */ reactExports.createElement(BreadcrumbSeparator$1, null, separator));
      }
      return null;
    };
    const BreadcrumbItem = (props) => {
      const {
        prefixCls: customizePrefixCls,
        children,
        href
      } = props, restProps = __rest$r(props, ["prefixCls", "children", "href"]);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("breadcrumb", customizePrefixCls);
      return /* @__PURE__ */ reactExports.createElement(InternalBreadcrumbItem, Object.assign({}, restProps, {
        prefixCls
      }), renderItem(prefixCls, restProps, children, href));
    };
    BreadcrumbItem.__ANT_BREADCRUMB_ITEM = true;
    const BreadcrumbItem$1 = BreadcrumbItem;
    const genBreadcrumbStyle = (token2) => {
      const {
        componentCls,
        iconCls,
        calc
      } = token2;
      return {
        [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
          color: token2.itemColor,
          fontSize: token2.fontSize,
          [iconCls]: {
            fontSize: token2.iconFontSize
          },
          ol: {
            display: "flex",
            flexWrap: "wrap",
            margin: 0,
            padding: 0,
            listStyle: "none"
          },
          a: Object.assign({
            color: token2.linkColor,
            transition: `color ${token2.motionDurationMid}`,
            padding: `0 ${unit$1(token2.paddingXXS)}`,
            borderRadius: token2.borderRadiusSM,
            height: token2.fontHeight,
            display: "inline-block",
            marginInline: calc(token2.marginXXS).mul(-1).equal(),
            "&:hover": {
              color: token2.linkHoverColor,
              backgroundColor: token2.colorBgTextHover
            }
          }, genFocusStyle(token2)),
          [`li:last-child`]: {
            color: token2.lastItemColor
          },
          [`${componentCls}-separator`]: {
            marginInline: token2.separatorMargin,
            color: token2.separatorColor
          },
          [`${componentCls}-link`]: {
            [`
          > ${iconCls} + span,
          > ${iconCls} + a
        `]: {
              marginInlineStart: token2.marginXXS
            }
          },
          [`${componentCls}-overlay-link`]: {
            borderRadius: token2.borderRadiusSM,
            height: token2.fontHeight,
            display: "inline-block",
            padding: `0 ${unit$1(token2.paddingXXS)}`,
            marginInline: calc(token2.marginXXS).mul(-1).equal(),
            [`> ${iconCls}`]: {
              marginInlineStart: token2.marginXXS,
              fontSize: token2.fontSizeIcon
            },
            "&:hover": {
              color: token2.linkHoverColor,
              backgroundColor: token2.colorBgTextHover,
              a: {
                color: token2.linkHoverColor
              }
            },
            a: {
              "&:hover": {
                backgroundColor: "transparent"
              }
            }
          },
          // rtl style
          [`&${token2.componentCls}-rtl`]: {
            direction: "rtl"
          }
        })
      };
    };
    const prepareComponentToken$a = (token2) => ({
      itemColor: token2.colorTextDescription,
      lastItemColor: token2.colorText,
      iconFontSize: token2.fontSize,
      linkColor: token2.colorTextDescription,
      linkHoverColor: token2.colorText,
      separatorColor: token2.colorTextDescription,
      separatorMargin: token2.marginXS
    });
    const useStyle$c = genStyleHooks("Breadcrumb", (token2) => {
      const breadcrumbToken = merge$1(token2, {});
      return genBreadcrumbStyle(breadcrumbToken);
    }, prepareComponentToken$a);
    var __rest$q = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    function route2item(route) {
      const {
        breadcrumbName,
        children
      } = route, rest = __rest$q(route, ["breadcrumbName", "children"]);
      const clone2 = Object.assign({
        title: breadcrumbName
      }, rest);
      if (children) {
        clone2.menu = {
          items: children.map((_a) => {
            var {
              breadcrumbName: itemBreadcrumbName
            } = _a, itemProps = __rest$q(_a, ["breadcrumbName"]);
            return Object.assign(Object.assign({}, itemProps), {
              title: itemBreadcrumbName
            });
          })
        };
      }
      return clone2;
    }
    function useItems(items, routes) {
      return reactExports.useMemo(() => {
        if (items) {
          return items;
        }
        if (routes) {
          return routes.map(route2item);
        }
        return null;
      }, [items, routes]);
    }
    var __rest$p = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const getPath = (params, path) => {
      if (path === void 0) {
        return path;
      }
      let mergedPath = (path || "").replace(/^\//, "");
      Object.keys(params).forEach((key) => {
        mergedPath = mergedPath.replace(`:${key}`, params[key]);
      });
      return mergedPath;
    };
    const Breadcrumb = (props) => {
      const {
        prefixCls: customizePrefixCls,
        separator = "/",
        style: style2,
        className,
        rootClassName,
        routes: legacyRoutes,
        items,
        children,
        itemRender,
        params = {}
      } = props, restProps = __rest$p(props, ["prefixCls", "separator", "style", "className", "rootClassName", "routes", "items", "children", "itemRender", "params"]);
      const {
        getPrefixCls,
        direction,
        breadcrumb
      } = reactExports.useContext(ConfigContext);
      let crumbs;
      const prefixCls = getPrefixCls("breadcrumb", customizePrefixCls);
      const [wrapCSSVar, hashId] = useStyle$c(prefixCls);
      const mergedItems = useItems(items, legacyRoutes);
      const mergedItemRender = useItemRender(prefixCls, itemRender);
      if (mergedItems && mergedItems.length > 0) {
        const paths = [];
        const itemRenderRoutes = items || legacyRoutes;
        crumbs = mergedItems.map((item, index2) => {
          const {
            path,
            key,
            type,
            menu,
            overlay,
            onClick,
            className: itemClassName,
            separator: itemSeparator,
            dropdownProps
          } = item;
          const mergedPath = getPath(params, path);
          if (mergedPath !== void 0) {
            paths.push(mergedPath);
          }
          const mergedKey = key !== null && key !== void 0 ? key : index2;
          if (type === "separator") {
            return /* @__PURE__ */ reactExports.createElement(BreadcrumbSeparator$1, {
              key: mergedKey
            }, itemSeparator);
          }
          const itemProps = {};
          const isLastItem = index2 === mergedItems.length - 1;
          if (menu) {
            itemProps.menu = menu;
          } else if (overlay) {
            itemProps.overlay = overlay;
          }
          let {
            href
          } = item;
          if (paths.length && mergedPath !== void 0) {
            href = `#/${paths.join("/")}`;
          }
          return /* @__PURE__ */ reactExports.createElement(InternalBreadcrumbItem, Object.assign({
            key: mergedKey
          }, itemProps, pickAttrs(item, {
            data: true,
            aria: true
          }), {
            className: itemClassName,
            dropdownProps,
            href,
            separator: isLastItem ? "" : separator,
            onClick,
            prefixCls
          }), mergedItemRender(item, params, itemRenderRoutes, paths, href));
        });
      } else if (children) {
        const childrenLength = toArray$a(children).length;
        crumbs = toArray$a(children).map((element, index2) => {
          if (!element) {
            return element;
          }
          const isLastItem = index2 === childrenLength - 1;
          return cloneElement(element, {
            separator: isLastItem ? "" : separator,
            key: index2
          });
        });
      }
      const breadcrumbClassName = classNames(prefixCls, breadcrumb === null || breadcrumb === void 0 ? void 0 : breadcrumb.className, {
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, className, rootClassName, hashId);
      const mergedStyle = Object.assign(Object.assign({}, breadcrumb === null || breadcrumb === void 0 ? void 0 : breadcrumb.style), style2);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("nav", Object.assign({
        className: breadcrumbClassName,
        style: mergedStyle
      }, restProps), /* @__PURE__ */ reactExports.createElement("ol", null, crumbs)));
    };
    Breadcrumb.Item = BreadcrumbItem$1;
    Breadcrumb.Separator = BreadcrumbSeparator$1;
    const Breadcrumb$1 = Breadcrumb;
    var dayjs_min = { exports: {} };
    (function(module2, exports2) {
      !function(t2, e2) {
        module2.exports = e2();
      }(commonjsGlobal, function() {
        var t2 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i = "second", s = "minute", u2 = "hour", a = "day", o2 = "week", c2 = "month", f2 = "quarter", h2 = "year", d2 = "date", l2 = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
          var e3 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
          return "[" + t3 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
        } }, m2 = function(t3, e3, n3) {
          var r3 = String(t3);
          return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
        }, v2 = { s: m2, z: function(t3) {
          var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i2 = n3 % 60;
          return (e3 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i2, 2, "0");
        }, m: function t3(e3, n3) {
          if (e3.date() < n3.date())
            return -t3(n3, e3);
          var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i2 = e3.clone().add(r3, c2), s2 = n3 - i2 < 0, u3 = e3.clone().add(r3 + (s2 ? -1 : 1), c2);
          return +(-(r3 + (n3 - i2) / (s2 ? i2 - u3 : u3 - i2)) || 0);
        }, a: function(t3) {
          return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
        }, p: function(t3) {
          return { M: c2, y: h2, w: o2, d: a, D: d2, h: u2, m: s, s: i, ms: r2, Q: f2 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
        }, u: function(t3) {
          return void 0 === t3;
        } }, g2 = "en", D2 = {};
        D2[g2] = M2;
        var p2 = "$isDayjsObject", S2 = function(t3) {
          return t3 instanceof _ || !(!t3 || !t3[p2]);
        }, w2 = function t3(e3, n3, r3) {
          var i2;
          if (!e3)
            return g2;
          if ("string" == typeof e3) {
            var s2 = e3.toLowerCase();
            D2[s2] && (i2 = s2), n3 && (D2[s2] = n3, i2 = s2);
            var u3 = e3.split("-");
            if (!i2 && u3.length > 1)
              return t3(u3[0]);
          } else {
            var a2 = e3.name;
            D2[a2] = e3, i2 = a2;
          }
          return !r3 && i2 && (g2 = i2), i2 || !r3 && g2;
        }, O2 = function(t3, e3) {
          if (S2(t3))
            return t3.clone();
          var n3 = "object" == typeof e3 ? e3 : {};
          return n3.date = t3, n3.args = arguments, new _(n3);
        }, b2 = v2;
        b2.l = w2, b2.i = S2, b2.w = function(t3, e3) {
          return O2(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
        };
        var _ = function() {
          function M3(t3) {
            this.$L = w2(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p2] = true;
          }
          var m3 = M3.prototype;
          return m3.parse = function(t3) {
            this.$d = function(t4) {
              var e3 = t4.date, n3 = t4.utc;
              if (null === e3)
                return /* @__PURE__ */ new Date(NaN);
              if (b2.u(e3))
                return /* @__PURE__ */ new Date();
              if (e3 instanceof Date)
                return new Date(e3);
              if ("string" == typeof e3 && !/Z$/i.test(e3)) {
                var r3 = e3.match($);
                if (r3) {
                  var i2 = r3[2] - 1 || 0, s2 = (r3[7] || "0").substring(0, 3);
                  return n3 ? new Date(Date.UTC(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2)) : new Date(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2);
                }
              }
              return new Date(e3);
            }(t3), this.init();
          }, m3.init = function() {
            var t3 = this.$d;
            this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
          }, m3.$utils = function() {
            return b2;
          }, m3.isValid = function() {
            return !(this.$d.toString() === l2);
          }, m3.isSame = function(t3, e3) {
            var n3 = O2(t3);
            return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
          }, m3.isAfter = function(t3, e3) {
            return O2(t3) < this.startOf(e3);
          }, m3.isBefore = function(t3, e3) {
            return this.endOf(e3) < O2(t3);
          }, m3.$g = function(t3, e3, n3) {
            return b2.u(t3) ? this[e3] : this.set(n3, t3);
          }, m3.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, m3.valueOf = function() {
            return this.$d.getTime();
          }, m3.startOf = function(t3, e3) {
            var n3 = this, r3 = !!b2.u(e3) || e3, f3 = b2.p(t3), l3 = function(t4, e4) {
              var i2 = b2.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
              return r3 ? i2 : i2.endOf(a);
            }, $2 = function(t4, e4) {
              return b2.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
            }, y3 = this.$W, M4 = this.$M, m4 = this.$D, v3 = "set" + (this.$u ? "UTC" : "");
            switch (f3) {
              case h2:
                return r3 ? l3(1, 0) : l3(31, 11);
              case c2:
                return r3 ? l3(1, M4) : l3(0, M4 + 1);
              case o2:
                var g3 = this.$locale().weekStart || 0, D3 = (y3 < g3 ? y3 + 7 : y3) - g3;
                return l3(r3 ? m4 - D3 : m4 + (6 - D3), M4);
              case a:
              case d2:
                return $2(v3 + "Hours", 0);
              case u2:
                return $2(v3 + "Minutes", 1);
              case s:
                return $2(v3 + "Seconds", 2);
              case i:
                return $2(v3 + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, m3.endOf = function(t3) {
            return this.startOf(t3, false);
          }, m3.$set = function(t3, e3) {
            var n3, o3 = b2.p(t3), f3 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a] = f3 + "Date", n3[d2] = f3 + "Date", n3[c2] = f3 + "Month", n3[h2] = f3 + "FullYear", n3[u2] = f3 + "Hours", n3[s] = f3 + "Minutes", n3[i] = f3 + "Seconds", n3[r2] = f3 + "Milliseconds", n3)[o3], $2 = o3 === a ? this.$D + (e3 - this.$W) : e3;
            if (o3 === c2 || o3 === h2) {
              var y3 = this.clone().set(d2, 1);
              y3.$d[l3]($2), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
            } else
              l3 && this.$d[l3]($2);
            return this.init(), this;
          }, m3.set = function(t3, e3) {
            return this.clone().$set(t3, e3);
          }, m3.get = function(t3) {
            return this[b2.p(t3)]();
          }, m3.add = function(r3, f3) {
            var d3, l3 = this;
            r3 = Number(r3);
            var $2 = b2.p(f3), y3 = function(t3) {
              var e3 = O2(l3);
              return b2.w(e3.date(e3.date() + Math.round(t3 * r3)), l3);
            };
            if ($2 === c2)
              return this.set(c2, this.$M + r3);
            if ($2 === h2)
              return this.set(h2, this.$y + r3);
            if ($2 === a)
              return y3(1);
            if ($2 === o2)
              return y3(7);
            var M4 = (d3 = {}, d3[s] = e2, d3[u2] = n2, d3[i] = t2, d3)[$2] || 1, m4 = this.$d.getTime() + r3 * M4;
            return b2.w(m4, this);
          }, m3.subtract = function(t3, e3) {
            return this.add(-1 * t3, e3);
          }, m3.format = function(t3) {
            var e3 = this, n3 = this.$locale();
            if (!this.isValid())
              return n3.invalidDate || l2;
            var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b2.z(this), s2 = this.$H, u3 = this.$m, a2 = this.$M, o3 = n3.weekdays, c3 = n3.months, f3 = n3.meridiem, h3 = function(t4, n4, i3, s3) {
              return t4 && (t4[n4] || t4(e3, r3)) || i3[n4].slice(0, s3);
            }, d3 = function(t4) {
              return b2.s(s2 % 12 || 12, t4, "0");
            }, $2 = f3 || function(t4, e4, n4) {
              var r4 = t4 < 12 ? "AM" : "PM";
              return n4 ? r4.toLowerCase() : r4;
            };
            return r3.replace(y2, function(t4, r4) {
              return r4 || function(t5) {
                switch (t5) {
                  case "YY":
                    return String(e3.$y).slice(-2);
                  case "YYYY":
                    return b2.s(e3.$y, 4, "0");
                  case "M":
                    return a2 + 1;
                  case "MM":
                    return b2.s(a2 + 1, 2, "0");
                  case "MMM":
                    return h3(n3.monthsShort, a2, c3, 3);
                  case "MMMM":
                    return h3(c3, a2);
                  case "D":
                    return e3.$D;
                  case "DD":
                    return b2.s(e3.$D, 2, "0");
                  case "d":
                    return String(e3.$W);
                  case "dd":
                    return h3(n3.weekdaysMin, e3.$W, o3, 2);
                  case "ddd":
                    return h3(n3.weekdaysShort, e3.$W, o3, 3);
                  case "dddd":
                    return o3[e3.$W];
                  case "H":
                    return String(s2);
                  case "HH":
                    return b2.s(s2, 2, "0");
                  case "h":
                    return d3(1);
                  case "hh":
                    return d3(2);
                  case "a":
                    return $2(s2, u3, true);
                  case "A":
                    return $2(s2, u3, false);
                  case "m":
                    return String(u3);
                  case "mm":
                    return b2.s(u3, 2, "0");
                  case "s":
                    return String(e3.$s);
                  case "ss":
                    return b2.s(e3.$s, 2, "0");
                  case "SSS":
                    return b2.s(e3.$ms, 3, "0");
                  case "Z":
                    return i2;
                }
                return null;
              }(t4) || i2.replace(":", "");
            });
          }, m3.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, m3.diff = function(r3, d3, l3) {
            var $2, y3 = this, M4 = b2.p(d3), m4 = O2(r3), v3 = (m4.utcOffset() - this.utcOffset()) * e2, g3 = this - m4, D3 = function() {
              return b2.m(y3, m4);
            };
            switch (M4) {
              case h2:
                $2 = D3() / 12;
                break;
              case c2:
                $2 = D3();
                break;
              case f2:
                $2 = D3() / 3;
                break;
              case o2:
                $2 = (g3 - v3) / 6048e5;
                break;
              case a:
                $2 = (g3 - v3) / 864e5;
                break;
              case u2:
                $2 = g3 / n2;
                break;
              case s:
                $2 = g3 / e2;
                break;
              case i:
                $2 = g3 / t2;
                break;
              default:
                $2 = g3;
            }
            return l3 ? $2 : b2.a($2);
          }, m3.daysInMonth = function() {
            return this.endOf(c2).$D;
          }, m3.$locale = function() {
            return D2[this.$L];
          }, m3.locale = function(t3, e3) {
            if (!t3)
              return this.$L;
            var n3 = this.clone(), r3 = w2(t3, e3, true);
            return r3 && (n3.$L = r3), n3;
          }, m3.clone = function() {
            return b2.w(this.$d, this);
          }, m3.toDate = function() {
            return new Date(this.valueOf());
          }, m3.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, m3.toISOString = function() {
            return this.$d.toISOString();
          }, m3.toString = function() {
            return this.$d.toUTCString();
          }, M3;
        }(), k2 = _.prototype;
        return O2.prototype = k2, [["$ms", r2], ["$s", i], ["$m", s], ["$H", u2], ["$W", a], ["$M", c2], ["$y", h2], ["$D", d2]].forEach(function(t3) {
          k2[t3[1]] = function(e3) {
            return this.$g(e3, t3[0], t3[1]);
          };
        }), O2.extend = function(t3, e3) {
          return t3.$i || (t3(e3, _, O2), t3.$i = true), O2;
        }, O2.locale = w2, O2.isDayjs = S2, O2.unix = function(t3) {
          return O2(1e3 * t3);
        }, O2.en = D2[g2], O2.Ls = D2, O2.p = {}, O2;
      });
    })(dayjs_min);
    var dayjs_minExports = dayjs_min.exports;
    const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
    var weekday$1 = { exports: {} };
    (function(module2, exports2) {
      !function(e2, t2) {
        module2.exports = t2();
      }(commonjsGlobal, function() {
        return function(e2, t2) {
          t2.prototype.weekday = function(e3) {
            var t3 = this.$locale().weekStart || 0, i = this.$W, n2 = (i < t3 ? i + 7 : i) - t3;
            return this.$utils().u(e3) ? n2 : this.subtract(n2, "day").add(e3, "day");
          };
        };
      });
    })(weekday$1);
    var weekdayExports = weekday$1.exports;
    const weekday = /* @__PURE__ */ getDefaultExportFromCjs(weekdayExports);
    var localeData$2 = { exports: {} };
    (function(module2, exports2) {
      !function(n2, e2) {
        module2.exports = e2();
      }(commonjsGlobal, function() {
        return function(n2, e2, t2) {
          var r2 = e2.prototype, o2 = function(n3) {
            return n3 && (n3.indexOf ? n3 : n3.s);
          }, u2 = function(n3, e3, t3, r3, u3) {
            var i2 = n3.name ? n3 : n3.$locale(), a2 = o2(i2[e3]), s2 = o2(i2[t3]), f2 = a2 || s2.map(function(n4) {
              return n4.slice(0, r3);
            });
            if (!u3)
              return f2;
            var d2 = i2.weekStart;
            return f2.map(function(n4, e4) {
              return f2[(e4 + (d2 || 0)) % 7];
            });
          }, i = function() {
            return t2.Ls[t2.locale()];
          }, a = function(n3, e3) {
            return n3.formats[e3] || function(n4) {
              return n4.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(n5, e4, t3) {
                return e4 || t3.slice(1);
              });
            }(n3.formats[e3.toUpperCase()]);
          }, s = function() {
            var n3 = this;
            return { months: function(e3) {
              return e3 ? e3.format("MMMM") : u2(n3, "months");
            }, monthsShort: function(e3) {
              return e3 ? e3.format("MMM") : u2(n3, "monthsShort", "months", 3);
            }, firstDayOfWeek: function() {
              return n3.$locale().weekStart || 0;
            }, weekdays: function(e3) {
              return e3 ? e3.format("dddd") : u2(n3, "weekdays");
            }, weekdaysMin: function(e3) {
              return e3 ? e3.format("dd") : u2(n3, "weekdaysMin", "weekdays", 2);
            }, weekdaysShort: function(e3) {
              return e3 ? e3.format("ddd") : u2(n3, "weekdaysShort", "weekdays", 3);
            }, longDateFormat: function(e3) {
              return a(n3.$locale(), e3);
            }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
          };
          r2.localeData = function() {
            return s.bind(this)();
          }, t2.localeData = function() {
            var n3 = i();
            return { firstDayOfWeek: function() {
              return n3.weekStart || 0;
            }, weekdays: function() {
              return t2.weekdays();
            }, weekdaysShort: function() {
              return t2.weekdaysShort();
            }, weekdaysMin: function() {
              return t2.weekdaysMin();
            }, months: function() {
              return t2.months();
            }, monthsShort: function() {
              return t2.monthsShort();
            }, longDateFormat: function(e3) {
              return a(n3, e3);
            }, meridiem: n3.meridiem, ordinal: n3.ordinal };
          }, t2.months = function() {
            return u2(i(), "months");
          }, t2.monthsShort = function() {
            return u2(i(), "monthsShort", "months", 3);
          }, t2.weekdays = function(n3) {
            return u2(i(), "weekdays", null, null, n3);
          }, t2.weekdaysShort = function(n3) {
            return u2(i(), "weekdaysShort", "weekdays", 3, n3);
          }, t2.weekdaysMin = function(n3) {
            return u2(i(), "weekdaysMin", "weekdays", 2, n3);
          };
        };
      });
    })(localeData$2);
    var localeDataExports = localeData$2.exports;
    const localeData$1 = /* @__PURE__ */ getDefaultExportFromCjs(localeDataExports);
    var weekOfYear$2 = { exports: {} };
    (function(module2, exports2) {
      !function(e2, t2) {
        module2.exports = t2();
      }(commonjsGlobal, function() {
        var e2 = "week", t2 = "year";
        return function(i, n2, r2) {
          var f2 = n2.prototype;
          f2.week = function(i2) {
            if (void 0 === i2 && (i2 = null), null !== i2)
              return this.add(7 * (i2 - this.week()), "day");
            var n3 = this.$locale().yearStart || 1;
            if (11 === this.month() && this.date() > 25) {
              var f3 = r2(this).startOf(t2).add(1, t2).date(n3), s = r2(this).endOf(e2);
              if (f3.isBefore(s))
                return 1;
            }
            var a = r2(this).startOf(t2).date(n3).startOf(e2).subtract(1, "millisecond"), o2 = this.diff(a, e2, true);
            return o2 < 0 ? r2(this).startOf("week").week() : Math.ceil(o2);
          }, f2.weeks = function(e3) {
            return void 0 === e3 && (e3 = null), this.week(e3);
          };
        };
      });
    })(weekOfYear$2);
    var weekOfYearExports = weekOfYear$2.exports;
    const weekOfYear$1 = /* @__PURE__ */ getDefaultExportFromCjs(weekOfYearExports);
    var weekYear$1 = { exports: {} };
    (function(module2, exports2) {
      !function(e2, t2) {
        module2.exports = t2();
      }(commonjsGlobal, function() {
        return function(e2, t2) {
          t2.prototype.weekYear = function() {
            var e3 = this.month(), t3 = this.week(), n2 = this.year();
            return 1 === t3 && 11 === e3 ? n2 + 1 : 0 === e3 && t3 >= 52 ? n2 - 1 : n2;
          };
        };
      });
    })(weekYear$1);
    var weekYearExports = weekYear$1.exports;
    const weekYear = /* @__PURE__ */ getDefaultExportFromCjs(weekYearExports);
    var advancedFormat$1 = { exports: {} };
    (function(module2, exports2) {
      !function(e2, t2) {
        module2.exports = t2();
      }(commonjsGlobal, function() {
        return function(e2, t2) {
          var r2 = t2.prototype, n2 = r2.format;
          r2.format = function(e3) {
            var t3 = this, r3 = this.$locale();
            if (!this.isValid())
              return n2.bind(this)(e3);
            var s = this.$utils(), a = (e3 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e4) {
              switch (e4) {
                case "Q":
                  return Math.ceil((t3.$M + 1) / 3);
                case "Do":
                  return r3.ordinal(t3.$D);
                case "gggg":
                  return t3.weekYear();
                case "GGGG":
                  return t3.isoWeekYear();
                case "wo":
                  return r3.ordinal(t3.week(), "W");
                case "w":
                case "ww":
                  return s.s(t3.week(), "w" === e4 ? 1 : 2, "0");
                case "W":
                case "WW":
                  return s.s(t3.isoWeek(), "W" === e4 ? 1 : 2, "0");
                case "k":
                case "kk":
                  return s.s(String(0 === t3.$H ? 24 : t3.$H), "k" === e4 ? 1 : 2, "0");
                case "X":
                  return Math.floor(t3.$d.getTime() / 1e3);
                case "x":
                  return t3.$d.getTime();
                case "z":
                  return "[" + t3.offsetName() + "]";
                case "zzz":
                  return "[" + t3.offsetName("long") + "]";
                default:
                  return e4;
              }
            });
            return n2.bind(this)(a);
          };
        };
      });
    })(advancedFormat$1);
    var advancedFormatExports = advancedFormat$1.exports;
    const advancedFormat = /* @__PURE__ */ getDefaultExportFromCjs(advancedFormatExports);
    var customParseFormat$1 = { exports: {} };
    (function(module2, exports2) {
      !function(e2, t2) {
        module2.exports = t2();
      }(commonjsGlobal, function() {
        var e2 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t2 = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n2 = /\d\d/, r2 = /\d\d?/, i = /\d*[^-_:/,()\s\d]+/, o2 = {}, s = function(e3) {
          return (e3 = +e3) + (e3 > 68 ? 1900 : 2e3);
        };
        var a = function(e3) {
          return function(t3) {
            this[e3] = +t3;
          };
        }, f2 = [/[+-]\d\d:?(\d\d)?|Z/, function(e3) {
          (this.zone || (this.zone = {})).offset = function(e4) {
            if (!e4)
              return 0;
            if ("Z" === e4)
              return 0;
            var t3 = e4.match(/([+-]|\d\d)/g), n3 = 60 * t3[1] + (+t3[2] || 0);
            return 0 === n3 ? 0 : "+" === t3[0] ? -n3 : n3;
          }(e3);
        }], h2 = function(e3) {
          var t3 = o2[e3];
          return t3 && (t3.indexOf ? t3 : t3.s.concat(t3.f));
        }, u2 = function(e3, t3) {
          var n3, r3 = o2.meridiem;
          if (r3) {
            for (var i2 = 1; i2 <= 24; i2 += 1)
              if (e3.indexOf(r3(i2, 0, t3)) > -1) {
                n3 = i2 > 12;
                break;
              }
          } else
            n3 = e3 === (t3 ? "pm" : "PM");
          return n3;
        }, d2 = { A: [i, function(e3) {
          this.afternoon = u2(e3, false);
        }], a: [i, function(e3) {
          this.afternoon = u2(e3, true);
        }], S: [/\d/, function(e3) {
          this.milliseconds = 100 * +e3;
        }], SS: [n2, function(e3) {
          this.milliseconds = 10 * +e3;
        }], SSS: [/\d{3}/, function(e3) {
          this.milliseconds = +e3;
        }], s: [r2, a("seconds")], ss: [r2, a("seconds")], m: [r2, a("minutes")], mm: [r2, a("minutes")], H: [r2, a("hours")], h: [r2, a("hours")], HH: [r2, a("hours")], hh: [r2, a("hours")], D: [r2, a("day")], DD: [n2, a("day")], Do: [i, function(e3) {
          var t3 = o2.ordinal, n3 = e3.match(/\d+/);
          if (this.day = n3[0], t3)
            for (var r3 = 1; r3 <= 31; r3 += 1)
              t3(r3).replace(/\[|\]/g, "") === e3 && (this.day = r3);
        }], M: [r2, a("month")], MM: [n2, a("month")], MMM: [i, function(e3) {
          var t3 = h2("months"), n3 = (h2("monthsShort") || t3.map(function(e4) {
            return e4.slice(0, 3);
          })).indexOf(e3) + 1;
          if (n3 < 1)
            throw new Error();
          this.month = n3 % 12 || n3;
        }], MMMM: [i, function(e3) {
          var t3 = h2("months").indexOf(e3) + 1;
          if (t3 < 1)
            throw new Error();
          this.month = t3 % 12 || t3;
        }], Y: [/[+-]?\d+/, a("year")], YY: [n2, function(e3) {
          this.year = s(e3);
        }], YYYY: [/\d{4}/, a("year")], Z: f2, ZZ: f2 };
        function c2(n3) {
          var r3, i2;
          r3 = n3, i2 = o2 && o2.formats;
          for (var s2 = (n3 = r3.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t3, n4, r4) {
            var o3 = r4 && r4.toUpperCase();
            return n4 || i2[r4] || e2[r4] || i2[o3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e3, t4, n5) {
              return t4 || n5.slice(1);
            });
          })).match(t2), a2 = s2.length, f3 = 0; f3 < a2; f3 += 1) {
            var h3 = s2[f3], u3 = d2[h3], c3 = u3 && u3[0], l2 = u3 && u3[1];
            s2[f3] = l2 ? { regex: c3, parser: l2 } : h3.replace(/^\[|\]$/g, "");
          }
          return function(e3) {
            for (var t3 = {}, n4 = 0, r4 = 0; n4 < a2; n4 += 1) {
              var i3 = s2[n4];
              if ("string" == typeof i3)
                r4 += i3.length;
              else {
                var o3 = i3.regex, f4 = i3.parser, h4 = e3.slice(r4), u4 = o3.exec(h4)[0];
                f4.call(t3, u4), e3 = e3.replace(u4, "");
              }
            }
            return function(e4) {
              var t4 = e4.afternoon;
              if (void 0 !== t4) {
                var n5 = e4.hours;
                t4 ? n5 < 12 && (e4.hours += 12) : 12 === n5 && (e4.hours = 0), delete e4.afternoon;
              }
            }(t3), t3;
          };
        }
        return function(e3, t3, n3) {
          n3.p.customParseFormat = true, e3 && e3.parseTwoDigitYear && (s = e3.parseTwoDigitYear);
          var r3 = t3.prototype, i2 = r3.parse;
          r3.parse = function(e4) {
            var t4 = e4.date, r4 = e4.utc, s2 = e4.args;
            this.$u = r4;
            var a2 = s2[1];
            if ("string" == typeof a2) {
              var f3 = true === s2[2], h3 = true === s2[3], u3 = f3 || h3, d3 = s2[2];
              h3 && (d3 = s2[2]), o2 = this.$locale(), !f3 && d3 && (o2 = n3.Ls[d3]), this.$d = function(e5, t5, n4) {
                try {
                  if (["x", "X"].indexOf(t5) > -1)
                    return new Date(("X" === t5 ? 1e3 : 1) * e5);
                  var r5 = c2(t5)(e5), i3 = r5.year, o3 = r5.month, s3 = r5.day, a3 = r5.hours, f4 = r5.minutes, h4 = r5.seconds, u4 = r5.milliseconds, d4 = r5.zone, l3 = /* @__PURE__ */ new Date(), m3 = s3 || (i3 || o3 ? 1 : l3.getDate()), M3 = i3 || l3.getFullYear(), Y2 = 0;
                  i3 && !o3 || (Y2 = o3 > 0 ? o3 - 1 : l3.getMonth());
                  var p2 = a3 || 0, v2 = f4 || 0, D2 = h4 || 0, g2 = u4 || 0;
                  return d4 ? new Date(Date.UTC(M3, Y2, m3, p2, v2, D2, g2 + 60 * d4.offset * 1e3)) : n4 ? new Date(Date.UTC(M3, Y2, m3, p2, v2, D2, g2)) : new Date(M3, Y2, m3, p2, v2, D2, g2);
                } catch (e6) {
                  return /* @__PURE__ */ new Date("");
                }
              }(t4, a2, r4), this.init(), d3 && true !== d3 && (this.$L = this.locale(d3).$L), u3 && t4 != this.format(a2) && (this.$d = /* @__PURE__ */ new Date("")), o2 = {};
            } else if (a2 instanceof Array)
              for (var l2 = a2.length, m2 = 1; m2 <= l2; m2 += 1) {
                s2[1] = a2[m2 - 1];
                var M2 = n3.apply(this, s2);
                if (M2.isValid()) {
                  this.$d = M2.$d, this.$L = M2.$L, this.init();
                  break;
                }
                m2 === l2 && (this.$d = /* @__PURE__ */ new Date(""));
              }
            else
              i2.call(this, e4);
          };
        };
      });
    })(customParseFormat$1);
    var customParseFormatExports = customParseFormat$1.exports;
    const customParseFormat = /* @__PURE__ */ getDefaultExportFromCjs(customParseFormatExports);
    dayjs.extend(customParseFormat);
    dayjs.extend(advancedFormat);
    dayjs.extend(weekday);
    dayjs.extend(localeData$1);
    dayjs.extend(weekOfYear$1);
    dayjs.extend(weekYear);
    dayjs.extend(function(o2, c2) {
      var proto2 = c2.prototype;
      var oldFormat = proto2.format;
      proto2.format = function f2(formatStr) {
        var str = (formatStr || "").replace("Wo", "wo");
        return oldFormat.bind(this)(str);
      };
    });
    var localeMap = {
      // ar_EG:
      // az_AZ:
      // bg_BG:
      bn_BD: "bn-bd",
      by_BY: "be",
      // ca_ES:
      // cs_CZ:
      // da_DK:
      // de_DE:
      // el_GR:
      en_GB: "en-gb",
      en_US: "en",
      // es_ES:
      // et_EE:
      // fa_IR:
      // fi_FI:
      fr_BE: "fr",
      // todo: dayjs has no fr_BE locale, use fr at present
      fr_CA: "fr-ca",
      // fr_FR:
      // ga_IE:
      // gl_ES:
      // he_IL:
      // hi_IN:
      // hr_HR:
      // hu_HU:
      hy_AM: "hy-am",
      // id_ID:
      // is_IS:
      // it_IT:
      // ja_JP:
      // ka_GE:
      // kk_KZ:
      // km_KH:
      kmr_IQ: "ku",
      // kn_IN:
      // ko_KR:
      // ku_IQ: // previous ku in antd
      // lt_LT:
      // lv_LV:
      // mk_MK:
      // ml_IN:
      // mn_MN:
      // ms_MY:
      // nb_NO:
      // ne_NP:
      nl_BE: "nl-be",
      // nl_NL:
      // pl_PL:
      pt_BR: "pt-br",
      // pt_PT:
      // ro_RO:
      // ru_RU:
      // sk_SK:
      // sl_SI:
      // sr_RS:
      // sv_SE:
      // ta_IN:
      // th_TH:
      // tr_TR:
      // uk_UA:
      // ur_PK:
      // vi_VN:
      zh_CN: "zh-cn",
      zh_HK: "zh-hk",
      zh_TW: "zh-tw"
    };
    var parseLocale = function parseLocale2(locale2) {
      var mapLocale = localeMap[locale2];
      return mapLocale || locale2.split("_")[0];
    };
    var parseNoMatchNotice = function parseNoMatchNotice2() {
      noteOnce(false, "Not match any format. Please help to fire a issue about this.");
    };
    var generateConfig = {
      // get
      getNow: function getNow() {
        return dayjs();
      },
      getFixedDate: function getFixedDate(string2) {
        return dayjs(string2, ["YYYY-M-DD", "YYYY-MM-DD"]);
      },
      getEndDate: function getEndDate(date) {
        return date.endOf("month");
      },
      getWeekDay: function getWeekDay(date) {
        var clone2 = date.locale("en");
        return clone2.weekday() + clone2.localeData().firstDayOfWeek();
      },
      getYear: function getYear(date) {
        return date.year();
      },
      getMonth: function getMonth(date) {
        return date.month();
      },
      getDate: function getDate(date) {
        return date.date();
      },
      getHour: function getHour(date) {
        return date.hour();
      },
      getMinute: function getMinute(date) {
        return date.minute();
      },
      getSecond: function getSecond(date) {
        return date.second();
      },
      // set
      addYear: function addYear(date, diff2) {
        return date.add(diff2, "year");
      },
      addMonth: function addMonth(date, diff2) {
        return date.add(diff2, "month");
      },
      addDate: function addDate(date, diff2) {
        return date.add(diff2, "day");
      },
      setYear: function setYear(date, year) {
        return date.year(year);
      },
      setMonth: function setMonth2(date, month) {
        return date.month(month);
      },
      setDate: function setDate(date, num) {
        return date.date(num);
      },
      setHour: function setHour(date, hour) {
        return date.hour(hour);
      },
      setMinute: function setMinute(date, minute) {
        return date.minute(minute);
      },
      setSecond: function setSecond(date, second) {
        return date.second(second);
      },
      // Compare
      isAfter: function isAfter2(date1, date22) {
        return date1.isAfter(date22);
      },
      isValidate: function isValidate(date) {
        return date.isValid();
      },
      locale: {
        getWeekFirstDay: function getWeekFirstDay(locale2) {
          return dayjs().locale(parseLocale(locale2)).localeData().firstDayOfWeek();
        },
        getWeekFirstDate: function getWeekFirstDate(locale2, date) {
          return date.locale(parseLocale(locale2)).weekday(0);
        },
        getWeek: function getWeek(locale2, date) {
          return date.locale(parseLocale(locale2)).week();
        },
        getShortWeekDays: function getShortWeekDays(locale2) {
          return dayjs().locale(parseLocale(locale2)).localeData().weekdaysMin();
        },
        getShortMonths: function getShortMonths(locale2) {
          return dayjs().locale(parseLocale(locale2)).localeData().monthsShort();
        },
        format: function format2(locale2, date, _format) {
          return date.locale(parseLocale(locale2)).format(_format);
        },
        parse: function parse2(locale2, text, formats) {
          var localeStr = parseLocale(locale2);
          for (var i = 0; i < formats.length; i += 1) {
            var format2 = formats[i];
            var formatText = text;
            if (format2.includes("wo") || format2.includes("Wo")) {
              var year = formatText.split("-")[0];
              var weekStr = formatText.split("-")[1];
              var firstWeek = dayjs(year, "YYYY").startOf("year").locale(localeStr);
              for (var j = 0; j <= 52; j += 1) {
                var nextWeek = firstWeek.add(j, "week");
                if (nextWeek.format("Wo") === weekStr) {
                  return nextWeek;
                }
              }
              parseNoMatchNotice();
              return null;
            }
            var date = dayjs(formatText, format2, true).locale(localeStr);
            if (date.isValid()) {
              return date;
            }
          }
          if (text) {
            parseNoMatchNotice();
          }
          return null;
        }
      }
    };
    var DECADE_UNIT_DIFF = 10;
    var DECADE_DISTANCE_COUNT = DECADE_UNIT_DIFF * 10;
    var WEEK_DAY_COUNT = 7;
    function isNullEqual(value1, value2) {
      if (!value1 && !value2) {
        return true;
      }
      if (!value1 || !value2) {
        return false;
      }
      return void 0;
    }
    function isSameDecade(generateConfig2, decade1, decade2) {
      var equal = isNullEqual(decade1, decade2);
      if (typeof equal === "boolean") {
        return equal;
      }
      var num1 = Math.floor(generateConfig2.getYear(decade1) / 10);
      var num2 = Math.floor(generateConfig2.getYear(decade2) / 10);
      return num1 === num2;
    }
    function isSameYear(generateConfig2, year1, year2) {
      var equal = isNullEqual(year1, year2);
      if (typeof equal === "boolean") {
        return equal;
      }
      return generateConfig2.getYear(year1) === generateConfig2.getYear(year2);
    }
    function getQuarter(generateConfig2, date) {
      var quota = Math.floor(generateConfig2.getMonth(date) / 3);
      return quota + 1;
    }
    function isSameQuarter(generateConfig2, quarter1, quarter2) {
      var equal = isNullEqual(quarter1, quarter2);
      if (typeof equal === "boolean") {
        return equal;
      }
      return isSameYear(generateConfig2, quarter1, quarter2) && getQuarter(generateConfig2, quarter1) === getQuarter(generateConfig2, quarter2);
    }
    function isSameMonth(generateConfig2, month1, month2) {
      var equal = isNullEqual(month1, month2);
      if (typeof equal === "boolean") {
        return equal;
      }
      return isSameYear(generateConfig2, month1, month2) && generateConfig2.getMonth(month1) === generateConfig2.getMonth(month2);
    }
    function isSameDate(generateConfig2, date1, date22) {
      var equal = isNullEqual(date1, date22);
      if (typeof equal === "boolean") {
        return equal;
      }
      return generateConfig2.getYear(date1) === generateConfig2.getYear(date22) && generateConfig2.getMonth(date1) === generateConfig2.getMonth(date22) && generateConfig2.getDate(date1) === generateConfig2.getDate(date22);
    }
    function isSameTime(generateConfig2, time1, time2) {
      var equal = isNullEqual(time1, time2);
      if (typeof equal === "boolean") {
        return equal;
      }
      return generateConfig2.getHour(time1) === generateConfig2.getHour(time2) && generateConfig2.getMinute(time1) === generateConfig2.getMinute(time2) && generateConfig2.getSecond(time1) === generateConfig2.getSecond(time2);
    }
    function isSameWeek(generateConfig2, locale2, date1, date22) {
      var equal = isNullEqual(date1, date22);
      if (typeof equal === "boolean") {
        return equal;
      }
      return isSameYear(generateConfig2, date1, date22) && generateConfig2.locale.getWeek(locale2, date1) === generateConfig2.locale.getWeek(locale2, date22);
    }
    function isEqual(generateConfig2, value1, value2) {
      return isSameDate(generateConfig2, value1, value2) && isSameTime(generateConfig2, value1, value2);
    }
    function isInRange(generateConfig2, startDate, endDate, current) {
      if (!startDate || !endDate || !current) {
        return false;
      }
      return !isSameDate(generateConfig2, startDate, current) && !isSameDate(generateConfig2, endDate, current) && generateConfig2.isAfter(current, startDate) && generateConfig2.isAfter(endDate, current);
    }
    function getWeekStartDate(locale2, generateConfig2, value) {
      var weekFirstDay = generateConfig2.locale.getWeekFirstDay(locale2);
      var monthStartDate = generateConfig2.setDate(value, 1);
      var startDateWeekDay = generateConfig2.getWeekDay(monthStartDate);
      var alignStartDate = generateConfig2.addDate(monthStartDate, weekFirstDay - startDateWeekDay);
      if (generateConfig2.getMonth(alignStartDate) === generateConfig2.getMonth(value) && generateConfig2.getDate(alignStartDate) > 1) {
        alignStartDate = generateConfig2.addDate(alignStartDate, -7);
      }
      return alignStartDate;
    }
    function getClosingViewDate(viewDate, picker, generateConfig2) {
      var offset2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
      switch (picker) {
        case "year":
          return generateConfig2.addYear(viewDate, offset2 * 10);
        case "quarter":
        case "month":
          return generateConfig2.addYear(viewDate, offset2);
        default:
          return generateConfig2.addMonth(viewDate, offset2);
      }
    }
    function formatValue(value, _ref) {
      var generateConfig2 = _ref.generateConfig, locale2 = _ref.locale, format2 = _ref.format;
      return typeof format2 === "function" ? format2(value) : generateConfig2.locale.format(locale2.locale, value, format2);
    }
    function parseValue(value, _ref2) {
      var generateConfig2 = _ref2.generateConfig, locale2 = _ref2.locale, formatList = _ref2.formatList;
      if (!value || typeof formatList[0] === "function") {
        return null;
      }
      return generateConfig2.locale.parse(locale2.locale, value, formatList);
    }
    function getCellDateDisabled(_ref3) {
      var cellDate = _ref3.cellDate, mode = _ref3.mode, disabledDate = _ref3.disabledDate, generateConfig2 = _ref3.generateConfig;
      if (!disabledDate)
        return false;
      var getDisabledFromRange = function getDisabledFromRange2(currentMode, start, end) {
        var current = start;
        while (current <= end) {
          var _date = void 0;
          switch (currentMode) {
            case "date": {
              _date = generateConfig2.setDate(cellDate, current);
              if (!disabledDate(_date)) {
                return false;
              }
              break;
            }
            case "month": {
              _date = generateConfig2.setMonth(cellDate, current);
              if (!getCellDateDisabled({
                cellDate: _date,
                mode: "month",
                generateConfig: generateConfig2,
                disabledDate
              })) {
                return false;
              }
              break;
            }
            case "year": {
              _date = generateConfig2.setYear(cellDate, current);
              if (!getCellDateDisabled({
                cellDate: _date,
                mode: "year",
                generateConfig: generateConfig2,
                disabledDate
              })) {
                return false;
              }
              break;
            }
          }
          current += 1;
        }
        return true;
      };
      switch (mode) {
        case "date":
        case "week": {
          return disabledDate(cellDate);
        }
        case "month": {
          var startDate = 1;
          var endDate = generateConfig2.getDate(generateConfig2.getEndDate(cellDate));
          return getDisabledFromRange("date", startDate, endDate);
        }
        case "quarter": {
          var startMonth = Math.floor(generateConfig2.getMonth(cellDate) / 3) * 3;
          var endMonth = startMonth + 2;
          return getDisabledFromRange("month", startMonth, endMonth);
        }
        case "year": {
          return getDisabledFromRange("month", 0, 11);
        }
        case "decade": {
          var year = generateConfig2.getYear(cellDate);
          var startYear = Math.floor(year / DECADE_UNIT_DIFF) * DECADE_UNIT_DIFF;
          var endYear = startYear + DECADE_UNIT_DIFF - 1;
          return getDisabledFromRange("year", startYear, endYear);
        }
      }
    }
    function useValueTexts(value, _ref) {
      var formatList = _ref.formatList, generateConfig2 = _ref.generateConfig, locale2 = _ref.locale;
      var _useMemo = useMemo(function() {
        if (!value) {
          return [[""], ""];
        }
        var firstValueText = "";
        var fullValueTexts = [];
        for (var i = 0; i < formatList.length; i += 1) {
          var format2 = formatList[i];
          var formatStr = formatValue(value, {
            generateConfig: generateConfig2,
            locale: locale2,
            format: format2
          });
          fullValueTexts.push(formatStr);
          if (i === 0) {
            firstValueText = formatStr;
          }
        }
        return [fullValueTexts, firstValueText];
      }, [value, formatList, locale2], function(prev2, next2) {
        return (
          // Not Same Date
          !isEqual(generateConfig2, prev2[0], next2[0]) || // Not Same format
          !isEqual$1(prev2[1], next2[1], true) || // Not Same locale
          !isEqual$1(prev2[2], next2[2], true)
        );
      }), _useMemo2 = _slicedToArray(_useMemo, 2), texts = _useMemo2[0], text = _useMemo2[1];
      return reactExports.useMemo(function() {
        return [texts, text];
      }, [texts.join(""), text]);
    }
    function useHoverValue(valueText, _ref) {
      var formatList = _ref.formatList, generateConfig2 = _ref.generateConfig, locale2 = _ref.locale;
      var _useState = reactExports.useState(null), _useState2 = _slicedToArray(_useState, 2), value = _useState2[0], internalSetValue = _useState2[1];
      var raf2 = reactExports.useRef(null);
      function setValue(val) {
        var immediately = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        cancelAnimationFrame(raf2.current);
        if (immediately) {
          internalSetValue(val);
          return;
        }
        raf2.current = requestAnimationFrame(function() {
          internalSetValue(val);
        });
      }
      var _useValueTexts = useValueTexts(value, {
        formatList,
        generateConfig: generateConfig2,
        locale: locale2
      }), _useValueTexts2 = _slicedToArray(_useValueTexts, 2), firstText = _useValueTexts2[1];
      function onEnter(date) {
        setValue(date);
      }
      function onLeave() {
        var immediately = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        setValue(null, immediately);
      }
      reactExports.useEffect(function() {
        onLeave(true);
      }, [valueText]);
      reactExports.useEffect(function() {
        return function() {
          return cancelAnimationFrame(raf2.current);
        };
      }, []);
      return [firstText, onEnter, onLeave];
    }
    var scrollIds = /* @__PURE__ */ new Map();
    function waitElementReady(element, callback) {
      var id2;
      function tryOrNextFrame() {
        if (isVisible(element)) {
          callback();
        } else {
          id2 = wrapperRaf(function() {
            tryOrNextFrame();
          });
        }
      }
      tryOrNextFrame();
      return function() {
        wrapperRaf.cancel(id2);
      };
    }
    function scrollTo(element, to2, duration) {
      if (scrollIds.get(element)) {
        cancelAnimationFrame(scrollIds.get(element));
      }
      if (duration <= 0) {
        scrollIds.set(element, requestAnimationFrame(function() {
          element.scrollTop = to2;
        }));
        return;
      }
      var difference = to2 - element.scrollTop;
      var perTick = difference / duration * 10;
      scrollIds.set(element, requestAnimationFrame(function() {
        element.scrollTop += perTick;
        if (element.scrollTop !== to2) {
          scrollTo(element, to2, duration - 10);
        }
      }));
    }
    function createKeyDownHandler(event, _ref) {
      var onLeftRight = _ref.onLeftRight, onCtrlLeftRight = _ref.onCtrlLeftRight, onUpDown = _ref.onUpDown, onPageUpDown = _ref.onPageUpDown, onEnter = _ref.onEnter;
      var which = event.which, ctrlKey = event.ctrlKey, metaKey = event.metaKey;
      switch (which) {
        case KeyCode.LEFT:
          if (ctrlKey || metaKey) {
            if (onCtrlLeftRight) {
              onCtrlLeftRight(-1);
              return true;
            }
          } else if (onLeftRight) {
            onLeftRight(-1);
            return true;
          }
          break;
        case KeyCode.RIGHT:
          if (ctrlKey || metaKey) {
            if (onCtrlLeftRight) {
              onCtrlLeftRight(1);
              return true;
            }
          } else if (onLeftRight) {
            onLeftRight(1);
            return true;
          }
          break;
        case KeyCode.UP:
          if (onUpDown) {
            onUpDown(-1);
            return true;
          }
          break;
        case KeyCode.DOWN:
          if (onUpDown) {
            onUpDown(1);
            return true;
          }
          break;
        case KeyCode.PAGE_UP:
          if (onPageUpDown) {
            onPageUpDown(-1);
            return true;
          }
          break;
        case KeyCode.PAGE_DOWN:
          if (onPageUpDown) {
            onPageUpDown(1);
            return true;
          }
          break;
        case KeyCode.ENTER:
          if (onEnter) {
            onEnter();
            return true;
          }
          break;
      }
      return false;
    }
    function getDefaultFormat(format2, picker, showTime, use12Hours) {
      var mergedFormat = format2;
      if (!mergedFormat) {
        switch (picker) {
          case "time":
            mergedFormat = use12Hours ? "hh:mm:ss a" : "HH:mm:ss";
            break;
          case "week":
            mergedFormat = "gggg-wo";
            break;
          case "month":
            mergedFormat = "YYYY-MM";
            break;
          case "quarter":
            mergedFormat = "YYYY-[Q]Q";
            break;
          case "year":
            mergedFormat = "YYYY";
            break;
          default:
            mergedFormat = showTime ? "YYYY-MM-DD HH:mm:ss" : "YYYY-MM-DD";
        }
      }
      return mergedFormat;
    }
    function getInputSize(picker, format2, generateConfig2) {
      var defaultSize = picker === "time" ? 8 : 10;
      var length2 = typeof format2 === "function" ? format2(generateConfig2.getNow()).length : format2.length;
      return Math.max(defaultSize, length2) + 2;
    }
    var globalClickFunc = null;
    var clickCallbacks = /* @__PURE__ */ new Set();
    function addGlobalMouseDownEvent(callback) {
      if (!globalClickFunc && typeof window !== "undefined" && window.addEventListener) {
        globalClickFunc = function globalClickFunc2(e2) {
          _toConsumableArray(clickCallbacks).forEach(function(queueFunc) {
            queueFunc(e2);
          });
        };
        window.addEventListener("mousedown", globalClickFunc);
      }
      clickCallbacks.add(callback);
      return function() {
        clickCallbacks.delete(callback);
        if (clickCallbacks.size === 0) {
          window.removeEventListener("mousedown", globalClickFunc);
          globalClickFunc = null;
        }
      };
    }
    function getTargetFromEvent(e2) {
      var target = e2.target;
      if (e2.composed && target.shadowRoot) {
        var _e$composedPath;
        return ((_e$composedPath = e2.composedPath) === null || _e$composedPath === void 0 ? void 0 : _e$composedPath.call(e2)[0]) || target;
      }
      return target;
    }
    var getYearNextMode = function getYearNextMode2(next2) {
      if (next2 === "month" || next2 === "date") {
        return "year";
      }
      return next2;
    };
    var getMonthNextMode = function getMonthNextMode2(next2) {
      if (next2 === "date") {
        return "month";
      }
      return next2;
    };
    var getQuarterNextMode = function getQuarterNextMode2(next2) {
      if (next2 === "month" || next2 === "date") {
        return "quarter";
      }
      return next2;
    };
    var getWeekNextMode = function getWeekNextMode2(next2) {
      if (next2 === "date") {
        return "week";
      }
      return next2;
    };
    var PickerModeMap = {
      year: getYearNextMode,
      month: getMonthNextMode,
      quarter: getQuarterNextMode,
      week: getWeekNextMode,
      time: null,
      date: null
    };
    function elementsContains(elements, target) {
      return elements.some(function(ele) {
        return ele && ele.contains(target);
      });
    }
    function usePickerInput(_ref) {
      var open = _ref.open, value = _ref.value, isClickOutside = _ref.isClickOutside, triggerOpen = _ref.triggerOpen, forwardKeyDown = _ref.forwardKeyDown, _onKeyDown = _ref.onKeyDown, blurToCancel = _ref.blurToCancel, changeOnBlur = _ref.changeOnBlur, onSubmit = _ref.onSubmit, onCancel = _ref.onCancel, _onFocus = _ref.onFocus, _onBlur = _ref.onBlur;
      var _useState = reactExports.useState(false), _useState2 = _slicedToArray(_useState, 2), typing = _useState2[0], setTyping = _useState2[1];
      var _useState3 = reactExports.useState(false), _useState4 = _slicedToArray(_useState3, 2), focused = _useState4[0], setFocused = _useState4[1];
      var preventBlurRef = reactExports.useRef(false);
      var valueChangedRef = reactExports.useRef(false);
      var preventDefaultRef = reactExports.useRef(false);
      var inputProps = {
        onMouseDown: function onMouseDown() {
          setTyping(true);
          triggerOpen(true);
        },
        onKeyDown: function onKeyDown2(e2) {
          var preventDefault = function preventDefault2() {
            preventDefaultRef.current = true;
          };
          _onKeyDown(e2, preventDefault);
          if (preventDefaultRef.current)
            return;
          switch (e2.which) {
            case KeyCode.ENTER: {
              if (!open) {
                triggerOpen(true);
              } else if (onSubmit() !== false) {
                setTyping(true);
              }
              e2.preventDefault();
              return;
            }
            case KeyCode.TAB: {
              if (typing && open && !e2.shiftKey) {
                setTyping(false);
                e2.preventDefault();
              } else if (!typing && open) {
                if (!forwardKeyDown(e2) && e2.shiftKey) {
                  setTyping(true);
                  e2.preventDefault();
                }
              }
              return;
            }
            case KeyCode.ESC: {
              setTyping(true);
              onCancel();
              return;
            }
          }
          if (!open && ![KeyCode.SHIFT].includes(e2.which)) {
            triggerOpen(true);
          } else if (!typing) {
            forwardKeyDown(e2);
          }
        },
        onFocus: function onFocus(e2) {
          setTyping(true);
          setFocused(true);
          if (_onFocus) {
            _onFocus(e2);
          }
        },
        onBlur: function onBlur(e2) {
          if (preventBlurRef.current || !isClickOutside(document.activeElement)) {
            preventBlurRef.current = false;
            return;
          }
          if (blurToCancel) {
            setTimeout(function() {
              var _document = document, activeElement = _document.activeElement;
              while (activeElement && activeElement.shadowRoot) {
                activeElement = activeElement.shadowRoot.activeElement;
              }
              if (isClickOutside(activeElement)) {
                onCancel();
              }
            }, 0);
          } else if (open) {
            triggerOpen(false);
            if (valueChangedRef.current) {
              onSubmit();
            }
          }
          setFocused(false);
          _onBlur === null || _onBlur === void 0 || _onBlur(e2);
        }
      };
      reactExports.useEffect(function() {
        valueChangedRef.current = false;
      }, [open]);
      reactExports.useEffect(function() {
        valueChangedRef.current = true;
      }, [value]);
      reactExports.useEffect(function() {
        return addGlobalMouseDownEvent(function(e2) {
          var target = getTargetFromEvent(e2);
          var clickedOutside = isClickOutside(target);
          if (open) {
            if (!clickedOutside) {
              preventBlurRef.current = true;
              wrapperRaf(function() {
                preventBlurRef.current = false;
              });
            } else if (!changeOnBlur && !blurToCancel && (!focused || clickedOutside)) {
              triggerOpen(false);
            }
          }
        });
      });
      return [inputProps, {
        focused,
        typing
      }];
    }
    function usePresets(presets, legacyRanges) {
      return reactExports.useMemo(function() {
        if (presets) {
          return presets;
        }
        if (legacyRanges) {
          warningOnce(false, "`ranges` is deprecated. Please use `presets` instead.");
          return Object.entries(legacyRanges).map(function(_ref) {
            var _ref2 = _slicedToArray(_ref, 2), label = _ref2[0], value = _ref2[1];
            return {
              label,
              value
            };
          });
        }
        return [];
      }, [presets, legacyRanges]);
    }
    function useTextValueMapping(_ref) {
      var valueTexts = _ref.valueTexts, onTextChange = _ref.onTextChange;
      var _React$useState = reactExports.useState(""), _React$useState2 = _slicedToArray(_React$useState, 2), text = _React$useState2[0], setInnerText = _React$useState2[1];
      var valueTextsRef = reactExports.useRef([]);
      valueTextsRef.current = valueTexts;
      function triggerTextChange(value) {
        setInnerText(value);
        onTextChange(value);
      }
      function resetText() {
        setInnerText(valueTextsRef.current[0]);
      }
      useLayoutEffect$1(function() {
        if (valueTexts.every(function(valText) {
          return valText !== text;
        })) {
          resetText();
        }
      }, [valueTexts.join("||")]);
      return [text, triggerTextChange, resetText];
    }
    var PanelContext = /* @__PURE__ */ reactExports.createContext({});
    function useCellRender$1(_ref) {
      var cellRender = _ref.cellRender, monthCellRender = _ref.monthCellRender, dateRender = _ref.dateRender;
      var mergedCellRender = React.useMemo(function() {
        if (cellRender)
          return cellRender;
        if (!monthCellRender && !dateRender)
          return void 0;
        return function(current, info) {
          var date = current;
          if (dateRender && info.type === "date") {
            return dateRender(date, info.today);
          }
          if (monthCellRender && info.type === "month") {
            return monthCellRender(date, info.locale);
          }
          return info.originNode;
        };
      }, [cellRender, monthCellRender, dateRender]);
      return mergedCellRender;
    }
    function leftPad(str, length2) {
      var fill = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
      var current = String(str);
      while (current.length < length2) {
        current = "".concat(fill).concat(str);
      }
      return current;
    }
    var tuple = function tuple2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return args;
    };
    function toArray$6(val) {
      if (val === null || val === void 0) {
        return [];
      }
      return Array.isArray(val) ? val : [val];
    }
    function getValue(values, index2) {
      return values ? values[index2] : null;
    }
    function updateValues(values, value, index2) {
      var newValues = [getValue(values, 0), getValue(values, 1)];
      newValues[index2] = typeof value === "function" ? value(newValues[index2]) : value;
      if (!newValues[0] && !newValues[1]) {
        return null;
      }
      return newValues;
    }
    function executeValue(value) {
      return typeof value === "function" ? value() : value;
    }
    function useCellClassName(_ref) {
      var cellPrefixCls = _ref.cellPrefixCls, generateConfig2 = _ref.generateConfig, rangedValue = _ref.rangedValue, hoverRangedValue = _ref.hoverRangedValue, isInView = _ref.isInView, isSameCell = _ref.isSameCell, offsetCell = _ref.offsetCell, today = _ref.today, value = _ref.value;
      function getClassName(currentDate) {
        var _ref2;
        var prevDate = offsetCell(currentDate, -1);
        var nextDate = offsetCell(currentDate, 1);
        var rangeStart = getValue(rangedValue, 0);
        var rangeEnd = getValue(rangedValue, 1);
        var hoverStart = getValue(hoverRangedValue, 0);
        var hoverEnd = getValue(hoverRangedValue, 1);
        var isRangeHovered = isInRange(generateConfig2, hoverStart, hoverEnd, currentDate);
        function isRangeStart(date) {
          return isSameCell(rangeStart, date);
        }
        function isRangeEnd(date) {
          return isSameCell(rangeEnd, date);
        }
        var isHoverStart = isSameCell(hoverStart, currentDate);
        var isHoverEnd = isSameCell(hoverEnd, currentDate);
        var isHoverEdgeStart = (isRangeHovered || isHoverEnd) && (!isInView(prevDate) || isRangeEnd(prevDate));
        var isHoverEdgeEnd = (isRangeHovered || isHoverStart) && (!isInView(nextDate) || isRangeStart(nextDate));
        return _ref2 = {}, _defineProperty(_ref2, "".concat(cellPrefixCls, "-in-view"), isInView(currentDate)), _defineProperty(_ref2, "".concat(cellPrefixCls, "-in-range"), isInRange(generateConfig2, rangeStart, rangeEnd, currentDate)), _defineProperty(_ref2, "".concat(cellPrefixCls, "-range-start"), isRangeStart(currentDate)), _defineProperty(_ref2, "".concat(cellPrefixCls, "-range-end"), isRangeEnd(currentDate)), _defineProperty(_ref2, "".concat(cellPrefixCls, "-range-start-single"), isRangeStart(currentDate) && !rangeEnd), _defineProperty(_ref2, "".concat(cellPrefixCls, "-range-end-single"), isRangeEnd(currentDate) && !rangeStart), _defineProperty(_ref2, "".concat(cellPrefixCls, "-range-start-near-hover"), isRangeStart(currentDate) && (isSameCell(prevDate, hoverStart) || isInRange(generateConfig2, hoverStart, hoverEnd, prevDate))), _defineProperty(_ref2, "".concat(cellPrefixCls, "-range-end-near-hover"), isRangeEnd(currentDate) && (isSameCell(nextDate, hoverEnd) || isInRange(generateConfig2, hoverStart, hoverEnd, nextDate))), _defineProperty(_ref2, "".concat(cellPrefixCls, "-range-hover"), isRangeHovered), _defineProperty(_ref2, "".concat(cellPrefixCls, "-range-hover-start"), isHoverStart), _defineProperty(_ref2, "".concat(cellPrefixCls, "-range-hover-end"), isHoverEnd), _defineProperty(_ref2, "".concat(cellPrefixCls, "-range-hover-edge-start"), isHoverEdgeStart), _defineProperty(_ref2, "".concat(cellPrefixCls, "-range-hover-edge-end"), isHoverEdgeEnd), _defineProperty(_ref2, "".concat(cellPrefixCls, "-range-hover-edge-start-near-range"), isHoverEdgeStart && isSameCell(prevDate, rangeEnd)), _defineProperty(_ref2, "".concat(cellPrefixCls, "-range-hover-edge-end-near-range"), isHoverEdgeEnd && isSameCell(nextDate, rangeStart)), _defineProperty(_ref2, "".concat(cellPrefixCls, "-today"), isSameCell(today, currentDate)), _defineProperty(_ref2, "".concat(cellPrefixCls, "-selected"), isSameCell(value, currentDate)), _ref2;
      }
      return getClassName;
    }
    var RangeContext = /* @__PURE__ */ reactExports.createContext({});
    function setTime(generateConfig2, date, hour, minute, second) {
      var nextTime = generateConfig2.setHour(date, hour);
      nextTime = generateConfig2.setMinute(nextTime, minute);
      nextTime = generateConfig2.setSecond(nextTime, second);
      return nextTime;
    }
    function setDateTime(generateConfig2, date, defaultDate) {
      if (!defaultDate) {
        return date;
      }
      var newDate = date;
      newDate = generateConfig2.setHour(newDate, generateConfig2.getHour(defaultDate));
      newDate = generateConfig2.setMinute(newDate, generateConfig2.getMinute(defaultDate));
      newDate = generateConfig2.setSecond(newDate, generateConfig2.getSecond(defaultDate));
      return newDate;
    }
    function getLowerBoundTime(hour, minute, second, hourStep, minuteStep, secondStep) {
      var lowerBoundHour = Math.floor(hour / hourStep) * hourStep;
      if (lowerBoundHour < hour) {
        return [lowerBoundHour, 60 - minuteStep, 60 - secondStep];
      }
      var lowerBoundMinute = Math.floor(minute / minuteStep) * minuteStep;
      if (lowerBoundMinute < minute) {
        return [lowerBoundHour, lowerBoundMinute, 60 - secondStep];
      }
      var lowerBoundSecond = Math.floor(second / secondStep) * secondStep;
      return [lowerBoundHour, lowerBoundMinute, lowerBoundSecond];
    }
    function getLastDay(generateConfig2, date) {
      var year = generateConfig2.getYear(date);
      var month = generateConfig2.getMonth(date) + 1;
      var endDate = generateConfig2.getEndDate(generateConfig2.getFixedDate("".concat(year, "-").concat(month, "-01")));
      var lastDay = generateConfig2.getDate(endDate);
      var monthShow = month < 10 ? "0".concat(month) : "".concat(month);
      return "".concat(year, "-").concat(monthShow, "-").concat(lastDay);
    }
    function PanelBody(_ref) {
      var prefixCls = _ref.prefixCls, disabledDate = _ref.disabledDate, onSelect = _ref.onSelect, picker = _ref.picker, rowNum = _ref.rowNum, colNum = _ref.colNum, prefixColumn = _ref.prefixColumn, rowClassName = _ref.rowClassName, baseDate = _ref.baseDate, getCellClassName = _ref.getCellClassName, getCellText = _ref.getCellText, getCellNode = _ref.getCellNode, getCellDate = _ref.getCellDate, generateConfig2 = _ref.generateConfig, titleCell = _ref.titleCell, headerCells = _ref.headerCells;
      var _React$useContext = reactExports.useContext(PanelContext), onDateMouseEnter = _React$useContext.onDateMouseEnter, onDateMouseLeave = _React$useContext.onDateMouseLeave, mode = _React$useContext.mode;
      var cellPrefixCls = "".concat(prefixCls, "-cell");
      var rows = [];
      for (var i = 0; i < rowNum; i += 1) {
        var row = [];
        var rowStartDate = void 0;
        var _loop = function _loop2() {
          var _objectSpread2$1;
          var offset2 = i * colNum + j;
          var currentDate = getCellDate(baseDate, offset2);
          var disabled = getCellDateDisabled({
            cellDate: currentDate,
            mode,
            disabledDate,
            generateConfig: generateConfig2
          });
          if (j === 0) {
            rowStartDate = currentDate;
            if (prefixColumn) {
              row.push(prefixColumn(rowStartDate));
            }
          }
          var title = titleCell && titleCell(currentDate);
          var inner = /* @__PURE__ */ reactExports.createElement("div", {
            className: "".concat(cellPrefixCls, "-inner")
          }, getCellText(currentDate));
          row.push(/* @__PURE__ */ reactExports.createElement("td", {
            key: j,
            title,
            className: classNames(cellPrefixCls, _objectSpread2((_objectSpread2$1 = {}, _defineProperty(_objectSpread2$1, "".concat(cellPrefixCls, "-disabled"), disabled), _defineProperty(_objectSpread2$1, "".concat(cellPrefixCls, "-start"), getCellText(currentDate) === 1 || picker === "year" && Number(title) % 10 === 0), _defineProperty(_objectSpread2$1, "".concat(cellPrefixCls, "-end"), title === getLastDay(generateConfig2, currentDate) || picker === "year" && Number(title) % 10 === 9), _objectSpread2$1), getCellClassName(currentDate))),
            onClick: function onClick() {
              if (!disabled) {
                onSelect(currentDate);
              }
            },
            onMouseEnter: function onMouseEnter() {
              if (!disabled && onDateMouseEnter) {
                onDateMouseEnter(currentDate);
              }
            },
            onMouseLeave: function onMouseLeave() {
              if (!disabled && onDateMouseLeave) {
                onDateMouseLeave(currentDate);
              }
            }
          }, getCellNode ? getCellNode(currentDate, inner) : inner));
        };
        for (var j = 0; j < colNum; j += 1) {
          _loop();
        }
        rows.push(/* @__PURE__ */ reactExports.createElement("tr", {
          key: i,
          className: rowClassName && rowClassName(rowStartDate)
        }, row));
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-body")
      }, /* @__PURE__ */ reactExports.createElement("table", {
        className: "".concat(prefixCls, "-content")
      }, headerCells && /* @__PURE__ */ reactExports.createElement("thead", null, /* @__PURE__ */ reactExports.createElement("tr", null, headerCells)), /* @__PURE__ */ reactExports.createElement("tbody", null, rows)));
    }
    function DateBody(props) {
      var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, prefixColumn = props.prefixColumn, locale2 = props.locale, rowCount = props.rowCount, viewDate = props.viewDate, value = props.value, cellRender = props.cellRender, isSameCell = props.isSameCell;
      var _React$useContext = reactExports.useContext(RangeContext), rangedValue = _React$useContext.rangedValue, hoverRangedValue = _React$useContext.hoverRangedValue;
      var baseDate = getWeekStartDate(locale2.locale, generateConfig2, viewDate);
      var cellPrefixCls = "".concat(prefixCls, "-cell");
      var weekFirstDay = generateConfig2.locale.getWeekFirstDay(locale2.locale);
      var today = generateConfig2.getNow();
      var headerCells = [];
      var weekDaysLocale = locale2.shortWeekDays || (generateConfig2.locale.getShortWeekDays ? generateConfig2.locale.getShortWeekDays(locale2.locale) : []);
      if (prefixColumn) {
        headerCells.push(/* @__PURE__ */ reactExports.createElement("th", {
          key: "empty",
          "aria-label": "empty cell"
        }));
      }
      for (var i = 0; i < WEEK_DAY_COUNT; i += 1) {
        headerCells.push(/* @__PURE__ */ reactExports.createElement("th", {
          key: i
        }, weekDaysLocale[(i + weekFirstDay) % WEEK_DAY_COUNT]));
      }
      var getCellClassName = useCellClassName({
        cellPrefixCls,
        today,
        value,
        generateConfig: generateConfig2,
        rangedValue: prefixColumn ? null : rangedValue,
        hoverRangedValue: prefixColumn ? null : hoverRangedValue,
        isSameCell: isSameCell || function(current, target) {
          return isSameDate(generateConfig2, current, target);
        },
        isInView: function isInView(date) {
          return isSameMonth(generateConfig2, date, viewDate);
        },
        offsetCell: function offsetCell(date, offset2) {
          return generateConfig2.addDate(date, offset2);
        }
      });
      var getCellNode = cellRender ? function(date, wrapperNode) {
        return cellRender(date, {
          originNode: wrapperNode,
          today,
          type: "date",
          locale: locale2
        });
      } : void 0;
      return /* @__PURE__ */ reactExports.createElement(PanelBody, _extends$1({}, props, {
        rowNum: rowCount,
        colNum: WEEK_DAY_COUNT,
        baseDate,
        getCellNode,
        getCellText: generateConfig2.getDate,
        getCellClassName,
        getCellDate: generateConfig2.addDate,
        titleCell: function titleCell(date) {
          return formatValue(date, {
            locale: locale2,
            format: "YYYY-MM-DD",
            generateConfig: generateConfig2
          });
        },
        headerCells
      }));
    }
    var HIDDEN_STYLE$1 = {
      visibility: "hidden"
    };
    function Header$2(_ref) {
      var prefixCls = _ref.prefixCls, _ref$prevIcon = _ref.prevIcon, prevIcon = _ref$prevIcon === void 0 ? "‹" : _ref$prevIcon, _ref$nextIcon = _ref.nextIcon, nextIcon = _ref$nextIcon === void 0 ? "›" : _ref$nextIcon, _ref$superPrevIcon = _ref.superPrevIcon, superPrevIcon = _ref$superPrevIcon === void 0 ? "«" : _ref$superPrevIcon, _ref$superNextIcon = _ref.superNextIcon, superNextIcon = _ref$superNextIcon === void 0 ? "»" : _ref$superNextIcon, onSuperPrev = _ref.onSuperPrev, onSuperNext = _ref.onSuperNext, onPrev = _ref.onPrev, onNext = _ref.onNext, children = _ref.children;
      var _React$useContext = reactExports.useContext(PanelContext), hideNextBtn = _React$useContext.hideNextBtn, hidePrevBtn = _React$useContext.hidePrevBtn;
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: prefixCls
      }, onSuperPrev && /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        onClick: onSuperPrev,
        tabIndex: -1,
        className: "".concat(prefixCls, "-super-prev-btn"),
        style: hidePrevBtn ? HIDDEN_STYLE$1 : {}
      }, superPrevIcon), onPrev && /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        onClick: onPrev,
        tabIndex: -1,
        className: "".concat(prefixCls, "-prev-btn"),
        style: hidePrevBtn ? HIDDEN_STYLE$1 : {}
      }, prevIcon), /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-view")
      }, children), onNext && /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        onClick: onNext,
        tabIndex: -1,
        className: "".concat(prefixCls, "-next-btn"),
        style: hideNextBtn ? HIDDEN_STYLE$1 : {}
      }, nextIcon), onSuperNext && /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        onClick: onSuperNext,
        tabIndex: -1,
        className: "".concat(prefixCls, "-super-next-btn"),
        style: hideNextBtn ? HIDDEN_STYLE$1 : {}
      }, superNextIcon));
    }
    function DateHeader(props) {
      var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, locale2 = props.locale, viewDate = props.viewDate, onNextMonth = props.onNextMonth, onPrevMonth = props.onPrevMonth, onNextYear = props.onNextYear, onPrevYear = props.onPrevYear, onYearClick = props.onYearClick, onMonthClick = props.onMonthClick;
      var _React$useContext = reactExports.useContext(PanelContext), hideHeader = _React$useContext.hideHeader;
      if (hideHeader) {
        return null;
      }
      var headerPrefixCls = "".concat(prefixCls, "-header");
      var monthsLocale = locale2.shortMonths || (generateConfig2.locale.getShortMonths ? generateConfig2.locale.getShortMonths(locale2.locale) : []);
      var month = generateConfig2.getMonth(viewDate);
      var yearNode = /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        key: "year",
        onClick: onYearClick,
        tabIndex: -1,
        className: "".concat(prefixCls, "-year-btn")
      }, formatValue(viewDate, {
        locale: locale2,
        format: locale2.yearFormat,
        generateConfig: generateConfig2
      }));
      var monthNode = /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        key: "month",
        onClick: onMonthClick,
        tabIndex: -1,
        className: "".concat(prefixCls, "-month-btn")
      }, locale2.monthFormat ? formatValue(viewDate, {
        locale: locale2,
        format: locale2.monthFormat,
        generateConfig: generateConfig2
      }) : monthsLocale[month]);
      var monthYearNodes = locale2.monthBeforeYear ? [monthNode, yearNode] : [yearNode, monthNode];
      return /* @__PURE__ */ reactExports.createElement(Header$2, _extends$1({}, props, {
        prefixCls: headerPrefixCls,
        onSuperPrev: onPrevYear,
        onPrev: onPrevMonth,
        onNext: onNextMonth,
        onSuperNext: onNextYear
      }), monthYearNodes);
    }
    var DATE_ROW_COUNT = 6;
    function DatePanel(props) {
      var prefixCls = props.prefixCls, _props$panelName = props.panelName, panelName = _props$panelName === void 0 ? "date" : _props$panelName, keyboardConfig = props.keyboardConfig, active = props.active, operationRef = props.operationRef, generateConfig2 = props.generateConfig, value = props.value, viewDate = props.viewDate, onViewDateChange = props.onViewDateChange, onPanelChange = props.onPanelChange, _onSelect = props.onSelect;
      var panelPrefixCls = "".concat(prefixCls, "-").concat(panelName, "-panel");
      operationRef.current = {
        onKeyDown: function onKeyDown2(event) {
          return createKeyDownHandler(event, _objectSpread2({
            onLeftRight: function onLeftRight(diff2) {
              _onSelect(generateConfig2.addDate(value || viewDate, diff2), "key");
            },
            onCtrlLeftRight: function onCtrlLeftRight(diff2) {
              _onSelect(generateConfig2.addYear(value || viewDate, diff2), "key");
            },
            onUpDown: function onUpDown(diff2) {
              _onSelect(generateConfig2.addDate(value || viewDate, diff2 * WEEK_DAY_COUNT), "key");
            },
            onPageUpDown: function onPageUpDown(diff2) {
              _onSelect(generateConfig2.addMonth(value || viewDate, diff2), "key");
            }
          }, keyboardConfig));
        }
      };
      var onYearChange = function onYearChange2(diff2) {
        var newDate = generateConfig2.addYear(viewDate, diff2);
        onViewDateChange(newDate);
        onPanelChange(null, newDate);
      };
      var onMonthChange = function onMonthChange2(diff2) {
        var newDate = generateConfig2.addMonth(viewDate, diff2);
        onViewDateChange(newDate);
        onPanelChange(null, newDate);
      };
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(panelPrefixCls, _defineProperty({}, "".concat(panelPrefixCls, "-active"), active))
      }, /* @__PURE__ */ reactExports.createElement(DateHeader, _extends$1({}, props, {
        prefixCls,
        value,
        viewDate,
        onPrevYear: function onPrevYear() {
          onYearChange(-1);
        },
        onNextYear: function onNextYear() {
          onYearChange(1);
        },
        onPrevMonth: function onPrevMonth() {
          onMonthChange(-1);
        },
        onNextMonth: function onNextMonth() {
          onMonthChange(1);
        },
        onMonthClick: function onMonthClick() {
          onPanelChange("month", viewDate);
        },
        onYearClick: function onYearClick() {
          onPanelChange("year", viewDate);
        }
      })), /* @__PURE__ */ reactExports.createElement(DateBody, _extends$1({}, props, {
        onSelect: function onSelect(date) {
          return _onSelect(date, "mouse");
        },
        prefixCls,
        value,
        viewDate,
        rowCount: DATE_ROW_COUNT
      })));
    }
    function useTimeSelection(_ref) {
      var value = _ref.value, generateConfig2 = _ref.generateConfig, disabledMinutes = _ref.disabledMinutes, disabledSeconds = _ref.disabledSeconds, minutes2 = _ref.minutes, seconds2 = _ref.seconds, use12Hours = _ref.use12Hours;
      var setTime$1 = function setTime$12(isNewPM, newHour, newMinute, newSecond) {
        var now2 = generateConfig2.getNow();
        var newDate = value || now2;
        var newFormattedHour = !use12Hours || !isNewPM ? newHour : newHour + 12;
        var mergedHour = newHour < 0 ? generateConfig2.getHour(now2) : newFormattedHour;
        var mergedMinute = newMinute < 0 ? generateConfig2.getMinute(now2) : newMinute;
        var mergedSecond = newSecond < 0 ? generateConfig2.getSecond(now2) : newSecond;
        var newDisabledMinutes = disabledMinutes && disabledMinutes(mergedHour);
        if (newDisabledMinutes !== null && newDisabledMinutes !== void 0 && newDisabledMinutes.includes(mergedMinute)) {
          var availableMinute = minutes2.find(function(i) {
            return !newDisabledMinutes.includes(i.value);
          });
          if (availableMinute) {
            mergedMinute = availableMinute.value;
          } else {
            return null;
          }
        }
        var newDisabledSeconds = disabledSeconds && disabledSeconds(mergedHour, mergedMinute);
        if (newDisabledSeconds !== null && newDisabledSeconds !== void 0 && newDisabledSeconds.includes(mergedSecond)) {
          var availableSecond = seconds2.find(function(i) {
            return !newDisabledSeconds.includes(i.value);
          });
          if (availableSecond) {
            mergedSecond = availableSecond.value;
          } else {
            return null;
          }
        }
        newDate = setTime(generateConfig2, newDate, mergedHour, mergedMinute, mergedSecond);
        return newDate;
      };
      return setTime$1;
    }
    function TimeUnitColumn(props) {
      var prefixCls = props.prefixCls, units = props.units, onSelect = props.onSelect, value = props.value, active = props.active, hideDisabledOptions = props.hideDisabledOptions, info = props.info, type = props.type;
      var cellPrefixCls = "".concat(prefixCls, "-cell");
      var _React$useContext = reactExports.useContext(PanelContext), open = _React$useContext.open;
      var ulRef = reactExports.useRef(null);
      var liRefs = reactExports.useRef(/* @__PURE__ */ new Map());
      var scrollRef = reactExports.useRef();
      reactExports.useLayoutEffect(function() {
        var li2 = liRefs.current.get(value);
        if (li2 && open !== false) {
          scrollTo(ulRef.current, li2.offsetTop, 120);
        }
      }, [value]);
      reactExports.useLayoutEffect(function() {
        if (open) {
          var li2 = liRefs.current.get(value);
          if (li2) {
            scrollRef.current = waitElementReady(li2, function() {
              scrollTo(ulRef.current, li2.offsetTop, 0);
            });
          }
        }
        return function() {
          var _scrollRef$current;
          (_scrollRef$current = scrollRef.current) === null || _scrollRef$current === void 0 || _scrollRef$current.call(scrollRef);
        };
      }, [open]);
      return /* @__PURE__ */ reactExports.createElement("ul", {
        className: classNames("".concat(prefixCls, "-column"), _defineProperty({}, "".concat(prefixCls, "-column-active"), active)),
        ref: ulRef,
        style: {
          position: "relative"
        }
      }, units.map(function(unit2) {
        var _classNames2;
        if (hideDisabledOptions && unit2.disabled) {
          return null;
        }
        return /* @__PURE__ */ reactExports.createElement("li", {
          key: unit2.value,
          ref: function ref(element) {
            liRefs.current.set(unit2.value, element);
          },
          className: classNames(cellPrefixCls, (_classNames2 = {}, _defineProperty(_classNames2, "".concat(cellPrefixCls, "-disabled"), unit2.disabled), _defineProperty(_classNames2, "".concat(cellPrefixCls, "-selected"), value === unit2.value), _classNames2)),
          onClick: function onClick() {
            if (unit2.disabled) {
              return;
            }
            onSelect(unit2.value);
          }
        }, info.cellRender ? info.cellRender(unit2.value, {
          today: info.today,
          locale: info.locale,
          originNode: /* @__PURE__ */ reactExports.createElement("div", {
            className: "".concat(cellPrefixCls, "-inner")
          }, unit2.label),
          type: "time",
          subType: type
        }) : /* @__PURE__ */ reactExports.createElement("div", {
          className: "".concat(cellPrefixCls, "-inner")
        }, unit2.label));
      }));
    }
    function shouldUnitsUpdate(prevUnits, nextUnits) {
      if (prevUnits.length !== nextUnits.length)
        return true;
      for (var i = 0; i < prevUnits.length; i += 1) {
        if (prevUnits[i].disabled !== nextUnits[i].disabled)
          return true;
      }
      return false;
    }
    function generateUnits(start, end, step, disabledUnits) {
      var units = [];
      var integerStep = step >= 1 ? step | 0 : 1;
      for (var i = start; i <= end; i += integerStep) {
        units.push({
          label: leftPad(i, 2),
          value: i,
          disabled: (disabledUnits || []).includes(i)
        });
      }
      return units;
    }
    function TimeBody(props) {
      var generateConfig2 = props.generateConfig, prefixCls = props.prefixCls, operationRef = props.operationRef, activeColumnIndex = props.activeColumnIndex, value = props.value, showHour = props.showHour, showMinute = props.showMinute, showSecond = props.showSecond, use12Hours = props.use12Hours, _props$hourStep = props.hourStep, hourStep = _props$hourStep === void 0 ? 1 : _props$hourStep, _props$minuteStep = props.minuteStep, minuteStep = _props$minuteStep === void 0 ? 1 : _props$minuteStep, _props$secondStep = props.secondStep, secondStep = _props$secondStep === void 0 ? 1 : _props$secondStep, disabledHours = props.disabledHours, disabledMinutes = props.disabledMinutes, disabledSeconds = props.disabledSeconds, disabledTime = props.disabledTime, hideDisabledOptions = props.hideDisabledOptions, onSelect = props.onSelect, cellRender = props.cellRender, locale2 = props.locale;
      var columns = [];
      var contentPrefixCls = "".concat(prefixCls, "-content");
      var columnPrefixCls = "".concat(prefixCls, "-time-panel");
      var isPM;
      var originHour = value ? generateConfig2.getHour(value) : -1;
      var hour = originHour;
      var minute = value ? generateConfig2.getMinute(value) : -1;
      var second = value ? generateConfig2.getSecond(value) : -1;
      var now2 = generateConfig2.getNow();
      var _React$useMemo = reactExports.useMemo(function() {
        if (disabledTime) {
          var disabledConfig = disabledTime(now2);
          return [disabledConfig.disabledHours, disabledConfig.disabledMinutes, disabledConfig.disabledSeconds];
        }
        return [disabledHours, disabledMinutes, disabledSeconds];
      }, [disabledHours, disabledMinutes, disabledSeconds, disabledTime, now2]), _React$useMemo2 = _slicedToArray(_React$useMemo, 3), mergedDisabledHours = _React$useMemo2[0], mergedDisabledMinutes = _React$useMemo2[1], mergedDisabledSeconds = _React$useMemo2[2];
      var rawHours = generateUnits(0, 23, hourStep, mergedDisabledHours && mergedDisabledHours());
      var memorizedRawHours = useMemo(function() {
        return rawHours;
      }, rawHours, shouldUnitsUpdate);
      if (use12Hours) {
        isPM = hour >= 12;
        hour %= 12;
      }
      var _React$useMemo3 = reactExports.useMemo(function() {
        if (!use12Hours) {
          return [false, false];
        }
        var AMPMDisabled = [true, true];
        memorizedRawHours.forEach(function(_ref) {
          var disabled = _ref.disabled, hourValue = _ref.value;
          if (disabled)
            return;
          if (hourValue >= 12) {
            AMPMDisabled[1] = false;
          } else {
            AMPMDisabled[0] = false;
          }
        });
        return AMPMDisabled;
      }, [use12Hours, memorizedRawHours]), _React$useMemo4 = _slicedToArray(_React$useMemo3, 2), AMDisabled = _React$useMemo4[0], PMDisabled = _React$useMemo4[1];
      var hours2 = reactExports.useMemo(function() {
        if (!use12Hours)
          return memorizedRawHours;
        return memorizedRawHours.filter(isPM ? function(hourMeta) {
          return hourMeta.value >= 12;
        } : function(hourMeta) {
          return hourMeta.value < 12;
        }).map(function(hourMeta) {
          var hourValue = hourMeta.value % 12;
          var hourLabel = hourValue === 0 ? "12" : leftPad(hourValue, 2);
          return _objectSpread2(_objectSpread2({}, hourMeta), {}, {
            label: hourLabel,
            value: hourValue
          });
        });
      }, [use12Hours, isPM, memorizedRawHours]);
      var minutes2 = generateUnits(0, 59, minuteStep, mergedDisabledMinutes && mergedDisabledMinutes(originHour));
      var seconds2 = generateUnits(0, 59, secondStep, mergedDisabledSeconds && mergedDisabledSeconds(originHour, minute));
      var setTime2 = useTimeSelection({
        value,
        generateConfig: generateConfig2,
        disabledMinutes: mergedDisabledMinutes,
        disabledSeconds: mergedDisabledSeconds,
        minutes: minutes2,
        seconds: seconds2,
        use12Hours
      });
      operationRef.current = {
        onUpDown: function onUpDown(diff2) {
          var column2 = columns[activeColumnIndex];
          if (column2) {
            var valueIndex = column2.units.findIndex(function(unit2) {
              return unit2.value === column2.value;
            });
            var unitLen = column2.units.length;
            for (var i = 1; i < unitLen; i += 1) {
              var nextUnit = column2.units[(valueIndex + diff2 * i + unitLen) % unitLen];
              if (nextUnit.disabled !== true) {
                column2.onSelect(nextUnit.value);
                break;
              }
            }
          }
        }
      };
      function addColumnNode(condition, node2, columnValue, units, onColumnSelect) {
        if (condition !== false) {
          columns.push({
            node: /* @__PURE__ */ reactExports.cloneElement(node2, {
              prefixCls: columnPrefixCls,
              value: columnValue,
              active: activeColumnIndex === columns.length,
              onSelect: onColumnSelect,
              units,
              hideDisabledOptions
            }),
            onSelect: onColumnSelect,
            value: columnValue,
            units
          });
        }
      }
      addColumnNode(showHour, /* @__PURE__ */ reactExports.createElement(TimeUnitColumn, {
        key: "hour",
        type: "hour",
        info: {
          today: now2,
          locale: locale2,
          cellRender
        }
      }), hour, hours2, function(num) {
        onSelect(setTime2(isPM, num, minute, second), "mouse");
      });
      addColumnNode(showMinute, /* @__PURE__ */ reactExports.createElement(TimeUnitColumn, {
        key: "minute",
        type: "minute",
        info: {
          today: now2,
          locale: locale2,
          cellRender
        }
      }), minute, minutes2, function(num) {
        onSelect(setTime2(isPM, hour, num, second), "mouse");
      });
      addColumnNode(showSecond, /* @__PURE__ */ reactExports.createElement(TimeUnitColumn, {
        key: "second",
        type: "second",
        info: {
          today: now2,
          locale: locale2,
          cellRender
        }
      }), second, seconds2, function(num) {
        onSelect(setTime2(isPM, hour, minute, num), "mouse");
      });
      var PMIndex = -1;
      if (typeof isPM === "boolean") {
        PMIndex = isPM ? 1 : 0;
      }
      addColumnNode(use12Hours === true, /* @__PURE__ */ reactExports.createElement(TimeUnitColumn, {
        key: "meridiem",
        type: "meridiem",
        info: {
          today: now2,
          locale: locale2,
          cellRender
        }
      }), PMIndex, [{
        label: "AM",
        value: 0,
        disabled: AMDisabled
      }, {
        label: "PM",
        value: 1,
        disabled: PMDisabled
      }], function(num) {
        onSelect(setTime2(!!num, hour, minute, second), "mouse");
      });
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: contentPrefixCls
      }, columns.map(function(_ref2) {
        var node2 = _ref2.node;
        return node2;
      }));
    }
    function TimeHeader(props) {
      var _React$useContext = reactExports.useContext(PanelContext), hideHeader = _React$useContext.hideHeader;
      if (hideHeader) {
        return null;
      }
      var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, locale2 = props.locale, value = props.value, format2 = props.format;
      var headerPrefixCls = "".concat(prefixCls, "-header");
      return /* @__PURE__ */ reactExports.createElement(Header$2, {
        prefixCls: headerPrefixCls
      }, value ? formatValue(value, {
        locale: locale2,
        format: format2,
        generateConfig: generateConfig2
      }) : " ");
    }
    var countBoolean = function countBoolean2(boolList) {
      return boolList.filter(function(bool) {
        return bool !== false;
      }).length;
    };
    function TimePanel(props) {
      var generateConfig2 = props.generateConfig, _props$format = props.format, format2 = _props$format === void 0 ? "HH:mm:ss" : _props$format, prefixCls = props.prefixCls, active = props.active, operationRef = props.operationRef, showHour = props.showHour, showMinute = props.showMinute, showSecond = props.showSecond, _props$use12Hours = props.use12Hours, use12Hours = _props$use12Hours === void 0 ? false : _props$use12Hours, onSelect = props.onSelect, value = props.value;
      var panelPrefixCls = "".concat(prefixCls, "-time-panel");
      var bodyOperationRef = reactExports.useRef();
      var _React$useState = reactExports.useState(-1), _React$useState2 = _slicedToArray(_React$useState, 2), activeColumnIndex = _React$useState2[0], setActiveColumnIndex = _React$useState2[1];
      var columnsCount = countBoolean([showHour, showMinute, showSecond, use12Hours]);
      operationRef.current = {
        onKeyDown: function onKeyDown2(event) {
          return createKeyDownHandler(event, {
            onLeftRight: function onLeftRight(diff2) {
              setActiveColumnIndex((activeColumnIndex + diff2 + columnsCount) % columnsCount);
            },
            onUpDown: function onUpDown(diff2) {
              if (activeColumnIndex === -1) {
                setActiveColumnIndex(0);
              } else if (bodyOperationRef.current) {
                bodyOperationRef.current.onUpDown(diff2);
              }
            },
            onEnter: function onEnter() {
              onSelect(value || generateConfig2.getNow(), "key");
              setActiveColumnIndex(-1);
            }
          });
        },
        onBlur: function onBlur() {
          setActiveColumnIndex(-1);
        }
      };
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(panelPrefixCls, _defineProperty({}, "".concat(panelPrefixCls, "-active"), active))
      }, /* @__PURE__ */ reactExports.createElement(TimeHeader, _extends$1({}, props, {
        format: format2,
        prefixCls
      })), /* @__PURE__ */ reactExports.createElement(TimeBody, _extends$1({}, props, {
        prefixCls,
        activeColumnIndex,
        operationRef: bodyOperationRef
      })));
    }
    var ACTIVE_PANEL = tuple("date", "time");
    var findValidTime = function findValidTime2(refValue, disabledRange, maxValidTime) {
      var rangeSet = new Set(disabledRange);
      if (rangeSet.has(refValue)) {
        for (var i = 0; i <= maxValidTime; i++) {
          if (!rangeSet.has(i) && i >= refValue) {
            return i;
          }
        }
      }
      return refValue;
    };
    function DatetimePanel(props) {
      var prefixCls = props.prefixCls, operationRef = props.operationRef, generateConfig2 = props.generateConfig, value = props.value, defaultValue = props.defaultValue, disabledTime = props.disabledTime, showTime = props.showTime, onSelect = props.onSelect, cellRender = props.cellRender;
      var panelPrefixCls = "".concat(prefixCls, "-datetime-panel");
      var _React$useState = reactExports.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), activePanel = _React$useState2[0], setActivePanel = _React$useState2[1];
      var dateOperationRef = reactExports.useRef({});
      var timeOperationRef = reactExports.useRef({});
      var timeProps = _typeof(showTime) === "object" ? _objectSpread2({}, showTime) : {};
      function getNextActive(offset2) {
        var activeIndex = ACTIVE_PANEL.indexOf(activePanel) + offset2;
        var nextActivePanel = ACTIVE_PANEL[activeIndex] || null;
        return nextActivePanel;
      }
      var onBlur = function onBlur2(e2) {
        if (timeOperationRef.current.onBlur) {
          timeOperationRef.current.onBlur(e2);
        }
        setActivePanel(null);
      };
      operationRef.current = {
        onKeyDown: function onKeyDown2(event) {
          if (event.which === KeyCode.TAB) {
            var nextActivePanel = getNextActive(event.shiftKey ? -1 : 1);
            setActivePanel(nextActivePanel);
            if (nextActivePanel) {
              event.preventDefault();
            }
            return true;
          }
          if (activePanel) {
            var ref = activePanel === "date" ? dateOperationRef : timeOperationRef;
            if (ref.current && ref.current.onKeyDown) {
              ref.current.onKeyDown(event);
            }
            return true;
          }
          if ([KeyCode.LEFT, KeyCode.RIGHT, KeyCode.UP, KeyCode.DOWN].includes(event.which)) {
            setActivePanel("date");
            return true;
          }
          return false;
        },
        onBlur,
        onClose: onBlur
      };
      var onInternalSelect = function onInternalSelect2(date, source) {
        var selectedDate = date;
        if (source === "date") {
          var _disabledTimes$disabl, _disabledTimes$disabl2, _disabledTimes$disabl3;
          var _disabledTimes = (disabledTime === null || disabledTime === void 0 ? void 0 : disabledTime(value || timeProps.defaultValue)) || {};
          var validHour = findValidTime(generateConfig2.getHour(selectedDate), ((_disabledTimes$disabl = _disabledTimes.disabledHours) === null || _disabledTimes$disabl === void 0 ? void 0 : _disabledTimes$disabl.call(_disabledTimes)) || [-1], 23);
          var validMinute = findValidTime(generateConfig2.getMinute(selectedDate), ((_disabledTimes$disabl2 = _disabledTimes.disabledMinutes) === null || _disabledTimes$disabl2 === void 0 ? void 0 : _disabledTimes$disabl2.call(_disabledTimes, validHour)) || [-1], 59);
          var validSeconds = findValidTime(generateConfig2.getSecond(selectedDate), ((_disabledTimes$disabl3 = _disabledTimes.disabledSeconds) === null || _disabledTimes$disabl3 === void 0 ? void 0 : _disabledTimes$disabl3.call(_disabledTimes, validHour, validMinute)) || [-1], 59);
          selectedDate = generateConfig2.setHour(selectedDate, validHour);
          selectedDate = generateConfig2.setMinute(selectedDate, validMinute);
          selectedDate = generateConfig2.setSecond(selectedDate, validSeconds);
        } else if (source === "time" && !value && defaultValue) {
          selectedDate = generateConfig2.setYear(selectedDate, generateConfig2.getYear(defaultValue));
          selectedDate = generateConfig2.setMonth(selectedDate, generateConfig2.getMonth(defaultValue));
          selectedDate = generateConfig2.setDate(selectedDate, generateConfig2.getDate(defaultValue));
        }
        if (onSelect) {
          onSelect(selectedDate, "mouse");
        }
      };
      var disabledTimes = disabledTime ? disabledTime(value || null) : {};
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(panelPrefixCls, _defineProperty({}, "".concat(panelPrefixCls, "-active"), activePanel))
      }, /* @__PURE__ */ reactExports.createElement(DatePanel, _extends$1({}, props, {
        cellRender,
        operationRef: dateOperationRef,
        active: activePanel === "date",
        onSelect: function onSelect2(date) {
          onInternalSelect(setDateTime(generateConfig2, date, !value && _typeof(showTime) === "object" ? showTime.defaultValue : null), "date");
        }
      })), /* @__PURE__ */ reactExports.createElement(TimePanel, _extends$1({}, props, {
        cellRender: cellRender ? function(current, info) {
          return cellRender(current, _objectSpread2(_objectSpread2({}, info), {}, {
            type: "time"
          }));
        } : void 0,
        format: void 0
      }, timeProps, disabledTimes, {
        disabledTime: null,
        defaultValue: void 0,
        operationRef: timeOperationRef,
        active: activePanel === "time",
        onSelect: function onSelect2(date) {
          onInternalSelect(date, "time");
        }
      })));
    }
    function DecadeHeader(props) {
      var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, viewDate = props.viewDate, onPrevDecades = props.onPrevDecades, onNextDecades = props.onNextDecades;
      var _React$useContext = reactExports.useContext(PanelContext), hideHeader = _React$useContext.hideHeader;
      if (hideHeader) {
        return null;
      }
      var headerPrefixCls = "".concat(prefixCls, "-header");
      var yearNumber = generateConfig2.getYear(viewDate);
      var startYear = Math.floor(yearNumber / DECADE_DISTANCE_COUNT) * DECADE_DISTANCE_COUNT;
      var endYear = startYear + DECADE_DISTANCE_COUNT - 1;
      return /* @__PURE__ */ reactExports.createElement(Header$2, _extends$1({}, props, {
        prefixCls: headerPrefixCls,
        onSuperPrev: onPrevDecades,
        onSuperNext: onNextDecades
      }), startYear, "-", endYear);
    }
    var DECADE_COL_COUNT = 3;
    var DECADE_ROW_COUNT = 4;
    function DecadeBody(props) {
      var DECADE_UNIT_DIFF_DES = DECADE_UNIT_DIFF - 1;
      var prefixCls = props.prefixCls, viewDate = props.viewDate, generateConfig2 = props.generateConfig, cellRender = props.cellRender, locale2 = props.locale;
      var cellPrefixCls = "".concat(prefixCls, "-cell");
      var yearNumber = generateConfig2.getYear(viewDate);
      var decadeYearNumber = Math.floor(yearNumber / DECADE_UNIT_DIFF) * DECADE_UNIT_DIFF;
      var startDecadeYear = Math.floor(yearNumber / DECADE_DISTANCE_COUNT) * DECADE_DISTANCE_COUNT;
      var endDecadeYear = startDecadeYear + DECADE_DISTANCE_COUNT - 1;
      var baseDecadeYear = generateConfig2.setYear(viewDate, startDecadeYear - Math.ceil((DECADE_COL_COUNT * DECADE_ROW_COUNT * DECADE_UNIT_DIFF - DECADE_DISTANCE_COUNT) / 2));
      var getCellClassName = function getCellClassName2(date) {
        var _ref;
        var startDecadeNumber = generateConfig2.getYear(date);
        var endDecadeNumber = startDecadeNumber + DECADE_UNIT_DIFF_DES;
        return _ref = {}, _defineProperty(_ref, "".concat(cellPrefixCls, "-in-view"), startDecadeYear <= startDecadeNumber && endDecadeNumber <= endDecadeYear), _defineProperty(_ref, "".concat(cellPrefixCls, "-selected"), startDecadeNumber === decadeYearNumber), _ref;
      };
      var getCellNode = cellRender ? function(date, wrapperNode) {
        return cellRender(date, {
          originNode: wrapperNode,
          today: generateConfig2.getNow(),
          type: "decade",
          locale: locale2
        });
      } : void 0;
      return /* @__PURE__ */ reactExports.createElement(PanelBody, _extends$1({}, props, {
        rowNum: DECADE_ROW_COUNT,
        colNum: DECADE_COL_COUNT,
        baseDate: baseDecadeYear,
        getCellNode,
        getCellText: function getCellText(date) {
          var startDecadeNumber = generateConfig2.getYear(date);
          return "".concat(startDecadeNumber, "-").concat(startDecadeNumber + DECADE_UNIT_DIFF_DES);
        },
        getCellClassName,
        getCellDate: function getCellDate(date, offset2) {
          return generateConfig2.addYear(date, offset2 * DECADE_UNIT_DIFF);
        }
      }));
    }
    function DecadePanel(props) {
      var prefixCls = props.prefixCls, onViewDateChange = props.onViewDateChange, generateConfig2 = props.generateConfig, viewDate = props.viewDate, operationRef = props.operationRef, onSelect = props.onSelect, onPanelChange = props.onPanelChange;
      var panelPrefixCls = "".concat(prefixCls, "-decade-panel");
      operationRef.current = {
        onKeyDown: function onKeyDown2(event) {
          return createKeyDownHandler(event, {
            onLeftRight: function onLeftRight(diff2) {
              onSelect(generateConfig2.addYear(viewDate, diff2 * DECADE_UNIT_DIFF), "key");
            },
            onCtrlLeftRight: function onCtrlLeftRight(diff2) {
              onSelect(generateConfig2.addYear(viewDate, diff2 * DECADE_DISTANCE_COUNT), "key");
            },
            onUpDown: function onUpDown(diff2) {
              onSelect(generateConfig2.addYear(viewDate, diff2 * DECADE_UNIT_DIFF * DECADE_COL_COUNT), "key");
            },
            onEnter: function onEnter() {
              onPanelChange("year", viewDate);
            }
          });
        }
      };
      var onDecadesChange = function onDecadesChange2(diff2) {
        var newDate = generateConfig2.addYear(viewDate, diff2 * DECADE_DISTANCE_COUNT);
        onViewDateChange(newDate);
        onPanelChange(null, newDate);
      };
      var onInternalSelect = function onInternalSelect2(date) {
        onSelect(date, "mouse");
        onPanelChange("year", date);
      };
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: panelPrefixCls
      }, /* @__PURE__ */ reactExports.createElement(DecadeHeader, _extends$1({}, props, {
        prefixCls,
        onPrevDecades: function onPrevDecades() {
          onDecadesChange(-1);
        },
        onNextDecades: function onNextDecades() {
          onDecadesChange(1);
        }
      })), /* @__PURE__ */ reactExports.createElement(DecadeBody, _extends$1({}, props, {
        prefixCls,
        onSelect: onInternalSelect
      })));
    }
    function MonthHeader(props) {
      var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, locale2 = props.locale, viewDate = props.viewDate, onNextYear = props.onNextYear, onPrevYear = props.onPrevYear, onYearClick = props.onYearClick;
      var _React$useContext = reactExports.useContext(PanelContext), hideHeader = _React$useContext.hideHeader;
      if (hideHeader) {
        return null;
      }
      var headerPrefixCls = "".concat(prefixCls, "-header");
      return /* @__PURE__ */ reactExports.createElement(Header$2, _extends$1({}, props, {
        prefixCls: headerPrefixCls,
        onSuperPrev: onPrevYear,
        onSuperNext: onNextYear
      }), /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        onClick: onYearClick,
        className: "".concat(prefixCls, "-year-btn")
      }, formatValue(viewDate, {
        locale: locale2,
        format: locale2.yearFormat,
        generateConfig: generateConfig2
      })));
    }
    var MONTH_COL_COUNT = 3;
    var MONTH_ROW_COUNT = 4;
    function MonthBody(props) {
      var prefixCls = props.prefixCls, locale2 = props.locale, value = props.value, viewDate = props.viewDate, generateConfig2 = props.generateConfig, cellRender = props.cellRender;
      var _React$useContext = reactExports.useContext(RangeContext), rangedValue = _React$useContext.rangedValue, hoverRangedValue = _React$useContext.hoverRangedValue;
      var cellPrefixCls = "".concat(prefixCls, "-cell");
      var getCellClassName = useCellClassName({
        cellPrefixCls,
        value,
        generateConfig: generateConfig2,
        rangedValue,
        hoverRangedValue,
        isSameCell: function isSameCell(current, target) {
          return isSameMonth(generateConfig2, current, target);
        },
        isInView: function isInView() {
          return true;
        },
        offsetCell: function offsetCell(date, offset2) {
          return generateConfig2.addMonth(date, offset2);
        }
      });
      var monthsLocale = locale2.shortMonths || (generateConfig2.locale.getShortMonths ? generateConfig2.locale.getShortMonths(locale2.locale) : []);
      var baseMonth = generateConfig2.setMonth(viewDate, 0);
      var getCellNode = cellRender ? function(date, wrapperNode) {
        return cellRender(date, {
          originNode: wrapperNode,
          locale: locale2,
          today: generateConfig2.getNow(),
          type: "month"
        });
      } : void 0;
      return /* @__PURE__ */ reactExports.createElement(PanelBody, _extends$1({}, props, {
        rowNum: MONTH_ROW_COUNT,
        colNum: MONTH_COL_COUNT,
        baseDate: baseMonth,
        getCellNode,
        getCellText: function getCellText(date) {
          return locale2.monthFormat ? formatValue(date, {
            locale: locale2,
            format: locale2.monthFormat,
            generateConfig: generateConfig2
          }) : monthsLocale[generateConfig2.getMonth(date)];
        },
        getCellClassName,
        getCellDate: generateConfig2.addMonth,
        titleCell: function titleCell(date) {
          return formatValue(date, {
            locale: locale2,
            format: "YYYY-MM",
            generateConfig: generateConfig2
          });
        }
      }));
    }
    function MonthPanel(props) {
      var prefixCls = props.prefixCls, operationRef = props.operationRef, onViewDateChange = props.onViewDateChange, generateConfig2 = props.generateConfig, value = props.value, viewDate = props.viewDate, onPanelChange = props.onPanelChange, _onSelect = props.onSelect;
      var panelPrefixCls = "".concat(prefixCls, "-month-panel");
      operationRef.current = {
        onKeyDown: function onKeyDown2(event) {
          return createKeyDownHandler(event, {
            onLeftRight: function onLeftRight(diff2) {
              _onSelect(generateConfig2.addMonth(value || viewDate, diff2), "key");
            },
            onCtrlLeftRight: function onCtrlLeftRight(diff2) {
              _onSelect(generateConfig2.addYear(value || viewDate, diff2), "key");
            },
            onUpDown: function onUpDown(diff2) {
              _onSelect(generateConfig2.addMonth(value || viewDate, diff2 * MONTH_COL_COUNT), "key");
            },
            onEnter: function onEnter() {
              onPanelChange("date", value || viewDate);
            }
          });
        }
      };
      var onYearChange = function onYearChange2(diff2) {
        var newDate = generateConfig2.addYear(viewDate, diff2);
        onViewDateChange(newDate);
        onPanelChange(null, newDate);
      };
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: panelPrefixCls
      }, /* @__PURE__ */ reactExports.createElement(MonthHeader, _extends$1({}, props, {
        prefixCls,
        onPrevYear: function onPrevYear() {
          onYearChange(-1);
        },
        onNextYear: function onNextYear() {
          onYearChange(1);
        },
        onYearClick: function onYearClick() {
          onPanelChange("year", viewDate);
        }
      })), /* @__PURE__ */ reactExports.createElement(MonthBody, _extends$1({}, props, {
        prefixCls,
        onSelect: function onSelect(date) {
          _onSelect(date, "mouse");
          onPanelChange("date", date);
        }
      })));
    }
    function QuarterHeader(props) {
      var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, locale2 = props.locale, viewDate = props.viewDate, onNextYear = props.onNextYear, onPrevYear = props.onPrevYear, onYearClick = props.onYearClick;
      var _React$useContext = reactExports.useContext(PanelContext), hideHeader = _React$useContext.hideHeader;
      if (hideHeader) {
        return null;
      }
      var headerPrefixCls = "".concat(prefixCls, "-header");
      return /* @__PURE__ */ reactExports.createElement(Header$2, _extends$1({}, props, {
        prefixCls: headerPrefixCls,
        onSuperPrev: onPrevYear,
        onSuperNext: onNextYear
      }), /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        onClick: onYearClick,
        className: "".concat(prefixCls, "-year-btn")
      }, formatValue(viewDate, {
        locale: locale2,
        format: locale2.yearFormat,
        generateConfig: generateConfig2
      })));
    }
    var QUARTER_COL_COUNT = 4;
    var QUARTER_ROW_COUNT = 1;
    function QuarterBody(props) {
      var prefixCls = props.prefixCls, locale2 = props.locale, value = props.value, viewDate = props.viewDate, generateConfig2 = props.generateConfig, cellRender = props.cellRender;
      var _React$useContext = reactExports.useContext(RangeContext), rangedValue = _React$useContext.rangedValue, hoverRangedValue = _React$useContext.hoverRangedValue;
      var cellPrefixCls = "".concat(prefixCls, "-cell");
      var getCellClassName = useCellClassName({
        cellPrefixCls,
        value,
        generateConfig: generateConfig2,
        rangedValue,
        hoverRangedValue,
        isSameCell: function isSameCell(current, target) {
          return isSameQuarter(generateConfig2, current, target);
        },
        isInView: function isInView() {
          return true;
        },
        offsetCell: function offsetCell(date, offset2) {
          return generateConfig2.addMonth(date, offset2 * 3);
        }
      });
      var baseQuarter = generateConfig2.setDate(generateConfig2.setMonth(viewDate, 0), 1);
      var getCellNode = cellRender ? function(date, wrapperNode) {
        return cellRender(date, {
          originNode: wrapperNode,
          locale: locale2,
          today: generateConfig2.getNow(),
          type: "quarter"
        });
      } : void 0;
      return /* @__PURE__ */ reactExports.createElement(PanelBody, _extends$1({}, props, {
        rowNum: QUARTER_ROW_COUNT,
        colNum: QUARTER_COL_COUNT,
        baseDate: baseQuarter,
        getCellNode,
        getCellText: function getCellText(date) {
          return formatValue(date, {
            locale: locale2,
            format: locale2.quarterFormat || "[Q]Q",
            generateConfig: generateConfig2
          });
        },
        getCellClassName,
        getCellDate: function getCellDate(date, offset2) {
          return generateConfig2.addMonth(date, offset2 * 3);
        },
        titleCell: function titleCell(date) {
          return formatValue(date, {
            locale: locale2,
            format: "YYYY-[Q]Q",
            generateConfig: generateConfig2
          });
        }
      }));
    }
    function QuarterPanel(props) {
      var prefixCls = props.prefixCls, operationRef = props.operationRef, onViewDateChange = props.onViewDateChange, generateConfig2 = props.generateConfig, value = props.value, viewDate = props.viewDate, onPanelChange = props.onPanelChange, _onSelect = props.onSelect;
      var panelPrefixCls = "".concat(prefixCls, "-quarter-panel");
      operationRef.current = {
        onKeyDown: function onKeyDown2(event) {
          return createKeyDownHandler(event, {
            onLeftRight: function onLeftRight(diff2) {
              _onSelect(generateConfig2.addMonth(value || viewDate, diff2 * 3), "key");
            },
            onCtrlLeftRight: function onCtrlLeftRight(diff2) {
              _onSelect(generateConfig2.addYear(value || viewDate, diff2), "key");
            },
            onUpDown: function onUpDown(diff2) {
              _onSelect(generateConfig2.addYear(value || viewDate, diff2), "key");
            }
          });
        }
      };
      var onYearChange = function onYearChange2(diff2) {
        var newDate = generateConfig2.addYear(viewDate, diff2);
        onViewDateChange(newDate);
        onPanelChange(null, newDate);
      };
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: panelPrefixCls
      }, /* @__PURE__ */ reactExports.createElement(QuarterHeader, _extends$1({}, props, {
        prefixCls,
        onPrevYear: function onPrevYear() {
          onYearChange(-1);
        },
        onNextYear: function onNextYear() {
          onYearChange(1);
        },
        onYearClick: function onYearClick() {
          onPanelChange("year", viewDate);
        }
      })), /* @__PURE__ */ reactExports.createElement(QuarterBody, _extends$1({}, props, {
        prefixCls,
        onSelect: function onSelect(date) {
          _onSelect(date, "mouse");
        }
      })));
    }
    function WeekPanel(props) {
      var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, locale2 = props.locale, value = props.value, disabledDate = props.disabledDate, onSelect = props.onSelect;
      var _React$useContext = reactExports.useContext(RangeContext), rangedValue = _React$useContext.rangedValue, hoverRangedValue = _React$useContext.hoverRangedValue;
      var _React$useContext2 = reactExports.useContext(PanelContext), onDateMouseEnter = _React$useContext2.onDateMouseEnter, onDateMouseLeave = _React$useContext2.onDateMouseLeave;
      var rangeStart = (hoverRangedValue === null || hoverRangedValue === void 0 ? void 0 : hoverRangedValue[0]) || (rangedValue === null || rangedValue === void 0 ? void 0 : rangedValue[0]);
      var rangeEnd = (hoverRangedValue === null || hoverRangedValue === void 0 ? void 0 : hoverRangedValue[1]) || (rangedValue === null || rangedValue === void 0 ? void 0 : rangedValue[1]);
      var cellPrefixCls = "".concat(prefixCls, "-cell");
      var prefixColumn = function prefixColumn2(date) {
        var disabled = getCellDateDisabled({
          cellDate: date,
          mode: "week",
          disabledDate,
          generateConfig: generateConfig2
        });
        return /* @__PURE__ */ reactExports.createElement("td", {
          key: "week",
          className: classNames(cellPrefixCls, "".concat(cellPrefixCls, "-week")),
          onClick: function onClick() {
            if (!disabled) {
              onSelect(date, "mouse");
            }
          },
          onMouseEnter: function onMouseEnter() {
            if (!disabled && onDateMouseEnter) {
              onDateMouseEnter(date);
            }
          },
          onMouseLeave: function onMouseLeave() {
            if (!disabled && onDateMouseLeave) {
              onDateMouseLeave(date);
            }
          }
        }, /* @__PURE__ */ reactExports.createElement("div", {
          className: "".concat(cellPrefixCls, "-inner")
        }, generateConfig2.locale.getWeek(locale2.locale, date)));
      };
      var rowPrefixCls = "".concat(prefixCls, "-week-panel-row");
      var rowClassName = function rowClassName2(date) {
        var _classNames;
        var isRangeStart = isSameWeek(generateConfig2, locale2.locale, rangeStart, date);
        var isRangeEnd = isSameWeek(generateConfig2, locale2.locale, rangeEnd, date);
        return classNames(rowPrefixCls, (_classNames = {}, _defineProperty(_classNames, "".concat(rowPrefixCls, "-selected"), !rangedValue && isSameWeek(generateConfig2, locale2.locale, value, date)), _defineProperty(_classNames, "".concat(rowPrefixCls, "-range-start"), isRangeStart), _defineProperty(_classNames, "".concat(rowPrefixCls, "-range-end"), isRangeEnd), _defineProperty(_classNames, "".concat(rowPrefixCls, "-range-hover"), !isRangeStart && !isRangeEnd && isInRange(generateConfig2, rangeStart, rangeEnd, date)), _classNames));
      };
      return /* @__PURE__ */ reactExports.createElement(DatePanel, _extends$1({}, props, {
        panelName: "week",
        prefixColumn,
        rowClassName,
        keyboardConfig: {
          onLeftRight: null
        },
        isSameCell: function isSameCell() {
          return false;
        }
      }));
    }
    var YEAR_DECADE_COUNT = 10;
    function YearHeader(props) {
      var prefixCls = props.prefixCls, generateConfig2 = props.generateConfig, viewDate = props.viewDate, onPrevDecade = props.onPrevDecade, onNextDecade = props.onNextDecade, onDecadeClick = props.onDecadeClick;
      var _React$useContext = reactExports.useContext(PanelContext), hideHeader = _React$useContext.hideHeader;
      if (hideHeader) {
        return null;
      }
      var headerPrefixCls = "".concat(prefixCls, "-header");
      var yearNumber = generateConfig2.getYear(viewDate);
      var startYear = Math.floor(yearNumber / YEAR_DECADE_COUNT) * YEAR_DECADE_COUNT;
      var endYear = startYear + YEAR_DECADE_COUNT - 1;
      return /* @__PURE__ */ reactExports.createElement(Header$2, _extends$1({}, props, {
        prefixCls: headerPrefixCls,
        onSuperPrev: onPrevDecade,
        onSuperNext: onNextDecade
      }), /* @__PURE__ */ reactExports.createElement("button", {
        type: "button",
        onClick: onDecadeClick,
        className: "".concat(prefixCls, "-decade-btn")
      }, startYear, "-", endYear));
    }
    var YEAR_COL_COUNT = 3;
    var YEAR_ROW_COUNT = 4;
    function YearBody(props) {
      var prefixCls = props.prefixCls, value = props.value, viewDate = props.viewDate, locale2 = props.locale, generateConfig2 = props.generateConfig, cellRender = props.cellRender;
      var _React$useContext = reactExports.useContext(RangeContext), rangedValue = _React$useContext.rangedValue, hoverRangedValue = _React$useContext.hoverRangedValue;
      var yearPrefixCls = "".concat(prefixCls, "-cell");
      var yearNumber = generateConfig2.getYear(viewDate);
      var startYear = Math.floor(yearNumber / YEAR_DECADE_COUNT) * YEAR_DECADE_COUNT;
      var endYear = startYear + YEAR_DECADE_COUNT - 1;
      var baseYear = generateConfig2.setYear(viewDate, startYear - Math.ceil((YEAR_COL_COUNT * YEAR_ROW_COUNT - YEAR_DECADE_COUNT) / 2));
      var today = generateConfig2.getNow();
      var isInView = function isInView2(date) {
        var currentYearNumber = generateConfig2.getYear(date);
        return startYear <= currentYearNumber && currentYearNumber <= endYear;
      };
      var getCellClassName = useCellClassName({
        cellPrefixCls: yearPrefixCls,
        value,
        generateConfig: generateConfig2,
        rangedValue,
        hoverRangedValue,
        isSameCell: function isSameCell(current, target) {
          return isSameYear(generateConfig2, current, target);
        },
        isInView,
        offsetCell: function offsetCell(date, offset2) {
          return generateConfig2.addYear(date, offset2);
        }
      });
      var getCellNode = cellRender ? function(date, wrapperNode) {
        return cellRender(date, {
          originNode: wrapperNode,
          today,
          type: "year",
          locale: locale2
        });
      } : void 0;
      return /* @__PURE__ */ reactExports.createElement(PanelBody, _extends$1({}, props, {
        rowNum: YEAR_ROW_COUNT,
        colNum: YEAR_COL_COUNT,
        baseDate: baseYear,
        getCellNode,
        getCellText: generateConfig2.getYear,
        getCellClassName,
        getCellDate: generateConfig2.addYear,
        titleCell: function titleCell(date) {
          return formatValue(date, {
            locale: locale2,
            format: "YYYY",
            generateConfig: generateConfig2
          });
        }
      }));
    }
    function YearPanel(props) {
      var prefixCls = props.prefixCls, operationRef = props.operationRef, onViewDateChange = props.onViewDateChange, generateConfig2 = props.generateConfig, value = props.value, viewDate = props.viewDate, sourceMode = props.sourceMode, _onSelect = props.onSelect, onPanelChange = props.onPanelChange;
      var panelPrefixCls = "".concat(prefixCls, "-year-panel");
      operationRef.current = {
        onKeyDown: function onKeyDown2(event) {
          return createKeyDownHandler(event, {
            onLeftRight: function onLeftRight(diff2) {
              _onSelect(generateConfig2.addYear(value || viewDate, diff2), "key");
            },
            onCtrlLeftRight: function onCtrlLeftRight(diff2) {
              _onSelect(generateConfig2.addYear(value || viewDate, diff2 * YEAR_DECADE_COUNT), "key");
            },
            onUpDown: function onUpDown(diff2) {
              _onSelect(generateConfig2.addYear(value || viewDate, diff2 * YEAR_COL_COUNT), "key");
            },
            onEnter: function onEnter() {
              onPanelChange(sourceMode === "date" ? "date" : "month", value || viewDate);
            }
          });
        }
      };
      var onDecadeChange = function onDecadeChange2(diff2) {
        var newDate = generateConfig2.addYear(viewDate, diff2 * 10);
        onViewDateChange(newDate);
        onPanelChange(null, newDate);
      };
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: panelPrefixCls
      }, /* @__PURE__ */ reactExports.createElement(YearHeader, _extends$1({}, props, {
        prefixCls,
        onPrevDecade: function onPrevDecade() {
          onDecadeChange(-1);
        },
        onNextDecade: function onNextDecade() {
          onDecadeChange(1);
        },
        onDecadeClick: function onDecadeClick() {
          onPanelChange("decade", viewDate);
        }
      })), /* @__PURE__ */ reactExports.createElement(YearBody, _extends$1({}, props, {
        prefixCls,
        onSelect: function onSelect(date) {
          onPanelChange(sourceMode === "date" ? "date" : "month", date);
          _onSelect(date, "mouse");
        }
      })));
    }
    function getExtraFooter(prefixCls, mode, renderExtraFooter) {
      if (!renderExtraFooter) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-footer-extra")
      }, renderExtraFooter(mode));
    }
    function getRanges(_ref) {
      var prefixCls = _ref.prefixCls, _ref$components = _ref.components, components = _ref$components === void 0 ? {} : _ref$components, needConfirmButton = _ref.needConfirmButton, onNow = _ref.onNow, onOk = _ref.onOk, okDisabled = _ref.okDisabled, showNow = _ref.showNow, locale2 = _ref.locale;
      var presetNode;
      var okNode;
      if (needConfirmButton) {
        var Button2 = components.button || "button";
        if (onNow && showNow !== false) {
          presetNode = /* @__PURE__ */ reactExports.createElement("li", {
            className: "".concat(prefixCls, "-now")
          }, /* @__PURE__ */ reactExports.createElement("a", {
            className: "".concat(prefixCls, "-now-btn"),
            onClick: onNow
          }, locale2.now));
        }
        okNode = needConfirmButton && /* @__PURE__ */ reactExports.createElement("li", {
          className: "".concat(prefixCls, "-ok")
        }, /* @__PURE__ */ reactExports.createElement(Button2, {
          disabled: okDisabled,
          onClick: onOk
        }, locale2.ok));
      }
      if (!presetNode && !okNode) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement("ul", {
        className: "".concat(prefixCls, "-ranges")
      }, presetNode, okNode);
    }
    var CALENDAR_PANEL_MODE = ["date", "month"];
    function PickerPanel(props) {
      var _classNames;
      var _ref = props, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-picker" : _ref$prefixCls, className = _ref.className, style2 = _ref.style, locale2 = _ref.locale, generateConfig2 = _ref.generateConfig, value = _ref.value, defaultValue = _ref.defaultValue, pickerValue = _ref.pickerValue, defaultPickerValue = _ref.defaultPickerValue, disabledDate = _ref.disabledDate, mode = _ref.mode, _ref$picker = _ref.picker, picker = _ref$picker === void 0 ? "date" : _ref$picker, _ref$tabIndex = _ref.tabIndex, tabIndex = _ref$tabIndex === void 0 ? 0 : _ref$tabIndex, showNow = _ref.showNow, showTime = _ref.showTime, showToday = _ref.showToday, renderExtraFooter = _ref.renderExtraFooter, hideHeader = _ref.hideHeader, onSelect = _ref.onSelect, onChange = _ref.onChange, onPanelChange = _ref.onPanelChange, onMouseDown = _ref.onMouseDown, onPickerValueChange = _ref.onPickerValueChange, _onOk = _ref.onOk, components = _ref.components, direction = _ref.direction, _ref$hourStep = _ref.hourStep, hourStep = _ref$hourStep === void 0 ? 1 : _ref$hourStep, _ref$minuteStep = _ref.minuteStep, minuteStep = _ref$minuteStep === void 0 ? 1 : _ref$minuteStep, _ref$secondStep = _ref.secondStep, secondStep = _ref$secondStep === void 0 ? 1 : _ref$secondStep, dateRender = _ref.dateRender, monthCellRender = _ref.monthCellRender, cellRender = _ref.cellRender;
      var needConfirmButton = picker === "date" && !!showTime || picker === "time";
      var isHourStepValid = 24 % hourStep === 0;
      var isMinuteStepValid = 60 % minuteStep === 0;
      var isSecondStepValid = 60 % secondStep === 0;
      var panelContext = reactExports.useContext(PanelContext);
      var operationRef = panelContext.operationRef, onContextSelect = panelContext.onSelect, hideRanges = panelContext.hideRanges, defaultOpenValue = panelContext.defaultOpenValue;
      var _React$useContext = reactExports.useContext(RangeContext), inRange = _React$useContext.inRange, panelPosition = _React$useContext.panelPosition, rangedValue = _React$useContext.rangedValue, hoverRangedValue = _React$useContext.hoverRangedValue;
      var panelRef = reactExports.useRef({});
      var initRef = reactExports.useRef(true);
      var _useMergedState = useMergedState(null, {
        value,
        defaultValue,
        postState: function postState(val) {
          if (!val && defaultOpenValue && picker === "time") {
            return defaultOpenValue;
          }
          return val;
        }
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedValue = _useMergedState2[0], setInnerValue = _useMergedState2[1];
      var _useMergedState3 = useMergedState(null, {
        value: pickerValue,
        defaultValue: defaultPickerValue || mergedValue,
        postState: function postState(date) {
          var now22 = generateConfig2.getNow();
          if (!date) {
            return now22;
          }
          if (!mergedValue && showTime) {
            var defaultDateObject = _typeof(showTime) === "object" ? showTime.defaultValue : defaultValue;
            return setDateTime(generateConfig2, Array.isArray(date) ? date[0] : date, defaultDateObject || now22);
          }
          return Array.isArray(date) ? date[0] : date;
        }
      }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), viewDate = _useMergedState4[0], setInnerViewDate = _useMergedState4[1];
      var setViewDate = function setViewDate2(date) {
        setInnerViewDate(date);
        if (onPickerValueChange) {
          onPickerValueChange(date);
        }
      };
      var getInternalNextMode = function getInternalNextMode2(nextMode) {
        var getNextMode = PickerModeMap[picker];
        if (getNextMode) {
          return getNextMode(nextMode);
        }
        return nextMode;
      };
      var _useMergedState5 = useMergedState(function() {
        if (picker === "time") {
          return "time";
        }
        return getInternalNextMode("date");
      }, {
        value: mode
      }), _useMergedState6 = _slicedToArray(_useMergedState5, 2), mergedMode = _useMergedState6[0], setInnerMode = _useMergedState6[1];
      reactExports.useEffect(function() {
        setInnerMode(picker);
      }, [picker]);
      var _React$useState = reactExports.useState(function() {
        return mergedMode;
      }), _React$useState2 = _slicedToArray(_React$useState, 2), sourceMode = _React$useState2[0], setSourceMode = _React$useState2[1];
      var onInternalPanelChange = function onInternalPanelChange2(newMode, viewValue) {
        var nextMode = getInternalNextMode(newMode || mergedMode);
        setSourceMode(mergedMode);
        setInnerMode(nextMode);
        if (onPanelChange && (mergedMode !== nextMode || isEqual(generateConfig2, viewDate, viewDate))) {
          onPanelChange(viewValue, nextMode);
        }
      };
      var triggerSelect = function triggerSelect2(date, type) {
        var forceTriggerSelect = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        if (mergedMode === picker || forceTriggerSelect) {
          setInnerValue(date);
          if (onSelect) {
            onSelect(date);
          }
          if (onContextSelect) {
            onContextSelect(date, type);
          }
          if (onChange && !isEqual(generateConfig2, date, mergedValue) && !(disabledDate !== null && disabledDate !== void 0 && disabledDate(date))) {
            onChange(date);
          }
        }
      };
      var isSelectable = function isSelectable2(key) {
        if (CALENDAR_PANEL_MODE.includes(mergedMode)) {
          var _date;
          var operationFnc;
          var isDateMode = mergedMode === "date";
          if (key === KeyCode.PAGE_UP || key === KeyCode.PAGE_DOWN) {
            operationFnc = isDateMode ? generateConfig2.addMonth : generateConfig2.addYear;
          } else {
            operationFnc = isDateMode ? generateConfig2.addDate : generateConfig2.addMonth;
          }
          switch (key) {
            case KeyCode.LEFT:
            case KeyCode.PAGE_UP:
              _date = operationFnc(viewDate, -1);
              break;
            case KeyCode.RIGHT:
            case KeyCode.PAGE_DOWN:
              _date = operationFnc(viewDate, 1);
              break;
            case KeyCode.UP:
            case KeyCode.DOWN:
              _date = operationFnc(viewDate, Number("".concat(key === KeyCode.UP ? "-" : "").concat(isDateMode ? WEEK_DAY_COUNT : MONTH_COL_COUNT)));
              break;
          }
          if (_date) {
            return !(disabledDate !== null && disabledDate !== void 0 && disabledDate(_date));
          }
        }
        return true;
      };
      var onInternalKeyDown = function onInternalKeyDown2(e2) {
        if (panelRef.current && panelRef.current.onKeyDown) {
          var selectable = true;
          var which = e2.which;
          if ([KeyCode.LEFT, KeyCode.RIGHT, KeyCode.UP, KeyCode.DOWN, KeyCode.PAGE_UP, KeyCode.PAGE_DOWN, KeyCode.ENTER].includes(which)) {
            e2.preventDefault();
            if (which !== KeyCode.ENTER && tabIndex === 0) {
              selectable = isSelectable(which);
            }
          }
          if (selectable) {
            return panelRef.current.onKeyDown(e2);
          }
        }
        {
          warningOnce(false, "Panel not correct handle keyDown event. Please help to fire issue about this.");
          return false;
        }
      };
      var onInternalBlur = function onInternalBlur2(e2) {
        if (panelRef.current && panelRef.current.onBlur) {
          panelRef.current.onBlur(e2);
        }
      };
      if (operationRef && panelPosition !== "right") {
        operationRef.current = {
          onKeyDown: onInternalKeyDown,
          onClose: function onClose() {
            if (panelRef.current && panelRef.current.onClose) {
              panelRef.current.onClose();
            }
          }
        };
      }
      reactExports.useEffect(function() {
        if (value && !initRef.current) {
          setInnerViewDate(value);
        }
      }, [value]);
      reactExports.useEffect(function() {
        initRef.current = false;
      }, []);
      var panelNode;
      var mergedCellRender = useCellRender$1({
        cellRender,
        monthCellRender,
        dateRender
      });
      var pickerProps = _objectSpread2(_objectSpread2({}, props), {}, {
        cellRender: mergedCellRender,
        operationRef: panelRef,
        prefixCls,
        viewDate,
        value: mergedValue,
        onViewDateChange: setViewDate,
        sourceMode,
        onPanelChange: onInternalPanelChange,
        disabledDate
      });
      delete pickerProps.onChange;
      delete pickerProps.onSelect;
      switch (mergedMode) {
        case "decade":
          panelNode = /* @__PURE__ */ reactExports.createElement(DecadePanel, _extends$1({}, pickerProps, {
            onSelect: function onSelect2(date, type) {
              setViewDate(date);
              triggerSelect(date, type);
            }
          }));
          break;
        case "year":
          panelNode = /* @__PURE__ */ reactExports.createElement(YearPanel, _extends$1({}, pickerProps, {
            onSelect: function onSelect2(date, type) {
              setViewDate(date);
              triggerSelect(date, type);
            }
          }));
          break;
        case "month":
          panelNode = /* @__PURE__ */ reactExports.createElement(MonthPanel, _extends$1({}, pickerProps, {
            onSelect: function onSelect2(date, type) {
              setViewDate(date);
              triggerSelect(date, type);
            }
          }));
          break;
        case "quarter":
          panelNode = /* @__PURE__ */ reactExports.createElement(QuarterPanel, _extends$1({}, pickerProps, {
            onSelect: function onSelect2(date, type) {
              setViewDate(date);
              triggerSelect(date, type);
            }
          }));
          break;
        case "week":
          panelNode = /* @__PURE__ */ reactExports.createElement(WeekPanel, _extends$1({}, pickerProps, {
            onSelect: function onSelect2(date, type) {
              setViewDate(date);
              triggerSelect(date, type);
            }
          }));
          break;
        case "time":
          delete pickerProps.showTime;
          panelNode = /* @__PURE__ */ reactExports.createElement(TimePanel, _extends$1({}, pickerProps, _typeof(showTime) === "object" ? showTime : null, {
            onSelect: function onSelect2(date, type) {
              setViewDate(date);
              triggerSelect(date, type);
            }
          }));
          break;
        default:
          if (showTime) {
            panelNode = /* @__PURE__ */ reactExports.createElement(DatetimePanel, _extends$1({}, pickerProps, {
              onSelect: function onSelect2(date, type) {
                setViewDate(date);
                triggerSelect(date, type);
              }
            }));
          } else {
            panelNode = /* @__PURE__ */ reactExports.createElement(DatePanel, _extends$1({}, pickerProps, {
              onSelect: function onSelect2(date, type) {
                setViewDate(date);
                triggerSelect(date, type);
              }
            }));
          }
      }
      var extraFooter;
      var rangesNode;
      var onNow = function onNow2() {
        var now22 = generateConfig2.getNow();
        var lowerBoundTime = getLowerBoundTime(generateConfig2.getHour(now22), generateConfig2.getMinute(now22), generateConfig2.getSecond(now22), isHourStepValid ? hourStep : 1, isMinuteStepValid ? minuteStep : 1, isSecondStepValid ? secondStep : 1);
        var adjustedNow = setTime(
          generateConfig2,
          now22,
          lowerBoundTime[0],
          // hour
          lowerBoundTime[1],
          // minute
          lowerBoundTime[2]
          // second
        );
        triggerSelect(adjustedNow, "submit");
      };
      if (!hideRanges) {
        extraFooter = getExtraFooter(prefixCls, mergedMode, renderExtraFooter);
        if (showTime && mergedMode !== "date") {
          rangesNode = null;
        } else {
          rangesNode = getRanges({
            prefixCls,
            components,
            needConfirmButton,
            okDisabled: !mergedValue || disabledDate && disabledDate(mergedValue),
            locale: locale2,
            showNow,
            onNow: needConfirmButton && onNow,
            onOk: function onOk() {
              if (mergedValue) {
                triggerSelect(mergedValue, "submit", true);
                if (_onOk) {
                  _onOk(mergedValue);
                }
              }
            }
          });
        }
      }
      var todayNode;
      if (showToday && mergedMode === "date" && picker === "date" && !showTime) {
        var now2 = generateConfig2.getNow();
        var todayCls = "".concat(prefixCls, "-today-btn");
        var disabled = disabledDate && disabledDate(now2);
        todayNode = /* @__PURE__ */ reactExports.createElement("a", {
          className: classNames(todayCls, disabled && "".concat(todayCls, "-disabled")),
          "aria-disabled": disabled,
          onClick: function onClick() {
            if (!disabled) {
              triggerSelect(now2, "mouse", true);
            }
          }
        }, locale2.today);
      }
      return /* @__PURE__ */ reactExports.createElement(PanelContext.Provider, {
        value: _objectSpread2(_objectSpread2({}, panelContext), {}, {
          mode: mergedMode,
          hideHeader: "hideHeader" in props ? hideHeader : panelContext.hideHeader,
          hidePrevBtn: inRange && panelPosition === "right",
          hideNextBtn: inRange && panelPosition === "left"
        })
      }, /* @__PURE__ */ reactExports.createElement("div", {
        tabIndex,
        className: classNames("".concat(prefixCls, "-panel"), className, (_classNames = {}, _defineProperty(_classNames, "".concat(prefixCls, "-panel-has-range"), rangedValue && rangedValue[0] && rangedValue[1]), _defineProperty(_classNames, "".concat(prefixCls, "-panel-has-range-hover"), hoverRangedValue && hoverRangedValue[0] && hoverRangedValue[1]), _defineProperty(_classNames, "".concat(prefixCls, "-panel-rtl"), direction === "rtl"), _classNames)),
        style: style2,
        onKeyDown: onInternalKeyDown,
        onBlur: onInternalBlur,
        onMouseDown
      }, panelNode, extraFooter || rangesNode || todayNode ? /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-footer")
      }, extraFooter, rangesNode, todayNode) : null));
    }
    var BUILT_IN_PLACEMENTS = {
      bottomLeft: {
        points: ["tl", "bl"],
        offset: [0, 4],
        overflow: {
          adjustX: 1,
          adjustY: 1
        }
      },
      bottomRight: {
        points: ["tr", "br"],
        offset: [0, 4],
        overflow: {
          adjustX: 1,
          adjustY: 1
        }
      },
      topLeft: {
        points: ["bl", "tl"],
        offset: [0, -4],
        overflow: {
          adjustX: 0,
          adjustY: 1
        }
      },
      topRight: {
        points: ["br", "tr"],
        offset: [0, -4],
        overflow: {
          adjustX: 0,
          adjustY: 1
        }
      }
    };
    function PickerTrigger(_ref) {
      var _classNames;
      var prefixCls = _ref.prefixCls, popupElement = _ref.popupElement, popupStyle = _ref.popupStyle, visible = _ref.visible, dropdownClassName = _ref.dropdownClassName, dropdownAlign = _ref.dropdownAlign, transitionName = _ref.transitionName, getPopupContainer = _ref.getPopupContainer, children = _ref.children, range2 = _ref.range, popupPlacement = _ref.popupPlacement, direction = _ref.direction;
      var dropdownPrefixCls = "".concat(prefixCls, "-dropdown");
      var getPopupPlacement = function getPopupPlacement2() {
        if (popupPlacement !== void 0) {
          return popupPlacement;
        }
        return direction === "rtl" ? "bottomRight" : "bottomLeft";
      };
      return /* @__PURE__ */ reactExports.createElement(Trigger, {
        showAction: [],
        hideAction: [],
        popupPlacement: getPopupPlacement(),
        builtinPlacements: BUILT_IN_PLACEMENTS,
        prefixCls: dropdownPrefixCls,
        popupTransitionName: transitionName,
        popup: popupElement,
        popupAlign: dropdownAlign,
        popupVisible: visible,
        popupClassName: classNames(dropdownClassName, (_classNames = {}, _defineProperty(_classNames, "".concat(dropdownPrefixCls, "-range"), range2), _defineProperty(_classNames, "".concat(dropdownPrefixCls, "-rtl"), direction === "rtl"), _classNames)),
        popupStyle,
        getPopupContainer
      }, children);
    }
    function PresetPanel(props) {
      var prefixCls = props.prefixCls, presets = props.presets, _onClick = props.onClick, onHover = props.onHover;
      if (!presets.length) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-presets")
      }, /* @__PURE__ */ reactExports.createElement("ul", null, presets.map(function(_ref, index2) {
        var label = _ref.label, value = _ref.value;
        return /* @__PURE__ */ reactExports.createElement("li", {
          key: index2,
          onClick: function onClick() {
            return _onClick === null || _onClick === void 0 ? void 0 : _onClick(executeValue(value));
          },
          onMouseEnter: function onMouseEnter() {
            return onHover === null || onHover === void 0 ? void 0 : onHover(executeValue(value));
          },
          onMouseLeave: function onMouseLeave() {
            return onHover === null || onHover === void 0 ? void 0 : onHover(null);
          }
        }, label);
      })));
    }
    function getClearIcon(prefixCls, allowClear, clearIcon) {
      var mergedClearIcon = _typeof(allowClear) === "object" ? allowClear.clearIcon : clearIcon;
      return mergedClearIcon || /* @__PURE__ */ React.createElement("span", {
        className: "".concat(prefixCls, "-clear-btn")
      });
    }
    function InnerPicker(props) {
      var _classNames2;
      var _ref = props, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-picker" : _ref$prefixCls, id2 = _ref.id, name = _ref.name, tabIndex = _ref.tabIndex, style2 = _ref.style, className = _ref.className, dropdownClassName = _ref.dropdownClassName, dropdownAlign = _ref.dropdownAlign, popupStyle = _ref.popupStyle, transitionName = _ref.transitionName, generateConfig2 = _ref.generateConfig, locale2 = _ref.locale, inputReadOnly = _ref.inputReadOnly, allowClear = _ref.allowClear, autoFocus = _ref.autoFocus, showTime = _ref.showTime, _ref$picker = _ref.picker, picker = _ref$picker === void 0 ? "date" : _ref$picker, format2 = _ref.format, use12Hours = _ref.use12Hours, value = _ref.value, defaultValue = _ref.defaultValue, presets = _ref.presets, open = _ref.open, defaultOpen = _ref.defaultOpen, defaultOpenValue = _ref.defaultOpenValue, suffixIcon = _ref.suffixIcon, clearIcon = _ref.clearIcon, disabled = _ref.disabled, disabledDate = _ref.disabledDate, placeholder = _ref.placeholder, getPopupContainer = _ref.getPopupContainer, pickerRef = _ref.pickerRef, panelRender = _ref.panelRender, onChange = _ref.onChange, onOpenChange = _ref.onOpenChange, onFocus = _ref.onFocus, onBlur = _ref.onBlur, onMouseDown = _ref.onMouseDown, onMouseUp = _ref.onMouseUp, onMouseEnter = _ref.onMouseEnter, onMouseLeave = _ref.onMouseLeave, onContextMenu = _ref.onContextMenu, onClick = _ref.onClick, _onKeyDown = _ref.onKeyDown, _onSelect = _ref.onSelect, direction = _ref.direction, _ref$autoComplete = _ref.autoComplete, autoComplete = _ref$autoComplete === void 0 ? "off" : _ref$autoComplete, inputRender = _ref.inputRender, changeOnBlur = _ref.changeOnBlur;
      var inputRef = reactExports.useRef(null);
      var needConfirmButton = picker === "date" && !!showTime || picker === "time";
      var presetList = usePresets(presets);
      var formatList = toArray$6(getDefaultFormat(format2, picker, showTime, use12Hours));
      var panelDivRef = reactExports.useRef(null);
      var inputDivRef = reactExports.useRef(null);
      var containerRef = reactExports.useRef(null);
      var _useMergedState = useMergedState(null, {
        value,
        defaultValue
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedValue = _useMergedState2[0], setInnerValue = _useMergedState2[1];
      var _React$useState = reactExports.useState(mergedValue), _React$useState2 = _slicedToArray(_React$useState, 2), selectedValue = _React$useState2[0], setSelectedValue = _React$useState2[1];
      var operationRef = reactExports.useRef(null);
      var _useMergedState3 = useMergedState(false, {
        value: open,
        defaultValue: defaultOpen,
        postState: function postState(postOpen) {
          return disabled ? false : postOpen;
        },
        onChange: function onChange2(newOpen) {
          if (onOpenChange) {
            onOpenChange(newOpen);
          }
          if (!newOpen && operationRef.current && operationRef.current.onClose) {
            operationRef.current.onClose();
          }
        }
      }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), mergedOpen = _useMergedState4[0], triggerInnerOpen = _useMergedState4[1];
      var _useValueTexts = useValueTexts(selectedValue, {
        formatList,
        generateConfig: generateConfig2,
        locale: locale2
      }), _useValueTexts2 = _slicedToArray(_useValueTexts, 2), valueTexts = _useValueTexts2[0], firstValueText = _useValueTexts2[1];
      var _useTextValueMapping = useTextValueMapping({
        valueTexts,
        onTextChange: function onTextChange(newText) {
          var inputDate = parseValue(newText, {
            locale: locale2,
            formatList,
            generateConfig: generateConfig2
          });
          if (inputDate && (!disabledDate || !disabledDate(inputDate))) {
            setSelectedValue(inputDate);
          }
        }
      }), _useTextValueMapping2 = _slicedToArray(_useTextValueMapping, 3), text = _useTextValueMapping2[0], triggerTextChange = _useTextValueMapping2[1], resetText = _useTextValueMapping2[2];
      var triggerChange = function triggerChange2(newValue) {
        setSelectedValue(newValue);
        setInnerValue(newValue);
        if (onChange && !isEqual(generateConfig2, mergedValue, newValue)) {
          onChange(newValue, newValue ? formatValue(newValue, {
            generateConfig: generateConfig2,
            locale: locale2,
            format: formatList[0]
          }) : "");
        }
      };
      var triggerOpen = function triggerOpen2(newOpen) {
        if (disabled && newOpen) {
          return;
        }
        triggerInnerOpen(newOpen);
      };
      var forwardKeyDown = function forwardKeyDown2(e2) {
        if (mergedOpen && operationRef.current && operationRef.current.onKeyDown) {
          return operationRef.current.onKeyDown(e2);
        }
        {
          warningOnce(false, "Picker not correct forward KeyDown operation. Please help to fire issue about this.");
          return false;
        }
      };
      var onInternalClick = function onInternalClick2() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        onClick === null || onClick === void 0 || onClick.apply(void 0, args);
        if (inputRef.current) {
          inputRef.current.focus();
          triggerOpen(true);
        }
      };
      var onInternalBlur = function onInternalBlur2(e2) {
        if (changeOnBlur) {
          triggerChange(selectedValue);
        }
        onBlur === null || onBlur === void 0 || onBlur(e2);
      };
      var _usePickerInput = usePickerInput({
        blurToCancel: needConfirmButton,
        changeOnBlur,
        open: mergedOpen,
        value: text,
        triggerOpen,
        forwardKeyDown,
        isClickOutside: function isClickOutside(target) {
          return !elementsContains([panelDivRef.current, inputDivRef.current, containerRef.current], target);
        },
        onSubmit: function onSubmit() {
          if (
            // When user typing disabledDate with keyboard and enter, this value will be empty
            !selectedValue || // Normal disabled check
            disabledDate && disabledDate(selectedValue)
          ) {
            return false;
          }
          triggerChange(selectedValue);
          triggerOpen(false);
          resetText();
          return true;
        },
        onCancel: function onCancel() {
          triggerOpen(false);
          setSelectedValue(mergedValue);
          resetText();
        },
        onKeyDown: function onKeyDown2(e2, preventDefault) {
          _onKeyDown === null || _onKeyDown === void 0 || _onKeyDown(e2, preventDefault);
        },
        onFocus,
        onBlur: onInternalBlur
      }), _usePickerInput2 = _slicedToArray(_usePickerInput, 2), inputProps = _usePickerInput2[0], _usePickerInput2$ = _usePickerInput2[1], focused = _usePickerInput2$.focused, typing = _usePickerInput2$.typing;
      reactExports.useEffect(function() {
        if (!mergedOpen) {
          setSelectedValue(mergedValue);
          if (!valueTexts.length || valueTexts[0] === "") {
            triggerTextChange("");
          } else if (firstValueText !== text) {
            resetText();
          }
        }
      }, [mergedOpen, valueTexts]);
      reactExports.useEffect(function() {
        if (!mergedOpen) {
          resetText();
        }
      }, [picker]);
      reactExports.useEffect(function() {
        setSelectedValue(mergedValue);
      }, [mergedValue]);
      if (pickerRef) {
        pickerRef.current = {
          focus: function focus() {
            var _inputRef$current;
            (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.focus();
          },
          blur: function blur() {
            var _inputRef$current2;
            (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 || _inputRef$current2.blur();
          }
        };
      }
      var _useHoverValue = useHoverValue(text, {
        formatList,
        generateConfig: generateConfig2,
        locale: locale2
      }), _useHoverValue2 = _slicedToArray(_useHoverValue, 3), hoverValue = _useHoverValue2[0], onEnter = _useHoverValue2[1], onLeave = _useHoverValue2[2];
      var panelProps = _objectSpread2(_objectSpread2({}, props), {}, {
        className: void 0,
        style: void 0,
        pickerValue: void 0,
        onPickerValueChange: void 0,
        onChange: null
      });
      var panelNode = /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-panel-layout")
      }, /* @__PURE__ */ reactExports.createElement(PresetPanel, {
        prefixCls,
        presets: presetList,
        onClick: function onClick2(nextValue) {
          triggerChange(nextValue);
          triggerOpen(false);
        }
      }), /* @__PURE__ */ reactExports.createElement(PickerPanel, _extends$1({}, panelProps, {
        generateConfig: generateConfig2,
        className: classNames(_defineProperty({}, "".concat(prefixCls, "-panel-focused"), !typing)),
        value: selectedValue,
        locale: locale2,
        tabIndex: -1,
        onSelect: function onSelect(date) {
          _onSelect === null || _onSelect === void 0 || _onSelect(date);
          setSelectedValue(date);
        },
        direction,
        onPanelChange: function onPanelChange(viewDate, mode) {
          var onPanelChange2 = props.onPanelChange;
          onLeave(true);
          onPanelChange2 === null || onPanelChange2 === void 0 || onPanelChange2(viewDate, mode);
        }
      })));
      if (panelRender) {
        panelNode = panelRender(panelNode);
      }
      var panel = /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-panel-container"),
        ref: panelDivRef,
        onMouseDown: function onMouseDown2(e2) {
          e2.preventDefault();
        }
      }, panelNode);
      var suffixNode;
      if (suffixIcon) {
        suffixNode = /* @__PURE__ */ reactExports.createElement("span", {
          className: "".concat(prefixCls, "-suffix"),
          onMouseDown: function onMouseDown2(e2) {
            e2.preventDefault();
          }
        }, suffixIcon);
      }
      var mergedClearIcon = getClearIcon(prefixCls, allowClear, clearIcon);
      var clearNode = /* @__PURE__ */ reactExports.createElement("span", {
        onMouseDown: function onMouseDown2(e2) {
          e2.preventDefault();
          e2.stopPropagation();
        },
        onMouseUp: function onMouseUp2(e2) {
          e2.preventDefault();
          e2.stopPropagation();
          triggerChange(null);
          triggerOpen(false);
        },
        className: "".concat(prefixCls, "-clear"),
        role: "button"
      }, mergedClearIcon);
      var mergedAllowClear = !!allowClear && mergedValue && !disabled;
      var mergedInputProps = _objectSpread2(_objectSpread2(_objectSpread2({
        id: id2,
        tabIndex,
        disabled,
        readOnly: inputReadOnly || typeof formatList[0] === "function" || !typing,
        value: hoverValue || text,
        onChange: function onChange2(e2) {
          triggerTextChange(e2.target.value);
        },
        autoFocus,
        placeholder,
        ref: inputRef,
        title: text
      }, inputProps), {}, {
        size: getInputSize(picker, formatList[0], generateConfig2),
        name
      }, pickAttrs(props, {
        aria: true,
        data: true
      })), {}, {
        autoComplete
      });
      var inputNode = inputRender ? inputRender(mergedInputProps) : /* @__PURE__ */ reactExports.createElement("input", mergedInputProps);
      var onContextSelect = function onContextSelect2(date, type) {
        if (type === "submit" || type !== "key" && !needConfirmButton) {
          triggerChange(date);
          triggerOpen(false);
        }
      };
      var popupPlacement = direction === "rtl" ? "bottomRight" : "bottomLeft";
      return /* @__PURE__ */ reactExports.createElement(PanelContext.Provider, {
        value: {
          operationRef,
          hideHeader: picker === "time",
          onSelect: onContextSelect,
          open: mergedOpen,
          defaultOpenValue,
          onDateMouseEnter: onEnter,
          onDateMouseLeave: onLeave
        }
      }, /* @__PURE__ */ reactExports.createElement(PickerTrigger, {
        visible: mergedOpen,
        popupElement: panel,
        popupStyle,
        prefixCls,
        dropdownClassName,
        dropdownAlign,
        getPopupContainer,
        transitionName,
        popupPlacement,
        direction
      }, /* @__PURE__ */ reactExports.createElement("div", {
        ref: containerRef,
        className: classNames(prefixCls, className, (_classNames2 = {}, _defineProperty(_classNames2, "".concat(prefixCls, "-disabled"), disabled), _defineProperty(_classNames2, "".concat(prefixCls, "-focused"), focused), _defineProperty(_classNames2, "".concat(prefixCls, "-rtl"), direction === "rtl"), _classNames2)),
        style: style2,
        onMouseDown,
        onMouseUp,
        onMouseEnter,
        onMouseLeave,
        onContextMenu,
        onClick: onInternalClick
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames("".concat(prefixCls, "-input"), _defineProperty({}, "".concat(prefixCls, "-input-placeholder"), !!hoverValue)),
        ref: inputDivRef
      }, inputNode, suffixNode, mergedAllowClear && clearNode))));
    }
    var Picker = /* @__PURE__ */ function(_React$Component) {
      _inherits(Picker2, _React$Component);
      var _super = _createSuper(Picker2);
      function Picker2() {
        var _this;
        _classCallCheck(this, Picker2);
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "pickerRef", /* @__PURE__ */ reactExports.createRef());
        _defineProperty(_assertThisInitialized(_this), "focus", function() {
          if (_this.pickerRef.current) {
            _this.pickerRef.current.focus();
          }
        });
        _defineProperty(_assertThisInitialized(_this), "blur", function() {
          if (_this.pickerRef.current) {
            _this.pickerRef.current.blur();
          }
        });
        return _this;
      }
      _createClass(Picker2, [{
        key: "render",
        value: function render2() {
          return /* @__PURE__ */ reactExports.createElement(InnerPicker, _extends$1({}, this.props, {
            pickerRef: this.pickerRef
          }));
        }
      }]);
      return Picker2;
    }(reactExports.Component);
    function useRangeDisabled(_ref, firstTimeOpen) {
      var picker = _ref.picker, locale2 = _ref.locale, selectedValue = _ref.selectedValue, disabledDate = _ref.disabledDate, disabled = _ref.disabled, generateConfig2 = _ref.generateConfig;
      var startDate = getValue(selectedValue, 0);
      var endDate = getValue(selectedValue, 1);
      function weekFirstDate(date) {
        return generateConfig2.locale.getWeekFirstDate(locale2.locale, date);
      }
      function monthNumber(date) {
        var year = generateConfig2.getYear(date);
        var month = generateConfig2.getMonth(date);
        return year * 100 + month;
      }
      function quarterNumber(date) {
        var year = generateConfig2.getYear(date);
        var quarter = getQuarter(generateConfig2, date);
        return year * 10 + quarter;
      }
      var disabledStartDate = reactExports.useCallback(function(date) {
        if (disabled[0] || disabledDate && disabledDate(date)) {
          return true;
        }
        if (disabled[1] && endDate) {
          return !isSameDate(generateConfig2, date, endDate) && generateConfig2.isAfter(date, endDate);
        }
        if (!firstTimeOpen && endDate) {
          switch (picker) {
            case "quarter":
              return quarterNumber(date) > quarterNumber(endDate);
            case "month":
              return monthNumber(date) > monthNumber(endDate);
            case "week":
              return weekFirstDate(date) > weekFirstDate(endDate);
            default:
              return !isSameDate(generateConfig2, date, endDate) && generateConfig2.isAfter(date, endDate);
          }
        }
        return false;
      }, [disabledDate, disabled[1], endDate, firstTimeOpen]);
      var disabledEndDate = reactExports.useCallback(function(date) {
        if (disabled[1] || disabledDate && disabledDate(date)) {
          return true;
        }
        if (disabled[0] && startDate) {
          return !isSameDate(generateConfig2, date, endDate) && generateConfig2.isAfter(startDate, date);
        }
        if (!firstTimeOpen && startDate) {
          switch (picker) {
            case "quarter":
              return quarterNumber(date) < quarterNumber(startDate);
            case "month":
              return monthNumber(date) < monthNumber(startDate);
            case "week":
              return weekFirstDate(date) < weekFirstDate(startDate);
            default:
              return !isSameDate(generateConfig2, date, startDate) && generateConfig2.isAfter(startDate, date);
          }
        }
        return false;
      }, [disabledDate, disabled[0], startDate, firstTimeOpen]);
      return [disabledStartDate, disabledEndDate];
    }
    function useRangeOpen(defaultOpen, open, activePickerIndex, changeOnBlur, needConfirmButton, startInputRef, endInputRef, startSelectedValue, endSelectedValue, disabled, onOpenChange) {
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), firstTimeOpen = _React$useState2[0], setFirstTimeOpen = _React$useState2[1];
      var _useMergedState = useMergedState(defaultOpen || false, {
        value: open
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), afferentOpen = _useMergedState2[0], setAfferentOpen = _useMergedState2[1];
      var _useMergedState3 = useMergedState(defaultOpen || false, {
        value: open,
        onChange: function onChange(nextOpen) {
          onOpenChange === null || onOpenChange === void 0 || onOpenChange(nextOpen);
        }
      }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), mergedOpen = _useMergedState4[0], setMergedOpen = _useMergedState4[1];
      var _useMergedState5 = useMergedState(0, {
        value: activePickerIndex
      }), _useMergedState6 = _slicedToArray(_useMergedState5, 2), mergedActivePickerIndex = _useMergedState6[0], setMergedActivePickerIndex = _useMergedState6[1];
      var _React$useState3 = reactExports.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), nextActiveIndex = _React$useState4[0], setNextActiveIndex = _React$useState4[1];
      reactExports.useEffect(function() {
        if (mergedOpen) {
          setFirstTimeOpen(true);
        }
      }, [mergedOpen]);
      var queryNextIndex = function queryNextIndex2(index2) {
        return index2 === 0 ? 1 : 0;
      };
      var triggerOpen = useEvent(function(nextOpen, index2, source) {
        if (index2 === false) {
          setMergedOpen(nextOpen);
        } else if (nextOpen) {
          setMergedActivePickerIndex(index2);
          setMergedOpen(nextOpen);
          var nextIndex = queryNextIndex(index2);
          if (!mergedOpen || // Also set next index if next is empty
          ![startSelectedValue, endSelectedValue][nextIndex]) {
            setNextActiveIndex(nextIndex);
          } else {
            setFirstTimeOpen(false);
            if (nextActiveIndex !== null) {
              setNextActiveIndex(null);
            }
          }
        } else if (source === "confirm" || source === "blur" && changeOnBlur) {
          var customNextActiveIndex = afferentOpen && !needConfirmButton ? queryNextIndex(index2) : nextActiveIndex;
          if (customNextActiveIndex !== null) {
            setFirstTimeOpen(false);
            setMergedActivePickerIndex(customNextActiveIndex);
          }
          setNextActiveIndex(null);
          if (customNextActiveIndex !== null && !disabled[customNextActiveIndex]) {
            wrapperRaf(function() {
              var _ref$current;
              var ref = [startInputRef, endInputRef][customNextActiveIndex];
              (_ref$current = ref.current) === null || _ref$current === void 0 || _ref$current.focus();
            });
          } else {
            setMergedOpen(false);
          }
        } else {
          setMergedOpen(false);
          setAfferentOpen(false);
        }
      });
      return [mergedOpen, mergedActivePickerIndex, firstTimeOpen, triggerOpen];
    }
    function getStartEndDistance(startDate, endDate, picker, generateConfig2) {
      var startNext = getClosingViewDate(startDate, picker, generateConfig2, 1);
      function getDistance(compareFunc) {
        if (compareFunc(startDate, endDate)) {
          return "same";
        }
        if (compareFunc(startNext, endDate)) {
          return "closing";
        }
        return "far";
      }
      switch (picker) {
        case "year":
          return getDistance(function(start, end) {
            return isSameDecade(generateConfig2, start, end);
          });
        case "quarter":
        case "month":
          return getDistance(function(start, end) {
            return isSameYear(generateConfig2, start, end);
          });
        default:
          return getDistance(function(start, end) {
            return isSameMonth(generateConfig2, start, end);
          });
      }
    }
    function getRangeViewDate(values, index2, picker, generateConfig2) {
      var startDate = getValue(values, 0);
      var endDate = getValue(values, 1);
      if (index2 === 0) {
        return startDate;
      }
      if (startDate && endDate) {
        var distance = getStartEndDistance(startDate, endDate, picker, generateConfig2);
        switch (distance) {
          case "same":
            return startDate;
          case "closing":
            return startDate;
          default:
            return getClosingViewDate(endDate, picker, generateConfig2, -1);
        }
      }
      return startDate;
    }
    function useRangeViewDates(_ref) {
      var values = _ref.values, picker = _ref.picker, defaultDates = _ref.defaultDates, generateConfig2 = _ref.generateConfig;
      var _React$useState = reactExports.useState(function() {
        return [getValue(defaultDates, 0), getValue(defaultDates, 1)];
      }), _React$useState2 = _slicedToArray(_React$useState, 2), defaultViewDates = _React$useState2[0], setDefaultViewDates = _React$useState2[1];
      var _React$useState3 = reactExports.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), viewDates = _React$useState4[0], setInternalViewDates = _React$useState4[1];
      var startDate = getValue(values, 0);
      var endDate = getValue(values, 1);
      function getViewDate(index2) {
        if (defaultViewDates[index2]) {
          return defaultViewDates[index2];
        }
        return getValue(viewDates, index2) || getRangeViewDate(values, index2, picker, generateConfig2) || startDate || endDate || generateConfig2.getNow();
      }
      function setViewDate(viewDate, index2) {
        if (viewDate) {
          var newViewDates = updateValues(viewDates, viewDate, index2);
          setDefaultViewDates(
            // Should always be an array
            updateValues(defaultViewDates, null, index2) || [null, null]
          );
          var anotherIndex = (index2 + 1) % 2;
          if (!getValue(values, anotherIndex)) {
            newViewDates = updateValues(newViewDates, viewDate, anotherIndex);
          }
          setInternalViewDates(newViewDates);
        } else if (startDate || endDate) {
          setInternalViewDates(null);
        }
      }
      return [getViewDate, setViewDate];
    }
    function reorderValues(values, generateConfig2) {
      if (values && values[0] && values[1] && generateConfig2.isAfter(values[0], values[1])) {
        return [values[1], values[0]];
      }
      return values;
    }
    function canValueTrigger(value, index2, disabled, allowEmpty) {
      if (value) {
        return true;
      }
      if (allowEmpty && allowEmpty[index2]) {
        return true;
      }
      if (disabled[(index2 + 1) % 2]) {
        return true;
      }
      return false;
    }
    function InnerRangePicker(props) {
      var _classNames2, _classNames3, _classNames4;
      var _ref = props, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-picker" : _ref$prefixCls, id2 = _ref.id, style2 = _ref.style, className = _ref.className, popupStyle = _ref.popupStyle, dropdownClassName = _ref.dropdownClassName, transitionName = _ref.transitionName, dropdownAlign = _ref.dropdownAlign, getPopupContainer = _ref.getPopupContainer, generateConfig2 = _ref.generateConfig, locale2 = _ref.locale, placeholder = _ref.placeholder, autoFocus = _ref.autoFocus, disabled = _ref.disabled, format2 = _ref.format, _ref$picker = _ref.picker, picker = _ref$picker === void 0 ? "date" : _ref$picker, showTime = _ref.showTime, use12Hours = _ref.use12Hours, _ref$separator = _ref.separator, separator = _ref$separator === void 0 ? "~" : _ref$separator, value = _ref.value, defaultValue = _ref.defaultValue, defaultPickerValue = _ref.defaultPickerValue, open = _ref.open, defaultOpen = _ref.defaultOpen, disabledDate = _ref.disabledDate, _disabledTime = _ref.disabledTime, dateRender = _ref.dateRender, monthCellRender = _ref.monthCellRender, cellRender = _ref.cellRender, panelRender = _ref.panelRender, presets = _ref.presets, ranges = _ref.ranges, allowEmpty = _ref.allowEmpty, allowClear = _ref.allowClear, suffixIcon = _ref.suffixIcon, clearIcon = _ref.clearIcon, pickerRef = _ref.pickerRef, inputReadOnly = _ref.inputReadOnly, mode = _ref.mode, renderExtraFooter = _ref.renderExtraFooter, onChange = _ref.onChange, onOpenChange = _ref.onOpenChange, onPanelChange = _ref.onPanelChange, onCalendarChange = _ref.onCalendarChange, _onFocus = _ref.onFocus, onBlur = _ref.onBlur, onMouseDown = _ref.onMouseDown, onMouseUp = _ref.onMouseUp, onMouseEnter = _ref.onMouseEnter, onMouseLeave = _ref.onMouseLeave, onClick = _ref.onClick, _onOk = _ref.onOk, _onKeyDown = _ref.onKeyDown, components = _ref.components, order = _ref.order, direction = _ref.direction, activePickerIndex = _ref.activePickerIndex, _ref$autoComplete = _ref.autoComplete, autoComplete = _ref$autoComplete === void 0 ? "off" : _ref$autoComplete, changeOnBlur = _ref.changeOnBlur;
      var needConfirmButton = picker === "date" && !!showTime || picker === "time";
      var containerRef = reactExports.useRef(null);
      var panelDivRef = reactExports.useRef(null);
      var startInputDivRef = reactExports.useRef(null);
      var endInputDivRef = reactExports.useRef(null);
      var separatorRef = reactExports.useRef(null);
      var startInputRef = reactExports.useRef(null);
      var endInputRef = reactExports.useRef(null);
      var arrowRef = reactExports.useRef(null);
      var formatList = toArray$6(getDefaultFormat(format2, picker, showTime, use12Hours));
      var formatDateValue = function formatDateValue2(values, index2) {
        return values && values[index2] ? formatValue(values[index2], {
          generateConfig: generateConfig2,
          locale: locale2,
          format: formatList[0]
        }) : "";
      };
      var operationRef = reactExports.useRef(null);
      var mergedDisabled = reactExports.useMemo(function() {
        if (Array.isArray(disabled)) {
          return disabled;
        }
        return [disabled || false, disabled || false];
      }, [disabled]);
      var _useMergedState = useMergedState(null, {
        value,
        defaultValue,
        postState: function postState(values) {
          return picker === "time" && !order ? values : reorderValues(values, generateConfig2);
        }
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedValue = _useMergedState2[0], setInnerValue = _useMergedState2[1];
      var _useRangeViewDates = useRangeViewDates({
        values: mergedValue,
        picker,
        defaultDates: defaultPickerValue,
        generateConfig: generateConfig2
      }), _useRangeViewDates2 = _slicedToArray(_useRangeViewDates, 2), getViewDate = _useRangeViewDates2[0], setViewDate = _useRangeViewDates2[1];
      var _useMergedState3 = useMergedState(mergedValue, {
        postState: function postState(values) {
          var postValues = values;
          if (mergedDisabled[0] && mergedDisabled[1]) {
            return postValues;
          }
          for (var i = 0; i < 2; i += 1) {
            if (mergedDisabled[i] && !postValues && !getValue(postValues, i) && !getValue(allowEmpty, i)) {
              postValues = updateValues(postValues, generateConfig2.getNow(), i);
            }
          }
          return postValues;
        }
      }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), selectedValue = _useMergedState4[0], setSelectedValue = _useMergedState4[1];
      var _useMergedState5 = useMergedState([picker, picker], {
        value: mode
      }), _useMergedState6 = _slicedToArray(_useMergedState5, 2), mergedModes = _useMergedState6[0], setInnerModes = _useMergedState6[1];
      reactExports.useEffect(function() {
        setInnerModes([picker, picker]);
      }, [picker]);
      var triggerModesChange = function triggerModesChange2(modes, values) {
        setInnerModes(modes);
        if (onPanelChange) {
          onPanelChange(values, modes);
        }
      };
      var _useRangeOpen = useRangeOpen(defaultOpen, open, activePickerIndex, changeOnBlur, needConfirmButton, startInputRef, endInputRef, getValue(selectedValue, 0), getValue(selectedValue, 1), mergedDisabled, onOpenChange), _useRangeOpen2 = _slicedToArray(_useRangeOpen, 4), mergedOpen = _useRangeOpen2[0], mergedActivePickerIndex = _useRangeOpen2[1], firstTimeOpen = _useRangeOpen2[2], _triggerOpen = _useRangeOpen2[3];
      var startOpen = mergedOpen && mergedActivePickerIndex === 0;
      var endOpen = mergedOpen && mergedActivePickerIndex === 1;
      var _useRangeDisabled = useRangeDisabled({
        picker,
        selectedValue,
        locale: locale2,
        disabled: mergedDisabled,
        disabledDate,
        generateConfig: generateConfig2
      }, !mergedOpen || firstTimeOpen), _useRangeDisabled2 = _slicedToArray(_useRangeDisabled, 2), disabledStartDate = _useRangeDisabled2[0], disabledEndDate = _useRangeDisabled2[1];
      var _useState = reactExports.useState(0), _useState2 = _slicedToArray(_useState, 2), popupMinWidth = _useState2[0], setPopupMinWidth = _useState2[1];
      reactExports.useEffect(function() {
        if (!mergedOpen && containerRef.current) {
          setPopupMinWidth(containerRef.current.offsetWidth);
        }
      }, [mergedOpen]);
      function triggerOpenAndFocus(index2) {
        _triggerOpen(true, index2, "open");
        wrapperRaf(function() {
          var _inputRef$current;
          var inputRef = [startInputRef, endInputRef][index2];
          (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.focus();
        }, 0);
      }
      function triggerChange(newValue, sourceIndex, triggerCalendarChangeOnly) {
        var values = newValue;
        var startValue = getValue(values, 0);
        var endValue = getValue(values, 1);
        if (startValue && endValue && generateConfig2.isAfter(startValue, endValue)) {
          if (
            // WeekPicker only compare week
            picker === "week" && !isSameWeek(generateConfig2, locale2.locale, startValue, endValue) || // QuotaPicker only compare week
            picker === "quarter" && !isSameQuarter(generateConfig2, startValue, endValue) || // Other non-TimePicker compare date
            picker !== "week" && picker !== "quarter" && picker !== "time" && !isSameDate(generateConfig2, startValue, endValue)
          ) {
            if (sourceIndex === 0) {
              values = [startValue, null];
              endValue = null;
            } else {
              startValue = null;
              values = [null, endValue];
            }
          } else if (picker !== "time" || order !== false) {
            values = reorderValues(values, generateConfig2);
          }
        }
        setSelectedValue(values);
        var startStr2 = formatDateValue(values, 0);
        var endStr2 = formatDateValue(values, 1);
        if (onCalendarChange) {
          var _info = {
            range: sourceIndex === 0 ? "start" : "end"
          };
          onCalendarChange(values, [startStr2, endStr2], _info);
        }
        if (!triggerCalendarChangeOnly) {
          var canStartValueTrigger = canValueTrigger(startValue, 0, mergedDisabled, allowEmpty);
          var canEndValueTrigger = canValueTrigger(endValue, 1, mergedDisabled, allowEmpty);
          var canTrigger = values === null || canStartValueTrigger && canEndValueTrigger;
          if (canTrigger) {
            setInnerValue(values);
            if (onChange && (!isEqual(generateConfig2, getValue(mergedValue, 0), startValue) || !isEqual(generateConfig2, getValue(mergedValue, 1), endValue))) {
              onChange(values, [startStr2, endStr2]);
            }
          }
        }
      }
      var forwardKeyDown = function forwardKeyDown2(e2) {
        if (mergedOpen && operationRef.current && operationRef.current.onKeyDown) {
          return operationRef.current.onKeyDown(e2);
        }
        {
          warningOnce(false, "Picker not correct forward KeyDown operation. Please help to fire issue about this.");
          return false;
        }
      };
      var sharedTextHooksProps = {
        formatList,
        generateConfig: generateConfig2,
        locale: locale2
      };
      var _useValueTexts = useValueTexts(getValue(selectedValue, 0), sharedTextHooksProps), _useValueTexts2 = _slicedToArray(_useValueTexts, 2), startValueTexts = _useValueTexts2[0], firstStartValueText = _useValueTexts2[1];
      var _useValueTexts3 = useValueTexts(getValue(selectedValue, 1), sharedTextHooksProps), _useValueTexts4 = _slicedToArray(_useValueTexts3, 2), endValueTexts = _useValueTexts4[0], firstEndValueText = _useValueTexts4[1];
      var _onTextChange = function onTextChange(newText, index2) {
        var inputDate = parseValue(newText, {
          locale: locale2,
          formatList,
          generateConfig: generateConfig2
        });
        var disabledFunc = index2 === 0 ? disabledStartDate : disabledEndDate;
        if (inputDate && !disabledFunc(inputDate)) {
          setSelectedValue(updateValues(selectedValue, inputDate, index2));
          setViewDate(inputDate, index2);
        }
      };
      var _useTextValueMapping = useTextValueMapping({
        valueTexts: startValueTexts,
        onTextChange: function onTextChange(newText) {
          return _onTextChange(newText, 0);
        }
      }), _useTextValueMapping2 = _slicedToArray(_useTextValueMapping, 3), startText = _useTextValueMapping2[0], triggerStartTextChange = _useTextValueMapping2[1], resetStartText = _useTextValueMapping2[2];
      var _useTextValueMapping3 = useTextValueMapping({
        valueTexts: endValueTexts,
        onTextChange: function onTextChange(newText) {
          return _onTextChange(newText, 1);
        }
      }), _useTextValueMapping4 = _slicedToArray(_useTextValueMapping3, 3), endText = _useTextValueMapping4[0], triggerEndTextChange = _useTextValueMapping4[1], resetEndText = _useTextValueMapping4[2];
      var _useState3 = reactExports.useState(null), _useState4 = _slicedToArray(_useState3, 2), rangeHoverValue = _useState4[0], setRangeHoverValue = _useState4[1];
      var _useState5 = reactExports.useState(null), _useState6 = _slicedToArray(_useState5, 2), hoverRangedValue = _useState6[0], setHoverRangedValue = _useState6[1];
      var _useHoverValue = useHoverValue(startText, {
        formatList,
        generateConfig: generateConfig2,
        locale: locale2
      }), _useHoverValue2 = _slicedToArray(_useHoverValue, 3), startHoverValue = _useHoverValue2[0], onStartEnter = _useHoverValue2[1], onStartLeave = _useHoverValue2[2];
      var _useHoverValue3 = useHoverValue(endText, {
        formatList,
        generateConfig: generateConfig2,
        locale: locale2
      }), _useHoverValue4 = _slicedToArray(_useHoverValue3, 3), endHoverValue = _useHoverValue4[0], onEndEnter = _useHoverValue4[1], onEndLeave = _useHoverValue4[2];
      var onDateMouseEnter = function onDateMouseEnter2(date) {
        setHoverRangedValue(updateValues(selectedValue, date, mergedActivePickerIndex));
        if (mergedActivePickerIndex === 0) {
          onStartEnter(date);
        } else {
          onEndEnter(date);
        }
      };
      var onDateMouseLeave = function onDateMouseLeave2() {
        setHoverRangedValue(updateValues(selectedValue, null, mergedActivePickerIndex));
        if (mergedActivePickerIndex === 0) {
          onStartLeave();
        } else {
          onEndLeave();
        }
      };
      var _React$useState = reactExports.useState(mergedOpen), _React$useState2 = _slicedToArray(_React$useState, 2), delayOpen = _React$useState2[0], setDelayOpen = _React$useState2[1];
      reactExports.useEffect(function() {
        setDelayOpen(mergedOpen);
      }, [mergedOpen]);
      var onInternalBlur = function onInternalBlur2(e2) {
        if (delayOpen) {
          if (needConfirmButton) {
            var needTriggerIndex = mergedActivePickerIndex ? 0 : 1;
            var selectedIndexValue = getValue(selectedValue, needTriggerIndex);
            if (selectedIndexValue) {
              triggerChange(selectedValue, needTriggerIndex, true);
            }
          } else if (changeOnBlur) {
            var _selectedIndexValue = getValue(selectedValue, mergedActivePickerIndex);
            if (_selectedIndexValue) {
              triggerChange(selectedValue, mergedActivePickerIndex);
            }
          }
        }
        return onBlur === null || onBlur === void 0 ? void 0 : onBlur(e2);
      };
      var getSharedInputHookProps = function getSharedInputHookProps2(index2, resetText) {
        return {
          blurToCancel: !changeOnBlur && needConfirmButton,
          changeOnBlur,
          forwardKeyDown,
          onBlur: onInternalBlur,
          isClickOutside: function isClickOutside(target) {
            var elementsRefs = [startInputDivRef.current, endInputDivRef.current, containerRef.current];
            return !elementsContains([].concat(_toConsumableArray(needConfirmButton ? [elementsRefs[mergedActivePickerIndex]] : elementsRefs), [panelDivRef.current]), target);
          },
          onFocus: function onFocus(e2) {
            if (_onFocus) {
              _onFocus(e2);
            }
          },
          triggerOpen: function triggerOpen(newOpen) {
            if (newOpen) {
              _triggerOpen(newOpen, index2, "open");
            } else {
              _triggerOpen(
                newOpen,
                // Close directly if no selected value provided
                getValue(selectedValue, index2) ? index2 : false,
                "blur"
              );
            }
          },
          onSubmit: function onSubmit() {
            if (
              // When user typing disabledDate with keyboard and enter, this value will be empty
              !selectedValue || // Normal disabled check
              disabledDate && disabledDate(selectedValue[index2])
            ) {
              return false;
            }
            triggerChange(selectedValue, index2);
            resetText();
            _triggerOpen(false, mergedActivePickerIndex, "confirm");
          },
          onCancel: function onCancel() {
            _triggerOpen(false, index2, "cancel");
            setSelectedValue(mergedValue);
            resetText();
          }
        };
      };
      var sharedPickerInput = {
        onKeyDown: function onKeyDown2(e2, preventDefault) {
          _onKeyDown === null || _onKeyDown === void 0 || _onKeyDown(e2, preventDefault);
        }
      };
      var _usePickerInput = usePickerInput(_objectSpread2(_objectSpread2({}, getSharedInputHookProps(0, resetStartText)), {}, {
        open: startOpen,
        value: startText
      }, sharedPickerInput)), _usePickerInput2 = _slicedToArray(_usePickerInput, 2), startInputProps = _usePickerInput2[0], _usePickerInput2$ = _usePickerInput2[1], startFocused = _usePickerInput2$.focused, startTyping = _usePickerInput2$.typing;
      var _usePickerInput3 = usePickerInput(_objectSpread2(_objectSpread2({}, getSharedInputHookProps(1, resetEndText)), {}, {
        open: endOpen,
        value: endText
      }, sharedPickerInput)), _usePickerInput4 = _slicedToArray(_usePickerInput3, 2), endInputProps = _usePickerInput4[0], _usePickerInput4$ = _usePickerInput4[1], endFocused = _usePickerInput4$.focused, endTyping = _usePickerInput4$.typing;
      var onPickerClick = function onPickerClick2(e2) {
        if (onClick) {
          onClick(e2);
        }
        if (!mergedOpen && !startInputRef.current.contains(e2.target) && !endInputRef.current.contains(e2.target)) {
          if (!mergedDisabled[0]) {
            triggerOpenAndFocus(0);
          } else if (!mergedDisabled[1]) {
            triggerOpenAndFocus(1);
          }
        }
      };
      var onPickerMouseDown = function onPickerMouseDown2(e2) {
        if (onMouseDown) {
          onMouseDown(e2);
        }
        if (mergedOpen && (startFocused || endFocused) && !startInputRef.current.contains(e2.target) && !endInputRef.current.contains(e2.target)) {
          e2.preventDefault();
        }
      };
      var startStr = mergedValue && mergedValue[0] ? formatValue(mergedValue[0], {
        locale: locale2,
        format: "YYYYMMDDHHmmss",
        generateConfig: generateConfig2
      }) : "";
      var endStr = mergedValue && mergedValue[1] ? formatValue(mergedValue[1], {
        locale: locale2,
        format: "YYYYMMDDHHmmss",
        generateConfig: generateConfig2
      }) : "";
      reactExports.useEffect(function() {
        if (!mergedOpen) {
          setSelectedValue(mergedValue);
          if (!startValueTexts.length || startValueTexts[0] === "") {
            triggerStartTextChange("");
          } else if (firstStartValueText !== startText) {
            resetStartText();
          }
          if (!endValueTexts.length || endValueTexts[0] === "") {
            triggerEndTextChange("");
          } else if (firstEndValueText !== endText) {
            resetEndText();
          }
        }
      }, [mergedOpen, startValueTexts, endValueTexts]);
      reactExports.useEffect(function() {
        setSelectedValue(mergedValue);
      }, [startStr, endStr]);
      var mergedCellRender = useCellRender$1({
        cellRender,
        monthCellRender,
        dateRender
      });
      var panelDateRender = reactExports.useMemo(function() {
        if (!mergedCellRender)
          return void 0;
        return function(date, info) {
          return mergedCellRender(date, _objectSpread2(_objectSpread2({}, info), {}, {
            range: mergedActivePickerIndex ? "end" : "start"
          }));
        };
      }, [mergedActivePickerIndex, mergedCellRender]);
      if (pickerRef) {
        pickerRef.current = {
          focus: function focus() {
            if (startInputRef.current) {
              startInputRef.current.focus();
            }
          },
          blur: function blur() {
            if (startInputRef.current) {
              startInputRef.current.blur();
            }
            if (endInputRef.current) {
              endInputRef.current.blur();
            }
          }
        };
      }
      var presetList = usePresets(presets, ranges);
      function renderPanel() {
        var panelPosition = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        var panelProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var panelHoverRangedValue = null;
        if (mergedOpen && hoverRangedValue && hoverRangedValue[0] && hoverRangedValue[1] && generateConfig2.isAfter(hoverRangedValue[1], hoverRangedValue[0])) {
          panelHoverRangedValue = hoverRangedValue;
        }
        var panelShowTime = showTime;
        if (showTime && _typeof(showTime) === "object" && showTime.defaultValue) {
          var timeDefaultValues = showTime.defaultValue;
          panelShowTime = _objectSpread2(_objectSpread2({}, showTime), {}, {
            defaultValue: getValue(timeDefaultValues, mergedActivePickerIndex) || void 0
          });
        }
        return /* @__PURE__ */ reactExports.createElement(RangeContext.Provider, {
          value: {
            inRange: true,
            panelPosition,
            rangedValue: rangeHoverValue || selectedValue,
            hoverRangedValue: panelHoverRangedValue
          }
        }, /* @__PURE__ */ reactExports.createElement(PickerPanel, _extends$1({}, props, panelProps, {
          cellRender: panelDateRender,
          showTime: panelShowTime,
          mode: mergedModes[mergedActivePickerIndex],
          generateConfig: generateConfig2,
          style: void 0,
          direction,
          disabledDate: mergedActivePickerIndex === 0 ? disabledStartDate : disabledEndDate,
          disabledTime: function disabledTime(date) {
            if (_disabledTime) {
              return _disabledTime(date, mergedActivePickerIndex === 0 ? "start" : "end");
            }
            return false;
          },
          className: classNames(_defineProperty({}, "".concat(prefixCls, "-panel-focused"), mergedActivePickerIndex === 0 ? !startTyping : !endTyping)),
          value: getValue(selectedValue, mergedActivePickerIndex),
          locale: locale2,
          tabIndex: -1,
          onPanelChange: function onPanelChange2(date, newMode) {
            if (mergedActivePickerIndex === 0) {
              onStartLeave(true);
            }
            if (mergedActivePickerIndex === 1) {
              onEndLeave(true);
            }
            triggerModesChange(updateValues(mergedModes, newMode, mergedActivePickerIndex), updateValues(selectedValue, date, mergedActivePickerIndex));
            var viewDate = date;
            if (panelPosition === "right" && mergedModes[mergedActivePickerIndex] === newMode) {
              viewDate = getClosingViewDate(viewDate, newMode, generateConfig2, -1);
            }
            setViewDate(viewDate, mergedActivePickerIndex);
          },
          onOk: null,
          onSelect: void 0,
          onChange: void 0,
          defaultValue: mergedActivePickerIndex === 0 ? getValue(selectedValue, 1) : getValue(selectedValue, 0)
          // defaultPickerValue={undefined}
        })));
      }
      var arrowLeft = 0;
      var panelLeft = 0;
      if (mergedActivePickerIndex && startInputDivRef.current && separatorRef.current && panelDivRef.current && arrowRef.current) {
        arrowLeft = startInputDivRef.current.offsetWidth + separatorRef.current.offsetWidth;
        var arrowMarginLeft = arrowRef.current.offsetLeft > arrowLeft ? arrowRef.current.offsetLeft - arrowLeft : arrowRef.current.offsetLeft;
        var panelWidth = panelDivRef.current.offsetWidth;
        var arrowWidth = arrowRef.current.offsetWidth;
        if (panelWidth && arrowWidth && arrowLeft > panelWidth - arrowWidth - (direction === "rtl" ? 0 : arrowMarginLeft)) {
          panelLeft = arrowLeft;
        }
      }
      var arrowPositionStyle = direction === "rtl" ? {
        right: arrowLeft
      } : {
        left: arrowLeft
      };
      function renderPanels() {
        var panels;
        var extraNode = getExtraFooter(prefixCls, mergedModes[mergedActivePickerIndex], renderExtraFooter);
        var rangesNode = getRanges({
          prefixCls,
          components,
          needConfirmButton,
          okDisabled: !getValue(selectedValue, mergedActivePickerIndex) || disabledDate && disabledDate(selectedValue[mergedActivePickerIndex]),
          locale: locale2,
          // rangeList,
          onOk: function onOk() {
            var selectedIndexValue = getValue(selectedValue, mergedActivePickerIndex);
            if (selectedIndexValue) {
              triggerChange(selectedValue, mergedActivePickerIndex);
              _onOk === null || _onOk === void 0 || _onOk(selectedValue);
              _triggerOpen(false, mergedActivePickerIndex, "confirm");
            }
          }
        });
        if (picker !== "time" && !showTime) {
          var viewDate = getViewDate(mergedActivePickerIndex);
          var nextViewDate = getClosingViewDate(viewDate, picker, generateConfig2);
          var currentMode = mergedModes[mergedActivePickerIndex];
          var showDoublePanel = currentMode === picker;
          var leftPanel = renderPanel(showDoublePanel ? "left" : false, {
            pickerValue: viewDate,
            onPickerValueChange: function onPickerValueChange(newViewDate) {
              setViewDate(newViewDate, mergedActivePickerIndex);
            }
          });
          var rightPanel = renderPanel("right", {
            pickerValue: nextViewDate,
            onPickerValueChange: function onPickerValueChange(newViewDate) {
              setViewDate(getClosingViewDate(newViewDate, picker, generateConfig2, -1), mergedActivePickerIndex);
            }
          });
          if (direction === "rtl") {
            panels = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, rightPanel, showDoublePanel && leftPanel);
          } else {
            panels = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, leftPanel, showDoublePanel && rightPanel);
          }
        } else {
          panels = renderPanel();
        }
        var mergedNodes = /* @__PURE__ */ reactExports.createElement("div", {
          className: "".concat(prefixCls, "-panel-layout")
        }, /* @__PURE__ */ reactExports.createElement(PresetPanel, {
          prefixCls,
          presets: presetList,
          onClick: function onClick2(nextValue) {
            triggerChange(nextValue, null);
            _triggerOpen(false, mergedActivePickerIndex, "preset");
          },
          onHover: function onHover(hoverValue) {
            setRangeHoverValue(hoverValue);
          }
        }), /* @__PURE__ */ reactExports.createElement("div", null, /* @__PURE__ */ reactExports.createElement("div", {
          className: "".concat(prefixCls, "-panels")
        }, panels), (extraNode || rangesNode) && /* @__PURE__ */ reactExports.createElement("div", {
          className: "".concat(prefixCls, "-footer")
        }, extraNode, rangesNode)));
        if (panelRender) {
          mergedNodes = panelRender(mergedNodes);
        }
        return /* @__PURE__ */ reactExports.createElement("div", {
          className: "".concat(prefixCls, "-panel-container"),
          style: {
            marginLeft: panelLeft
          },
          ref: panelDivRef,
          onMouseDown: function onMouseDown2(e2) {
            e2.preventDefault();
          }
        }, mergedNodes);
      }
      var rangePanel = /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames("".concat(prefixCls, "-range-wrapper"), "".concat(prefixCls, "-").concat(picker, "-range-wrapper")),
        style: {
          minWidth: popupMinWidth
        }
      }, /* @__PURE__ */ reactExports.createElement("div", {
        ref: arrowRef,
        className: "".concat(prefixCls, "-range-arrow"),
        style: arrowPositionStyle
      }), renderPanels());
      var suffixNode;
      if (suffixIcon) {
        suffixNode = /* @__PURE__ */ reactExports.createElement("span", {
          className: "".concat(prefixCls, "-suffix"),
          onMouseDown: function onMouseDown2(e2) {
            e2.preventDefault();
          }
        }, suffixIcon);
      }
      var mergedClearIcon = getClearIcon(prefixCls, allowClear, clearIcon);
      var clearNode = /* @__PURE__ */ reactExports.createElement("span", {
        onMouseDown: function onMouseDown2(e2) {
          e2.preventDefault();
          e2.stopPropagation();
        },
        onMouseUp: function onMouseUp2(e2) {
          e2.preventDefault();
          e2.stopPropagation();
          var values = mergedValue;
          if (!mergedDisabled[0]) {
            values = updateValues(values, null, 0);
          }
          if (!mergedDisabled[1]) {
            values = updateValues(values, null, 1);
          }
          triggerChange(values, null);
          _triggerOpen(false, mergedActivePickerIndex, "clear");
        },
        className: "".concat(prefixCls, "-clear"),
        role: "button"
      }, mergedClearIcon);
      var mergedAllowClear = allowClear && (getValue(mergedValue, 0) && !mergedDisabled[0] || getValue(mergedValue, 1) && !mergedDisabled[1]);
      var inputSharedProps = {
        size: getInputSize(picker, formatList[0], generateConfig2)
      };
      var activeBarLeft = 0;
      var activeBarWidth = 0;
      if (startInputDivRef.current && endInputDivRef.current && separatorRef.current) {
        if (mergedActivePickerIndex === 0) {
          activeBarWidth = startInputDivRef.current.offsetWidth;
        } else {
          activeBarLeft = arrowLeft;
          activeBarWidth = endInputDivRef.current.offsetWidth;
        }
      }
      var activeBarPositionStyle = direction === "rtl" ? {
        right: activeBarLeft
      } : {
        left: activeBarLeft
      };
      var onContextSelect = function onContextSelect2(date, type) {
        var values = updateValues(selectedValue, date, mergedActivePickerIndex);
        if (type === "submit" || type !== "key" && !needConfirmButton) {
          triggerChange(values, mergedActivePickerIndex);
          if (mergedActivePickerIndex === 0) {
            onStartLeave();
          } else {
            onEndLeave();
          }
          var nextActivePickerIndex = mergedActivePickerIndex === 0 ? 1 : 0;
          if (mergedDisabled[nextActivePickerIndex]) {
            _triggerOpen(false, false, "confirm");
          } else {
            _triggerOpen(false, mergedActivePickerIndex, "confirm");
          }
        } else {
          setSelectedValue(values);
        }
      };
      return /* @__PURE__ */ reactExports.createElement(PanelContext.Provider, {
        value: {
          operationRef,
          hideHeader: picker === "time",
          onDateMouseEnter,
          onDateMouseLeave,
          hideRanges: true,
          onSelect: onContextSelect,
          open: mergedOpen
        }
      }, /* @__PURE__ */ reactExports.createElement(PickerTrigger, {
        visible: mergedOpen,
        popupElement: rangePanel,
        popupStyle,
        prefixCls,
        dropdownClassName,
        dropdownAlign,
        getPopupContainer,
        transitionName,
        range: true,
        direction
      }, /* @__PURE__ */ reactExports.createElement("div", _extends$1({
        ref: containerRef,
        className: classNames(prefixCls, "".concat(prefixCls, "-range"), className, (_classNames2 = {}, _defineProperty(_classNames2, "".concat(prefixCls, "-disabled"), mergedDisabled[0] && mergedDisabled[1]), _defineProperty(_classNames2, "".concat(prefixCls, "-focused"), mergedActivePickerIndex === 0 ? startFocused : endFocused), _defineProperty(_classNames2, "".concat(prefixCls, "-rtl"), direction === "rtl"), _classNames2)),
        style: style2,
        onClick: onPickerClick,
        onMouseEnter,
        onMouseLeave,
        onMouseDown: onPickerMouseDown,
        onMouseUp
      }, pickAttrs(props, {
        aria: true,
        data: true
      })), /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames("".concat(prefixCls, "-input"), (_classNames3 = {}, _defineProperty(_classNames3, "".concat(prefixCls, "-input-active"), mergedActivePickerIndex === 0), _defineProperty(_classNames3, "".concat(prefixCls, "-input-placeholder"), !!startHoverValue), _classNames3)),
        ref: startInputDivRef
      }, /* @__PURE__ */ reactExports.createElement("input", _extends$1({
        id: id2,
        disabled: mergedDisabled[0],
        readOnly: inputReadOnly || typeof formatList[0] === "function" || !startTyping,
        value: startHoverValue || startText,
        onChange: function onChange2(e2) {
          triggerStartTextChange(e2.target.value);
        },
        autoFocus,
        placeholder: getValue(placeholder, 0) || "",
        ref: startInputRef
      }, startInputProps, inputSharedProps, {
        autoComplete
      }))), /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-range-separator"),
        ref: separatorRef
      }, separator), /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames("".concat(prefixCls, "-input"), (_classNames4 = {}, _defineProperty(_classNames4, "".concat(prefixCls, "-input-active"), mergedActivePickerIndex === 1), _defineProperty(_classNames4, "".concat(prefixCls, "-input-placeholder"), !!endHoverValue), _classNames4)),
        ref: endInputDivRef
      }, /* @__PURE__ */ reactExports.createElement("input", _extends$1({
        disabled: mergedDisabled[1],
        readOnly: inputReadOnly || typeof formatList[0] === "function" || !endTyping,
        value: endHoverValue || endText,
        onChange: function onChange2(e2) {
          triggerEndTextChange(e2.target.value);
        },
        placeholder: getValue(placeholder, 1) || "",
        ref: endInputRef
      }, endInputProps, inputSharedProps, {
        autoComplete
      }))), /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-active-bar"),
        style: _objectSpread2(_objectSpread2({}, activeBarPositionStyle), {}, {
          width: activeBarWidth,
          position: "absolute"
        })
      }), suffixNode, mergedAllowClear && clearNode)));
    }
    var RangePicker = /* @__PURE__ */ function(_React$Component) {
      _inherits(RangePicker2, _React$Component);
      var _super = _createSuper(RangePicker2);
      function RangePicker2() {
        var _this;
        _classCallCheck(this, RangePicker2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "pickerRef", /* @__PURE__ */ reactExports.createRef());
        _defineProperty(_assertThisInitialized(_this), "focus", function() {
          if (_this.pickerRef.current) {
            _this.pickerRef.current.focus();
          }
        });
        _defineProperty(_assertThisInitialized(_this), "blur", function() {
          if (_this.pickerRef.current) {
            _this.pickerRef.current.blur();
          }
        });
        return _this;
      }
      _createClass(RangePicker2, [{
        key: "render",
        value: function render2() {
          return /* @__PURE__ */ reactExports.createElement(InnerRangePicker, _extends$1({}, this.props, {
            pickerRef: this.pickerRef
          }));
        }
      }]);
      return RangePicker2;
    }(reactExports.Component);
    const RadioGroupContext = /* @__PURE__ */ reactExports.createContext(null);
    const RadioGroupContextProvider = RadioGroupContext.Provider;
    const RadioOptionTypeContext = /* @__PURE__ */ reactExports.createContext(null);
    const RadioOptionTypeContextProvider = RadioOptionTypeContext.Provider;
    var _excluded$g = ["prefixCls", "className", "style", "checked", "disabled", "defaultChecked", "type", "title", "onChange"];
    var Checkbox$3 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var _classNames;
      var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-checkbox" : _props$prefixCls, className = props.className, style2 = props.style, checked = props.checked, disabled = props.disabled, _props$defaultChecked = props.defaultChecked, defaultChecked = _props$defaultChecked === void 0 ? false : _props$defaultChecked, _props$type = props.type, type = _props$type === void 0 ? "checkbox" : _props$type, title = props.title, onChange = props.onChange, inputProps = _objectWithoutProperties(props, _excluded$g);
      var inputRef = reactExports.useRef(null);
      var _useMergedState = useMergedState(defaultChecked, {
        value: checked
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), rawValue = _useMergedState2[0], setRawValue = _useMergedState2[1];
      reactExports.useImperativeHandle(ref, function() {
        return {
          focus: function focus() {
            var _inputRef$current;
            (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.focus();
          },
          blur: function blur() {
            var _inputRef$current2;
            (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.blur();
          },
          input: inputRef.current
        };
      });
      var classString = classNames(prefixCls, className, (_classNames = {}, _defineProperty(_classNames, "".concat(prefixCls, "-checked"), rawValue), _defineProperty(_classNames, "".concat(prefixCls, "-disabled"), disabled), _classNames));
      var handleChange = function handleChange2(e2) {
        if (disabled) {
          return;
        }
        if (!("checked" in props)) {
          setRawValue(e2.target.checked);
        }
        onChange === null || onChange === void 0 ? void 0 : onChange({
          target: _objectSpread2(_objectSpread2({}, props), {}, {
            type,
            checked: e2.target.checked
          }),
          stopPropagation: function stopPropagation() {
            e2.stopPropagation();
          },
          preventDefault: function preventDefault() {
            e2.preventDefault();
          },
          nativeEvent: e2.nativeEvent
        });
      };
      return /* @__PURE__ */ reactExports.createElement("span", {
        className: classString,
        title,
        style: style2
      }, /* @__PURE__ */ reactExports.createElement("input", _extends$1({}, inputProps, {
        className: "".concat(prefixCls, "-input"),
        ref: inputRef,
        onChange: handleChange,
        disabled,
        checked: !!rawValue,
        type
      })), /* @__PURE__ */ reactExports.createElement("span", {
        className: "".concat(prefixCls, "-inner")
      }));
    });
    const getGroupRadioStyle = (token2) => {
      const {
        componentCls,
        antCls
      } = token2;
      const groupPrefixCls = `${componentCls}-group`;
      return {
        [groupPrefixCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
          display: "inline-block",
          fontSize: 0,
          // RTL
          [`&${groupPrefixCls}-rtl`]: {
            direction: "rtl"
          },
          [`${antCls}-badge ${antCls}-badge-count`]: {
            zIndex: 1
          },
          [`> ${antCls}-badge:not(:first-child) > ${antCls}-button-wrapper`]: {
            borderInlineStart: "none"
          }
        })
      };
    };
    const getRadioBasicStyle = (token2) => {
      const {
        componentCls,
        wrapperMarginInlineEnd,
        colorPrimary,
        radioSize,
        motionDurationSlow,
        motionDurationMid,
        motionEaseInOutCirc,
        colorBgContainer,
        colorBorder,
        lineWidth,
        colorBgContainerDisabled,
        colorTextDisabled,
        paddingXS,
        dotColorDisabled,
        lineType,
        radioColor,
        radioBgColor,
        calc
      } = token2;
      const radioInnerPrefixCls = `${componentCls}-inner`;
      const dotPadding = 4;
      const radioDotDisabledSize = calc(radioSize).sub(calc(dotPadding).mul(2));
      const radioSizeCalc = calc(1).mul(radioSize).equal();
      return {
        [`${componentCls}-wrapper`]: Object.assign(Object.assign({}, resetComponent(token2)), {
          display: "inline-flex",
          alignItems: "baseline",
          marginInlineStart: 0,
          marginInlineEnd: wrapperMarginInlineEnd,
          cursor: "pointer",
          // RTL
          [`&${componentCls}-wrapper-rtl`]: {
            direction: "rtl"
          },
          "&-disabled": {
            cursor: "not-allowed",
            color: token2.colorTextDisabled
          },
          "&::after": {
            display: "inline-block",
            width: 0,
            overflow: "hidden",
            content: '"\\a0"'
          },
          // hashId 在 wrapper 上，只能铺平
          [`${componentCls}-checked::after`]: {
            position: "absolute",
            insetBlockStart: 0,
            insetInlineStart: 0,
            width: "100%",
            height: "100%",
            border: `${unit$1(lineWidth)} ${lineType} ${colorPrimary}`,
            borderRadius: "50%",
            visibility: "hidden",
            content: '""'
          },
          [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
            position: "relative",
            display: "inline-block",
            outline: "none",
            cursor: "pointer",
            alignSelf: "center",
            borderRadius: "50%"
          }),
          [`${componentCls}-wrapper:hover &,
        &:hover ${radioInnerPrefixCls}`]: {
            borderColor: colorPrimary
          },
          [`${componentCls}-input:focus-visible + ${radioInnerPrefixCls}`]: Object.assign({}, genFocusOutline(token2)),
          [`${componentCls}:hover::after, ${componentCls}-wrapper:hover &::after`]: {
            visibility: "visible"
          },
          [`${componentCls}-inner`]: {
            "&::after": {
              boxSizing: "border-box",
              position: "absolute",
              insetBlockStart: "50%",
              insetInlineStart: "50%",
              display: "block",
              width: radioSizeCalc,
              height: radioSizeCalc,
              marginBlockStart: calc(1).mul(radioSize).div(-2).equal(),
              marginInlineStart: calc(1).mul(radioSize).div(-2).equal(),
              backgroundColor: radioColor,
              borderBlockStart: 0,
              borderInlineStart: 0,
              borderRadius: radioSizeCalc,
              transform: "scale(0)",
              opacity: 0,
              transition: `all ${motionDurationSlow} ${motionEaseInOutCirc}`,
              content: '""'
            },
            boxSizing: "border-box",
            position: "relative",
            insetBlockStart: 0,
            insetInlineStart: 0,
            display: "block",
            width: radioSizeCalc,
            height: radioSizeCalc,
            backgroundColor: colorBgContainer,
            borderColor: colorBorder,
            borderStyle: "solid",
            borderWidth: lineWidth,
            borderRadius: "50%",
            transition: `all ${motionDurationMid}`
          },
          [`${componentCls}-input`]: {
            position: "absolute",
            inset: 0,
            zIndex: 1,
            cursor: "pointer",
            opacity: 0
          },
          // 选中状态
          [`${componentCls}-checked`]: {
            [radioInnerPrefixCls]: {
              borderColor: colorPrimary,
              backgroundColor: radioBgColor,
              "&::after": {
                transform: `scale(${token2.calc(token2.dotSize).div(radioSize).equal()})`,
                opacity: 1,
                transition: `all ${motionDurationSlow} ${motionEaseInOutCirc}`
              }
            }
          },
          [`${componentCls}-disabled`]: {
            cursor: "not-allowed",
            [radioInnerPrefixCls]: {
              backgroundColor: colorBgContainerDisabled,
              borderColor: colorBorder,
              cursor: "not-allowed",
              "&::after": {
                backgroundColor: dotColorDisabled
              }
            },
            [`${componentCls}-input`]: {
              cursor: "not-allowed"
            },
            [`${componentCls}-disabled + span`]: {
              color: colorTextDisabled,
              cursor: "not-allowed"
            },
            [`&${componentCls}-checked`]: {
              [radioInnerPrefixCls]: {
                "&::after": {
                  transform: `scale(${calc(radioDotDisabledSize).div(radioSize).equal({
                    unit: false
                  })})`
                }
              }
            }
          },
          [`span${componentCls} + *`]: {
            paddingInlineStart: paddingXS,
            paddingInlineEnd: paddingXS
          }
        })
      };
    };
    const getRadioButtonStyle = (token2) => {
      const {
        buttonColor,
        controlHeight,
        componentCls,
        lineWidth,
        lineType,
        colorBorder,
        motionDurationSlow,
        motionDurationMid,
        buttonPaddingInline,
        fontSize,
        buttonBg,
        fontSizeLG,
        controlHeightLG,
        controlHeightSM,
        paddingXS,
        borderRadius,
        borderRadiusSM,
        borderRadiusLG,
        buttonCheckedBg,
        buttonSolidCheckedColor,
        colorTextDisabled,
        colorBgContainerDisabled,
        buttonCheckedBgDisabled,
        buttonCheckedColorDisabled,
        colorPrimary,
        colorPrimaryHover,
        colorPrimaryActive,
        buttonSolidCheckedBg,
        buttonSolidCheckedHoverBg,
        buttonSolidCheckedActiveBg,
        calc
      } = token2;
      return {
        [`${componentCls}-button-wrapper`]: {
          position: "relative",
          display: "inline-block",
          height: controlHeight,
          margin: 0,
          paddingInline: buttonPaddingInline,
          paddingBlock: 0,
          color: buttonColor,
          fontSize,
          lineHeight: unit$1(calc(controlHeight).sub(calc(lineWidth).mul(2)).equal()),
          background: buttonBg,
          border: `${unit$1(lineWidth)} ${lineType} ${colorBorder}`,
          // strange align fix for chrome but works
          // https://gw.alipayobjects.com/zos/rmsportal/VFTfKXJuogBAXcvfAUWJ.gif
          borderBlockStartWidth: calc(lineWidth).add(0.02).equal(),
          borderInlineStartWidth: 0,
          borderInlineEndWidth: lineWidth,
          cursor: "pointer",
          transition: [`color ${motionDurationMid}`, `background ${motionDurationMid}`, `box-shadow ${motionDurationMid}`].join(","),
          a: {
            color: buttonColor
          },
          [`> ${componentCls}-button`]: {
            position: "absolute",
            insetBlockStart: 0,
            insetInlineStart: 0,
            zIndex: -1,
            width: "100%",
            height: "100%"
          },
          "&:not(:first-child)": {
            "&::before": {
              position: "absolute",
              insetBlockStart: calc(lineWidth).mul(-1).equal(),
              insetInlineStart: calc(lineWidth).mul(-1).equal(),
              display: "block",
              boxSizing: "content-box",
              width: 1,
              height: "100%",
              paddingBlock: lineWidth,
              paddingInline: 0,
              backgroundColor: colorBorder,
              transition: `background-color ${motionDurationSlow}`,
              content: '""'
            }
          },
          "&:first-child": {
            borderInlineStart: `${unit$1(lineWidth)} ${lineType} ${colorBorder}`,
            borderStartStartRadius: borderRadius,
            borderEndStartRadius: borderRadius
          },
          "&:last-child": {
            borderStartEndRadius: borderRadius,
            borderEndEndRadius: borderRadius
          },
          "&:first-child:last-child": {
            borderRadius
          },
          [`${componentCls}-group-large &`]: {
            height: controlHeightLG,
            fontSize: fontSizeLG,
            lineHeight: unit$1(calc(controlHeightLG).sub(calc(lineWidth).mul(2)).equal()),
            "&:first-child": {
              borderStartStartRadius: borderRadiusLG,
              borderEndStartRadius: borderRadiusLG
            },
            "&:last-child": {
              borderStartEndRadius: borderRadiusLG,
              borderEndEndRadius: borderRadiusLG
            }
          },
          [`${componentCls}-group-small &`]: {
            height: controlHeightSM,
            paddingInline: calc(paddingXS).sub(lineWidth).equal(),
            paddingBlock: 0,
            lineHeight: unit$1(calc(controlHeightSM).sub(calc(lineWidth).mul(2)).equal()),
            "&:first-child": {
              borderStartStartRadius: borderRadiusSM,
              borderEndStartRadius: borderRadiusSM
            },
            "&:last-child": {
              borderStartEndRadius: borderRadiusSM,
              borderEndEndRadius: borderRadiusSM
            }
          },
          "&:hover": {
            position: "relative",
            color: colorPrimary
          },
          "&:has(:focus-visible)": Object.assign({}, genFocusOutline(token2)),
          [`${componentCls}-inner, input[type='checkbox'], input[type='radio']`]: {
            width: 0,
            height: 0,
            opacity: 0,
            pointerEvents: "none"
          },
          [`&-checked:not(${componentCls}-button-wrapper-disabled)`]: {
            zIndex: 1,
            color: colorPrimary,
            background: buttonCheckedBg,
            borderColor: colorPrimary,
            "&::before": {
              backgroundColor: colorPrimary
            },
            "&:first-child": {
              borderColor: colorPrimary
            },
            "&:hover": {
              color: colorPrimaryHover,
              borderColor: colorPrimaryHover,
              "&::before": {
                backgroundColor: colorPrimaryHover
              }
            },
            "&:active": {
              color: colorPrimaryActive,
              borderColor: colorPrimaryActive,
              "&::before": {
                backgroundColor: colorPrimaryActive
              }
            }
          },
          [`${componentCls}-group-solid &-checked:not(${componentCls}-button-wrapper-disabled)`]: {
            color: buttonSolidCheckedColor,
            background: buttonSolidCheckedBg,
            borderColor: buttonSolidCheckedBg,
            "&:hover": {
              color: buttonSolidCheckedColor,
              background: buttonSolidCheckedHoverBg,
              borderColor: buttonSolidCheckedHoverBg
            },
            "&:active": {
              color: buttonSolidCheckedColor,
              background: buttonSolidCheckedActiveBg,
              borderColor: buttonSolidCheckedActiveBg
            }
          },
          "&-disabled": {
            color: colorTextDisabled,
            backgroundColor: colorBgContainerDisabled,
            borderColor: colorBorder,
            cursor: "not-allowed",
            "&:first-child, &:hover": {
              color: colorTextDisabled,
              backgroundColor: colorBgContainerDisabled,
              borderColor: colorBorder
            }
          },
          [`&-disabled${componentCls}-button-wrapper-checked`]: {
            color: buttonCheckedColorDisabled,
            backgroundColor: buttonCheckedBgDisabled,
            borderColor: colorBorder,
            boxShadow: "none"
          }
        }
      };
    };
    const prepareComponentToken$9 = (token2) => {
      const {
        wireframe,
        padding,
        marginXS,
        lineWidth,
        fontSizeLG,
        colorText,
        colorBgContainer,
        colorTextDisabled,
        controlItemBgActiveDisabled,
        colorTextLightSolid,
        colorPrimary,
        colorPrimaryHover,
        colorPrimaryActive,
        colorWhite
      } = token2;
      const dotPadding = 4;
      const radioSize = fontSizeLG;
      const radioDotSize = wireframe ? radioSize - dotPadding * 2 : radioSize - (dotPadding + lineWidth) * 2;
      return {
        // Radio
        radioSize,
        dotSize: radioDotSize,
        dotColorDisabled: colorTextDisabled,
        // Radio buttons
        buttonSolidCheckedColor: colorTextLightSolid,
        buttonSolidCheckedBg: colorPrimary,
        buttonSolidCheckedHoverBg: colorPrimaryHover,
        buttonSolidCheckedActiveBg: colorPrimaryActive,
        buttonBg: colorBgContainer,
        buttonCheckedBg: colorBgContainer,
        buttonColor: colorText,
        buttonCheckedBgDisabled: controlItemBgActiveDisabled,
        buttonCheckedColorDisabled: colorTextDisabled,
        buttonPaddingInline: padding - lineWidth,
        wrapperMarginInlineEnd: marginXS,
        // internal
        radioColor: wireframe ? colorPrimary : colorWhite,
        radioBgColor: wireframe ? colorBgContainer : colorPrimary
      };
    };
    const useStyle$b = genStyleHooks("Radio", (token2) => {
      const {
        controlOutline,
        controlOutlineWidth
      } = token2;
      const radioFocusShadow = `0 0 0 ${unit$1(controlOutlineWidth)} ${controlOutline}`;
      const radioButtonFocusShadow = radioFocusShadow;
      const radioToken = merge$1(token2, {
        radioFocusShadow,
        radioButtonFocusShadow
      });
      return [getGroupRadioStyle(radioToken), getRadioBasicStyle(radioToken), getRadioButtonStyle(radioToken)];
    }, prepareComponentToken$9, {
      unitless: {
        radioSize: true,
        dotSize: true
      }
    });
    var __rest$o = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const InternalRadio = (props, ref) => {
      var _a, _b;
      const groupContext = reactExports.useContext(RadioGroupContext);
      const radioOptionTypeContext = reactExports.useContext(RadioOptionTypeContext);
      const {
        getPrefixCls,
        direction,
        radio
      } = reactExports.useContext(ConfigContext);
      const innerRef = reactExports.useRef(null);
      const mergedRef = composeRef(ref, innerRef);
      const {
        isFormItemInput
      } = reactExports.useContext(FormItemInputContext);
      const onChange = (e2) => {
        var _a2, _b2;
        (_a2 = props.onChange) === null || _a2 === void 0 ? void 0 : _a2.call(props, e2);
        (_b2 = groupContext === null || groupContext === void 0 ? void 0 : groupContext.onChange) === null || _b2 === void 0 ? void 0 : _b2.call(groupContext, e2);
      };
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        children,
        style: style2
      } = props, restProps = __rest$o(props, ["prefixCls", "className", "rootClassName", "children", "style"]);
      const radioPrefixCls = getPrefixCls("radio", customizePrefixCls);
      const isButtonType = ((groupContext === null || groupContext === void 0 ? void 0 : groupContext.optionType) || radioOptionTypeContext) === "button";
      const prefixCls = isButtonType ? `${radioPrefixCls}-button` : radioPrefixCls;
      const rootCls = useCSSVarCls$1(radioPrefixCls);
      const [wrapCSSVar, hashId] = useStyle$b(radioPrefixCls, rootCls);
      const radioProps = Object.assign({}, restProps);
      const disabled = reactExports.useContext(DisabledContext$1);
      if (groupContext) {
        radioProps.name = groupContext.name;
        radioProps.onChange = onChange;
        radioProps.checked = props.value === groupContext.value;
        radioProps.disabled = (_a = radioProps.disabled) !== null && _a !== void 0 ? _a : groupContext.disabled;
      }
      radioProps.disabled = (_b = radioProps.disabled) !== null && _b !== void 0 ? _b : disabled;
      const wrapperClassString = classNames(`${prefixCls}-wrapper`, {
        [`${prefixCls}-wrapper-checked`]: radioProps.checked,
        [`${prefixCls}-wrapper-disabled`]: radioProps.disabled,
        [`${prefixCls}-wrapper-rtl`]: direction === "rtl",
        [`${prefixCls}-wrapper-in-form-item`]: isFormItemInput
      }, radio === null || radio === void 0 ? void 0 : radio.className, className, rootClassName, hashId, rootCls);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(Wave$1, {
        component: "Radio",
        disabled: radioProps.disabled
      }, /* @__PURE__ */ reactExports.createElement("label", {
        className: wrapperClassString,
        style: Object.assign(Object.assign({}, radio === null || radio === void 0 ? void 0 : radio.style), style2),
        onMouseEnter: props.onMouseEnter,
        onMouseLeave: props.onMouseLeave
      }, /* @__PURE__ */ reactExports.createElement(Checkbox$3, Object.assign({}, radioProps, {
        className: classNames(radioProps.className, !isButtonType && TARGET_CLS),
        type: "radio",
        prefixCls,
        ref: mergedRef
      })), children !== void 0 ? /* @__PURE__ */ reactExports.createElement("span", null, children) : null)));
    };
    const Radio$2 = /* @__PURE__ */ reactExports.forwardRef(InternalRadio);
    const InternalRadio$1 = Radio$2;
    const RadioGroup = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const [value, setValue] = useMergedState(props.defaultValue, {
        value: props.value
      });
      const onRadioChange = (ev) => {
        const lastValue = value;
        const val = ev.target.value;
        if (!("value" in props)) {
          setValue(val);
        }
        const {
          onChange
        } = props;
        if (onChange && val !== lastValue) {
          onChange(ev);
        }
      };
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        options,
        buttonStyle = "outline",
        disabled,
        children,
        size: customizeSize,
        style: style2,
        id: id2,
        onMouseEnter,
        onMouseLeave,
        onFocus,
        onBlur
      } = props;
      const prefixCls = getPrefixCls("radio", customizePrefixCls);
      const groupPrefixCls = `${prefixCls}-group`;
      const rootCls = useCSSVarCls$1(prefixCls);
      const [wrapCSSVar, hashId] = useStyle$b(prefixCls, rootCls);
      let childrenToRender = children;
      if (options && options.length > 0) {
        childrenToRender = options.map((option) => {
          if (typeof option === "string" || typeof option === "number") {
            return /* @__PURE__ */ reactExports.createElement(InternalRadio$1, {
              key: option.toString(),
              prefixCls,
              disabled,
              value: option,
              checked: value === option
            }, option);
          }
          return /* @__PURE__ */ reactExports.createElement(InternalRadio$1, {
            key: `radio-group-value-options-${option.value}`,
            prefixCls,
            disabled: option.disabled || disabled,
            value: option.value,
            checked: value === option.value,
            title: option.title,
            style: option.style,
            id: option.id,
            required: option.required
          }, option.label);
        });
      }
      const mergedSize = useSize$1(customizeSize);
      const classString = classNames(groupPrefixCls, `${groupPrefixCls}-${buttonStyle}`, {
        [`${groupPrefixCls}-${mergedSize}`]: mergedSize,
        [`${groupPrefixCls}-rtl`]: direction === "rtl"
      }, className, rootClassName, hashId, rootCls);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("div", Object.assign({}, pickAttrs(props, {
        aria: true,
        data: true
      }), {
        className: classString,
        style: style2,
        onMouseEnter,
        onMouseLeave,
        onFocus,
        onBlur,
        id: id2,
        ref
      }), /* @__PURE__ */ reactExports.createElement(RadioGroupContextProvider, {
        value: {
          onChange: onRadioChange,
          value,
          disabled: props.disabled,
          name: props.name,
          optionType: props.optionType
        }
      }, childrenToRender)));
    });
    const Group$3 = /* @__PURE__ */ reactExports.memo(RadioGroup);
    var __rest$n = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const RadioButton = (props, ref) => {
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const {
        prefixCls: customizePrefixCls
      } = props, radioProps = __rest$n(props, ["prefixCls"]);
      const prefixCls = getPrefixCls("radio", customizePrefixCls);
      return /* @__PURE__ */ reactExports.createElement(RadioOptionTypeContextProvider, {
        value: "button"
      }, /* @__PURE__ */ reactExports.createElement(InternalRadio$1, Object.assign({
        prefixCls
      }, radioProps, {
        type: "radio",
        ref
      })));
    };
    const Button = /* @__PURE__ */ reactExports.forwardRef(RadioButton);
    const Radio = InternalRadio$1;
    Radio.Button = Button;
    Radio.Group = Group$3;
    Radio.__ANT_RADIO = true;
    const Radio$1 = Radio;
    const YearSelectOffset = 10;
    const YearSelectTotal = 20;
    function YearSelect(props) {
      const {
        fullscreen,
        validRange,
        generateConfig: generateConfig2,
        locale: locale2,
        prefixCls,
        value,
        onChange,
        divRef
      } = props;
      const year = generateConfig2.getYear(value || generateConfig2.getNow());
      let start = year - YearSelectOffset;
      let end = start + YearSelectTotal;
      if (validRange) {
        start = generateConfig2.getYear(validRange[0]);
        end = generateConfig2.getYear(validRange[1]) + 1;
      }
      const suffix = locale2 && locale2.year === "年" ? "年" : "";
      const options = [];
      for (let index2 = start; index2 < end; index2++) {
        options.push({
          label: `${index2}${suffix}`,
          value: index2
        });
      }
      return /* @__PURE__ */ reactExports.createElement(Select$1, {
        size: fullscreen ? void 0 : "small",
        options,
        value: year,
        className: `${prefixCls}-year-select`,
        onChange: (numYear) => {
          let newDate = generateConfig2.setYear(value, numYear);
          if (validRange) {
            const [startDate, endDate] = validRange;
            const newYear = generateConfig2.getYear(newDate);
            const newMonth = generateConfig2.getMonth(newDate);
            if (newYear === generateConfig2.getYear(endDate) && newMonth > generateConfig2.getMonth(endDate)) {
              newDate = generateConfig2.setMonth(newDate, generateConfig2.getMonth(endDate));
            }
            if (newYear === generateConfig2.getYear(startDate) && newMonth < generateConfig2.getMonth(startDate)) {
              newDate = generateConfig2.setMonth(newDate, generateConfig2.getMonth(startDate));
            }
          }
          onChange(newDate);
        },
        getPopupContainer: () => divRef.current
      });
    }
    function MonthSelect(props) {
      const {
        prefixCls,
        fullscreen,
        validRange,
        value,
        generateConfig: generateConfig2,
        locale: locale2,
        onChange,
        divRef
      } = props;
      const month = generateConfig2.getMonth(value || generateConfig2.getNow());
      let start = 0;
      let end = 11;
      if (validRange) {
        const [rangeStart, rangeEnd] = validRange;
        const currentYear = generateConfig2.getYear(value);
        if (generateConfig2.getYear(rangeEnd) === currentYear) {
          end = generateConfig2.getMonth(rangeEnd);
        }
        if (generateConfig2.getYear(rangeStart) === currentYear) {
          start = generateConfig2.getMonth(rangeStart);
        }
      }
      const months2 = locale2.shortMonths || generateConfig2.locale.getShortMonths(locale2.locale);
      const options = [];
      for (let index2 = start; index2 <= end; index2 += 1) {
        options.push({
          label: months2[index2],
          value: index2
        });
      }
      return /* @__PURE__ */ reactExports.createElement(Select$1, {
        size: fullscreen ? void 0 : "small",
        className: `${prefixCls}-month-select`,
        value: month,
        options,
        onChange: (newMonth) => {
          onChange(generateConfig2.setMonth(value, newMonth));
        },
        getPopupContainer: () => divRef.current
      });
    }
    function ModeSwitch(props) {
      const {
        prefixCls,
        locale: locale2,
        mode,
        fullscreen,
        onModeChange
      } = props;
      return /* @__PURE__ */ reactExports.createElement(Group$3, {
        onChange: (_ref) => {
          let {
            target: {
              value
            }
          } = _ref;
          onModeChange(value);
        },
        value: mode,
        size: fullscreen ? void 0 : "small",
        className: `${prefixCls}-mode-switch`
      }, /* @__PURE__ */ reactExports.createElement(Button, {
        value: "month"
      }, locale2.month), /* @__PURE__ */ reactExports.createElement(Button, {
        value: "year"
      }, locale2.year));
    }
    function CalendarHeader(props) {
      const {
        prefixCls,
        fullscreen,
        mode,
        onChange,
        onModeChange
      } = props;
      const divRef = reactExports.useRef(null);
      const formItemInputContext = reactExports.useContext(FormItemInputContext);
      const mergedFormItemInputContext = reactExports.useMemo(() => Object.assign(Object.assign({}, formItemInputContext), {
        isFormItemInput: false
      }), [formItemInputContext]);
      const sharedProps = Object.assign(Object.assign({}, props), {
        fullscreen,
        divRef
      });
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-header`,
        ref: divRef
      }, /* @__PURE__ */ reactExports.createElement(FormItemInputContext.Provider, {
        value: mergedFormItemInputContext
      }, /* @__PURE__ */ reactExports.createElement(YearSelect, Object.assign({}, sharedProps, {
        onChange: (v2) => {
          onChange(v2, "year");
        }
      })), mode === "month" && /* @__PURE__ */ reactExports.createElement(MonthSelect, Object.assign({}, sharedProps, {
        onChange: (v2) => {
          onChange(v2, "month");
        }
      }))), /* @__PURE__ */ reactExports.createElement(ModeSwitch, Object.assign({}, sharedProps, {
        onModeChange
      })));
    }
    const genPlaceholderStyle = (color) => ({
      // Firefox
      "&::-moz-placeholder": {
        opacity: 1
      },
      "&::placeholder": {
        color,
        userSelect: "none"
        // https://github.com/ant-design/ant-design/pull/32639
      },
      "&:placeholder-shown": {
        textOverflow: "ellipsis"
      }
    });
    const genHoverStyle = (token2) => ({
      borderColor: token2.hoverBorderColor,
      backgroundColor: token2.hoverBg
    });
    const genActiveStyle = (token2) => ({
      borderColor: token2.activeBorderColor,
      boxShadow: token2.activeShadow,
      outline: 0,
      backgroundColor: token2.activeBg
    });
    const genDisabledStyle = (token2) => ({
      color: token2.colorTextDisabled,
      backgroundColor: token2.colorBgContainerDisabled,
      borderColor: token2.colorBorder,
      boxShadow: "none",
      cursor: "not-allowed",
      opacity: 1,
      "&:hover:not([disabled])": Object.assign({}, genHoverStyle(merge$1(token2, {
        hoverBorderColor: token2.colorBorder,
        hoverBg: token2.colorBgContainerDisabled
      })))
    });
    const genInputLargeStyle = (token2) => {
      const {
        paddingBlockLG,
        fontSizeLG,
        lineHeightLG,
        borderRadiusLG,
        paddingInlineLG
      } = token2;
      return {
        padding: `${unit$1(paddingBlockLG)} ${unit$1(paddingInlineLG)}`,
        fontSize: fontSizeLG,
        lineHeight: lineHeightLG,
        borderRadius: borderRadiusLG
      };
    };
    const genInputSmallStyle = (token2) => ({
      padding: `${unit$1(token2.paddingBlockSM)} ${unit$1(token2.paddingInlineSM)}`,
      borderRadius: token2.borderRadiusSM
    });
    const genStatusStyle = (token2, parentCls) => {
      const {
        componentCls,
        colorError,
        colorWarning,
        errorActiveShadow,
        warningActiveShadow,
        colorErrorBorderHover,
        colorWarningBorderHover
      } = token2;
      return {
        [`&-status-error:not(${parentCls}-disabled):not(${parentCls}-borderless)${parentCls}`]: {
          borderColor: colorError,
          "&:hover": {
            borderColor: colorErrorBorderHover
          },
          "&:focus, &:focus-within": Object.assign({}, genActiveStyle(merge$1(token2, {
            activeBorderColor: colorError,
            activeShadow: errorActiveShadow
          }))),
          [`${componentCls}-prefix, ${componentCls}-suffix`]: {
            color: colorError
          }
        },
        [`&-status-warning:not(${parentCls}-disabled):not(${parentCls}-borderless)${parentCls}`]: {
          borderColor: colorWarning,
          "&:hover": {
            borderColor: colorWarningBorderHover
          },
          "&:focus, &:focus-within": Object.assign({}, genActiveStyle(merge$1(token2, {
            activeBorderColor: colorWarning,
            activeShadow: warningActiveShadow
          }))),
          [`${componentCls}-prefix, ${componentCls}-suffix`]: {
            color: colorWarning
          }
        }
      };
    };
    const genBasicInputStyle = (token2) => Object.assign(Object.assign({
      position: "relative",
      display: "inline-block",
      width: "100%",
      minWidth: 0,
      padding: `${unit$1(token2.paddingBlock)} ${unit$1(token2.paddingInline)}`,
      color: token2.colorText,
      fontSize: token2.fontSize,
      lineHeight: token2.lineHeight,
      backgroundColor: token2.colorBgContainer,
      backgroundImage: "none",
      borderWidth: token2.lineWidth,
      borderStyle: token2.lineType,
      borderColor: token2.colorBorder,
      borderRadius: token2.borderRadius,
      transition: `all ${token2.motionDurationMid}`
    }, genPlaceholderStyle(token2.colorTextPlaceholder)), {
      "&:hover": Object.assign({}, genHoverStyle(token2)),
      "&:focus, &:focus-within": Object.assign({}, genActiveStyle(token2)),
      "&-disabled, &[disabled]": Object.assign({}, genDisabledStyle(token2)),
      "&-borderless": {
        "&, &:hover, &:focus, &-focused, &-disabled, &[disabled]": {
          backgroundColor: "transparent",
          border: "none",
          boxShadow: "none"
        }
      },
      // Reset height for `textarea`s
      "textarea&": {
        maxWidth: "100%",
        // prevent textarea resize from coming out of its container
        height: "auto",
        minHeight: token2.controlHeight,
        lineHeight: token2.lineHeight,
        verticalAlign: "bottom",
        transition: `all ${token2.motionDurationSlow}, height 0s`,
        resize: "vertical"
      },
      // Size
      "&-lg": Object.assign({}, genInputLargeStyle(token2)),
      "&-sm": Object.assign({}, genInputSmallStyle(token2)),
      // RTL
      "&-rtl": {
        direction: "rtl"
      },
      "&-textarea-rtl": {
        direction: "rtl"
      }
    });
    const genInputGroupStyle = (token2) => {
      const {
        componentCls,
        antCls
      } = token2;
      return {
        position: "relative",
        display: "table",
        width: "100%",
        borderCollapse: "separate",
        borderSpacing: 0,
        // Undo padding and float of grid classes
        [`&[class*='col-']`]: {
          paddingInlineEnd: token2.paddingXS,
          "&:last-child": {
            paddingInlineEnd: 0
          }
        },
        // Sizing options
        [`&-lg ${componentCls}, &-lg > ${componentCls}-group-addon`]: Object.assign({}, genInputLargeStyle(token2)),
        [`&-sm ${componentCls}, &-sm > ${componentCls}-group-addon`]: Object.assign({}, genInputSmallStyle(token2)),
        // Fix https://github.com/ant-design/ant-design/issues/5754
        [`&-lg ${antCls}-select-single ${antCls}-select-selector`]: {
          height: token2.controlHeightLG
        },
        [`&-sm ${antCls}-select-single ${antCls}-select-selector`]: {
          height: token2.controlHeightSM
        },
        [`> ${componentCls}`]: {
          display: "table-cell",
          "&:not(:first-child):not(:last-child)": {
            borderRadius: 0
          }
        },
        [`${componentCls}-group`]: {
          [`&-addon, &-wrap`]: {
            display: "table-cell",
            width: 1,
            whiteSpace: "nowrap",
            verticalAlign: "middle",
            "&:not(:first-child):not(:last-child)": {
              borderRadius: 0
            }
          },
          "&-wrap > *": {
            display: "block !important"
          },
          "&-addon": {
            position: "relative",
            padding: `0 ${unit$1(token2.paddingInline)}`,
            color: token2.colorText,
            fontWeight: "normal",
            fontSize: token2.fontSize,
            textAlign: "center",
            backgroundColor: token2.addonBg,
            border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
            borderRadius: token2.borderRadius,
            transition: `all ${token2.motionDurationSlow}`,
            lineHeight: 1,
            // Reset Select's style in addon
            [`${antCls}-select`]: {
              margin: `${unit$1(token2.calc(token2.paddingBlock).add(1).mul(-1).equal())} ${unit$1(token2.calc(token2.paddingInline).mul(-1).equal())}`,
              [`&${antCls}-select-single:not(${antCls}-select-customize-input):not(${antCls}-pagination-size-changer)`]: {
                [`${antCls}-select-selector`]: {
                  backgroundColor: "inherit",
                  border: `${unit$1(token2.lineWidth)} ${token2.lineType} transparent`,
                  boxShadow: "none"
                }
              },
              "&-open, &-focused": {
                [`${antCls}-select-selector`]: {
                  color: token2.colorPrimary
                }
              }
            },
            // https://github.com/ant-design/ant-design/issues/31333
            [`${antCls}-cascader-picker`]: {
              margin: `-9px ${unit$1(token2.calc(token2.paddingInline).mul(-1).equal())}`,
              backgroundColor: "transparent",
              [`${antCls}-cascader-input`]: {
                textAlign: "start",
                border: 0,
                boxShadow: "none"
              }
            }
          },
          "&-addon:first-child": {
            borderInlineEnd: 0
          },
          "&-addon:last-child": {
            borderInlineStart: 0
          }
        },
        [`${componentCls}`]: {
          width: "100%",
          marginBottom: 0,
          textAlign: "inherit",
          "&:focus": {
            zIndex: 1,
            // Fix https://gw.alipayobjects.com/zos/rmsportal/DHNpoqfMXSfrSnlZvhsJ.png
            borderInlineEndWidth: 1
          },
          "&:hover": {
            zIndex: 1,
            borderInlineEndWidth: 1,
            [`${componentCls}-search-with-button &`]: {
              zIndex: 0
            }
          }
        },
        // Reset rounded corners
        [`> ${componentCls}:first-child, ${componentCls}-group-addon:first-child`]: {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0,
          // Reset Select's style in addon
          [`${antCls}-select ${antCls}-select-selector`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        },
        [`> ${componentCls}-affix-wrapper`]: {
          [`&:not(:first-child) ${componentCls}`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          },
          [`&:not(:last-child) ${componentCls}`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        },
        [`> ${componentCls}:last-child, ${componentCls}-group-addon:last-child`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0,
          // Reset Select's style in addon
          [`${antCls}-select ${antCls}-select-selector`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          }
        },
        [`${componentCls}-affix-wrapper`]: {
          "&:not(:last-child)": {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0,
            [`${componentCls}-search &`]: {
              borderStartStartRadius: token2.borderRadius,
              borderEndStartRadius: token2.borderRadius
            }
          },
          [`&:not(:first-child), ${componentCls}-search &:not(:first-child)`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          }
        },
        [`&${componentCls}-group-compact`]: Object.assign(Object.assign({
          display: "block"
        }, clearFix()), {
          [`${componentCls}-group-addon, ${componentCls}-group-wrap, > ${componentCls}`]: {
            "&:not(:first-child):not(:last-child)": {
              borderInlineEndWidth: token2.lineWidth,
              "&:hover": {
                zIndex: 1
              },
              "&:focus": {
                zIndex: 1
              }
            }
          },
          "& > *": {
            display: "inline-block",
            float: "none",
            verticalAlign: "top",
            // https://github.com/ant-design/ant-design-pro/issues/139
            borderRadius: 0
          },
          [`
        & > ${componentCls}-affix-wrapper,
        & > ${componentCls}-number-affix-wrapper,
        & > ${antCls}-picker-range
      `]: {
            display: "inline-flex"
          },
          "& > *:not(:last-child)": {
            marginInlineEnd: token2.calc(token2.lineWidth).mul(-1).equal(),
            borderInlineEndWidth: token2.lineWidth
          },
          // Undo float for .ant-input-group .ant-input
          [`${componentCls}`]: {
            float: "none"
          },
          // reset border for Select, DatePicker, AutoComplete, Cascader, Mention, TimePicker, Input
          [`& > ${antCls}-select > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete ${componentCls},
      & > ${antCls}-cascader-picker ${componentCls},
      & > ${componentCls}-group-wrapper ${componentCls}`]: {
            borderInlineEndWidth: token2.lineWidth,
            borderRadius: 0,
            "&:hover": {
              zIndex: 1
            },
            "&:focus": {
              zIndex: 1
            }
          },
          [`& > ${antCls}-select-focused`]: {
            zIndex: 1
          },
          // update z-index for arrow icon
          [`& > ${antCls}-select > ${antCls}-select-arrow`]: {
            zIndex: 1
            // https://github.com/ant-design/ant-design/issues/20371
          },
          [`& > *:first-child,
      & > ${antCls}-select:first-child > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete:first-child ${componentCls},
      & > ${antCls}-cascader-picker:first-child ${componentCls}`]: {
            borderStartStartRadius: token2.borderRadius,
            borderEndStartRadius: token2.borderRadius
          },
          [`& > *:last-child,
      & > ${antCls}-select:last-child > ${antCls}-select-selector,
      & > ${antCls}-cascader-picker:last-child ${componentCls},
      & > ${antCls}-cascader-picker-focused:last-child ${componentCls}`]: {
            borderInlineEndWidth: token2.lineWidth,
            borderStartEndRadius: token2.borderRadius,
            borderEndEndRadius: token2.borderRadius
          },
          // https://github.com/ant-design/ant-design/issues/12493
          [`& > ${antCls}-select-auto-complete ${componentCls}`]: {
            verticalAlign: "top"
          },
          [`${componentCls}-group-wrapper + ${componentCls}-group-wrapper`]: {
            marginInlineStart: token2.calc(token2.lineWidth).mul(-1).equal(),
            [`${componentCls}-affix-wrapper`]: {
              borderRadius: 0
            }
          },
          [`${componentCls}-group-wrapper:not(:last-child)`]: {
            [`&${componentCls}-search > ${componentCls}-group`]: {
              [`& > ${componentCls}-group-addon > ${componentCls}-search-button`]: {
                borderRadius: 0
              },
              [`& > ${componentCls}`]: {
                borderStartStartRadius: token2.borderRadius,
                borderStartEndRadius: 0,
                borderEndEndRadius: 0,
                borderEndStartRadius: token2.borderRadius
              }
            }
          }
        })
      };
    };
    const genInputStyle = (token2) => {
      const {
        componentCls,
        controlHeightSM,
        lineWidth,
        calc
      } = token2;
      const FIXED_CHROME_COLOR_HEIGHT = 16;
      const colorSmallPadding = calc(controlHeightSM).sub(calc(lineWidth).mul(2)).sub(FIXED_CHROME_COLOR_HEIGHT).div(2).equal();
      return {
        [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genBasicInputStyle(token2)), genStatusStyle(token2, componentCls)), {
          '&[type="color"]': {
            height: token2.controlHeight,
            [`&${componentCls}-lg`]: {
              height: token2.controlHeightLG
            },
            [`&${componentCls}-sm`]: {
              height: controlHeightSM,
              paddingTop: colorSmallPadding,
              paddingBottom: colorSmallPadding
            }
          },
          '&[type="search"]::-webkit-search-cancel-button, &[type="search"]::-webkit-search-decoration': {
            "-webkit-appearance": "none"
          }
        })
      };
    };
    const genAllowClearStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        // ========================= Input =========================
        [`${componentCls}-clear-icon`]: {
          margin: 0,
          color: token2.colorTextQuaternary,
          fontSize: token2.fontSizeIcon,
          verticalAlign: -1,
          // https://github.com/ant-design/ant-design/pull/18151
          // https://codesandbox.io/s/wizardly-sun-u10br
          cursor: "pointer",
          transition: `color ${token2.motionDurationSlow}`,
          "&:hover": {
            color: token2.colorTextTertiary
          },
          "&:active": {
            color: token2.colorText
          },
          "&-hidden": {
            visibility: "hidden"
          },
          "&-has-suffix": {
            margin: `0 ${unit$1(token2.inputAffixPadding)}`
          }
        }
      };
    };
    const genAffixStyle = (token2) => {
      const {
        componentCls,
        inputAffixPadding,
        colorTextDescription,
        motionDurationSlow,
        colorIcon,
        colorIconHover,
        iconCls
      } = token2;
      return {
        [`${componentCls}-affix-wrapper`]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genBasicInputStyle(token2)), {
          display: "inline-flex",
          [`&:not(${componentCls}-affix-wrapper-disabled):hover`]: {
            zIndex: 1,
            [`${componentCls}-search-with-button &`]: {
              zIndex: 0
            }
          },
          "&-focused, &:focus": {
            zIndex: 1
          },
          "&-disabled": {
            [`${componentCls}[disabled]`]: {
              background: "transparent"
            }
          },
          [`> input${componentCls}`]: {
            padding: 0,
            fontSize: "inherit",
            border: "none",
            borderRadius: 0,
            outline: "none",
            "&::-ms-reveal": {
              display: "none"
            },
            "&:focus": {
              boxShadow: "none !important"
            }
          },
          "&::before": {
            display: "inline-block",
            width: 0,
            visibility: "hidden",
            content: '"\\a0"'
          },
          [`${componentCls}`]: {
            "&-prefix, &-suffix": {
              display: "flex",
              flex: "none",
              alignItems: "center",
              "> *:not(:last-child)": {
                marginInlineEnd: token2.paddingXS
              }
            },
            "&-show-count-suffix": {
              color: colorTextDescription
            },
            "&-show-count-has-suffix": {
              marginInlineEnd: token2.paddingXXS
            },
            "&-prefix": {
              marginInlineEnd: inputAffixPadding
            },
            "&-suffix": {
              marginInlineStart: inputAffixPadding
            }
          }
        }), genAllowClearStyle(token2)), {
          // password
          [`${iconCls}${componentCls}-password-icon`]: {
            color: colorIcon,
            cursor: "pointer",
            transition: `all ${motionDurationSlow}`,
            "&:hover": {
              color: colorIconHover
            }
          }
        }), genStatusStyle(token2, `${componentCls}-affix-wrapper`))
      };
    };
    const genGroupStyle = (token2) => {
      const {
        componentCls,
        colorError,
        colorWarning,
        borderRadiusLG,
        borderRadiusSM
      } = token2;
      return {
        [`${componentCls}-group`]: Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genInputGroupStyle(token2)), {
          "&-rtl": {
            direction: "rtl"
          },
          "&-wrapper": {
            display: "inline-block",
            width: "100%",
            textAlign: "start",
            verticalAlign: "top",
            // https://github.com/ant-design/ant-design/issues/6403
            "&-rtl": {
              direction: "rtl"
            },
            // Size
            "&-lg": {
              [`${componentCls}-group-addon`]: {
                borderRadius: borderRadiusLG,
                fontSize: token2.fontSizeLG
              }
            },
            "&-sm": {
              [`${componentCls}-group-addon`]: {
                borderRadius: borderRadiusSM
              }
            },
            // Status
            "&-status-error": {
              [`${componentCls}-group-addon`]: {
                color: colorError,
                borderColor: colorError
              }
            },
            "&-status-warning": {
              [`${componentCls}-group-addon`]: {
                color: colorWarning,
                borderColor: colorWarning
              }
            },
            "&-disabled": {
              [`${componentCls}-group-addon`]: Object.assign({}, genDisabledStyle(token2))
            },
            // Fix the issue of using icons in Space Compact mode
            // https://github.com/ant-design/ant-design/issues/42122
            [`&:not(${componentCls}-compact-first-item):not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: {
              [`${componentCls}, ${componentCls}-group-addon`]: {
                borderRadius: 0
              }
            },
            [`&:not(${componentCls}-compact-last-item)${componentCls}-compact-first-item`]: {
              [`${componentCls}, ${componentCls}-group-addon`]: {
                borderStartEndRadius: 0,
                borderEndEndRadius: 0
              }
            },
            [`&:not(${componentCls}-compact-first-item)${componentCls}-compact-last-item`]: {
              [`${componentCls}, ${componentCls}-group-addon`]: {
                borderStartStartRadius: 0,
                borderEndStartRadius: 0
              }
            }
          }
        })
      };
    };
    const genSearchInputStyle = (token2) => {
      const {
        componentCls,
        antCls
      } = token2;
      const searchPrefixCls = `${componentCls}-search`;
      return {
        [searchPrefixCls]: {
          [`${componentCls}`]: {
            "&:hover, &:focus": {
              borderColor: token2.colorPrimaryHover,
              [`+ ${componentCls}-group-addon ${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
                borderInlineStartColor: token2.colorPrimaryHover
              }
            }
          },
          [`${componentCls}-affix-wrapper`]: {
            borderRadius: 0
          },
          // fix slight height diff in Firefox:
          // https://ant.design/components/auto-complete-cn/#components-auto-complete-demo-certain-category
          [`${componentCls}-lg`]: {
            lineHeight: token2.calc(token2.lineHeightLG).sub(2e-4).equal({
              unit: false
            })
          },
          [`> ${componentCls}-group`]: {
            [`> ${componentCls}-group-addon:last-child`]: {
              insetInlineStart: -1,
              padding: 0,
              border: 0,
              [`${searchPrefixCls}-button`]: {
                paddingTop: 0,
                paddingBottom: 0,
                borderStartStartRadius: 0,
                borderStartEndRadius: token2.borderRadius,
                borderEndEndRadius: token2.borderRadius,
                borderEndStartRadius: 0,
                boxShadow: "none"
              },
              [`${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
                color: token2.colorTextDescription,
                "&:hover": {
                  color: token2.colorPrimaryHover
                },
                "&:active": {
                  color: token2.colorPrimaryActive
                },
                [`&${antCls}-btn-loading::before`]: {
                  insetInlineStart: 0,
                  insetInlineEnd: 0,
                  insetBlockStart: 0,
                  insetBlockEnd: 0
                }
              }
            }
          },
          [`${searchPrefixCls}-button`]: {
            height: token2.controlHeight,
            "&:hover, &:focus": {
              zIndex: 1
            }
          },
          [`&-large ${searchPrefixCls}-button`]: {
            height: token2.controlHeightLG
          },
          [`&-small ${searchPrefixCls}-button`]: {
            height: token2.controlHeightSM
          },
          "&-rtl": {
            direction: "rtl"
          },
          // ===================== Compact Item Customized Styles =====================
          [`&${componentCls}-compact-item`]: {
            [`&:not(${componentCls}-compact-last-item)`]: {
              [`${componentCls}-group-addon`]: {
                [`${componentCls}-search-button`]: {
                  marginInlineEnd: token2.calc(token2.lineWidth).mul(-1).equal(),
                  borderRadius: 0
                }
              }
            },
            [`&:not(${componentCls}-compact-first-item)`]: {
              [`${componentCls},${componentCls}-affix-wrapper`]: {
                borderRadius: 0
              }
            },
            [`> ${componentCls}-group-addon ${componentCls}-search-button,
        > ${componentCls},
        ${componentCls}-affix-wrapper`]: {
              "&:hover,&:focus,&:active": {
                zIndex: 2
              }
            },
            [`> ${componentCls}-affix-wrapper-focused`]: {
              zIndex: 2
            }
          }
        }
      };
    };
    const genTextAreaStyle = (token2) => {
      const {
        componentCls,
        paddingLG
      } = token2;
      const textareaPrefixCls = `${componentCls}-textarea`;
      return {
        [textareaPrefixCls]: {
          position: "relative",
          "&-show-count": {
            // https://github.com/ant-design/ant-design/issues/33049
            [`> ${componentCls}`]: {
              height: "100%"
            },
            [`${componentCls}-data-count`]: {
              position: "absolute",
              bottom: token2.calc(token2.fontSize).mul(token2.lineHeight).mul(-1).equal(),
              insetInlineEnd: 0,
              color: token2.colorTextDescription,
              whiteSpace: "nowrap",
              pointerEvents: "none"
            }
          },
          "&-allow-clear": {
            [`> ${componentCls}`]: {
              paddingInlineEnd: paddingLG
            }
          },
          [`&-affix-wrapper${textareaPrefixCls}-has-feedback`]: {
            [`${componentCls}`]: {
              paddingInlineEnd: paddingLG
            }
          },
          [`&-affix-wrapper${componentCls}-affix-wrapper`]: {
            padding: 0,
            [`> textarea${componentCls}`]: {
              fontSize: "inherit",
              border: "none",
              outline: "none",
              "&:focus": {
                boxShadow: "none !important"
              }
            },
            [`${componentCls}-suffix`]: {
              margin: 0,
              "> *:not(:last-child)": {
                marginInline: 0
              },
              // Clear Icon
              [`${componentCls}-clear-icon`]: {
                position: "absolute",
                insetInlineEnd: token2.paddingXS,
                insetBlockStart: token2.paddingXS
              },
              // Feedback Icon
              [`${textareaPrefixCls}-suffix`]: {
                position: "absolute",
                top: 0,
                insetInlineEnd: token2.paddingInline,
                bottom: 0,
                zIndex: 1,
                display: "inline-flex",
                alignItems: "center",
                margin: "auto",
                pointerEvents: "none"
              }
            }
          }
        }
      };
    };
    const genRangeStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}-out-of-range`]: {
          [`&, & input, & textarea, ${componentCls}-show-count-suffix, ${componentCls}-data-count`]: {
            color: token2.colorError
          }
        }
      };
    };
    function initInputToken(token2) {
      return merge$1(token2, {
        inputAffixPadding: token2.paddingXXS
      });
    }
    const initComponentToken$1 = (token2) => {
      const {
        controlHeight,
        fontSize,
        lineHeight,
        lineWidth,
        controlHeightSM,
        controlHeightLG,
        fontSizeLG,
        lineHeightLG,
        paddingSM,
        controlPaddingHorizontalSM,
        controlPaddingHorizontal,
        colorFillAlter,
        colorPrimaryHover,
        colorPrimary,
        controlOutlineWidth,
        controlOutline,
        colorErrorOutline,
        colorWarningOutline
      } = token2;
      return {
        paddingBlock: Math.max(Math.round((controlHeight - fontSize * lineHeight) / 2 * 10) / 10 - lineWidth, 0),
        paddingBlockSM: Math.max(Math.round((controlHeightSM - fontSize * lineHeight) / 2 * 10) / 10 - lineWidth, 0),
        paddingBlockLG: Math.ceil((controlHeightLG - fontSizeLG * lineHeightLG) / 2 * 10) / 10 - lineWidth,
        paddingInline: paddingSM - lineWidth,
        paddingInlineSM: controlPaddingHorizontalSM - lineWidth,
        paddingInlineLG: controlPaddingHorizontal - lineWidth,
        addonBg: colorFillAlter,
        activeBorderColor: colorPrimary,
        hoverBorderColor: colorPrimaryHover,
        activeShadow: `0 0 0 ${controlOutlineWidth}px ${controlOutline}`,
        errorActiveShadow: `0 0 0 ${controlOutlineWidth}px ${colorErrorOutline}`,
        warningActiveShadow: `0 0 0 ${controlOutlineWidth}px ${colorWarningOutline}`,
        hoverBg: "",
        activeBg: ""
      };
    };
    const useStyle$a = genStyleHooks("Input", (token2) => {
      const inputToken = merge$1(token2, initInputToken(token2));
      return [
        genInputStyle(inputToken),
        genTextAreaStyle(inputToken),
        genAffixStyle(inputToken),
        genGroupStyle(inputToken),
        genSearchInputStyle(inputToken),
        genRangeStyle(inputToken),
        // =====================================================
        // ==             Space Compact                       ==
        // =====================================================
        genCompactItemStyle(inputToken)
      ];
    }, initComponentToken$1);
    const genPikerPadding = (token2, inputHeight, fontHeight, paddingHorizontal) => {
      const height = token2.calc(fontHeight).add(2).equal();
      const paddingTop = token2.max(token2.calc(inputHeight).sub(height).div(2).equal(), 0);
      const paddingBottom = token2.max(token2.calc(inputHeight).sub(height).sub(paddingTop).equal(), 0);
      return {
        padding: `${unit$1(paddingTop)} ${unit$1(paddingHorizontal)} ${unit$1(paddingBottom)}`
      };
    };
    const genPickerCellInnerStyle = (token2) => {
      const {
        componentCls,
        pickerCellCls,
        pickerCellInnerCls,
        cellHeight,
        motionDurationSlow,
        borderRadiusSM,
        motionDurationMid,
        cellHoverBg,
        lineWidth,
        lineType,
        colorPrimary,
        cellActiveWithRangeBg,
        colorTextLightSolid,
        controlHeightSM,
        cellRangeBorderColor,
        pickerCellBorderGap,
        cellHoverWithRangeBg,
        cellWidth,
        colorTextDisabled,
        cellBgDisabled
      } = token2;
      return {
        "&::before": {
          position: "absolute",
          top: "50%",
          insetInlineStart: 0,
          insetInlineEnd: 0,
          zIndex: 1,
          height: cellHeight,
          transform: "translateY(-50%)",
          transition: `all ${motionDurationSlow}`,
          content: '""'
        },
        // >>> Default
        [pickerCellInnerCls]: {
          position: "relative",
          zIndex: 2,
          display: "inline-block",
          minWidth: cellHeight,
          height: cellHeight,
          lineHeight: unit$1(cellHeight),
          borderRadius: borderRadiusSM,
          transition: `background ${motionDurationMid}, border ${motionDurationMid}`
        },
        [`&-range-hover-start, &-range-hover-end`]: {
          [pickerCellInnerCls]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        },
        // >>> Hover
        [`&:hover:not(${pickerCellCls}-in-view),
    &:hover:not(${pickerCellCls}-selected):not(${pickerCellCls}-range-start):not(${pickerCellCls}-range-end):not(${pickerCellCls}-range-hover-start):not(${pickerCellCls}-range-hover-end)`]: {
          [pickerCellInnerCls]: {
            background: cellHoverBg
          }
        },
        // >>> Today
        [`&-in-view${pickerCellCls}-today ${pickerCellInnerCls}`]: {
          "&::before": {
            position: "absolute",
            top: 0,
            insetInlineEnd: 0,
            bottom: 0,
            insetInlineStart: 0,
            zIndex: 1,
            border: `${unit$1(lineWidth)} ${lineType} ${colorPrimary}`,
            borderRadius: borderRadiusSM,
            content: '""'
          }
        },
        // >>> In Range
        [`&-in-view${pickerCellCls}-in-range`]: {
          position: "relative",
          "&::before": {
            background: cellActiveWithRangeBg
          }
        },
        // >>> Selected
        [`&-in-view${pickerCellCls}-selected ${pickerCellInnerCls},
      &-in-view${pickerCellCls}-range-start ${pickerCellInnerCls},
      &-in-view${pickerCellCls}-range-end ${pickerCellInnerCls}`]: {
          color: colorTextLightSolid,
          background: colorPrimary
        },
        [`&-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-range-start-single),
      &-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-range-end-single)`]: {
          "&::before": {
            background: cellActiveWithRangeBg
          }
        },
        [`&-in-view${pickerCellCls}-range-start::before`]: {
          insetInlineStart: "50%"
        },
        [`&-in-view${pickerCellCls}-range-end::before`]: {
          insetInlineEnd: "50%"
        },
        // >>> Range Hover
        [`&-in-view${pickerCellCls}-range-hover-start:not(${pickerCellCls}-in-range):not(${pickerCellCls}-range-start):not(${pickerCellCls}-range-end),
      &-in-view${pickerCellCls}-range-hover-end:not(${pickerCellCls}-in-range):not(${pickerCellCls}-range-start):not(${pickerCellCls}-range-end),
      &-in-view${pickerCellCls}-range-hover-start${pickerCellCls}-range-start-single,
      &-in-view${pickerCellCls}-range-hover-start${pickerCellCls}-range-start${pickerCellCls}-range-end${pickerCellCls}-range-end-near-hover,
      &-in-view${pickerCellCls}-range-hover-end${pickerCellCls}-range-start${pickerCellCls}-range-end${pickerCellCls}-range-start-near-hover,
      &-in-view${pickerCellCls}-range-hover-end${pickerCellCls}-range-end-single,
      &-in-view${pickerCellCls}-range-hover:not(${pickerCellCls}-in-range)`]: {
          "&::after": {
            position: "absolute",
            top: "50%",
            zIndex: 0,
            height: controlHeightSM,
            borderTop: `${unit$1(lineWidth)} dashed ${cellRangeBorderColor}`,
            borderBottom: `${unit$1(lineWidth)} dashed ${cellRangeBorderColor}`,
            transform: "translateY(-50%)",
            transition: `all ${motionDurationSlow}`,
            content: '""'
          }
        },
        // Add space for stash
        [`&-range-hover-start::after,
      &-range-hover-end::after,
      &-range-hover::after`]: {
          insetInlineEnd: 0,
          insetInlineStart: pickerCellBorderGap
        },
        // Hover with in range
        [`&-in-view${pickerCellCls}-in-range${pickerCellCls}-range-hover::before,
      &-in-view${pickerCellCls}-in-range${pickerCellCls}-range-hover-start::before,
      &-in-view${pickerCellCls}-in-range${pickerCellCls}-range-hover-end::before,
      &-in-view${pickerCellCls}-range-start${pickerCellCls}-range-hover::before,
      &-in-view${pickerCellCls}-range-end${pickerCellCls}-range-hover::before,
      &-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-range-start-single)${pickerCellCls}-range-hover-start::before,
      &-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-range-end-single)${pickerCellCls}-range-hover-end::before,
      ${componentCls}-panel
      > :not(${componentCls}-date-panel)
      &-in-view${pickerCellCls}-in-range${pickerCellCls}-range-hover-start::before,
      ${componentCls}-panel
      > :not(${componentCls}-date-panel)
      &-in-view${pickerCellCls}-in-range${pickerCellCls}-range-hover-end::before`]: {
          background: cellHoverWithRangeBg
        },
        // range start border-radius
        [`&-in-view${pickerCellCls}-range-start:not(${pickerCellCls}-range-start-single):not(${pickerCellCls}-range-end) ${pickerCellInnerCls}`]: {
          borderStartStartRadius: borderRadiusSM,
          borderEndStartRadius: borderRadiusSM,
          borderStartEndRadius: 0,
          borderEndEndRadius: 0
        },
        // range end border-radius
        [`&-in-view${pickerCellCls}-range-end:not(${pickerCellCls}-range-end-single):not(${pickerCellCls}-range-start) ${pickerCellInnerCls}`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0,
          borderStartEndRadius: borderRadiusSM,
          borderEndEndRadius: borderRadiusSM
        },
        [`&-range-hover${pickerCellCls}-range-end::after`]: {
          insetInlineStart: "50%"
        },
        // Edge start
        [`tr > &-in-view${pickerCellCls}-range-hover:first-child::after,
      tr > &-in-view${pickerCellCls}-range-hover-end:first-child::after,
      &-in-view${pickerCellCls}-start${pickerCellCls}-range-hover-edge-start${pickerCellCls}-range-hover-edge-start-near-range::after,
      &-in-view${pickerCellCls}-range-hover-edge-start:not(${pickerCellCls}-range-hover-edge-start-near-range)::after,
      &-in-view${pickerCellCls}-range-hover-start::after`]: {
          insetInlineStart: token2.calc(cellWidth).sub(cellHeight).div(2).equal(),
          borderInlineStart: `${unit$1(lineWidth)} dashed ${cellRangeBorderColor}`,
          borderStartStartRadius: borderRadiusSM,
          borderEndStartRadius: borderRadiusSM
        },
        // Edge end
        [`tr > &-in-view${pickerCellCls}-range-hover:last-child::after,
      tr > &-in-view${pickerCellCls}-range-hover-start:last-child::after,
      &-in-view${pickerCellCls}-end${pickerCellCls}-range-hover-edge-end${pickerCellCls}-range-hover-edge-end-near-range::after,
      &-in-view${pickerCellCls}-range-hover-edge-end:not(${pickerCellCls}-range-hover-edge-end-near-range)::after,
      &-in-view${pickerCellCls}-range-hover-end::after`]: {
          insetInlineEnd: token2.calc(cellWidth).sub(cellHeight).div(2).equal(),
          borderInlineEnd: `${unit$1(lineWidth)} dashed ${cellRangeBorderColor}`,
          borderStartEndRadius: borderRadiusSM,
          borderEndEndRadius: borderRadiusSM
        },
        // >>> Disabled
        "&-disabled": {
          color: colorTextDisabled,
          pointerEvents: "none",
          [pickerCellInnerCls]: {
            background: "transparent"
          },
          "&::before": {
            background: cellBgDisabled
          }
        },
        [`&-disabled${pickerCellCls}-today ${pickerCellInnerCls}::before`]: {
          borderColor: colorTextDisabled
        }
      };
    };
    const genPanelStyle = (token2) => {
      const {
        componentCls,
        pickerCellCls,
        pickerCellInnerCls,
        pickerYearMonthCellWidth,
        pickerControlIconSize,
        cellWidth,
        paddingSM,
        paddingXS,
        paddingXXS,
        colorBgContainer,
        lineWidth,
        lineType,
        borderRadiusLG,
        colorPrimary,
        colorTextHeading,
        colorSplit,
        pickerControlIconBorderWidth,
        colorIcon,
        textHeight,
        motionDurationMid,
        colorIconHover,
        fontWeightStrong,
        cellHeight,
        pickerCellPaddingVertical,
        colorTextDisabled,
        colorText,
        fontSize,
        cellHoverWithRangeBg,
        motionDurationSlow,
        withoutTimeCellHeight,
        pickerQuarterPanelContentHeight,
        colorLink,
        colorLinkActive,
        colorLinkHover,
        cellRangeBorderColor,
        borderRadiusSM,
        colorTextLightSolid,
        cellHoverBg,
        timeColumnHeight,
        timeColumnWidth,
        timeCellHeight,
        controlItemBgActive,
        marginXXS,
        pickerDatePanelPaddingHorizontal,
        pickerControlIconMargin
      } = token2;
      const pickerPanelWidth = token2.calc(cellWidth).mul(7).add(token2.calc(pickerDatePanelPaddingHorizontal).mul(2)).equal();
      const commonHoverCellFixedDistance = token2.calc(pickerPanelWidth).sub(token2.calc(paddingXS).mul(2)).div(3).sub(token2.pickerYearMonthCellWidth).sub(paddingSM).equal();
      const quarterHoverCellFixedDistance = token2.calc(pickerPanelWidth).sub(token2.calc(paddingXS).mul(2)).div(4).sub(token2.pickerYearMonthCellWidth).equal();
      return {
        [componentCls]: {
          "&-panel": {
            display: "inline-flex",
            flexDirection: "column",
            textAlign: "center",
            background: colorBgContainer,
            border: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`,
            borderRadius: borderRadiusLG,
            outline: "none",
            "&-focused": {
              borderColor: colorPrimary
            },
            "&-rtl": {
              direction: "rtl",
              [`${componentCls}-prev-icon,
              ${componentCls}-super-prev-icon`]: {
                transform: "rotate(45deg)"
              },
              [`${componentCls}-next-icon,
              ${componentCls}-super-next-icon`]: {
                transform: "rotate(-135deg)"
              }
            }
          },
          // ========================================================
          // =                     Shared Panel                     =
          // ========================================================
          [`&-decade-panel,
        &-year-panel,
        &-quarter-panel,
        &-month-panel,
        &-week-panel,
        &-date-panel,
        &-time-panel`]: {
            display: "flex",
            flexDirection: "column",
            width: pickerPanelWidth
          },
          // ======================= Header =======================
          "&-header": {
            display: "flex",
            padding: `0 ${unit$1(paddingXS)}`,
            color: colorTextHeading,
            borderBottom: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`,
            "> *": {
              flex: "none"
            },
            button: {
              padding: 0,
              color: colorIcon,
              lineHeight: unit$1(textHeight),
              background: "transparent",
              border: 0,
              cursor: "pointer",
              transition: `color ${motionDurationMid}`,
              fontSize: "inherit"
            },
            "> button": {
              minWidth: "1.6em",
              fontSize,
              "&:hover": {
                color: colorIconHover
              }
            },
            "&-view": {
              flex: "auto",
              fontWeight: fontWeightStrong,
              lineHeight: unit$1(textHeight),
              button: {
                color: "inherit",
                fontWeight: "inherit",
                verticalAlign: "top",
                "&:not(:first-child)": {
                  marginInlineStart: paddingXS
                },
                "&:hover": {
                  color: colorPrimary
                }
              }
            }
          },
          // Arrow button
          [`&-prev-icon,
        &-next-icon,
        &-super-prev-icon,
        &-super-next-icon`]: {
            position: "relative",
            display: "inline-block",
            width: pickerControlIconSize,
            height: pickerControlIconSize,
            "&::before": {
              position: "absolute",
              top: 0,
              insetInlineStart: 0,
              display: "inline-block",
              width: pickerControlIconSize,
              height: pickerControlIconSize,
              border: `0 solid currentcolor`,
              borderBlockStartWidth: pickerControlIconBorderWidth,
              borderBlockEndWidth: 0,
              borderInlineStartWidth: pickerControlIconBorderWidth,
              borderInlineEndWidth: 0,
              content: '""'
            }
          },
          [`&-super-prev-icon,
        &-super-next-icon`]: {
            "&::after": {
              position: "absolute",
              top: pickerControlIconMargin,
              insetInlineStart: pickerControlIconMargin,
              display: "inline-block",
              width: pickerControlIconSize,
              height: pickerControlIconSize,
              border: "0 solid currentcolor",
              borderBlockStartWidth: pickerControlIconBorderWidth,
              borderBlockEndWidth: 0,
              borderInlineStartWidth: pickerControlIconBorderWidth,
              borderInlineEndWidth: 0,
              content: '""'
            }
          },
          [`&-prev-icon,
        &-super-prev-icon`]: {
            transform: "rotate(-45deg)"
          },
          [`&-next-icon,
        &-super-next-icon`]: {
            transform: "rotate(135deg)"
          },
          // ======================== Body ========================
          "&-content": {
            width: "100%",
            tableLayout: "fixed",
            borderCollapse: "collapse",
            "th, td": {
              position: "relative",
              minWidth: cellHeight,
              fontWeight: "normal"
            },
            th: {
              height: token2.calc(cellHeight).add(token2.calc(pickerCellPaddingVertical).mul(2)).equal(),
              color: colorText,
              verticalAlign: "middle"
            }
          },
          "&-cell": Object.assign({
            padding: `${unit$1(pickerCellPaddingVertical)} 0`,
            color: colorTextDisabled,
            cursor: "pointer",
            // In view
            "&-in-view": {
              color: colorText
            }
          }, genPickerCellInnerStyle(token2)),
          // DatePanel only
          [`&-date-panel ${componentCls}-cell-in-view${componentCls}-cell-in-range${componentCls}-cell-range-hover-start ${pickerCellInnerCls},
        &-date-panel ${componentCls}-cell-in-view${componentCls}-cell-in-range${componentCls}-cell-range-hover-end ${pickerCellInnerCls}`]: {
            "&::after": {
              position: "absolute",
              top: 0,
              bottom: 0,
              zIndex: -1,
              background: cellHoverWithRangeBg,
              transition: `all ${motionDurationSlow}`,
              content: '""'
            }
          },
          [`&-date-panel
        ${componentCls}-cell-in-view${componentCls}-cell-in-range${componentCls}-cell-range-hover-start
        ${pickerCellInnerCls}::after`]: {
            insetInlineEnd: token2.calc(cellWidth).sub(cellHeight).mul(-1).div(2).equal(),
            insetInlineStart: 0
          },
          [`&-date-panel ${componentCls}-cell-in-view${componentCls}-cell-in-range${componentCls}-cell-range-hover-end ${pickerCellInnerCls}::after`]: {
            insetInlineEnd: 0,
            insetInlineStart: token2.calc(cellWidth).sub(cellHeight).mul(-1).div(2).equal()
          },
          // Hover with range start & end
          [`&-range-hover${componentCls}-range-start::after`]: {
            insetInlineEnd: "50%"
          },
          [`&-decade-panel,
        &-year-panel,
        &-quarter-panel,
        &-month-panel`]: {
            [`${componentCls}-content`]: {
              height: token2.calc(withoutTimeCellHeight).mul(4).equal()
            },
            [pickerCellInnerCls]: {
              padding: `0 ${unit$1(paddingXS)}`
            }
          },
          "&-quarter-panel": {
            [`${componentCls}-content`]: {
              height: pickerQuarterPanelContentHeight
            },
            // Quarter Panel Special Style
            [`${componentCls}-cell-range-hover-start::after`]: {
              insetInlineStart: quarterHoverCellFixedDistance,
              borderInlineStart: `${unit$1(lineWidth)} dashed ${cellRangeBorderColor}`,
              [`${componentCls}-panel-rtl &`]: {
                insetInlineEnd: quarterHoverCellFixedDistance,
                borderInlineEnd: `${unit$1(lineWidth)} dashed ${cellRangeBorderColor}`
              }
            },
            [`${componentCls}-cell-range-hover-end::after`]: {
              insetInlineEnd: quarterHoverCellFixedDistance,
              borderInlineEnd: `${unit$1(lineWidth)} dashed ${cellRangeBorderColor}`,
              [`${componentCls}-panel-rtl &`]: {
                insetInlineStart: quarterHoverCellFixedDistance,
                borderInlineStart: `${unit$1(lineWidth)} dashed ${cellRangeBorderColor}`
              }
            }
          },
          // ======================== Footer ========================
          [`&-panel ${componentCls}-footer`]: {
            borderTop: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`
          },
          "&-footer": {
            width: "min-content",
            minWidth: "100%",
            lineHeight: unit$1(token2.calc(textHeight).sub(token2.calc(lineWidth).mul(2)).equal()),
            textAlign: "center",
            "&-extra": {
              padding: `0 ${unit$1(paddingSM)}`,
              lineHeight: unit$1(token2.calc(textHeight).sub(token2.calc(lineWidth).mul(2)).equal()),
              textAlign: "start",
              "&:not(:last-child)": {
                borderBottom: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`
              }
            }
          },
          "&-now": {
            textAlign: "start"
          },
          "&-today-btn": {
            color: colorLink,
            "&:hover": {
              color: colorLinkHover
            },
            "&:active": {
              color: colorLinkActive
            },
            [`&${componentCls}-today-btn-disabled`]: {
              color: colorTextDisabled,
              cursor: "not-allowed"
            }
          },
          // ========================================================
          // =                       Special                        =
          // ========================================================
          // ===================== Decade Panel =====================
          "&-decade-panel": {
            [pickerCellInnerCls]: {
              padding: `0 ${unit$1(token2.calc(paddingXS).div(2).equal())}`
            },
            [`${componentCls}-cell::before`]: {
              display: "none"
            }
          },
          // ============= Year & Quarter & Month Panel =============
          [`&-year-panel,
        &-quarter-panel,
        &-month-panel`]: {
            [`${componentCls}-body`]: {
              padding: `0 ${unit$1(paddingXS)}`
            },
            [pickerCellInnerCls]: {
              width: pickerYearMonthCellWidth
            },
            [`${componentCls}-cell-range-hover-start::after`]: {
              borderStartStartRadius: borderRadiusSM,
              borderEndStartRadius: borderRadiusSM,
              borderStartEndRadius: 0,
              borderEndEndRadius: 0,
              [`${componentCls}-panel-rtl &`]: {
                borderStartStartRadius: 0,
                borderEndStartRadius: 0,
                borderStartEndRadius: borderRadiusSM,
                borderEndEndRadius: borderRadiusSM
              }
            },
            [`${componentCls}-cell-range-hover-end::after`]: {
              borderStartStartRadius: 0,
              borderEndStartRadius: 0,
              borderStartEndRadius: borderRadiusSM,
              borderEndEndRadius: borderRadiusSM,
              [`${componentCls}-panel-rtl &`]: {
                borderStartStartRadius: borderRadiusSM,
                borderEndStartRadius: borderRadiusSM,
                borderStartEndRadius: 0,
                borderEndEndRadius: 0
              }
            }
          },
          [`&-year-panel,
        &-month-panel`]: {
            [`${componentCls}-cell-range-hover-start::after`]: {
              insetInlineStart: commonHoverCellFixedDistance,
              borderInlineStart: `${unit$1(lineWidth)} dashed ${cellRangeBorderColor}`,
              [`${componentCls}-panel-rtl &`]: {
                insetInlineEnd: commonHoverCellFixedDistance,
                borderInlineEnd: `${unit$1(lineWidth)} dashed ${cellRangeBorderColor}`
              }
            },
            [`${componentCls}-cell-range-hover-end::after`]: {
              insetInlineEnd: commonHoverCellFixedDistance,
              borderInlineEnd: `${unit$1(lineWidth)} dashed ${cellRangeBorderColor}`,
              [`${componentCls}-panel-rtl &`]: {
                insetInlineStart: commonHoverCellFixedDistance,
                borderInlineStart: `${unit$1(lineWidth)} dashed ${cellRangeBorderColor}`
              }
            }
          },
          // ====================== Week Panel ======================
          "&-week-panel": {
            [`${componentCls}-body`]: {
              padding: `${unit$1(paddingXS)} ${unit$1(paddingSM)}`
            },
            // Clear cell style
            [`${componentCls}-cell`]: {
              [`&:hover ${pickerCellInnerCls},
            &-selected ${pickerCellInnerCls},
            ${pickerCellInnerCls}`]: {
                background: "transparent !important"
              }
            },
            "&-row": {
              td: {
                "&:before": {
                  transition: `background ${motionDurationMid}`
                },
                "&:first-child:before": {
                  borderStartStartRadius: borderRadiusSM,
                  borderEndStartRadius: borderRadiusSM
                },
                "&:last-child:before": {
                  borderStartEndRadius: borderRadiusSM,
                  borderEndEndRadius: borderRadiusSM
                }
              },
              [`&:hover td`]: {
                "&:before": {
                  background: cellHoverBg
                }
              },
              [`&-range-start td,
            &-range-end td,
            &-selected td`]: {
                // Rise priority to override hover style
                [`&${pickerCellCls}`]: {
                  "&:before": {
                    background: colorPrimary
                  },
                  [`&${componentCls}-cell-week`]: {
                    color: new TinyColor(colorTextLightSolid).setAlpha(0.5).toHexString()
                  },
                  [pickerCellInnerCls]: {
                    color: colorTextLightSolid
                  }
                }
              },
              [`&-range-hover td:before`]: {
                background: controlItemBgActive
              }
            }
          },
          // ====================== Date Panel ======================
          "&-date-panel": {
            [`${componentCls}-body`]: {
              padding: `${unit$1(paddingXS)} ${unit$1(pickerDatePanelPaddingHorizontal)}`
            },
            [`${componentCls}-content`]: {
              width: token2.calc(cellWidth).mul(7).equal(),
              th: {
                width: cellWidth,
                boxSizing: "border-box",
                padding: 0
              }
            }
          },
          // ==================== Datetime Panel ====================
          "&-datetime-panel": {
            display: "flex",
            [`${componentCls}-time-panel`]: {
              borderInlineStart: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`
            },
            [`${componentCls}-date-panel,
          ${componentCls}-time-panel`]: {
              transition: `opacity ${motionDurationSlow}`
            },
            // Keyboard
            "&-active": {
              [`${componentCls}-date-panel,
            ${componentCls}-time-panel`]: {
                opacity: 0.3,
                "&-active": {
                  opacity: 1
                }
              }
            }
          },
          // ====================== Time Panel ======================
          "&-time-panel": {
            width: "auto",
            minWidth: "auto",
            direction: "ltr",
            [`${componentCls}-content`]: {
              display: "flex",
              flex: "auto",
              height: timeColumnHeight
            },
            "&-column": {
              flex: "1 0 auto",
              width: timeColumnWidth,
              margin: `${unit$1(paddingXXS)} 0`,
              padding: 0,
              overflowY: "hidden",
              textAlign: "start",
              listStyle: "none",
              transition: `background ${motionDurationMid}`,
              overflowX: "hidden",
              "&::-webkit-scrollbar": {
                width: 8,
                backgroundColor: "transparent"
              },
              "&::-webkit-scrollbar-thumb": {
                backgroundColor: token2.colorTextTertiary,
                borderRadius: 4
              },
              // For Firefox
              "&": {
                scrollbarWidth: "thin",
                scrollbarColor: `${token2.colorTextTertiary} transparent`
              },
              "&::after": {
                display: "block",
                height: token2.calc(timeColumnHeight).sub(timeCellHeight).equal(),
                content: '""'
              },
              "&:not(:first-child)": {
                borderInlineStart: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`
              },
              "&-active": {
                background: new TinyColor(controlItemBgActive).setAlpha(0.2).toHexString()
              },
              "&:hover": {
                overflowY: "auto"
              },
              "> li": {
                margin: 0,
                padding: 0,
                [`&${componentCls}-time-panel-cell`]: {
                  marginInline: marginXXS,
                  [`${componentCls}-time-panel-cell-inner`]: {
                    display: "block",
                    width: token2.calc(timeColumnWidth).sub(token2.calc(marginXXS).mul(2)).equal(),
                    height: timeCellHeight,
                    margin: 0,
                    paddingBlock: 0,
                    paddingInlineEnd: 0,
                    paddingInlineStart: token2.calc(timeColumnWidth).sub(timeCellHeight).div(2).equal(),
                    color: colorText,
                    lineHeight: unit$1(timeCellHeight),
                    borderRadius: borderRadiusSM,
                    cursor: "pointer",
                    transition: `background ${motionDurationMid}`,
                    "&:hover": {
                      background: cellHoverBg
                    }
                  },
                  "&-selected": {
                    [`${componentCls}-time-panel-cell-inner`]: {
                      background: controlItemBgActive
                    }
                  },
                  "&-disabled": {
                    [`${componentCls}-time-panel-cell-inner`]: {
                      color: colorTextDisabled,
                      background: "transparent",
                      cursor: "not-allowed"
                    }
                  }
                }
              }
            }
          },
          // https://github.com/ant-design/ant-design/issues/39227
          [`&-datetime-panel ${componentCls}-time-panel-column:after`]: {
            height: token2.calc(timeColumnHeight).sub(timeCellHeight).add(token2.calc(paddingXXS).mul(2)).equal()
          }
        }
      };
    };
    const genPickerStatusStyle = (token2) => {
      const {
        componentCls,
        colorBgContainer,
        colorError,
        errorActiveShadow,
        colorWarning,
        warningActiveShadow,
        colorErrorHover,
        colorWarningHover
      } = token2;
      return {
        [`${componentCls}:not(${componentCls}-disabled):not([disabled])`]: {
          [`&${componentCls}-status-error`]: {
            backgroundColor: colorBgContainer,
            borderColor: colorError,
            "&:hover": {
              borderColor: colorErrorHover
            },
            [`&${componentCls}-focused, &:focus`]: Object.assign({}, genActiveStyle(merge$1(token2, {
              activeBorderColor: colorError,
              activeShadow: errorActiveShadow
            }))),
            [`${componentCls}-active-bar`]: {
              background: colorError
            }
          },
          [`&${componentCls}-status-warning`]: {
            backgroundColor: colorBgContainer,
            borderColor: colorWarning,
            "&:hover": {
              borderColor: colorWarningHover
            },
            [`&${componentCls}-focused, &:focus`]: Object.assign({}, genActiveStyle(merge$1(token2, {
              activeBorderColor: colorWarning,
              activeShadow: warningActiveShadow
            }))),
            [`${componentCls}-active-bar`]: {
              background: colorWarning
            }
          }
        }
      };
    };
    const genPickerStyle = (token2) => {
      const {
        componentCls,
        antCls,
        controlHeight,
        paddingInline,
        colorBgContainer,
        lineWidth,
        lineType,
        colorBorder,
        borderRadius,
        motionDurationMid,
        colorBgContainerDisabled,
        colorTextDisabled,
        colorTextPlaceholder,
        controlHeightLG,
        fontSizeLG,
        controlHeightSM,
        paddingInlineSM,
        paddingXS,
        marginXS,
        colorTextDescription,
        lineWidthBold,
        colorPrimary,
        motionDurationSlow,
        zIndexPopup,
        paddingXXS,
        paddingSM,
        textHeight,
        cellActiveWithRangeBg,
        colorPrimaryBorder,
        sizePopupArrow,
        colorBgElevated,
        borderRadiusLG,
        boxShadowSecondary,
        borderRadiusSM,
        colorSplit,
        cellHoverBg,
        presetsWidth,
        presetsMaxWidth,
        boxShadowPopoverArrow,
        colorTextQuaternary,
        fontHeight,
        fontHeightLG,
        lineHeightLG
      } = token2;
      return [
        {
          [componentCls]: Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genPikerPadding(token2, controlHeight, fontHeight, paddingInline)), {
            position: "relative",
            display: "inline-flex",
            alignItems: "center",
            background: colorBgContainer,
            lineHeight: 1,
            border: `${unit$1(lineWidth)} ${lineType} ${colorBorder}`,
            borderRadius,
            transition: `border ${motionDurationMid}, box-shadow ${motionDurationMid}`,
            "&:hover": Object.assign({}, genHoverStyle(token2)),
            [`&-focused${componentCls}`]: Object.assign({}, genActiveStyle(token2)),
            [`&${componentCls}-disabled`]: {
              background: colorBgContainerDisabled,
              borderColor: colorBorder,
              cursor: "not-allowed",
              [`${componentCls}-suffix`]: {
                color: colorTextQuaternary
              }
            },
            [`&${componentCls}-borderless`]: {
              backgroundColor: "transparent !important",
              borderColor: "transparent !important",
              boxShadow: "none !important"
            },
            // ======================== Input =========================
            [`${componentCls}-input`]: {
              position: "relative",
              display: "inline-flex",
              alignItems: "center",
              width: "100%",
              "> input": Object.assign(Object.assign({}, genBasicInputStyle(token2)), {
                flex: "auto",
                // Fix Firefox flex not correct:
                // https://github.com/ant-design/ant-design/pull/20023#issuecomment-564389553
                minWidth: 1,
                height: "auto",
                padding: 0,
                background: "transparent",
                border: 0,
                borderRadius: 0,
                fontFamily: "inherit",
                "&:focus": {
                  boxShadow: "none"
                },
                "&[disabled]": {
                  background: "transparent"
                }
              }),
              "&:hover": {
                [`${componentCls}-clear`]: {
                  opacity: 1
                }
              },
              "&-placeholder": {
                "> input": {
                  color: colorTextPlaceholder
                }
              }
            },
            // Size
            "&-large": Object.assign(Object.assign({}, genPikerPadding(token2, controlHeightLG, fontHeightLG, paddingInline)), {
              [`${componentCls}-input > input`]: {
                fontSize: fontSizeLG,
                lineHeight: lineHeightLG
              }
            }),
            "&-small": Object.assign({}, genPikerPadding(token2, controlHeightSM, fontHeight, paddingInlineSM)),
            [`${componentCls}-suffix`]: {
              display: "flex",
              flex: "none",
              alignSelf: "center",
              marginInlineStart: token2.calc(paddingXS).div(2).equal(),
              color: colorTextDisabled,
              lineHeight: 1,
              pointerEvents: "none",
              "> *": {
                verticalAlign: "top",
                "&:not(:last-child)": {
                  marginInlineEnd: marginXS
                }
              }
            },
            [`${componentCls}-clear`]: {
              position: "absolute",
              top: "50%",
              insetInlineEnd: 0,
              color: colorTextDisabled,
              lineHeight: 1,
              background: colorBgContainer,
              transform: "translateY(-50%)",
              cursor: "pointer",
              opacity: 0,
              transition: `opacity ${motionDurationMid}, color ${motionDurationMid}`,
              "> *": {
                verticalAlign: "top"
              },
              "&:hover": {
                color: colorTextDescription
              }
            },
            [`${componentCls}-separator`]: {
              position: "relative",
              display: "inline-block",
              width: "1em",
              height: fontSizeLG,
              color: colorTextDisabled,
              fontSize: fontSizeLG,
              verticalAlign: "top",
              cursor: "default",
              [`${componentCls}-focused &`]: {
                color: colorTextDescription
              },
              [`${componentCls}-range-separator &`]: {
                [`${componentCls}-disabled &`]: {
                  cursor: "not-allowed"
                }
              }
            },
            // ======================== Range =========================
            "&-range": {
              position: "relative",
              display: "inline-flex",
              // Clear
              [`${componentCls}-clear`]: {
                insetInlineEnd: paddingInline
              },
              "&:hover": {
                [`${componentCls}-clear`]: {
                  opacity: 1
                }
              },
              // Active bar
              [`${componentCls}-active-bar`]: {
                bottom: token2.calc(lineWidth).mul(-1).equal(),
                height: lineWidthBold,
                marginInlineStart: paddingInline,
                background: colorPrimary,
                opacity: 0,
                transition: `all ${motionDurationSlow} ease-out`,
                pointerEvents: "none"
              },
              [`&${componentCls}-focused`]: {
                [`${componentCls}-active-bar`]: {
                  opacity: 1
                }
              },
              [`${componentCls}-range-separator`]: {
                alignItems: "center",
                padding: `0 ${unit$1(paddingXS)}`,
                lineHeight: 1
              },
              [`&${componentCls}-small`]: {
                [`${componentCls}-clear`]: {
                  insetInlineEnd: paddingInlineSM
                },
                [`${componentCls}-active-bar`]: {
                  marginInlineStart: paddingInlineSM
                }
              }
            },
            // ======================= Dropdown =======================
            "&-dropdown": Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genPanelStyle(token2)), {
              position: "absolute",
              // Fix incorrect position of picker popup
              // https://github.com/ant-design/ant-design/issues/35590
              top: -9999,
              left: {
                _skip_check_: true,
                value: -9999
              },
              zIndex: zIndexPopup,
              [`&${componentCls}-dropdown-hidden`]: {
                display: "none"
              },
              [`&${componentCls}-dropdown-placement-bottomLeft`]: {
                [`${componentCls}-range-arrow`]: {
                  top: 0,
                  display: "block",
                  transform: "translateY(-100%)"
                }
              },
              [`&${componentCls}-dropdown-placement-topLeft`]: {
                [`${componentCls}-range-arrow`]: {
                  bottom: 0,
                  display: "block",
                  transform: "translateY(100%) rotate(180deg)"
                }
              },
              [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-topRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-topRight`]: {
                animationName: slideDownIn
              },
              [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-dropdown-placement-bottomRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-dropdown-placement-bottomRight`]: {
                animationName: slideUpIn
              },
              [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-topRight`]: {
                animationName: slideDownOut
              },
              [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-dropdown-placement-bottomRight`]: {
                animationName: slideUpOut
              },
              // Time picker with additional style
              [`${componentCls}-panel > ${componentCls}-time-panel`]: {
                paddingTop: paddingXXS
              },
              // ======================== Ranges ========================
              [`${componentCls}-ranges`]: {
                marginBottom: 0,
                padding: `${unit$1(paddingXXS)} ${unit$1(paddingSM)}`,
                overflow: "hidden",
                lineHeight: unit$1(token2.calc(textHeight).sub(token2.calc(lineWidth).mul(2)).sub(token2.calc(paddingXS).div(2)).equal()),
                textAlign: "start",
                listStyle: "none",
                display: "flex",
                justifyContent: "space-between",
                "> li": {
                  display: "inline-block"
                },
                // https://github.com/ant-design/ant-design/issues/23687
                [`${componentCls}-preset > ${antCls}-tag-blue`]: {
                  color: colorPrimary,
                  background: cellActiveWithRangeBg,
                  borderColor: colorPrimaryBorder,
                  cursor: "pointer"
                },
                [`${componentCls}-ok`]: {
                  marginInlineStart: "auto"
                }
              },
              [`${componentCls}-range-wrapper`]: {
                display: "flex",
                position: "relative"
              },
              [`${componentCls}-range-arrow`]: Object.assign({
                position: "absolute",
                zIndex: 1,
                display: "none",
                marginInlineStart: token2.calc(paddingInline).mul(1.5).equal(),
                transition: `left ${motionDurationSlow} ease-out`
              }, genRoundedArrow(token2, colorBgElevated, boxShadowPopoverArrow)),
              [`${componentCls}-panel-container`]: {
                overflow: "hidden",
                verticalAlign: "top",
                background: colorBgElevated,
                borderRadius: borderRadiusLG,
                boxShadow: boxShadowSecondary,
                transition: `margin ${motionDurationSlow}`,
                // ======================== Layout ========================
                [`${componentCls}-panel-layout`]: {
                  display: "flex",
                  flexWrap: "nowrap",
                  alignItems: "stretch"
                },
                // ======================== Preset ========================
                [`${componentCls}-presets`]: {
                  display: "flex",
                  flexDirection: "column",
                  minWidth: presetsWidth,
                  maxWidth: presetsMaxWidth,
                  ul: {
                    height: 0,
                    flex: "auto",
                    listStyle: "none",
                    overflow: "auto",
                    margin: 0,
                    padding: paddingXS,
                    borderInlineEnd: `${unit$1(lineWidth)} ${lineType} ${colorSplit}`,
                    li: Object.assign(Object.assign({}, textEllipsis), {
                      borderRadius: borderRadiusSM,
                      paddingInline: paddingXS,
                      paddingBlock: token2.calc(controlHeightSM).sub(fontHeight).div(2).equal(),
                      cursor: "pointer",
                      transition: `all ${motionDurationSlow}`,
                      "+ li": {
                        marginTop: marginXS
                      },
                      "&:hover": {
                        background: cellHoverBg
                      }
                    })
                  }
                },
                // ======================== Panels ========================
                [`${componentCls}-panels`]: {
                  display: "inline-flex",
                  flexWrap: "nowrap",
                  direction: "ltr",
                  [`${componentCls}-panel`]: {
                    borderWidth: `0 0 ${unit$1(lineWidth)}`
                  },
                  "&:last-child": {
                    [`${componentCls}-panel`]: {
                      borderWidth: 0
                    }
                  }
                },
                [`${componentCls}-panel`]: {
                  verticalAlign: "top",
                  background: "transparent",
                  borderRadius: 0,
                  borderWidth: 0,
                  [`${componentCls}-content,
            table`]: {
                    textAlign: "center"
                  },
                  "&-focused": {
                    borderColor: colorBorder
                  }
                }
              }
            }),
            "&-dropdown-range": {
              padding: `${unit$1(token2.calc(sizePopupArrow).mul(2).div(3).equal())} 0`,
              "&-hidden": {
                display: "none"
              }
            },
            "&-rtl": {
              direction: "rtl",
              [`${componentCls}-separator`]: {
                transform: "rotate(180deg)"
              },
              [`${componentCls}-footer`]: {
                "&-extra": {
                  direction: "rtl"
                }
              }
            }
          })
        },
        // Follow code may reuse in other components
        initSlideMotion(token2, "slide-up"),
        initSlideMotion(token2, "slide-down"),
        initMoveMotion(token2, "move-up"),
        initMoveMotion(token2, "move-down")
      ];
    };
    const initPickerPanelToken = (token2) => {
      const {
        componentCls,
        controlHeightLG,
        paddingXXS,
        padding
      } = token2;
      return {
        pickerCellCls: `${componentCls}-cell`,
        pickerCellInnerCls: `${componentCls}-cell-inner`,
        pickerYearMonthCellWidth: token2.calc(controlHeightLG).mul(1.5).equal(),
        pickerQuarterPanelContentHeight: token2.calc(controlHeightLG).mul(1.4).equal(),
        pickerCellPaddingVertical: token2.calc(paddingXXS).add(token2.calc(paddingXXS).div(2)).equal(),
        pickerCellBorderGap: 2,
        // Magic for gap between cells
        pickerControlIconSize: 7,
        pickerControlIconMargin: 4,
        pickerControlIconBorderWidth: 1.5,
        pickerDatePanelPaddingHorizontal: token2.calc(padding).add(token2.calc(paddingXXS).div(2)).equal()
        // 18 in normal
      };
    };
    const initPanelComponentToken = (token2) => ({
      cellHoverBg: token2.controlItemBgHover,
      cellActiveWithRangeBg: token2.controlItemBgActive,
      cellHoverWithRangeBg: new TinyColor(token2.colorPrimary).lighten(35).toHexString(),
      cellRangeBorderColor: new TinyColor(token2.colorPrimary).lighten(20).toHexString(),
      cellBgDisabled: token2.colorBgContainerDisabled,
      timeColumnWidth: token2.controlHeightLG * 1.4,
      timeColumnHeight: 28 * 8,
      timeCellHeight: 28,
      cellWidth: token2.controlHeightSM * 1.5,
      cellHeight: token2.controlHeightSM,
      textHeight: token2.controlHeightLG,
      withoutTimeCellHeight: token2.controlHeightLG * 1.65
    });
    const prepareComponentToken$8 = (token2) => Object.assign(Object.assign(Object.assign(Object.assign({}, initComponentToken$1(token2)), initPanelComponentToken(token2)), getArrowToken(token2)), {
      presetsWidth: 120,
      presetsMaxWidth: 200,
      zIndexPopup: token2.zIndexPopupBase + 50
    });
    const useStyle$9 = genStyleHooks("DatePicker", (token2) => {
      const pickerToken = merge$1(initInputToken(token2), initPickerPanelToken(token2));
      return [
        genPickerStyle(pickerToken),
        genPickerStatusStyle(pickerToken),
        // =====================================================
        // ==             Space Compact                       ==
        // =====================================================
        genCompactItemStyle(token2, {
          focusElCls: `${token2.componentCls}-focused`
        })
      ];
    }, prepareComponentToken$8);
    const genCalendarStyles = (token2) => {
      const {
        calendarCls,
        componentCls,
        fullBg,
        fullPanelBg,
        itemActiveBg
      } = token2;
      return {
        [calendarCls]: Object.assign(Object.assign(Object.assign({}, genPanelStyle(token2)), resetComponent(token2)), {
          background: fullBg,
          "&-rtl": {
            direction: "rtl"
          },
          [`${calendarCls}-header`]: {
            display: "flex",
            justifyContent: "flex-end",
            padding: `${unit$1(token2.paddingSM)} 0`,
            [`${calendarCls}-year-select`]: {
              minWidth: token2.yearControlWidth
            },
            [`${calendarCls}-month-select`]: {
              minWidth: token2.monthControlWidth,
              marginInlineStart: token2.marginXS
            },
            [`${calendarCls}-mode-switch`]: {
              marginInlineStart: token2.marginXS
            }
          }
        }),
        [`${calendarCls} ${componentCls}-panel`]: {
          background: fullPanelBg,
          border: 0,
          borderTop: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorSplit}`,
          borderRadius: 0,
          [`${componentCls}-month-panel, ${componentCls}-date-panel`]: {
            width: "auto"
          },
          [`${componentCls}-body`]: {
            padding: `${unit$1(token2.paddingXS)} 0`
          },
          [`${componentCls}-content`]: {
            width: "100%"
          }
        },
        [`${calendarCls}-mini`]: {
          borderRadius: token2.borderRadiusLG,
          [`${calendarCls}-header`]: {
            paddingInlineEnd: token2.paddingXS,
            paddingInlineStart: token2.paddingXS
          },
          [`${componentCls}-panel`]: {
            borderRadius: `0 0 ${unit$1(token2.borderRadiusLG)} ${unit$1(token2.borderRadiusLG)}`
          },
          [`${componentCls}-content`]: {
            height: token2.miniContentHeight,
            th: {
              height: "auto",
              padding: 0,
              lineHeight: `${unit$1(token2.weekHeight)}`
            }
          },
          [`${componentCls}-cell::before`]: {
            pointerEvents: "none"
          }
        },
        [`${calendarCls}${calendarCls}-full`]: {
          [`${componentCls}-panel`]: {
            display: "block",
            width: "100%",
            textAlign: "end",
            background: fullBg,
            border: 0,
            [`${componentCls}-body`]: {
              "th, td": {
                padding: 0
              },
              th: {
                height: "auto",
                paddingInlineEnd: token2.paddingSM,
                paddingBottom: token2.paddingXXS,
                lineHeight: `${unit$1(token2.weekHeight)}`
              }
            }
          },
          [`${componentCls}-cell`]: {
            "&::before": {
              display: "none"
            },
            "&:hover": {
              [`${calendarCls}-date`]: {
                background: token2.controlItemBgHover
              }
            },
            [`${calendarCls}-date-today::before`]: {
              display: "none"
            },
            // >>> Selected
            [`&-in-view${componentCls}-cell-selected`]: {
              [`${calendarCls}-date, ${calendarCls}-date-today`]: {
                background: itemActiveBg
              }
            },
            "&-selected, &-selected:hover": {
              [`${calendarCls}-date, ${calendarCls}-date-today`]: {
                [`${calendarCls}-date-value`]: {
                  color: token2.colorPrimary
                }
              }
            }
          },
          [`${calendarCls}-date`]: {
            display: "block",
            width: "auto",
            height: "auto",
            margin: `0 ${unit$1(token2.calc(token2.marginXS).div(2).equal())}`,
            padding: `${unit$1(token2.calc(token2.paddingXS).div(2).equal())} ${unit$1(token2.paddingXS)} 0`,
            border: 0,
            borderTop: `${unit$1(token2.lineWidthBold)} ${token2.lineType} ${token2.colorSplit}`,
            borderRadius: 0,
            transition: `background ${token2.motionDurationSlow}`,
            "&-value": {
              lineHeight: `${unit$1(token2.dateValueHeight)}`,
              transition: `color ${token2.motionDurationSlow}`
            },
            "&-content": {
              position: "static",
              width: "auto",
              height: token2.dateContentHeight,
              overflowY: "auto",
              color: token2.colorText,
              lineHeight: token2.lineHeight,
              textAlign: "start"
            },
            "&-today": {
              borderColor: token2.colorPrimary,
              [`${calendarCls}-date-value`]: {
                color: token2.colorText
              }
            }
          }
        },
        [`@media only screen and (max-width: ${unit$1(token2.screenXS)}) `]: {
          [`${calendarCls}`]: {
            [`${calendarCls}-header`]: {
              display: "block",
              [`${calendarCls}-year-select`]: {
                width: "50%"
              },
              [`${calendarCls}-month-select`]: {
                width: `calc(50% - ${unit$1(token2.paddingXS)})`
              },
              [`${calendarCls}-mode-switch`]: {
                width: "100%",
                marginTop: token2.marginXS,
                marginInlineStart: 0,
                "> label": {
                  width: "50%",
                  textAlign: "center"
                }
              }
            }
          }
        }
      };
    };
    const prepareComponentToken$7 = (token2) => Object.assign({
      fullBg: token2.colorBgContainer,
      fullPanelBg: token2.colorBgContainer,
      itemActiveBg: token2.controlItemBgActive,
      yearControlWidth: 80,
      monthControlWidth: 70,
      miniContentHeight: 256
    }, initPanelComponentToken(token2));
    const useStyle$8 = genStyleHooks("Calendar", (token2) => {
      const calendarCls = `${token2.componentCls}-calendar`;
      const calendarToken = merge$1(token2, initPickerPanelToken(token2), {
        calendarCls,
        pickerCellInnerCls: `${token2.componentCls}-cell-inner`,
        dateValueHeight: token2.controlHeightSM,
        weekHeight: token2.calc(token2.controlHeightSM).mul(0.75).equal(),
        dateContentHeight: token2.calc(token2.calc(token2.fontHeightSM).add(token2.marginXS)).mul(3).add(token2.calc(token2.lineWidth).mul(2)).equal()
      });
      return [genCalendarStyles(calendarToken)];
    }, prepareComponentToken$7);
    function generateCalendar(generateConfig2) {
      function isSameYear2(date1, date22) {
        return date1 && date22 && generateConfig2.getYear(date1) === generateConfig2.getYear(date22);
      }
      function isSameMonth2(date1, date22) {
        return isSameYear2(date1, date22) && generateConfig2.getMonth(date1) === generateConfig2.getMonth(date22);
      }
      function isSameDate2(date1, date22) {
        return isSameMonth2(date1, date22) && generateConfig2.getDate(date1) === generateConfig2.getDate(date22);
      }
      const Calendar2 = (props) => {
        const {
          prefixCls: customizePrefixCls,
          className,
          rootClassName,
          style: style2,
          dateFullCellRender,
          dateCellRender,
          monthFullCellRender,
          monthCellRender,
          cellRender,
          fullCellRender,
          headerRender,
          value,
          defaultValue,
          disabledDate,
          mode,
          validRange,
          fullscreen = true,
          onChange,
          onPanelChange,
          onSelect
        } = props;
        const {
          getPrefixCls,
          direction,
          calendar: calendar2
        } = reactExports.useContext(ConfigContext);
        const prefixCls = getPrefixCls("picker", customizePrefixCls);
        const calendarPrefixCls = `${prefixCls}-calendar`;
        const [wrapCSSVar, hashId] = useStyle$8(prefixCls, calendarPrefixCls);
        const today = generateConfig2.getNow();
        const [mergedValue, setMergedValue] = useMergedState(() => value || generateConfig2.getNow(), {
          defaultValue,
          value
        });
        const [mergedMode, setMergedMode] = useMergedState("month", {
          value: mode
        });
        const panelMode = reactExports.useMemo(() => mergedMode === "year" ? "month" : "date", [mergedMode]);
        const mergedDisabledDate = reactExports.useCallback((date) => {
          const notInRange = validRange ? generateConfig2.isAfter(validRange[0], date) || generateConfig2.isAfter(date, validRange[1]) : false;
          return notInRange || !!(disabledDate === null || disabledDate === void 0 ? void 0 : disabledDate(date));
        }, [disabledDate, validRange]);
        const triggerPanelChange = (date, newMode) => {
          onPanelChange === null || onPanelChange === void 0 ? void 0 : onPanelChange(date, newMode);
        };
        const triggerChange = (date) => {
          setMergedValue(date);
          if (!isSameDate2(date, mergedValue)) {
            if (panelMode === "date" && !isSameMonth2(date, mergedValue) || panelMode === "month" && !isSameYear2(date, mergedValue)) {
              triggerPanelChange(date, mergedMode);
            }
            onChange === null || onChange === void 0 ? void 0 : onChange(date);
          }
        };
        const triggerModeChange = (newMode) => {
          setMergedMode(newMode);
          triggerPanelChange(mergedValue, newMode);
        };
        const onInternalSelect = (date, source) => {
          triggerChange(date);
          onSelect === null || onSelect === void 0 ? void 0 : onSelect(date, {
            source
          });
        };
        const getDefaultLocale = () => {
          const {
            locale: locale2
          } = props;
          const result = Object.assign(Object.assign({}, enUS), locale2);
          result.lang = Object.assign(Object.assign({}, result.lang), (locale2 || {}).lang);
          return result;
        };
        const dateRender = reactExports.useCallback((date, info) => {
          if (fullCellRender) {
            return fullCellRender(date, info);
          }
          if (dateFullCellRender) {
            return dateFullCellRender(date);
          }
          return /* @__PURE__ */ reactExports.createElement("div", {
            className: classNames(`${prefixCls}-cell-inner`, `${calendarPrefixCls}-date`, {
              [`${calendarPrefixCls}-date-today`]: isSameDate2(today, date)
            })
          }, /* @__PURE__ */ reactExports.createElement("div", {
            className: `${calendarPrefixCls}-date-value`
          }, String(generateConfig2.getDate(date)).padStart(2, "0")), /* @__PURE__ */ reactExports.createElement("div", {
            className: `${calendarPrefixCls}-date-content`
          }, cellRender ? cellRender(date, info) : dateCellRender && dateCellRender(date)));
        }, [dateFullCellRender, dateCellRender, cellRender, fullCellRender]);
        const monthRender = reactExports.useCallback((date, info) => {
          if (fullCellRender) {
            return fullCellRender(date, info);
          }
          if (monthFullCellRender) {
            return monthFullCellRender(date);
          }
          const months2 = info.locale.shortMonths || generateConfig2.locale.getShortMonths(info.locale.locale);
          return /* @__PURE__ */ reactExports.createElement("div", {
            className: classNames(`${prefixCls}-cell-inner`, `${calendarPrefixCls}-date`, {
              [`${calendarPrefixCls}-date-today`]: isSameMonth2(today, date)
            })
          }, /* @__PURE__ */ reactExports.createElement("div", {
            className: `${calendarPrefixCls}-date-value`
          }, months2[generateConfig2.getMonth(date)]), /* @__PURE__ */ reactExports.createElement("div", {
            className: `${calendarPrefixCls}-date-content`
          }, cellRender ? cellRender(date, info) : monthCellRender && monthCellRender(date)));
        }, [monthFullCellRender, monthCellRender, cellRender, fullCellRender]);
        const [contextLocale] = useLocale$1("Calendar", getDefaultLocale);
        const mergedCellRender = (current, info) => {
          if (info.type === "date") {
            return dateRender(current, info);
          }
          if (info.type === "month") {
            return monthRender(current, Object.assign(Object.assign({}, info), {
              locale: contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.lang
            }));
          }
        };
        return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("div", {
          className: classNames(calendarPrefixCls, {
            [`${calendarPrefixCls}-full`]: fullscreen,
            [`${calendarPrefixCls}-mini`]: !fullscreen,
            [`${calendarPrefixCls}-rtl`]: direction === "rtl"
          }, calendar2 === null || calendar2 === void 0 ? void 0 : calendar2.className, className, rootClassName, hashId),
          style: Object.assign(Object.assign({}, calendar2 === null || calendar2 === void 0 ? void 0 : calendar2.style), style2)
        }, headerRender ? headerRender({
          value: mergedValue,
          type: mergedMode,
          onChange: (nextDate) => {
            onInternalSelect(nextDate, "customize");
          },
          onTypeChange: triggerModeChange
        }) : /* @__PURE__ */ reactExports.createElement(CalendarHeader, {
          prefixCls: calendarPrefixCls,
          value: mergedValue,
          generateConfig: generateConfig2,
          mode: mergedMode,
          fullscreen,
          locale: contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.lang,
          validRange,
          onChange: onInternalSelect,
          onModeChange: triggerModeChange
        }), /* @__PURE__ */ reactExports.createElement(PickerPanel, {
          value: mergedValue,
          prefixCls,
          locale: contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.lang,
          generateConfig: generateConfig2,
          cellRender: mergedCellRender,
          onSelect: (nextDate) => {
            onInternalSelect(nextDate, panelMode);
          },
          mode: panelMode,
          picker: panelMode,
          disabledDate: mergedDisabledDate,
          hideHeader: true
        })));
      };
      return Calendar2;
    }
    const Calendar = generateCalendar(generateConfig);
    Calendar.generateCalendar = generateCalendar;
    const Calendar$1 = Calendar;
    function throttle(delay, callback, options) {
      var _ref = options || {}, _ref$noTrailing = _ref.noTrailing, noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing, _ref$noLeading = _ref.noLeading, noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading, _ref$debounceMode = _ref.debounceMode, debounceMode = _ref$debounceMode === void 0 ? void 0 : _ref$debounceMode;
      var timeoutID;
      var cancelled = false;
      var lastExec = 0;
      function clearExistingTimeout() {
        if (timeoutID) {
          clearTimeout(timeoutID);
        }
      }
      function cancel(options2) {
        var _ref2 = options2 || {}, _ref2$upcomingOnly = _ref2.upcomingOnly, upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;
        clearExistingTimeout();
        cancelled = !upcomingOnly;
      }
      function wrapper() {
        for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
          arguments_[_key] = arguments[_key];
        }
        var self2 = this;
        var elapsed = Date.now() - lastExec;
        if (cancelled) {
          return;
        }
        function exec() {
          lastExec = Date.now();
          callback.apply(self2, arguments_);
        }
        function clear() {
          timeoutID = void 0;
        }
        if (!noLeading && debounceMode && !timeoutID) {
          exec();
        }
        clearExistingTimeout();
        if (debounceMode === void 0 && elapsed > delay) {
          if (noLeading) {
            lastExec = Date.now();
            if (!noTrailing) {
              timeoutID = setTimeout(debounceMode ? clear : exec, delay);
            }
          } else {
            exec();
          }
        } else if (noTrailing !== true) {
          timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay);
        }
      }
      wrapper.cancel = cancel;
      return wrapper;
    }
    function debounce(delay, callback, options) {
      var _ref = options || {}, _ref$atBegin = _ref.atBegin, atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;
      return throttle(delay, callback, {
        debounceMode: atBegin !== false
      });
    }
    function getEntity(keyEntities, key) {
      return keyEntities[key];
    }
    var _excluded$f = ["children"];
    function getPosition(level, index2) {
      return "".concat(level, "-").concat(index2);
    }
    function isTreeNode(node2) {
      return node2 && node2.type && node2.type.isTreeNode;
    }
    function getKey(key, pos) {
      if (key !== null && key !== void 0) {
        return key;
      }
      return pos;
    }
    function fillFieldNames(fieldNames) {
      var _ref = fieldNames || {}, title = _ref.title, _title = _ref._title, key = _ref.key, children = _ref.children;
      var mergedTitle = title || "title";
      return {
        title: mergedTitle,
        _title: _title || [mergedTitle],
        key: key || "key",
        children: children || "children"
      };
    }
    function convertTreeToData(rootNodes) {
      function dig(node2) {
        var treeNodes = toArray$a(node2);
        return treeNodes.map(function(treeNode) {
          if (!isTreeNode(treeNode)) {
            warningOnce(!treeNode, "Tree/TreeNode can only accept TreeNode as children.");
            return null;
          }
          var key = treeNode.key;
          var _treeNode$props = treeNode.props, children = _treeNode$props.children, rest = _objectWithoutProperties(_treeNode$props, _excluded$f);
          var dataNode = _objectSpread2({
            key
          }, rest);
          var parsedChildren = dig(children);
          if (parsedChildren.length) {
            dataNode.children = parsedChildren;
          }
          return dataNode;
        }).filter(function(dataNode) {
          return dataNode;
        });
      }
      return dig(rootNodes);
    }
    function flattenTreeData(treeNodeList, expandedKeys, fieldNames) {
      var _fillFieldNames = fillFieldNames(fieldNames), fieldTitles = _fillFieldNames._title, fieldKey = _fillFieldNames.key, fieldChildren = _fillFieldNames.children;
      var expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);
      var flattenList = [];
      function dig(list) {
        var parent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        return list.map(function(treeNode, index2) {
          var pos = getPosition(parent ? parent.pos : "0", index2);
          var mergedKey = getKey(treeNode[fieldKey], pos);
          var mergedTitle;
          for (var i = 0; i < fieldTitles.length; i += 1) {
            var fieldTitle = fieldTitles[i];
            if (treeNode[fieldTitle] !== void 0) {
              mergedTitle = treeNode[fieldTitle];
              break;
            }
          }
          var flattenNode = _objectSpread2(_objectSpread2({}, omit(treeNode, [].concat(_toConsumableArray(fieldTitles), [fieldKey, fieldChildren]))), {}, {
            title: mergedTitle,
            key: mergedKey,
            parent,
            pos,
            children: null,
            data: treeNode,
            isStart: [].concat(_toConsumableArray(parent ? parent.isStart : []), [index2 === 0]),
            isEnd: [].concat(_toConsumableArray(parent ? parent.isEnd : []), [index2 === list.length - 1])
          });
          flattenList.push(flattenNode);
          if (expandedKeys === true || expandedKeySet.has(mergedKey)) {
            flattenNode.children = dig(treeNode[fieldChildren] || [], flattenNode);
          } else {
            flattenNode.children = [];
          }
          return flattenNode;
        });
      }
      dig(treeNodeList);
      return flattenList;
    }
    function traverseDataNodes(dataNodes, callback, config) {
      var mergedConfig = {};
      if (_typeof(config) === "object") {
        mergedConfig = config;
      } else {
        mergedConfig = {
          externalGetKey: config
        };
      }
      mergedConfig = mergedConfig || {};
      var _mergedConfig = mergedConfig, childrenPropName = _mergedConfig.childrenPropName, externalGetKey = _mergedConfig.externalGetKey, fieldNames = _mergedConfig.fieldNames;
      var _fillFieldNames2 = fillFieldNames(fieldNames), fieldKey = _fillFieldNames2.key, fieldChildren = _fillFieldNames2.children;
      var mergeChildrenPropName = childrenPropName || fieldChildren;
      var syntheticGetKey;
      if (externalGetKey) {
        if (typeof externalGetKey === "string") {
          syntheticGetKey = function syntheticGetKey2(node2) {
            return node2[externalGetKey];
          };
        } else if (typeof externalGetKey === "function") {
          syntheticGetKey = function syntheticGetKey2(node2) {
            return externalGetKey(node2);
          };
        }
      } else {
        syntheticGetKey = function syntheticGetKey2(node2, pos) {
          return getKey(node2[fieldKey], pos);
        };
      }
      function processNode(node2, index2, parent, pathNodes) {
        var children = node2 ? node2[mergeChildrenPropName] : dataNodes;
        var pos = node2 ? getPosition(parent.pos, index2) : "0";
        var connectNodes = node2 ? [].concat(_toConsumableArray(pathNodes), [node2]) : [];
        if (node2) {
          var key = syntheticGetKey(node2, pos);
          var data = {
            node: node2,
            index: index2,
            pos,
            key,
            parentPos: parent.node ? parent.pos : null,
            level: parent.level + 1,
            nodes: connectNodes
          };
          callback(data);
        }
        if (children) {
          children.forEach(function(subNode, subIndex) {
            processNode(subNode, subIndex, {
              node: node2,
              pos,
              level: parent ? parent.level + 1 : -1
            }, connectNodes);
          });
        }
      }
      processNode(null);
    }
    function convertDataToEntities(dataNodes) {
      var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, initWrapper = _ref2.initWrapper, processEntity = _ref2.processEntity, onProcessFinished = _ref2.onProcessFinished, externalGetKey = _ref2.externalGetKey, childrenPropName = _ref2.childrenPropName, fieldNames = _ref2.fieldNames;
      var legacyExternalGetKey = arguments.length > 2 ? arguments[2] : void 0;
      var mergedExternalGetKey = externalGetKey || legacyExternalGetKey;
      var posEntities = {};
      var keyEntities = {};
      var wrapper = {
        posEntities,
        keyEntities
      };
      if (initWrapper) {
        wrapper = initWrapper(wrapper) || wrapper;
      }
      traverseDataNodes(dataNodes, function(item) {
        var node2 = item.node, index2 = item.index, pos = item.pos, key = item.key, parentPos = item.parentPos, level = item.level, nodes = item.nodes;
        var entity = {
          node: node2,
          nodes,
          index: index2,
          key,
          pos,
          level
        };
        var mergedKey = getKey(key, pos);
        posEntities[pos] = entity;
        keyEntities[mergedKey] = entity;
        entity.parent = posEntities[parentPos];
        if (entity.parent) {
          entity.parent.children = entity.parent.children || [];
          entity.parent.children.push(entity);
        }
        if (processEntity) {
          processEntity(entity, wrapper);
        }
      }, {
        externalGetKey: mergedExternalGetKey,
        childrenPropName,
        fieldNames
      });
      if (onProcessFinished) {
        onProcessFinished(wrapper);
      }
      return wrapper;
    }
    function getTreeNodeProps(key, _ref3) {
      var expandedKeys = _ref3.expandedKeys, selectedKeys = _ref3.selectedKeys, loadedKeys = _ref3.loadedKeys, loadingKeys = _ref3.loadingKeys, checkedKeys = _ref3.checkedKeys, halfCheckedKeys = _ref3.halfCheckedKeys, dragOverNodeKey = _ref3.dragOverNodeKey, dropPosition = _ref3.dropPosition, keyEntities = _ref3.keyEntities;
      var entity = getEntity(keyEntities, key);
      var treeNodeProps = {
        eventKey: key,
        expanded: expandedKeys.indexOf(key) !== -1,
        selected: selectedKeys.indexOf(key) !== -1,
        loaded: loadedKeys.indexOf(key) !== -1,
        loading: loadingKeys.indexOf(key) !== -1,
        checked: checkedKeys.indexOf(key) !== -1,
        halfChecked: halfCheckedKeys.indexOf(key) !== -1,
        pos: String(entity ? entity.pos : ""),
        // [Legacy] Drag props
        // Since the interaction of drag is changed, the semantic of the props are
        // not accuracy, I think it should be finally removed
        dragOver: dragOverNodeKey === key && dropPosition === 0,
        dragOverGapTop: dragOverNodeKey === key && dropPosition === -1,
        dragOverGapBottom: dragOverNodeKey === key && dropPosition === 1
      };
      return treeNodeProps;
    }
    function convertNodePropsToEventData(props) {
      var data = props.data, expanded = props.expanded, selected = props.selected, checked = props.checked, loaded = props.loaded, loading = props.loading, halfChecked = props.halfChecked, dragOver = props.dragOver, dragOverGapTop = props.dragOverGapTop, dragOverGapBottom = props.dragOverGapBottom, pos = props.pos, active = props.active, eventKey = props.eventKey;
      var eventData = _objectSpread2(_objectSpread2({}, data), {}, {
        expanded,
        selected,
        checked,
        loaded,
        loading,
        halfChecked,
        dragOver,
        dragOverGapTop,
        dragOverGapBottom,
        pos,
        active,
        key: eventKey
      });
      if (!("props" in eventData)) {
        Object.defineProperty(eventData, "props", {
          get: function get2() {
            warningOnce(false, "Second param return from event is node data instead of TreeNode instance. Please read value directly instead of reading from `props`.");
            return props;
          }
        });
      }
      return eventData;
    }
    function removeFromCheckedKeys(halfCheckedKeys, checkedKeys) {
      var filteredKeys = /* @__PURE__ */ new Set();
      halfCheckedKeys.forEach(function(key) {
        if (!checkedKeys.has(key)) {
          filteredKeys.add(key);
        }
      });
      return filteredKeys;
    }
    function isCheckDisabled(node2) {
      var _ref = node2 || {}, disabled = _ref.disabled, disableCheckbox = _ref.disableCheckbox, checkable = _ref.checkable;
      return !!(disabled || disableCheckbox) || checkable === false;
    }
    function fillConductCheck(keys2, levelEntities, maxLevel, syntheticGetCheckDisabled) {
      var checkedKeys = new Set(keys2);
      var halfCheckedKeys = /* @__PURE__ */ new Set();
      for (var level = 0; level <= maxLevel; level += 1) {
        var entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
        entities.forEach(function(entity) {
          var key = entity.key, node2 = entity.node, _entity$children = entity.children, children = _entity$children === void 0 ? [] : _entity$children;
          if (checkedKeys.has(key) && !syntheticGetCheckDisabled(node2)) {
            children.filter(function(childEntity) {
              return !syntheticGetCheckDisabled(childEntity.node);
            }).forEach(function(childEntity) {
              checkedKeys.add(childEntity.key);
            });
          }
        });
      }
      var visitedKeys = /* @__PURE__ */ new Set();
      for (var _level = maxLevel; _level >= 0; _level -= 1) {
        var _entities = levelEntities.get(_level) || /* @__PURE__ */ new Set();
        _entities.forEach(function(entity) {
          var parent = entity.parent, node2 = entity.node;
          if (syntheticGetCheckDisabled(node2) || !entity.parent || visitedKeys.has(entity.parent.key)) {
            return;
          }
          if (syntheticGetCheckDisabled(entity.parent.node)) {
            visitedKeys.add(parent.key);
            return;
          }
          var allChecked = true;
          var partialChecked = false;
          (parent.children || []).filter(function(childEntity) {
            return !syntheticGetCheckDisabled(childEntity.node);
          }).forEach(function(_ref2) {
            var key = _ref2.key;
            var checked = checkedKeys.has(key);
            if (allChecked && !checked) {
              allChecked = false;
            }
            if (!partialChecked && (checked || halfCheckedKeys.has(key))) {
              partialChecked = true;
            }
          });
          if (allChecked) {
            checkedKeys.add(parent.key);
          }
          if (partialChecked) {
            halfCheckedKeys.add(parent.key);
          }
          visitedKeys.add(parent.key);
        });
      }
      return {
        checkedKeys: Array.from(checkedKeys),
        halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
      };
    }
    function cleanConductCheck(keys2, halfKeys, levelEntities, maxLevel, syntheticGetCheckDisabled) {
      var checkedKeys = new Set(keys2);
      var halfCheckedKeys = new Set(halfKeys);
      for (var level = 0; level <= maxLevel; level += 1) {
        var entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
        entities.forEach(function(entity) {
          var key = entity.key, node2 = entity.node, _entity$children2 = entity.children, children = _entity$children2 === void 0 ? [] : _entity$children2;
          if (!checkedKeys.has(key) && !halfCheckedKeys.has(key) && !syntheticGetCheckDisabled(node2)) {
            children.filter(function(childEntity) {
              return !syntheticGetCheckDisabled(childEntity.node);
            }).forEach(function(childEntity) {
              checkedKeys.delete(childEntity.key);
            });
          }
        });
      }
      halfCheckedKeys = /* @__PURE__ */ new Set();
      var visitedKeys = /* @__PURE__ */ new Set();
      for (var _level2 = maxLevel; _level2 >= 0; _level2 -= 1) {
        var _entities2 = levelEntities.get(_level2) || /* @__PURE__ */ new Set();
        _entities2.forEach(function(entity) {
          var parent = entity.parent, node2 = entity.node;
          if (syntheticGetCheckDisabled(node2) || !entity.parent || visitedKeys.has(entity.parent.key)) {
            return;
          }
          if (syntheticGetCheckDisabled(entity.parent.node)) {
            visitedKeys.add(parent.key);
            return;
          }
          var allChecked = true;
          var partialChecked = false;
          (parent.children || []).filter(function(childEntity) {
            return !syntheticGetCheckDisabled(childEntity.node);
          }).forEach(function(_ref3) {
            var key = _ref3.key;
            var checked = checkedKeys.has(key);
            if (allChecked && !checked) {
              allChecked = false;
            }
            if (!partialChecked && (checked || halfCheckedKeys.has(key))) {
              partialChecked = true;
            }
          });
          if (!allChecked) {
            checkedKeys.delete(parent.key);
          }
          if (partialChecked) {
            halfCheckedKeys.add(parent.key);
          }
          visitedKeys.add(parent.key);
        });
      }
      return {
        checkedKeys: Array.from(checkedKeys),
        halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
      };
    }
    function conductCheck(keyList, checked, keyEntities, getCheckDisabled) {
      var warningMissKeys = [];
      var syntheticGetCheckDisabled;
      if (getCheckDisabled) {
        syntheticGetCheckDisabled = getCheckDisabled;
      } else {
        syntheticGetCheckDisabled = isCheckDisabled;
      }
      var keys2 = new Set(keyList.filter(function(key) {
        var hasEntity = !!getEntity(keyEntities, key);
        if (!hasEntity) {
          warningMissKeys.push(key);
        }
        return hasEntity;
      }));
      var levelEntities = /* @__PURE__ */ new Map();
      var maxLevel = 0;
      Object.keys(keyEntities).forEach(function(key) {
        var entity = keyEntities[key];
        var level = entity.level;
        var levelSet = levelEntities.get(level);
        if (!levelSet) {
          levelSet = /* @__PURE__ */ new Set();
          levelEntities.set(level, levelSet);
        }
        levelSet.add(entity);
        maxLevel = Math.max(maxLevel, level);
      });
      warningOnce(!warningMissKeys.length, "Tree missing follow keys: ".concat(warningMissKeys.slice(0, 100).map(function(key) {
        return "'".concat(key, "'");
      }).join(", ")));
      var result;
      if (checked === true) {
        result = fillConductCheck(keys2, levelEntities, maxLevel, syntheticGetCheckDisabled);
      } else {
        result = cleanConductCheck(keys2, checked.halfCheckedKeys, levelEntities, maxLevel, syntheticGetCheckDisabled);
      }
      return result;
    }
    const genCheckboxStyle = (token2) => {
      const {
        checkboxCls
      } = token2;
      const wrapperCls = `${checkboxCls}-wrapper`;
      return [
        // ===================== Basic =====================
        {
          // Group
          [`${checkboxCls}-group`]: Object.assign(Object.assign({}, resetComponent(token2)), {
            display: "inline-flex",
            flexWrap: "wrap",
            columnGap: token2.marginXS,
            // Group > Grid
            [`> ${token2.antCls}-row`]: {
              flex: 1
            }
          }),
          // Wrapper
          [wrapperCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
            display: "inline-flex",
            alignItems: "baseline",
            cursor: "pointer",
            // Fix checkbox & radio in flex align #30260
            "&:after": {
              display: "inline-block",
              width: 0,
              overflow: "hidden",
              content: "'\\a0'"
            },
            // Checkbox near checkbox
            [`& + ${wrapperCls}`]: {
              marginInlineStart: 0
            },
            [`&${wrapperCls}-in-form-item`]: {
              'input[type="checkbox"]': {
                width: 14,
                // FIXME: magic
                height: 14
                // FIXME: magic
              }
            }
          }),
          // Wrapper > Checkbox
          [checkboxCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
            position: "relative",
            whiteSpace: "nowrap",
            lineHeight: 1,
            cursor: "pointer",
            borderRadius: token2.borderRadiusSM,
            // To make alignment right when `controlHeight` is changed
            // Ref: https://github.com/ant-design/ant-design/issues/41564
            alignSelf: "center",
            // Wrapper > Checkbox > input
            [`${checkboxCls}-input`]: {
              position: "absolute",
              // Since baseline align will get additional space offset,
              // we need to move input to top to make it align with text.
              // Ref: https://github.com/ant-design/ant-design/issues/38926#issuecomment-1486137799
              inset: 0,
              zIndex: 1,
              cursor: "pointer",
              opacity: 0,
              margin: 0,
              [`&:focus-visible + ${checkboxCls}-inner`]: Object.assign({}, genFocusOutline(token2))
            },
            // Wrapper > Checkbox > inner
            [`${checkboxCls}-inner`]: {
              boxSizing: "border-box",
              position: "relative",
              top: 0,
              insetInlineStart: 0,
              display: "block",
              width: token2.checkboxSize,
              height: token2.checkboxSize,
              direction: "ltr",
              backgroundColor: token2.colorBgContainer,
              border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
              borderRadius: token2.borderRadiusSM,
              borderCollapse: "separate",
              transition: `all ${token2.motionDurationSlow}`,
              "&:after": {
                boxSizing: "border-box",
                position: "absolute",
                top: "50%",
                insetInlineStart: "21.5%",
                display: "table",
                width: token2.calc(token2.checkboxSize).div(14).mul(5).equal(),
                height: token2.calc(token2.checkboxSize).div(14).mul(8).equal(),
                border: `${unit$1(token2.lineWidthBold)} solid ${token2.colorWhite}`,
                borderTop: 0,
                borderInlineStart: 0,
                transform: "rotate(45deg) scale(0) translate(-50%,-50%)",
                opacity: 0,
                content: '""',
                transition: `all ${token2.motionDurationFast} ${token2.motionEaseInBack}, opacity ${token2.motionDurationFast}`
              }
            },
            // Wrapper > Checkbox + Text
            "& + span": {
              paddingInlineStart: token2.paddingXS,
              paddingInlineEnd: token2.paddingXS
            }
          })
        },
        // ===================== Hover =====================
        {
          // Wrapper & Wrapper > Checkbox
          [`
        ${wrapperCls}:not(${wrapperCls}-disabled),
        ${checkboxCls}:not(${checkboxCls}-disabled)
      `]: {
            [`&:hover ${checkboxCls}-inner`]: {
              borderColor: token2.colorPrimary
            }
          },
          [`${wrapperCls}:not(${wrapperCls}-disabled)`]: {
            [`&:hover ${checkboxCls}-checked:not(${checkboxCls}-disabled) ${checkboxCls}-inner`]: {
              backgroundColor: token2.colorPrimaryHover,
              borderColor: "transparent"
            },
            [`&:hover ${checkboxCls}-checked:not(${checkboxCls}-disabled):after`]: {
              borderColor: token2.colorPrimaryHover
            }
          }
        },
        // ==================== Checked ====================
        {
          // Wrapper > Checkbox
          [`${checkboxCls}-checked`]: {
            [`${checkboxCls}-inner`]: {
              backgroundColor: token2.colorPrimary,
              borderColor: token2.colorPrimary,
              "&:after": {
                opacity: 1,
                transform: "rotate(45deg) scale(1) translate(-50%,-50%)",
                transition: `all ${token2.motionDurationMid} ${token2.motionEaseOutBack} ${token2.motionDurationFast}`
              }
            }
          },
          [`
        ${wrapperCls}-checked:not(${wrapperCls}-disabled),
        ${checkboxCls}-checked:not(${checkboxCls}-disabled)
      `]: {
            [`&:hover ${checkboxCls}-inner`]: {
              backgroundColor: token2.colorPrimaryHover,
              borderColor: "transparent"
            }
          }
        },
        // ================= Indeterminate =================
        {
          [checkboxCls]: {
            "&-indeterminate": {
              // Wrapper > Checkbox > inner
              [`${checkboxCls}-inner`]: {
                backgroundColor: token2.colorBgContainer,
                borderColor: token2.colorBorder,
                "&:after": {
                  top: "50%",
                  insetInlineStart: "50%",
                  width: token2.calc(token2.fontSizeLG).div(2).equal(),
                  height: token2.calc(token2.fontSizeLG).div(2).equal(),
                  backgroundColor: token2.colorPrimary,
                  border: 0,
                  transform: "translate(-50%, -50%) scale(1)",
                  opacity: 1,
                  content: '""'
                }
              }
            }
          }
        },
        // ==================== Disable ====================
        {
          // Wrapper
          [`${wrapperCls}-disabled`]: {
            cursor: "not-allowed"
          },
          // Wrapper > Checkbox
          [`${checkboxCls}-disabled`]: {
            // Wrapper > Checkbox > input
            [`&, ${checkboxCls}-input`]: {
              cursor: "not-allowed",
              // Disabled for native input to enable Tooltip event handler
              // ref: https://github.com/ant-design/ant-design/issues/39822#issuecomment-1365075901
              pointerEvents: "none"
            },
            // Wrapper > Checkbox > inner
            [`${checkboxCls}-inner`]: {
              background: token2.colorBgContainerDisabled,
              borderColor: token2.colorBorder,
              "&:after": {
                borderColor: token2.colorTextDisabled
              }
            },
            "&:after": {
              display: "none"
            },
            "& + span": {
              color: token2.colorTextDisabled
            },
            [`&${checkboxCls}-indeterminate ${checkboxCls}-inner::after`]: {
              background: token2.colorTextDisabled
            }
          }
        }
      ];
    };
    function getStyle(prefixCls, token2) {
      const checkboxToken = merge$1(token2, {
        checkboxCls: `.${prefixCls}`,
        checkboxSize: token2.controlInteractiveSize
      });
      return [genCheckboxStyle(checkboxToken)];
    }
    const useStyle$7 = genStyleHooks("Checkbox", (token2, _ref) => {
      let {
        prefixCls
      } = _ref;
      return [getStyle(prefixCls, token2)];
    });
    const GroupContext = /* @__PURE__ */ React.createContext(null);
    const GroupContext$1 = GroupContext;
    var __rest$m = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const InternalCheckbox = (props, ref) => {
      var _a;
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        children,
        indeterminate = false,
        style: style2,
        onMouseEnter,
        onMouseLeave,
        skipGroup = false,
        disabled
      } = props, restProps = __rest$m(props, ["prefixCls", "className", "rootClassName", "children", "indeterminate", "style", "onMouseEnter", "onMouseLeave", "skipGroup", "disabled"]);
      const {
        getPrefixCls,
        direction,
        checkbox
      } = reactExports.useContext(ConfigContext);
      const checkboxGroup = reactExports.useContext(GroupContext$1);
      const {
        isFormItemInput
      } = reactExports.useContext(FormItemInputContext);
      const contextDisabled = reactExports.useContext(DisabledContext$1);
      const mergedDisabled = (_a = (checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.disabled) || disabled) !== null && _a !== void 0 ? _a : contextDisabled;
      const prevValue = reactExports.useRef(restProps.value);
      reactExports.useEffect(() => {
        checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.registerValue(restProps.value);
      }, []);
      reactExports.useEffect(() => {
        if (skipGroup) {
          return;
        }
        if (restProps.value !== prevValue.current) {
          checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.cancelValue(prevValue.current);
          checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.registerValue(restProps.value);
          prevValue.current = restProps.value;
        }
        return () => checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.cancelValue(restProps.value);
      }, [restProps.value]);
      const prefixCls = getPrefixCls("checkbox", customizePrefixCls);
      const rootCls = useCSSVarCls$1(prefixCls);
      const [wrapCSSVar, hashId] = useStyle$7(prefixCls, rootCls);
      const checkboxProps = Object.assign({}, restProps);
      if (checkboxGroup && !skipGroup) {
        checkboxProps.onChange = function() {
          if (restProps.onChange) {
            restProps.onChange.apply(restProps, arguments);
          }
          if (checkboxGroup.toggleOption) {
            checkboxGroup.toggleOption({
              label: children,
              value: restProps.value
            });
          }
        };
        checkboxProps.name = checkboxGroup.name;
        checkboxProps.checked = checkboxGroup.value.includes(restProps.value);
      }
      const classString = classNames(`${prefixCls}-wrapper`, {
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-wrapper-checked`]: checkboxProps.checked,
        [`${prefixCls}-wrapper-disabled`]: mergedDisabled,
        [`${prefixCls}-wrapper-in-form-item`]: isFormItemInput
      }, checkbox === null || checkbox === void 0 ? void 0 : checkbox.className, className, rootClassName, rootCls, hashId);
      const checkboxClass = classNames({
        [`${prefixCls}-indeterminate`]: indeterminate
      }, TARGET_CLS, hashId);
      const ariaChecked = indeterminate ? "mixed" : void 0;
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(Wave$1, {
        component: "Checkbox",
        disabled: mergedDisabled
      }, /* @__PURE__ */ reactExports.createElement("label", {
        className: classString,
        style: Object.assign(Object.assign({}, checkbox === null || checkbox === void 0 ? void 0 : checkbox.style), style2),
        onMouseEnter,
        onMouseLeave
      }, /* @__PURE__ */ reactExports.createElement(Checkbox$3, Object.assign({
        "aria-checked": ariaChecked
      }, checkboxProps, {
        prefixCls,
        className: checkboxClass,
        disabled: mergedDisabled,
        ref
      })), children !== void 0 && /* @__PURE__ */ reactExports.createElement("span", null, children))));
    };
    const Checkbox$2 = /* @__PURE__ */ reactExports.forwardRef(InternalCheckbox);
    const InternalCheckbox$1 = Checkbox$2;
    var __rest$l = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const InternalGroup = (props, ref) => {
      const {
        defaultValue,
        children,
        options = [],
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        style: style2,
        onChange
      } = props, restProps = __rest$l(props, ["defaultValue", "children", "options", "prefixCls", "className", "rootClassName", "style", "onChange"]);
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const [value, setValue] = reactExports.useState(restProps.value || defaultValue || []);
      const [registeredValues, setRegisteredValues] = reactExports.useState([]);
      reactExports.useEffect(() => {
        if ("value" in restProps) {
          setValue(restProps.value || []);
        }
      }, [restProps.value]);
      const memoOptions = reactExports.useMemo(() => options.map((option) => {
        if (typeof option === "string" || typeof option === "number") {
          return {
            label: option,
            value: option
          };
        }
        return option;
      }), [options]);
      const cancelValue = (val) => {
        setRegisteredValues((prevValues) => prevValues.filter((v2) => v2 !== val));
      };
      const registerValue = (val) => {
        setRegisteredValues((prevValues) => [].concat(_toConsumableArray(prevValues), [val]));
      };
      const toggleOption = (option) => {
        const optionIndex = value.indexOf(option.value);
        const newValue = _toConsumableArray(value);
        if (optionIndex === -1) {
          newValue.push(option.value);
        } else {
          newValue.splice(optionIndex, 1);
        }
        if (!("value" in restProps)) {
          setValue(newValue);
        }
        onChange === null || onChange === void 0 ? void 0 : onChange(newValue.filter((val) => registeredValues.includes(val)).sort((a, b2) => {
          const indexA = memoOptions.findIndex((opt) => opt.value === a);
          const indexB = memoOptions.findIndex((opt) => opt.value === b2);
          return indexA - indexB;
        }));
      };
      const prefixCls = getPrefixCls("checkbox", customizePrefixCls);
      const groupPrefixCls = `${prefixCls}-group`;
      const rootCls = useCSSVarCls$1(prefixCls);
      const [wrapCSSVar, hashId] = useStyle$7(prefixCls, rootCls);
      const domProps = omit(restProps, ["value", "disabled"]);
      const childrenNode = options.length ? memoOptions.map((option) => /* @__PURE__ */ reactExports.createElement(InternalCheckbox$1, {
        prefixCls,
        key: option.value.toString(),
        disabled: "disabled" in option ? option.disabled : restProps.disabled,
        value: option.value,
        checked: value.includes(option.value),
        onChange: option.onChange,
        className: `${groupPrefixCls}-item`,
        style: option.style,
        title: option.title,
        id: option.id,
        required: option.required
      }, option.label)) : children;
      const context = {
        toggleOption,
        value,
        disabled: restProps.disabled,
        name: restProps.name,
        // https://github.com/ant-design/ant-design/issues/16376
        registerValue,
        cancelValue
      };
      const classString = classNames(groupPrefixCls, {
        [`${groupPrefixCls}-rtl`]: direction === "rtl"
      }, className, rootClassName, rootCls, hashId);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("div", Object.assign({
        className: classString,
        style: style2
      }, domProps, {
        ref
      }), /* @__PURE__ */ reactExports.createElement(GroupContext$1.Provider, {
        value: context
      }, childrenNode)));
    };
    const CheckboxGroup = /* @__PURE__ */ reactExports.forwardRef(InternalGroup);
    const Group$2 = /* @__PURE__ */ reactExports.memo(CheckboxGroup);
    const Checkbox = InternalCheckbox$1;
    Checkbox.Group = Group$2;
    Checkbox.__ANT_CHECKBOX = true;
    const Checkbox$1 = Checkbox;
    const RowContext = /* @__PURE__ */ reactExports.createContext({});
    const RowContext$1 = RowContext;
    const genGridRowStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        // Grid system
        [componentCls]: {
          display: "flex",
          flexFlow: "row wrap",
          minWidth: 0,
          "&::before, &::after": {
            display: "flex"
          },
          "&-no-wrap": {
            flexWrap: "nowrap"
          },
          // The origin of the X-axis
          "&-start": {
            justifyContent: "flex-start"
          },
          // The center of the X-axis
          "&-center": {
            justifyContent: "center"
          },
          // The opposite of the X-axis
          "&-end": {
            justifyContent: "flex-end"
          },
          "&-space-between": {
            justifyContent: "space-between"
          },
          "&-space-around": {
            justifyContent: "space-around"
          },
          "&-space-evenly": {
            justifyContent: "space-evenly"
          },
          // Align at the top
          "&-top": {
            alignItems: "flex-start"
          },
          // Align at the center
          "&-middle": {
            alignItems: "center"
          },
          "&-bottom": {
            alignItems: "flex-end"
          }
        }
      };
    };
    const genGridColStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        // Grid system
        [componentCls]: {
          position: "relative",
          maxWidth: "100%",
          // Prevent columns from collapsing when empty
          minHeight: 1
        }
      };
    };
    const genLoopGridColumnsStyle = (token2, sizeCls) => {
      const {
        componentCls,
        gridColumns
      } = token2;
      const gridColumnsStyle = {};
      for (let i = gridColumns; i >= 0; i--) {
        if (i === 0) {
          gridColumnsStyle[`${componentCls}${sizeCls}-${i}`] = {
            display: "none"
          };
          gridColumnsStyle[`${componentCls}-push-${i}`] = {
            insetInlineStart: "auto"
          };
          gridColumnsStyle[`${componentCls}-pull-${i}`] = {
            insetInlineEnd: "auto"
          };
          gridColumnsStyle[`${componentCls}${sizeCls}-push-${i}`] = {
            insetInlineStart: "auto"
          };
          gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i}`] = {
            insetInlineEnd: "auto"
          };
          gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i}`] = {
            marginInlineStart: 0
          };
          gridColumnsStyle[`${componentCls}${sizeCls}-order-${i}`] = {
            order: 0
          };
        } else {
          gridColumnsStyle[`${componentCls}${sizeCls}-${i}`] = [
            // https://github.com/ant-design/ant-design/issues/44456
            // Form set `display: flex` on Col which will override `display: block`.
            // Let's get it from css variable to support override.
            {
              ["--ant-display"]: "block",
              // Fallback to display if variable not support
              display: "block"
            },
            {
              display: "var(--ant-display)",
              flex: `0 0 ${i / gridColumns * 100}%`,
              maxWidth: `${i / gridColumns * 100}%`
            }
          ];
          gridColumnsStyle[`${componentCls}${sizeCls}-push-${i}`] = {
            insetInlineStart: `${i / gridColumns * 100}%`
          };
          gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i}`] = {
            insetInlineEnd: `${i / gridColumns * 100}%`
          };
          gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i}`] = {
            marginInlineStart: `${i / gridColumns * 100}%`
          };
          gridColumnsStyle[`${componentCls}${sizeCls}-order-${i}`] = {
            order: i
          };
        }
      }
      return gridColumnsStyle;
    };
    const genGridStyle = (token2, sizeCls) => genLoopGridColumnsStyle(token2, sizeCls);
    const genGridMediaStyle = (token2, screenSize, sizeCls) => ({
      [`@media (min-width: ${unit$1(screenSize)})`]: Object.assign({}, genGridStyle(token2, sizeCls))
    });
    const prepareRowComponentToken = () => ({});
    const prepareColComponentToken = () => ({});
    const useRowStyle = genStyleHooks("Grid", genGridRowStyle, prepareRowComponentToken);
    const useColStyle = genStyleHooks("Grid", (token2) => {
      const gridToken = merge$1(token2, {
        gridColumns: 24
        // Row is divided into 24 parts in Grid
      });
      const gridMediaSizesMap = {
        "-sm": gridToken.screenSMMin,
        "-md": gridToken.screenMDMin,
        "-lg": gridToken.screenLGMin,
        "-xl": gridToken.screenXLMin,
        "-xxl": gridToken.screenXXLMin
      };
      return [genGridColStyle(gridToken), genGridStyle(gridToken, ""), genGridStyle(gridToken, "-xs"), Object.keys(gridMediaSizesMap).map((key) => genGridMediaStyle(gridToken, gridMediaSizesMap[key], key)).reduce((pre, cur) => Object.assign(Object.assign({}, pre), cur), {})];
    }, prepareColComponentToken);
    var __rest$k = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    function parseFlex(flex) {
      if (typeof flex === "number") {
        return `${flex} ${flex} auto`;
      }
      if (/^\d+(\.\d+)?(px|em|rem|%)$/.test(flex)) {
        return `0 0 ${flex}`;
      }
      return flex;
    }
    const sizes = ["xs", "sm", "md", "lg", "xl", "xxl"];
    const Col = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const {
        gutter,
        wrap
      } = reactExports.useContext(RowContext$1);
      const {
        prefixCls: customizePrefixCls,
        span,
        order,
        offset: offset2,
        push,
        pull,
        className,
        children,
        flex,
        style: style2
      } = props, others = __rest$k(props, ["prefixCls", "span", "order", "offset", "push", "pull", "className", "children", "flex", "style"]);
      const prefixCls = getPrefixCls("col", customizePrefixCls);
      const [wrapCSSVar, hashId] = useColStyle(prefixCls);
      let sizeClassObj = {};
      sizes.forEach((size) => {
        let sizeProps = {};
        const propSize = props[size];
        if (typeof propSize === "number") {
          sizeProps.span = propSize;
        } else if (typeof propSize === "object") {
          sizeProps = propSize || {};
        }
        delete others[size];
        sizeClassObj = Object.assign(Object.assign({}, sizeClassObj), {
          [`${prefixCls}-${size}-${sizeProps.span}`]: sizeProps.span !== void 0,
          [`${prefixCls}-${size}-order-${sizeProps.order}`]: sizeProps.order || sizeProps.order === 0,
          [`${prefixCls}-${size}-offset-${sizeProps.offset}`]: sizeProps.offset || sizeProps.offset === 0,
          [`${prefixCls}-${size}-push-${sizeProps.push}`]: sizeProps.push || sizeProps.push === 0,
          [`${prefixCls}-${size}-pull-${sizeProps.pull}`]: sizeProps.pull || sizeProps.pull === 0,
          [`${prefixCls}-${size}-flex-${sizeProps.flex}`]: sizeProps.flex || sizeProps.flex === "auto",
          [`${prefixCls}-rtl`]: direction === "rtl"
        });
      });
      const classes = classNames(prefixCls, {
        [`${prefixCls}-${span}`]: span !== void 0,
        [`${prefixCls}-order-${order}`]: order,
        [`${prefixCls}-offset-${offset2}`]: offset2,
        [`${prefixCls}-push-${push}`]: push,
        [`${prefixCls}-pull-${pull}`]: pull
      }, className, sizeClassObj, hashId);
      const mergedStyle = {};
      if (gutter && gutter[0] > 0) {
        const horizontalGutter = gutter[0] / 2;
        mergedStyle.paddingLeft = horizontalGutter;
        mergedStyle.paddingRight = horizontalGutter;
      }
      if (flex) {
        mergedStyle.flex = parseFlex(flex);
        if (wrap === false && !mergedStyle.minWidth) {
          mergedStyle.minWidth = 0;
        }
      }
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("div", Object.assign({}, others, {
        style: Object.assign(Object.assign({}, mergedStyle), style2),
        className: classes,
        ref
      }), children));
    });
    const Col$1 = Col;
    var __rest$j = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    function useMergePropByScreen(oriProp, screen) {
      const [prop, setProp] = reactExports.useState(typeof oriProp === "string" ? oriProp : "");
      const calcMergeAlignOrJustify = () => {
        if (typeof oriProp === "string") {
          setProp(oriProp);
        }
        if (typeof oriProp !== "object") {
          return;
        }
        for (let i = 0; i < responsiveArray.length; i++) {
          const breakpoint = responsiveArray[i];
          if (!screen[breakpoint]) {
            continue;
          }
          const curVal = oriProp[breakpoint];
          if (curVal !== void 0) {
            setProp(curVal);
            return;
          }
        }
      };
      reactExports.useEffect(() => {
        calcMergeAlignOrJustify();
      }, [JSON.stringify(oriProp), screen]);
      return prop;
    }
    const Row = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        prefixCls: customizePrefixCls,
        justify,
        align,
        className,
        style: style2,
        children,
        gutter = 0,
        wrap
      } = props, others = __rest$j(props, ["prefixCls", "justify", "align", "className", "style", "children", "gutter", "wrap"]);
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const [screens, setScreens] = reactExports.useState({
        xs: true,
        sm: true,
        md: true,
        lg: true,
        xl: true,
        xxl: true
      });
      const [curScreens, setCurScreens] = reactExports.useState({
        xs: false,
        sm: false,
        md: false,
        lg: false,
        xl: false,
        xxl: false
      });
      const mergeAlign = useMergePropByScreen(align, curScreens);
      const mergeJustify = useMergePropByScreen(justify, curScreens);
      const gutterRef = reactExports.useRef(gutter);
      const responsiveObserver = useResponsiveObserver();
      reactExports.useEffect(() => {
        const token2 = responsiveObserver.subscribe((screen) => {
          setCurScreens(screen);
          const currentGutter = gutterRef.current || 0;
          if (!Array.isArray(currentGutter) && typeof currentGutter === "object" || Array.isArray(currentGutter) && (typeof currentGutter[0] === "object" || typeof currentGutter[1] === "object")) {
            setScreens(screen);
          }
        });
        return () => responsiveObserver.unsubscribe(token2);
      }, []);
      const getGutter = () => {
        const results = [void 0, void 0];
        const normalizedGutter = Array.isArray(gutter) ? gutter : [gutter, void 0];
        normalizedGutter.forEach((g2, index2) => {
          if (typeof g2 === "object") {
            for (let i = 0; i < responsiveArray.length; i++) {
              const breakpoint = responsiveArray[i];
              if (screens[breakpoint] && g2[breakpoint] !== void 0) {
                results[index2] = g2[breakpoint];
                break;
              }
            }
          } else {
            results[index2] = g2;
          }
        });
        return results;
      };
      const prefixCls = getPrefixCls("row", customizePrefixCls);
      const [wrapCSSVar, hashId] = useRowStyle(prefixCls);
      const gutters = getGutter();
      const classes = classNames(prefixCls, {
        [`${prefixCls}-no-wrap`]: wrap === false,
        [`${prefixCls}-${mergeJustify}`]: mergeJustify,
        [`${prefixCls}-${mergeAlign}`]: mergeAlign,
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, className, hashId);
      const rowStyle = {};
      const horizontalGutter = gutters[0] != null && gutters[0] > 0 ? gutters[0] / -2 : void 0;
      if (horizontalGutter) {
        rowStyle.marginLeft = horizontalGutter;
        rowStyle.marginRight = horizontalGutter;
      }
      [, rowStyle.rowGap] = gutters;
      const [gutterH, gutterV] = gutters;
      const rowContext = reactExports.useMemo(() => ({
        gutter: [gutterH, gutterV],
        wrap
      }), [gutterH, gutterV, wrap]);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(RowContext$1.Provider, {
        value: rowContext
      }, /* @__PURE__ */ reactExports.createElement("div", Object.assign({}, others, {
        className: classes,
        style: Object.assign(Object.assign({}, rowStyle), style2),
        ref
      }), children)));
    });
    const Row$1 = Row;
    function hasAddon(props) {
      return !!(props.addonBefore || props.addonAfter);
    }
    function hasPrefixSuffix$1(props) {
      return !!(props.prefix || props.suffix || props.allowClear);
    }
    function resolveOnChange(target, e2, onChange, targetValue) {
      if (!onChange) {
        return;
      }
      var event = e2;
      if (e2.type === "click") {
        var currentTarget = target.cloneNode(true);
        event = Object.create(e2, {
          target: {
            value: currentTarget
          },
          currentTarget: {
            value: currentTarget
          }
        });
        currentTarget.value = "";
        onChange(event);
        return;
      }
      if (targetValue !== void 0) {
        var _currentTarget = target.cloneNode(true);
        event = Object.create(e2, {
          target: {
            value: _currentTarget
          },
          currentTarget: {
            value: _currentTarget
          }
        });
        if (_currentTarget.type !== "file") {
          _currentTarget.value = targetValue;
        }
        onChange(event);
        return;
      }
      onChange(event);
    }
    function triggerFocus$1(element, option) {
      if (!element)
        return;
      element.focus(option);
      var _ref = option || {}, cursor = _ref.cursor;
      if (cursor) {
        var len = element.value.length;
        switch (cursor) {
          case "start":
            element.setSelectionRange(0, 0);
            break;
          case "end":
            element.setSelectionRange(len, len);
            break;
          default:
            element.setSelectionRange(0, len);
        }
      }
    }
    var BaseInput = function BaseInput2(props) {
      var _inputElement$props, _inputElement$props2;
      var inputElement = props.inputElement, prefixCls = props.prefixCls, prefix = props.prefix, suffix = props.suffix, addonBefore = props.addonBefore, addonAfter = props.addonAfter, className = props.className, style2 = props.style, disabled = props.disabled, readOnly = props.readOnly, focused = props.focused, triggerFocus2 = props.triggerFocus, allowClear = props.allowClear, value = props.value, handleReset = props.handleReset, hidden = props.hidden, classes = props.classes, classNames$1 = props.classNames, dataAttrs = props.dataAttrs, styles = props.styles, components = props.components;
      var AffixWrapperComponent = (components === null || components === void 0 ? void 0 : components.affixWrapper) || "span";
      var GroupWrapperComponent = (components === null || components === void 0 ? void 0 : components.groupWrapper) || "span";
      var WrapperComponent = (components === null || components === void 0 ? void 0 : components.wrapper) || "span";
      var GroupAddonComponent = (components === null || components === void 0 ? void 0 : components.groupAddon) || "span";
      var containerRef = reactExports.useRef(null);
      var onInputClick = function onInputClick2(e2) {
        var _containerRef$current;
        if ((_containerRef$current = containerRef.current) !== null && _containerRef$current !== void 0 && _containerRef$current.contains(e2.target)) {
          triggerFocus2 === null || triggerFocus2 === void 0 || triggerFocus2();
        }
      };
      var getClearIcon2 = function getClearIcon3() {
        var _clsx;
        if (!allowClear) {
          return null;
        }
        var needClear = !disabled && !readOnly && value;
        var clearIconCls = "".concat(prefixCls, "-clear-icon");
        var iconNode = _typeof(allowClear) === "object" && allowClear !== null && allowClear !== void 0 && allowClear.clearIcon ? allowClear.clearIcon : "✖";
        return /* @__PURE__ */ React.createElement("span", {
          onClick: handleReset,
          onMouseDown: function onMouseDown(e2) {
            return e2.preventDefault();
          },
          className: classNames(clearIconCls, (_clsx = {}, _defineProperty(_clsx, "".concat(clearIconCls, "-hidden"), !needClear), _defineProperty(_clsx, "".concat(clearIconCls, "-has-suffix"), !!suffix), _clsx)),
          role: "button",
          tabIndex: -1
        }, iconNode);
      };
      var element = /* @__PURE__ */ reactExports.cloneElement(inputElement, {
        value,
        hidden,
        className: classNames((_inputElement$props = inputElement.props) === null || _inputElement$props === void 0 ? void 0 : _inputElement$props.className, !hasPrefixSuffix$1(props) && !hasAddon(props) && className) || null,
        style: _objectSpread2(_objectSpread2({}, (_inputElement$props2 = inputElement.props) === null || _inputElement$props2 === void 0 ? void 0 : _inputElement$props2.style), !hasPrefixSuffix$1(props) && !hasAddon(props) ? style2 : {})
      });
      if (hasPrefixSuffix$1(props)) {
        var _clsx2;
        var affixWrapperPrefixCls = "".concat(prefixCls, "-affix-wrapper");
        var affixWrapperCls = classNames(affixWrapperPrefixCls, (_clsx2 = {}, _defineProperty(_clsx2, "".concat(affixWrapperPrefixCls, "-disabled"), disabled), _defineProperty(_clsx2, "".concat(affixWrapperPrefixCls, "-focused"), focused), _defineProperty(_clsx2, "".concat(affixWrapperPrefixCls, "-readonly"), readOnly), _defineProperty(_clsx2, "".concat(affixWrapperPrefixCls, "-input-with-clear-btn"), suffix && allowClear && value), _clsx2), !hasAddon(props) && className, classes === null || classes === void 0 ? void 0 : classes.affixWrapper, classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.affixWrapper);
        var suffixNode = (suffix || allowClear) && /* @__PURE__ */ React.createElement("span", {
          className: classNames("".concat(prefixCls, "-suffix"), classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.suffix),
          style: styles === null || styles === void 0 ? void 0 : styles.suffix
        }, getClearIcon2(), suffix);
        element = /* @__PURE__ */ React.createElement(AffixWrapperComponent, _extends$1({
          className: affixWrapperCls,
          style: _objectSpread2(_objectSpread2({}, !hasAddon(props) ? style2 : void 0), styles === null || styles === void 0 ? void 0 : styles.affixWrapper),
          hidden: !hasAddon(props) && hidden,
          onClick: onInputClick
        }, dataAttrs === null || dataAttrs === void 0 ? void 0 : dataAttrs.affixWrapper, {
          ref: containerRef
        }), prefix && /* @__PURE__ */ React.createElement("span", {
          className: classNames("".concat(prefixCls, "-prefix"), classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.prefix),
          style: styles === null || styles === void 0 ? void 0 : styles.prefix
        }, prefix), /* @__PURE__ */ reactExports.cloneElement(inputElement, {
          value,
          hidden: null
        }), suffixNode);
      }
      if (hasAddon(props)) {
        var wrapperCls = "".concat(prefixCls, "-group");
        var addonCls = "".concat(wrapperCls, "-addon");
        var mergedWrapperClassName = classNames("".concat(prefixCls, "-wrapper"), wrapperCls, classes === null || classes === void 0 ? void 0 : classes.wrapper);
        var mergedGroupClassName = classNames("".concat(prefixCls, "-group-wrapper"), className, classes === null || classes === void 0 ? void 0 : classes.group);
        return /* @__PURE__ */ React.createElement(GroupWrapperComponent, {
          className: mergedGroupClassName,
          style: style2,
          hidden
        }, /* @__PURE__ */ React.createElement(WrapperComponent, {
          className: mergedWrapperClassName
        }, addonBefore && /* @__PURE__ */ React.createElement(GroupAddonComponent, {
          className: addonCls
        }, addonBefore), /* @__PURE__ */ reactExports.cloneElement(element, {
          hidden: null
        }), addonAfter && /* @__PURE__ */ React.createElement(GroupAddonComponent, {
          className: addonCls
        }, addonAfter)));
      }
      return element;
    };
    var _excluded$e = ["show"];
    function useCount(count, showCount) {
      return reactExports.useMemo(function() {
        var mergedConfig = {};
        if (showCount) {
          mergedConfig.show = _typeof(showCount) === "object" && showCount.formatter ? showCount.formatter : !!showCount;
        }
        mergedConfig = _objectSpread2(_objectSpread2({}, mergedConfig), count);
        var _ref = mergedConfig, show = _ref.show, rest = _objectWithoutProperties(_ref, _excluded$e);
        return _objectSpread2(_objectSpread2({}, rest), {}, {
          show: !!show,
          showFormatter: typeof show === "function" ? show : void 0,
          strategy: rest.strategy || function(value) {
            return value.length;
          }
        });
      }, [count, showCount]);
    }
    var _excluded$d = ["autoComplete", "onChange", "onFocus", "onBlur", "onPressEnter", "onKeyDown", "prefixCls", "disabled", "htmlSize", "className", "maxLength", "suffix", "showCount", "count", "type", "classes", "classNames", "styles", "onCompositionStart", "onCompositionEnd"];
    var Input$3 = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var autoComplete = props.autoComplete, onChange = props.onChange, onFocus = props.onFocus, onBlur = props.onBlur, onPressEnter = props.onPressEnter, onKeyDown2 = props.onKeyDown, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-input" : _props$prefixCls, disabled = props.disabled, htmlSize = props.htmlSize, className = props.className, maxLength = props.maxLength, suffix = props.suffix, showCount = props.showCount, count = props.count, _props$type = props.type, type = _props$type === void 0 ? "text" : _props$type, classes = props.classes, classNames$1 = props.classNames, styles = props.styles, _onCompositionStart = props.onCompositionStart, onCompositionEnd = props.onCompositionEnd, rest = _objectWithoutProperties(props, _excluded$d);
      var _useState = reactExports.useState(false), _useState2 = _slicedToArray(_useState, 2), focused = _useState2[0], setFocused = _useState2[1];
      var compositionRef = React.useRef(false);
      var inputRef = reactExports.useRef(null);
      var focus = function focus2(option) {
        if (inputRef.current) {
          triggerFocus$1(inputRef.current, option);
        }
      };
      var _useMergedState = useMergedState(props.defaultValue, {
        value: props.value
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), value = _useMergedState2[0], setValue = _useMergedState2[1];
      var formatValue2 = value === void 0 || value === null ? "" : String(value);
      var _React$useState = React.useState(null), _React$useState2 = _slicedToArray(_React$useState, 2), selection = _React$useState2[0], setSelection = _React$useState2[1];
      var countConfig = useCount(count, showCount);
      var mergedMax = countConfig.max || maxLength;
      var valueLength = countConfig.strategy(formatValue2);
      var isOutOfRange = !!mergedMax && valueLength > mergedMax;
      reactExports.useImperativeHandle(ref, function() {
        return {
          focus,
          blur: function blur() {
            var _inputRef$current;
            (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.blur();
          },
          setSelectionRange: function setSelectionRange(start, end, direction) {
            var _inputRef$current2;
            (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 || _inputRef$current2.setSelectionRange(start, end, direction);
          },
          select: function select() {
            var _inputRef$current3;
            (_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 || _inputRef$current3.select();
          },
          input: inputRef.current
        };
      });
      reactExports.useEffect(function() {
        setFocused(function(prev2) {
          return prev2 && disabled ? false : prev2;
        });
      }, [disabled]);
      var triggerChange = function triggerChange2(e2, currentValue) {
        var cutValue = currentValue;
        if (!compositionRef.current && countConfig.exceedFormatter && countConfig.max && countConfig.strategy(currentValue) > countConfig.max) {
          cutValue = countConfig.exceedFormatter(currentValue, {
            max: countConfig.max
          });
          if (currentValue !== cutValue) {
            var _inputRef$current4, _inputRef$current5;
            setSelection([((_inputRef$current4 = inputRef.current) === null || _inputRef$current4 === void 0 ? void 0 : _inputRef$current4.selectionStart) || 0, ((_inputRef$current5 = inputRef.current) === null || _inputRef$current5 === void 0 ? void 0 : _inputRef$current5.selectionEnd) || 0]);
          }
        }
        setValue(cutValue);
        if (inputRef.current) {
          resolveOnChange(inputRef.current, e2, onChange, cutValue);
        }
      };
      React.useEffect(function() {
        if (selection) {
          var _inputRef$current6;
          (_inputRef$current6 = inputRef.current) === null || _inputRef$current6 === void 0 || _inputRef$current6.setSelectionRange.apply(_inputRef$current6, _toConsumableArray(selection));
        }
      }, [selection]);
      var onInternalChange = function onInternalChange2(e2) {
        triggerChange(e2, e2.target.value);
      };
      var onInternalCompositionEnd = function onInternalCompositionEnd2(e2) {
        compositionRef.current = false;
        triggerChange(e2, e2.currentTarget.value);
        onCompositionEnd === null || onCompositionEnd === void 0 || onCompositionEnd(e2);
      };
      var handleKeyDown = function handleKeyDown2(e2) {
        if (onPressEnter && e2.key === "Enter") {
          onPressEnter(e2);
        }
        onKeyDown2 === null || onKeyDown2 === void 0 || onKeyDown2(e2);
      };
      var handleFocus = function handleFocus2(e2) {
        setFocused(true);
        onFocus === null || onFocus === void 0 || onFocus(e2);
      };
      var handleBlur = function handleBlur2(e2) {
        setFocused(false);
        onBlur === null || onBlur === void 0 || onBlur(e2);
      };
      var handleReset = function handleReset2(e2) {
        setValue("");
        focus();
        if (inputRef.current) {
          resolveOnChange(inputRef.current, e2, onChange);
        }
      };
      var outOfRangeCls = isOutOfRange && "".concat(prefixCls, "-out-of-range");
      var getInputElement = function getInputElement2() {
        var otherProps = omit(props, [
          "prefixCls",
          "onPressEnter",
          "addonBefore",
          "addonAfter",
          "prefix",
          "suffix",
          "allowClear",
          // Input elements must be either controlled or uncontrolled,
          // specify either the value prop, or the defaultValue prop, but not both.
          "defaultValue",
          "showCount",
          "count",
          "classes",
          "htmlSize",
          "styles",
          "classNames"
        ]);
        return /* @__PURE__ */ React.createElement("input", _extends$1({
          autoComplete
        }, otherProps, {
          onChange: onInternalChange,
          onFocus: handleFocus,
          onBlur: handleBlur,
          onKeyDown: handleKeyDown,
          className: classNames(prefixCls, _defineProperty({}, "".concat(prefixCls, "-disabled"), disabled), classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.input),
          style: styles === null || styles === void 0 ? void 0 : styles.input,
          ref: inputRef,
          size: htmlSize,
          type,
          onCompositionStart: function onCompositionStart(e2) {
            compositionRef.current = true;
            _onCompositionStart === null || _onCompositionStart === void 0 || _onCompositionStart(e2);
          },
          onCompositionEnd: onInternalCompositionEnd
        }));
      };
      var getSuffix = function getSuffix2() {
        var hasMaxLength = Number(mergedMax) > 0;
        if (suffix || countConfig.show) {
          var dataCount = countConfig.showFormatter ? countConfig.showFormatter({
            value: formatValue2,
            count: valueLength,
            maxLength: mergedMax
          }) : "".concat(valueLength).concat(hasMaxLength ? " / ".concat(mergedMax) : "");
          return /* @__PURE__ */ React.createElement(React.Fragment, null, countConfig.show && /* @__PURE__ */ React.createElement("span", {
            className: classNames("".concat(prefixCls, "-show-count-suffix"), _defineProperty({}, "".concat(prefixCls, "-show-count-has-suffix"), !!suffix), classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.count),
            style: _objectSpread2({}, styles === null || styles === void 0 ? void 0 : styles.count)
          }, dataCount), suffix);
        }
        return null;
      };
      return /* @__PURE__ */ React.createElement(BaseInput, _extends$1({}, rest, {
        prefixCls,
        className: classNames(className, outOfRangeCls),
        inputElement: getInputElement(),
        handleReset,
        value: formatValue2,
        focused,
        triggerFocus: focus,
        suffix: getSuffix(),
        disabled,
        classes,
        classNames: classNames$1,
        styles
      }));
    });
    const Group = (props) => {
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const {
        prefixCls: customizePrefixCls,
        className
      } = props;
      const prefixCls = getPrefixCls("input-group", customizePrefixCls);
      const inputPrefixCls = getPrefixCls("input");
      const [wrapCSSVar, hashId] = useStyle$a(inputPrefixCls);
      const cls = classNames(prefixCls, {
        [`${prefixCls}-lg`]: props.size === "large",
        [`${prefixCls}-sm`]: props.size === "small",
        [`${prefixCls}-compact`]: props.compact,
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, hashId, className);
      const formItemContext = reactExports.useContext(FormItemInputContext);
      const groupFormItemContext = reactExports.useMemo(() => Object.assign(Object.assign({}, formItemContext), {
        isFormItemInput: false
      }), [formItemContext]);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("span", {
        className: cls,
        style: props.style,
        onMouseEnter: props.onMouseEnter,
        onMouseLeave: props.onMouseLeave,
        onFocus: props.onFocus,
        onBlur: props.onBlur
      }, /* @__PURE__ */ reactExports.createElement(FormItemInputContext.Provider, {
        value: groupFormItemContext
      }, props.children)));
    };
    const Group$1 = Group;
    function useRemovePasswordTimeout(inputRef, triggerOnMount) {
      const removePasswordTimeoutRef = reactExports.useRef([]);
      const removePasswordTimeout = () => {
        removePasswordTimeoutRef.current.push(setTimeout(() => {
          var _a, _b, _c, _d;
          if (((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input) && ((_b = inputRef.current) === null || _b === void 0 ? void 0 : _b.input.getAttribute("type")) === "password" && ((_c = inputRef.current) === null || _c === void 0 ? void 0 : _c.input.hasAttribute("value"))) {
            (_d = inputRef.current) === null || _d === void 0 ? void 0 : _d.input.removeAttribute("value");
          }
        }));
      };
      reactExports.useEffect(() => {
        if (triggerOnMount) {
          removePasswordTimeout();
        }
        return () => removePasswordTimeoutRef.current.forEach((timer) => {
          if (timer) {
            clearTimeout(timer);
          }
        });
      }, []);
      return removePasswordTimeout;
    }
    function hasPrefixSuffix(props) {
      return !!(props.prefix || props.suffix || props.allowClear);
    }
    var __rest$i = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    function triggerFocus(element, option) {
      if (!element) {
        return;
      }
      element.focus(option);
      const {
        cursor
      } = option || {};
      if (cursor) {
        const len = element.value.length;
        switch (cursor) {
          case "start":
            element.setSelectionRange(0, 0);
            break;
          case "end":
            element.setSelectionRange(len, len);
            break;
          default:
            element.setSelectionRange(0, len);
            break;
        }
      }
    }
    const Input$2 = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      var _a;
      const {
        prefixCls: customizePrefixCls,
        bordered = true,
        status: customStatus,
        size: customSize,
        disabled: customDisabled,
        onBlur,
        onFocus,
        suffix,
        allowClear,
        addonAfter,
        addonBefore,
        className,
        style: style2,
        styles,
        rootClassName,
        onChange,
        classNames: classes
      } = props, rest = __rest$i(props, ["prefixCls", "bordered", "status", "size", "disabled", "onBlur", "onFocus", "suffix", "allowClear", "addonAfter", "addonBefore", "className", "style", "styles", "rootClassName", "onChange", "classNames"]);
      const {
        getPrefixCls,
        direction,
        input
      } = React.useContext(ConfigContext);
      const prefixCls = getPrefixCls("input", customizePrefixCls);
      const inputRef = reactExports.useRef(null);
      const cssVarCls = useCSSVarCls$1(prefixCls);
      const [wrapCSSVar, hashId] = useStyle$a(prefixCls, cssVarCls);
      const {
        compactSize,
        compactItemClassnames
      } = useCompactItemContext(prefixCls, direction);
      const mergedSize = useSize$1((ctx) => {
        var _a2;
        return (_a2 = customSize !== null && customSize !== void 0 ? customSize : compactSize) !== null && _a2 !== void 0 ? _a2 : ctx;
      });
      const disabled = React.useContext(DisabledContext$1);
      const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
      const {
        status: contextStatus,
        hasFeedback,
        feedbackIcon
      } = reactExports.useContext(FormItemInputContext);
      const mergedStatus = getMergedStatus(contextStatus, customStatus);
      const inputHasPrefixSuffix = hasPrefixSuffix(props) || !!hasFeedback;
      reactExports.useRef(inputHasPrefixSuffix);
      const removePasswordTimeout = useRemovePasswordTimeout(inputRef, true);
      const handleBlur = (e2) => {
        removePasswordTimeout();
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e2);
      };
      const handleFocus = (e2) => {
        removePasswordTimeout();
        onFocus === null || onFocus === void 0 ? void 0 : onFocus(e2);
      };
      const handleChange = (e2) => {
        removePasswordTimeout();
        onChange === null || onChange === void 0 ? void 0 : onChange(e2);
      };
      const suffixNode = (hasFeedback || suffix) && /* @__PURE__ */ React.createElement(React.Fragment, null, suffix, hasFeedback && feedbackIcon);
      let mergedAllowClear;
      if (typeof allowClear === "object" && (allowClear === null || allowClear === void 0 ? void 0 : allowClear.clearIcon)) {
        mergedAllowClear = allowClear;
      } else if (allowClear) {
        mergedAllowClear = {
          clearIcon: /* @__PURE__ */ React.createElement(CloseCircleFilled$1, null)
        };
      }
      return wrapCSSVar(/* @__PURE__ */ React.createElement(Input$3, Object.assign({
        ref: composeRef(ref, inputRef),
        prefixCls,
        autoComplete: input === null || input === void 0 ? void 0 : input.autoComplete
      }, rest, {
        disabled: mergedDisabled,
        onBlur: handleBlur,
        onFocus: handleFocus,
        style: Object.assign(Object.assign({}, input === null || input === void 0 ? void 0 : input.style), style2),
        styles: Object.assign(Object.assign({}, input === null || input === void 0 ? void 0 : input.styles), styles),
        suffix: suffixNode,
        allowClear: mergedAllowClear,
        className: classNames(className, rootClassName, cssVarCls, hashId, compactItemClassnames, input === null || input === void 0 ? void 0 : input.className),
        onChange: handleChange,
        addonAfter: addonAfter && /* @__PURE__ */ React.createElement(NoCompactStyle, null, /* @__PURE__ */ React.createElement(NoFormStyle, {
          override: true,
          status: true
        }, addonAfter)),
        addonBefore: addonBefore && /* @__PURE__ */ React.createElement(NoCompactStyle, null, /* @__PURE__ */ React.createElement(NoFormStyle, {
          override: true,
          status: true
        }, addonBefore)),
        classNames: Object.assign(Object.assign(Object.assign({}, classes), input === null || input === void 0 ? void 0 : input.classNames), {
          input: classNames({
            [`${prefixCls}-sm`]: mergedSize === "small",
            [`${prefixCls}-lg`]: mergedSize === "large",
            [`${prefixCls}-rtl`]: direction === "rtl",
            [`${prefixCls}-borderless`]: !bordered
          }, !inputHasPrefixSuffix && getStatusClassNames(prefixCls, mergedStatus), classes === null || classes === void 0 ? void 0 : classes.input, (_a = input === null || input === void 0 ? void 0 : input.classNames) === null || _a === void 0 ? void 0 : _a.input, hashId)
        }),
        classes: {
          affixWrapper: classNames({
            [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
            [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
            [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
            [`${prefixCls}-affix-wrapper-borderless`]: !bordered
          }, getStatusClassNames(`${prefixCls}-affix-wrapper`, mergedStatus, hasFeedback), hashId),
          wrapper: classNames({
            [`${prefixCls}-group-rtl`]: direction === "rtl"
          }, hashId),
          group: classNames({
            [`${prefixCls}-group-wrapper-sm`]: mergedSize === "small",
            [`${prefixCls}-group-wrapper-lg`]: mergedSize === "large",
            [`${prefixCls}-group-wrapper-rtl`]: direction === "rtl",
            [`${prefixCls}-group-wrapper-disabled`]: mergedDisabled
          }, getStatusClassNames(`${prefixCls}-group-wrapper`, mergedStatus, hasFeedback), hashId)
        }
      })));
    });
    const InternalInput = Input$2;
    var EyeInvisibleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z" } }, { "tag": "path", "attrs": { "d": "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z" } }] }, "name": "eye-invisible", "theme": "outlined" };
    const EyeInvisibleOutlinedSvg = EyeInvisibleOutlined$2;
    var EyeInvisibleOutlined = function EyeInvisibleOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: EyeInvisibleOutlinedSvg
      }));
    };
    const EyeInvisibleOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(EyeInvisibleOutlined);
    var EyeOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, "name": "eye", "theme": "outlined" };
    const EyeOutlinedSvg = EyeOutlined$2;
    var EyeOutlined = function EyeOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: EyeOutlinedSvg
      }));
    };
    const EyeOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(EyeOutlined);
    var __rest$h = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const defaultIconRender = (visible) => visible ? /* @__PURE__ */ reactExports.createElement(EyeOutlined$1, null) : /* @__PURE__ */ reactExports.createElement(EyeInvisibleOutlined$1, null);
    const ActionMap = {
      click: "onClick",
      hover: "onMouseOver"
    };
    const Password = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        visibilityToggle = true
      } = props;
      const visibilityControlled = typeof visibilityToggle === "object" && visibilityToggle.visible !== void 0;
      const [visible, setVisible] = reactExports.useState(() => visibilityControlled ? visibilityToggle.visible : false);
      const inputRef = reactExports.useRef(null);
      reactExports.useEffect(() => {
        if (visibilityControlled) {
          setVisible(visibilityToggle.visible);
        }
      }, [visibilityControlled, visibilityToggle]);
      const removePasswordTimeout = useRemovePasswordTimeout(inputRef);
      const onVisibleChange = () => {
        const {
          disabled
        } = props;
        if (disabled) {
          return;
        }
        if (visible) {
          removePasswordTimeout();
        }
        setVisible((prevState) => {
          var _a;
          const newState = !prevState;
          if (typeof visibilityToggle === "object") {
            (_a = visibilityToggle.onVisibleChange) === null || _a === void 0 ? void 0 : _a.call(visibilityToggle, newState);
          }
          return newState;
        });
      };
      const getIcon2 = (prefixCls2) => {
        const {
          action = "click",
          iconRender = defaultIconRender
        } = props;
        const iconTrigger = ActionMap[action] || "";
        const icon = iconRender(visible);
        const iconProps = {
          [iconTrigger]: onVisibleChange,
          className: `${prefixCls2}-icon`,
          key: "passwordIcon",
          onMouseDown: (e2) => {
            e2.preventDefault();
          },
          onMouseUp: (e2) => {
            e2.preventDefault();
          }
        };
        return /* @__PURE__ */ reactExports.cloneElement(/* @__PURE__ */ reactExports.isValidElement(icon) ? icon : /* @__PURE__ */ reactExports.createElement("span", null, icon), iconProps);
      };
      const {
        className,
        prefixCls: customizePrefixCls,
        inputPrefixCls: customizeInputPrefixCls,
        size
      } = props, restProps = __rest$h(props, ["className", "prefixCls", "inputPrefixCls", "size"]);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
      const prefixCls = getPrefixCls("input-password", customizePrefixCls);
      const suffixIcon = visibilityToggle && getIcon2(prefixCls);
      const inputClassName = classNames(prefixCls, className, {
        [`${prefixCls}-${size}`]: !!size
      });
      const omittedProps = Object.assign(Object.assign({}, omit(restProps, ["suffix", "iconRender", "visibilityToggle"])), {
        type: visible ? "text" : "password",
        className: inputClassName,
        prefixCls: inputPrefixCls,
        suffix: suffixIcon
      });
      if (size) {
        omittedProps.size = size;
      }
      return /* @__PURE__ */ reactExports.createElement(InternalInput, Object.assign({
        ref: composeRef(ref, inputRef)
      }, omittedProps));
    });
    const Password$1 = Password;
    var __rest$g = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const Search = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        prefixCls: customizePrefixCls,
        inputPrefixCls: customizeInputPrefixCls,
        className,
        size: customizeSize,
        suffix,
        enterButton = false,
        addonAfter,
        loading,
        disabled,
        onSearch: customOnSearch,
        onChange: customOnChange,
        onCompositionStart,
        onCompositionEnd
      } = props, restProps = __rest$g(props, ["prefixCls", "inputPrefixCls", "className", "size", "suffix", "enterButton", "addonAfter", "loading", "disabled", "onSearch", "onChange", "onCompositionStart", "onCompositionEnd"]);
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const composedRef = reactExports.useRef(false);
      const prefixCls = getPrefixCls("input-search", customizePrefixCls);
      const inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
      const {
        compactSize
      } = useCompactItemContext(prefixCls, direction);
      const size = useSize$1((ctx) => {
        var _a;
        return (_a = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a !== void 0 ? _a : ctx;
      });
      const inputRef = reactExports.useRef(null);
      const onChange = (e2) => {
        if (e2 && e2.target && e2.type === "click" && customOnSearch) {
          customOnSearch(e2.target.value, e2, {
            source: "clear"
          });
        }
        if (customOnChange) {
          customOnChange(e2);
        }
      };
      const onMouseDown = (e2) => {
        var _a;
        if (document.activeElement === ((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input)) {
          e2.preventDefault();
        }
      };
      const onSearch = (e2) => {
        var _a, _b;
        if (customOnSearch) {
          customOnSearch((_b = (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input) === null || _b === void 0 ? void 0 : _b.value, e2, {
            source: "input"
          });
        }
      };
      const onPressEnter = (e2) => {
        if (composedRef.current || loading) {
          return;
        }
        onSearch(e2);
      };
      const searchIcon = typeof enterButton === "boolean" ? /* @__PURE__ */ reactExports.createElement(SearchOutlined$1, null) : null;
      const btnClassName = `${prefixCls}-button`;
      let button;
      const enterButtonAsElement = enterButton || {};
      const isAntdButton = enterButtonAsElement.type && enterButtonAsElement.type.__ANT_BUTTON === true;
      if (isAntdButton || enterButtonAsElement.type === "button") {
        button = cloneElement(enterButtonAsElement, Object.assign({
          onMouseDown,
          onClick: (e2) => {
            var _a, _b;
            (_b = (_a = enterButtonAsElement === null || enterButtonAsElement === void 0 ? void 0 : enterButtonAsElement.props) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e2);
            onSearch(e2);
          },
          key: "enterButton"
        }, isAntdButton ? {
          className: btnClassName,
          size
        } : {}));
      } else {
        button = /* @__PURE__ */ reactExports.createElement(Button$2, {
          className: btnClassName,
          type: enterButton ? "primary" : void 0,
          size,
          disabled,
          key: "enterButton",
          onMouseDown,
          onClick: onSearch,
          loading,
          icon: searchIcon
        }, enterButton);
      }
      if (addonAfter) {
        button = [button, cloneElement(addonAfter, {
          key: "addonAfter"
        })];
      }
      const cls = classNames(prefixCls, {
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-${size}`]: !!size,
        [`${prefixCls}-with-button`]: !!enterButton
      }, className);
      const handleOnCompositionStart = (e2) => {
        composedRef.current = true;
        onCompositionStart === null || onCompositionStart === void 0 ? void 0 : onCompositionStart(e2);
      };
      const handleOnCompositionEnd = (e2) => {
        composedRef.current = false;
        onCompositionEnd === null || onCompositionEnd === void 0 ? void 0 : onCompositionEnd(e2);
      };
      return /* @__PURE__ */ reactExports.createElement(InternalInput, Object.assign({
        ref: composeRef(inputRef, ref),
        onPressEnter
      }, restProps, {
        size,
        onCompositionStart: handleOnCompositionStart,
        onCompositionEnd: handleOnCompositionEnd,
        prefixCls: inputPrefixCls,
        addonAfter: button,
        suffix,
        onChange,
        className: cls,
        disabled
      }));
    });
    const Search$1 = Search;
    var HIDDEN_TEXTAREA_STYLE = "\n  min-height:0 !important;\n  max-height:none !important;\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important;\n  pointer-events: none !important;\n";
    var SIZING_STYLE = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing", "word-break", "white-space"];
    var computedStyleCache = {};
    var hiddenTextarea;
    function calculateNodeStyling(node2) {
      var useCache2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var nodeRef = node2.getAttribute("id") || node2.getAttribute("data-reactid") || node2.getAttribute("name");
      if (useCache2 && computedStyleCache[nodeRef]) {
        return computedStyleCache[nodeRef];
      }
      var style2 = window.getComputedStyle(node2);
      var boxSizing = style2.getPropertyValue("box-sizing") || style2.getPropertyValue("-moz-box-sizing") || style2.getPropertyValue("-webkit-box-sizing");
      var paddingSize = parseFloat(style2.getPropertyValue("padding-bottom")) + parseFloat(style2.getPropertyValue("padding-top"));
      var borderSize = parseFloat(style2.getPropertyValue("border-bottom-width")) + parseFloat(style2.getPropertyValue("border-top-width"));
      var sizingStyle = SIZING_STYLE.map(function(name) {
        return "".concat(name, ":").concat(style2.getPropertyValue(name));
      }).join(";");
      var nodeInfo = {
        sizingStyle,
        paddingSize,
        borderSize,
        boxSizing
      };
      if (useCache2 && nodeRef) {
        computedStyleCache[nodeRef] = nodeInfo;
      }
      return nodeInfo;
    }
    function calculateAutoSizeStyle(uiTextNode) {
      var useCache2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var minRows = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      var maxRows = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      if (!hiddenTextarea) {
        hiddenTextarea = document.createElement("textarea");
        hiddenTextarea.setAttribute("tab-index", "-1");
        hiddenTextarea.setAttribute("aria-hidden", "true");
        document.body.appendChild(hiddenTextarea);
      }
      if (uiTextNode.getAttribute("wrap")) {
        hiddenTextarea.setAttribute("wrap", uiTextNode.getAttribute("wrap"));
      } else {
        hiddenTextarea.removeAttribute("wrap");
      }
      var _calculateNodeStyling = calculateNodeStyling(uiTextNode, useCache2), paddingSize = _calculateNodeStyling.paddingSize, borderSize = _calculateNodeStyling.borderSize, boxSizing = _calculateNodeStyling.boxSizing, sizingStyle = _calculateNodeStyling.sizingStyle;
      hiddenTextarea.setAttribute("style", "".concat(sizingStyle, ";").concat(HIDDEN_TEXTAREA_STYLE));
      hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || "";
      var minHeight = void 0;
      var maxHeight = void 0;
      var overflowY;
      var height = hiddenTextarea.scrollHeight;
      if (boxSizing === "border-box") {
        height += borderSize;
      } else if (boxSizing === "content-box") {
        height -= paddingSize;
      }
      if (minRows !== null || maxRows !== null) {
        hiddenTextarea.value = " ";
        var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
        if (minRows !== null) {
          minHeight = singleRowHeight * minRows;
          if (boxSizing === "border-box") {
            minHeight = minHeight + paddingSize + borderSize;
          }
          height = Math.max(minHeight, height);
        }
        if (maxRows !== null) {
          maxHeight = singleRowHeight * maxRows;
          if (boxSizing === "border-box") {
            maxHeight = maxHeight + paddingSize + borderSize;
          }
          overflowY = height > maxHeight ? "" : "hidden";
          height = Math.min(maxHeight, height);
        }
      }
      var style2 = {
        height,
        overflowY,
        resize: "none"
      };
      if (minHeight) {
        style2.minHeight = minHeight;
      }
      if (maxHeight) {
        style2.maxHeight = maxHeight;
      }
      return style2;
    }
    var _excluded$c = ["prefixCls", "onPressEnter", "defaultValue", "value", "autoSize", "onResize", "className", "style", "disabled", "onChange", "onInternalAutoSize"];
    var RESIZE_START = 0;
    var RESIZE_MEASURING = 1;
    var RESIZE_STABLE = 2;
    var ResizableTextArea = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var _ref = props, prefixCls = _ref.prefixCls;
      _ref.onPressEnter;
      var defaultValue = _ref.defaultValue, value = _ref.value, autoSize = _ref.autoSize, onResize2 = _ref.onResize, className = _ref.className, style2 = _ref.style, disabled = _ref.disabled, onChange = _ref.onChange;
      _ref.onInternalAutoSize;
      var restProps = _objectWithoutProperties(_ref, _excluded$c);
      var _useMergedState = useMergedState(defaultValue, {
        value,
        postState: function postState(val) {
          return val !== null && val !== void 0 ? val : "";
        }
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedValue = _useMergedState2[0], setMergedValue = _useMergedState2[1];
      var onInternalChange = function onInternalChange2(event) {
        setMergedValue(event.target.value);
        onChange === null || onChange === void 0 || onChange(event);
      };
      var textareaRef = reactExports.useRef();
      reactExports.useImperativeHandle(ref, function() {
        return {
          textArea: textareaRef.current
        };
      });
      var _React$useMemo = reactExports.useMemo(function() {
        if (autoSize && _typeof(autoSize) === "object") {
          return [autoSize.minRows, autoSize.maxRows];
        }
        return [];
      }, [autoSize]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), minRows = _React$useMemo2[0], maxRows = _React$useMemo2[1];
      var needAutoSize = !!autoSize;
      var fixFirefoxAutoScroll = function fixFirefoxAutoScroll2() {
        try {
          if (document.activeElement === textareaRef.current) {
            var _textareaRef$current = textareaRef.current, selectionStart = _textareaRef$current.selectionStart, selectionEnd = _textareaRef$current.selectionEnd, scrollTop = _textareaRef$current.scrollTop;
            textareaRef.current.setSelectionRange(selectionStart, selectionEnd);
            textareaRef.current.scrollTop = scrollTop;
          }
        } catch (e2) {
        }
      };
      var _React$useState = reactExports.useState(RESIZE_STABLE), _React$useState2 = _slicedToArray(_React$useState, 2), resizeState = _React$useState2[0], setResizeState = _React$useState2[1];
      var _React$useState3 = reactExports.useState(), _React$useState4 = _slicedToArray(_React$useState3, 2), autoSizeStyle = _React$useState4[0], setAutoSizeStyle = _React$useState4[1];
      var startResize = function startResize2() {
        setResizeState(RESIZE_START);
      };
      useLayoutEffect$1(function() {
        if (needAutoSize) {
          startResize();
        }
      }, [value, minRows, maxRows, needAutoSize]);
      useLayoutEffect$1(function() {
        if (resizeState === RESIZE_START) {
          setResizeState(RESIZE_MEASURING);
        } else if (resizeState === RESIZE_MEASURING) {
          var textareaStyles = calculateAutoSizeStyle(textareaRef.current, false, minRows, maxRows);
          setResizeState(RESIZE_STABLE);
          setAutoSizeStyle(textareaStyles);
        } else {
          fixFirefoxAutoScroll();
        }
      }, [resizeState]);
      var resizeRafRef = reactExports.useRef();
      var cleanRaf = function cleanRaf2() {
        wrapperRaf.cancel(resizeRafRef.current);
      };
      var onInternalResize = function onInternalResize2(size) {
        if (resizeState === RESIZE_STABLE) {
          onResize2 === null || onResize2 === void 0 || onResize2(size);
          if (autoSize) {
            cleanRaf();
            resizeRafRef.current = wrapperRaf(function() {
              startResize();
            });
          }
        }
      };
      reactExports.useEffect(function() {
        return cleanRaf;
      }, []);
      var mergedAutoSizeStyle = needAutoSize ? autoSizeStyle : null;
      var mergedStyle = _objectSpread2(_objectSpread2({}, style2), mergedAutoSizeStyle);
      if (resizeState === RESIZE_START || resizeState === RESIZE_MEASURING) {
        mergedStyle.overflowY = "hidden";
        mergedStyle.overflowX = "hidden";
      }
      return /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
        onResize: onInternalResize,
        disabled: !(autoSize || onResize2)
      }, /* @__PURE__ */ reactExports.createElement("textarea", _extends$1({}, restProps, {
        ref: textareaRef,
        style: mergedStyle,
        className: classNames(prefixCls, className, _defineProperty({}, "".concat(prefixCls, "-disabled"), disabled)),
        disabled,
        value: mergedValue,
        onChange: onInternalChange
      })));
    });
    var _excluded$b = ["defaultValue", "value", "onFocus", "onBlur", "onChange", "allowClear", "maxLength", "onCompositionStart", "onCompositionEnd", "suffix", "prefixCls", "classes", "showCount", "count", "className", "style", "disabled", "hidden", "classNames", "styles", "onResize"];
    var TextArea$2 = /* @__PURE__ */ React.forwardRef(function(_ref, ref) {
      var _countConfig$max, _clsx;
      var defaultValue = _ref.defaultValue, customValue = _ref.value, onFocus = _ref.onFocus, onBlur = _ref.onBlur, onChange = _ref.onChange, allowClear = _ref.allowClear, maxLength = _ref.maxLength, onCompositionStart = _ref.onCompositionStart, onCompositionEnd = _ref.onCompositionEnd, suffix = _ref.suffix, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-textarea" : _ref$prefixCls, classes = _ref.classes, showCount = _ref.showCount, count = _ref.count, className = _ref.className, style2 = _ref.style, disabled = _ref.disabled, hidden = _ref.hidden, classNames$1 = _ref.classNames, styles = _ref.styles, onResize2 = _ref.onResize, rest = _objectWithoutProperties(_ref, _excluded$b);
      var _useMergedState = useMergedState(defaultValue, {
        value: customValue,
        defaultValue
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), value = _useMergedState2[0], setValue = _useMergedState2[1];
      var formatValue2 = value === void 0 || value === null ? "" : String(value);
      var _React$useState = React.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), focused = _React$useState2[0], setFocused = _React$useState2[1];
      var compositionRef = React.useRef(false);
      var _React$useState3 = React.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), textareaResized = _React$useState4[0], setTextareaResized = _React$useState4[1];
      var resizableTextAreaRef = reactExports.useRef(null);
      var getTextArea = function getTextArea2() {
        var _resizableTextAreaRef;
        return (_resizableTextAreaRef = resizableTextAreaRef.current) === null || _resizableTextAreaRef === void 0 ? void 0 : _resizableTextAreaRef.textArea;
      };
      var focus = function focus2() {
        getTextArea().focus();
      };
      reactExports.useImperativeHandle(ref, function() {
        return {
          resizableTextArea: resizableTextAreaRef.current,
          focus,
          blur: function blur() {
            getTextArea().blur();
          }
        };
      });
      reactExports.useEffect(function() {
        setFocused(function(prev2) {
          return !disabled && prev2;
        });
      }, [disabled]);
      var _React$useState5 = React.useState(null), _React$useState6 = _slicedToArray(_React$useState5, 2), selection = _React$useState6[0], setSelection = _React$useState6[1];
      React.useEffect(function() {
        if (selection) {
          var _getTextArea;
          (_getTextArea = getTextArea()).setSelectionRange.apply(_getTextArea, _toConsumableArray(selection));
        }
      }, [selection]);
      var countConfig = useCount(count, showCount);
      var mergedMax = (_countConfig$max = countConfig.max) !== null && _countConfig$max !== void 0 ? _countConfig$max : maxLength;
      var hasMaxLength = Number(mergedMax) > 0;
      var valueLength = countConfig.strategy(formatValue2);
      var isOutOfRange = !!mergedMax && valueLength > mergedMax;
      var triggerChange = function triggerChange2(e2, currentValue) {
        var cutValue = currentValue;
        if (!compositionRef.current && countConfig.exceedFormatter && countConfig.max && countConfig.strategy(currentValue) > countConfig.max) {
          cutValue = countConfig.exceedFormatter(currentValue, {
            max: countConfig.max
          });
          if (currentValue !== cutValue) {
            setSelection([getTextArea().selectionStart || 0, getTextArea().selectionEnd || 0]);
          }
        }
        setValue(cutValue);
        resolveOnChange(e2.currentTarget, e2, onChange, cutValue);
      };
      var onInternalCompositionStart = function onInternalCompositionStart2(e2) {
        compositionRef.current = true;
        onCompositionStart === null || onCompositionStart === void 0 || onCompositionStart(e2);
      };
      var onInternalCompositionEnd = function onInternalCompositionEnd2(e2) {
        compositionRef.current = false;
        triggerChange(e2, e2.currentTarget.value);
        onCompositionEnd === null || onCompositionEnd === void 0 || onCompositionEnd(e2);
      };
      var onInternalChange = function onInternalChange2(e2) {
        triggerChange(e2, e2.target.value);
      };
      var handleKeyDown = function handleKeyDown2(e2) {
        var onPressEnter = rest.onPressEnter, onKeyDown2 = rest.onKeyDown;
        if (e2.key === "Enter" && onPressEnter) {
          onPressEnter(e2);
        }
        onKeyDown2 === null || onKeyDown2 === void 0 || onKeyDown2(e2);
      };
      var handleFocus = function handleFocus2(e2) {
        setFocused(true);
        onFocus === null || onFocus === void 0 || onFocus(e2);
      };
      var handleBlur = function handleBlur2(e2) {
        setFocused(false);
        onBlur === null || onBlur === void 0 || onBlur(e2);
      };
      var handleReset = function handleReset2(e2) {
        setValue("");
        focus();
        resolveOnChange(getTextArea(), e2, onChange);
      };
      var suffixNode = suffix;
      var dataCount;
      if (countConfig.show) {
        if (countConfig.showFormatter) {
          dataCount = countConfig.showFormatter({
            value: formatValue2,
            count: valueLength,
            maxLength: mergedMax
          });
        } else {
          dataCount = "".concat(valueLength).concat(hasMaxLength ? " / ".concat(mergedMax) : "");
        }
        suffixNode = /* @__PURE__ */ React.createElement(React.Fragment, null, suffixNode, /* @__PURE__ */ React.createElement("span", {
          className: classNames("".concat(prefixCls, "-data-count"), classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.count),
          style: styles === null || styles === void 0 ? void 0 : styles.count
        }, dataCount));
      }
      var handleResize = function handleResize2(size) {
        var _getTextArea2;
        onResize2 === null || onResize2 === void 0 || onResize2(size);
        if ((_getTextArea2 = getTextArea()) !== null && _getTextArea2 !== void 0 && _getTextArea2.style.height) {
          setTextareaResized(true);
        }
      };
      var isPureTextArea = !rest.autoSize && !showCount && !allowClear;
      var textarea = /* @__PURE__ */ React.createElement(BaseInput, {
        value: formatValue2,
        allowClear,
        handleReset,
        suffix: suffixNode,
        prefixCls,
        classes: {
          affixWrapper: classNames(classes === null || classes === void 0 ? void 0 : classes.affixWrapper, (_clsx = {}, _defineProperty(_clsx, "".concat(prefixCls, "-show-count"), showCount), _defineProperty(_clsx, "".concat(prefixCls, "-textarea-allow-clear"), allowClear), _clsx))
        },
        disabled,
        focused,
        className: classNames(className, isOutOfRange && "".concat(prefixCls, "-out-of-range")),
        style: _objectSpread2(_objectSpread2({}, style2), textareaResized && !isPureTextArea ? {
          height: "auto"
        } : {}),
        dataAttrs: {
          affixWrapper: {
            "data-count": typeof dataCount === "string" ? dataCount : void 0
          }
        },
        hidden,
        inputElement: /* @__PURE__ */ React.createElement(ResizableTextArea, _extends$1({}, rest, {
          maxLength,
          onKeyDown: handleKeyDown,
          onChange: onInternalChange,
          onFocus: handleFocus,
          onBlur: handleBlur,
          onCompositionStart: onInternalCompositionStart,
          onCompositionEnd: onInternalCompositionEnd,
          className: classNames(classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.textarea),
          style: _objectSpread2(_objectSpread2({}, styles === null || styles === void 0 ? void 0 : styles.textarea), {}, {
            resize: style2 === null || style2 === void 0 ? void 0 : style2.resize
          }),
          disabled,
          prefixCls,
          onResize: handleResize,
          ref: resizableTextAreaRef
        }))
      });
      return textarea;
    });
    var __rest$f = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const TextArea = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      var _a;
      const {
        prefixCls: customizePrefixCls,
        bordered = true,
        size: customizeSize,
        disabled: customDisabled,
        status: customStatus,
        allowClear,
        classNames: classes,
        rootClassName,
        className
      } = props, rest = __rest$f(props, ["prefixCls", "bordered", "size", "disabled", "status", "allowClear", "classNames", "rootClassName", "className"]);
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const mergedSize = useSize$1(customizeSize);
      const disabled = reactExports.useContext(DisabledContext$1);
      const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
      const {
        status: contextStatus,
        hasFeedback,
        feedbackIcon
      } = reactExports.useContext(FormItemInputContext);
      const mergedStatus = getMergedStatus(contextStatus, customStatus);
      const innerRef = reactExports.useRef(null);
      reactExports.useImperativeHandle(ref, () => {
        var _a2;
        return {
          resizableTextArea: (_a2 = innerRef.current) === null || _a2 === void 0 ? void 0 : _a2.resizableTextArea,
          focus: (option) => {
            var _a3, _b;
            triggerFocus((_b = (_a3 = innerRef.current) === null || _a3 === void 0 ? void 0 : _a3.resizableTextArea) === null || _b === void 0 ? void 0 : _b.textArea, option);
          },
          blur: () => {
            var _a3;
            return (_a3 = innerRef.current) === null || _a3 === void 0 ? void 0 : _a3.blur();
          }
        };
      });
      const prefixCls = getPrefixCls("input", customizePrefixCls);
      let mergedAllowClear;
      if (typeof allowClear === "object" && (allowClear === null || allowClear === void 0 ? void 0 : allowClear.clearIcon)) {
        mergedAllowClear = allowClear;
      } else if (allowClear) {
        mergedAllowClear = {
          clearIcon: /* @__PURE__ */ reactExports.createElement(CloseCircleFilled$1, null)
        };
      }
      const cssVarCls = useCSSVarCls$1(prefixCls);
      const [wrapCSSVar, hashId] = useStyle$a(prefixCls, cssVarCls);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(TextArea$2, Object.assign({}, rest, {
        disabled: mergedDisabled,
        allowClear: mergedAllowClear,
        className: classNames(cssVarCls, className, rootClassName),
        classes: {
          affixWrapper: classNames(`${prefixCls}-textarea-affix-wrapper`, {
            [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
            [`${prefixCls}-affix-wrapper-borderless`]: !bordered,
            [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
            [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
            [`${prefixCls}-textarea-show-count`]: props.showCount || ((_a = props.count) === null || _a === void 0 ? void 0 : _a.show)
          }, getStatusClassNames(`${prefixCls}-affix-wrapper`, mergedStatus), hashId)
        },
        classNames: Object.assign(Object.assign({}, classes), {
          textarea: classNames({
            [`${prefixCls}-borderless`]: !bordered,
            [`${prefixCls}-sm`]: mergedSize === "small",
            [`${prefixCls}-lg`]: mergedSize === "large"
          }, getStatusClassNames(prefixCls, mergedStatus), hashId, classes === null || classes === void 0 ? void 0 : classes.textarea)
        }),
        prefixCls,
        suffix: hasFeedback && /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-textarea-suffix`
        }, feedbackIcon),
        ref: innerRef
      })));
    });
    const TextArea$1 = TextArea;
    const Input = InternalInput;
    Input.Group = Group$1;
    Input.Search = Search$1;
    Input.TextArea = TextArea$1;
    Input.Password = Password$1;
    const Input$1 = Input;
    var CalendarOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M880 184H712v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H384v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H144c-17.7 0-32 14.3-32 32v664c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V216c0-17.7-14.3-32-32-32zm-40 656H184V460h656v380zM184 392V256h128v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h256v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h128v136H184z" } }] }, "name": "calendar", "theme": "outlined" };
    const CalendarOutlinedSvg = CalendarOutlined$2;
    var CalendarOutlined = function CalendarOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: CalendarOutlinedSvg
      }));
    };
    const CalendarOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(CalendarOutlined);
    var ClockCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M686.7 638.6L544.1 535.5V288c0-4.4-3.6-8-8-8H488c-4.4 0-8 3.6-8 8v275.4c0 2.6 1.2 5 3.3 6.5l165.4 120.6c3.6 2.6 8.6 1.8 11.2-1.7l28.6-39c2.6-3.7 1.8-8.7-1.8-11.2z" } }] }, "name": "clock-circle", "theme": "outlined" };
    const ClockCircleOutlinedSvg = ClockCircleOutlined$2;
    var ClockCircleOutlined = function ClockCircleOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: ClockCircleOutlinedSvg
      }));
    };
    const ClockCircleOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(ClockCircleOutlined);
    var SwapRightOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M873.1 596.2l-164-208A32 32 0 00684 376h-64.8c-6.7 0-10.4 7.7-6.3 13l144.3 183H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h695.9c26.8 0 41.7-30.8 25.2-51.8z" } }] }, "name": "swap-right", "theme": "outlined" };
    const SwapRightOutlinedSvg = SwapRightOutlined$2;
    var SwapRightOutlined = function SwapRightOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: SwapRightOutlinedSvg
      }));
    };
    const SwapRightOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(SwapRightOutlined);
    function getPlaceholder(locale2, picker, customizePlaceholder) {
      if (customizePlaceholder !== void 0) {
        return customizePlaceholder;
      }
      if (picker === "year" && locale2.lang.yearPlaceholder) {
        return locale2.lang.yearPlaceholder;
      }
      if (picker === "quarter" && locale2.lang.quarterPlaceholder) {
        return locale2.lang.quarterPlaceholder;
      }
      if (picker === "month" && locale2.lang.monthPlaceholder) {
        return locale2.lang.monthPlaceholder;
      }
      if (picker === "week" && locale2.lang.weekPlaceholder) {
        return locale2.lang.weekPlaceholder;
      }
      if (picker === "time" && locale2.timePickerLocale.placeholder) {
        return locale2.timePickerLocale.placeholder;
      }
      return locale2.lang.placeholder;
    }
    function getRangePlaceholder(locale2, picker, customizePlaceholder) {
      if (customizePlaceholder !== void 0) {
        return customizePlaceholder;
      }
      if (picker === "year" && locale2.lang.yearPlaceholder) {
        return locale2.lang.rangeYearPlaceholder;
      }
      if (picker === "quarter" && locale2.lang.quarterPlaceholder) {
        return locale2.lang.rangeQuarterPlaceholder;
      }
      if (picker === "month" && locale2.lang.monthPlaceholder) {
        return locale2.lang.rangeMonthPlaceholder;
      }
      if (picker === "week" && locale2.lang.weekPlaceholder) {
        return locale2.lang.rangeWeekPlaceholder;
      }
      if (picker === "time" && locale2.timePickerLocale.placeholder) {
        return locale2.timePickerLocale.rangePlaceholder;
      }
      return locale2.lang.rangePlaceholder;
    }
    function transPlacement2DropdownAlign(direction, placement) {
      const overflow = {
        adjustX: 1,
        adjustY: 1
      };
      switch (placement) {
        case "bottomLeft": {
          return {
            points: ["tl", "bl"],
            offset: [0, 4],
            overflow
          };
        }
        case "bottomRight": {
          return {
            points: ["tr", "br"],
            offset: [0, 4],
            overflow
          };
        }
        case "topLeft": {
          return {
            points: ["bl", "tl"],
            offset: [0, -4],
            overflow
          };
        }
        case "topRight": {
          return {
            points: ["br", "tr"],
            offset: [0, -4],
            overflow
          };
        }
        default: {
          return {
            points: direction === "rtl" ? ["tr", "br"] : ["tl", "bl"],
            offset: [0, 4],
            overflow
          };
        }
      }
    }
    function toArray$5(list) {
      if (!list) {
        return [];
      }
      return Array.isArray(list) ? list : [list];
    }
    function getTimeProps(props) {
      const {
        format: format2,
        picker,
        showHour,
        showMinute,
        showSecond,
        use12Hours
      } = props;
      const firstFormat = toArray$5(format2)[0];
      const showTimeObj = Object.assign({}, props);
      if (format2 && Array.isArray(format2)) {
        showTimeObj.format = firstFormat;
      }
      if (firstFormat && typeof firstFormat === "string") {
        if (!firstFormat.includes("s") && showSecond === void 0) {
          showTimeObj.showSecond = false;
        }
        if (!firstFormat.includes("m") && showMinute === void 0) {
          showTimeObj.showMinute = false;
        }
        if (!firstFormat.includes("H") && !firstFormat.includes("h") && !firstFormat.includes("K") && !firstFormat.includes("k") && showHour === void 0) {
          showTimeObj.showHour = false;
        }
        if ((firstFormat.includes("a") || firstFormat.includes("A")) && use12Hours === void 0) {
          showTimeObj.use12Hours = true;
        }
      }
      if (picker === "time") {
        return showTimeObj;
      }
      if (typeof firstFormat === "function") {
        delete showTimeObj.format;
      }
      return {
        showTime: showTimeObj
      };
    }
    function mergeAllowClear(allowClear, clearIcon, defaultClearIcon) {
      if (allowClear === false) {
        return false;
      }
      const defaults2 = {
        clearIcon: clearIcon !== null && clearIcon !== void 0 ? clearIcon : defaultClearIcon
      };
      return typeof allowClear === "object" ? Object.assign(Object.assign({}, defaults2), allowClear) : defaults2;
    }
    function PickerButton(props) {
      return /* @__PURE__ */ reactExports.createElement(Button$2, Object.assign({
        size: "small",
        type: "primary"
      }, props));
    }
    const Components = {
      button: PickerButton
    };
    const Components$1 = Components;
    var __rest$e = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    function generateRangePicker(generateConfig2) {
      const RangePicker$1 = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
        var _a;
        const {
          prefixCls: customizePrefixCls,
          getPopupContainer: customGetPopupContainer,
          className,
          style: style2,
          placement,
          size: customizeSize,
          disabled: customDisabled,
          bordered = true,
          placeholder,
          popupClassName,
          dropdownClassName,
          status: customStatus,
          clearIcon,
          allowClear,
          rootClassName
        } = props, restProps = __rest$e(props, ["prefixCls", "getPopupContainer", "className", "style", "placement", "size", "disabled", "bordered", "placeholder", "popupClassName", "dropdownClassName", "status", "clearIcon", "allowClear", "rootClassName"]);
        const innerRef = reactExports.useRef(null);
        const {
          getPrefixCls,
          direction,
          getPopupContainer,
          rangePicker
        } = reactExports.useContext(ConfigContext);
        const prefixCls = getPrefixCls("picker", customizePrefixCls);
        const {
          compactSize,
          compactItemClassnames
        } = useCompactItemContext(prefixCls, direction);
        const {
          format: format2,
          showTime,
          picker
        } = props;
        const rootPrefixCls = getPrefixCls();
        const cssVarCls = useCSSVarCls$1(prefixCls);
        const [wrapCSSVar, hashId] = useStyle$9(prefixCls, cssVarCls);
        const additionalOverrideProps = Object.assign(Object.assign({}, showTime ? getTimeProps(Object.assign({
          format: format2,
          picker
        }, showTime)) : {}), picker === "time" ? getTimeProps(Object.assign(Object.assign({
          format: format2
        }, props), {
          picker
        })) : {});
        const mergedSize = useSize$1((ctx) => {
          var _a2;
          return (_a2 = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a2 !== void 0 ? _a2 : ctx;
        });
        const disabled = reactExports.useContext(DisabledContext$1);
        const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
        const formItemContext = reactExports.useContext(FormItemInputContext);
        const {
          hasFeedback,
          status: contextStatus,
          feedbackIcon
        } = formItemContext;
        const suffixNode = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, picker === "time" ? /* @__PURE__ */ reactExports.createElement(ClockCircleOutlined$1, null) : /* @__PURE__ */ reactExports.createElement(CalendarOutlined$1, null), hasFeedback && feedbackIcon);
        reactExports.useImperativeHandle(ref, () => ({
          focus: () => {
            var _a2;
            return (_a2 = innerRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
          },
          blur: () => {
            var _a2;
            return (_a2 = innerRef.current) === null || _a2 === void 0 ? void 0 : _a2.blur();
          }
        }));
        const [contextLocale] = useLocale$1("Calendar", enUS);
        const locale2 = Object.assign(Object.assign({}, contextLocale), props.locale);
        const [zIndex] = useZIndex("DatePicker", (_a = props.popupStyle) === null || _a === void 0 ? void 0 : _a.zIndex);
        return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(RangePicker, Object.assign({
          separator: /* @__PURE__ */ reactExports.createElement("span", {
            "aria-label": "to",
            className: `${prefixCls}-separator`
          }, /* @__PURE__ */ reactExports.createElement(SwapRightOutlined$1, null)),
          disabled: mergedDisabled,
          ref: innerRef,
          dropdownAlign: transPlacement2DropdownAlign(direction, placement),
          placeholder: getRangePlaceholder(locale2, picker, placeholder),
          suffixIcon: suffixNode,
          prevIcon: /* @__PURE__ */ reactExports.createElement("span", {
            className: `${prefixCls}-prev-icon`
          }),
          nextIcon: /* @__PURE__ */ reactExports.createElement("span", {
            className: `${prefixCls}-next-icon`
          }),
          superPrevIcon: /* @__PURE__ */ reactExports.createElement("span", {
            className: `${prefixCls}-super-prev-icon`
          }),
          superNextIcon: /* @__PURE__ */ reactExports.createElement("span", {
            className: `${prefixCls}-super-next-icon`
          }),
          transitionName: `${rootPrefixCls}-slide-up`
        }, restProps, additionalOverrideProps, {
          className: classNames({
            [`${prefixCls}-${mergedSize}`]: mergedSize,
            [`${prefixCls}-borderless`]: !bordered
          }, getStatusClassNames(prefixCls, getMergedStatus(contextStatus, customStatus), hasFeedback), hashId, compactItemClassnames, className, rangePicker === null || rangePicker === void 0 ? void 0 : rangePicker.className, cssVarCls, rootClassName),
          style: Object.assign(Object.assign({}, rangePicker === null || rangePicker === void 0 ? void 0 : rangePicker.style), style2),
          locale: locale2.lang,
          prefixCls,
          getPopupContainer: customGetPopupContainer || getPopupContainer,
          generateConfig: generateConfig2,
          components: Components$1,
          direction,
          dropdownClassName: classNames(hashId, popupClassName || dropdownClassName, cssVarCls, rootClassName),
          popupStyle: Object.assign(Object.assign({}, props.popupStyle), {
            zIndex
          }),
          allowClear: mergeAllowClear(allowClear, clearIcon, /* @__PURE__ */ reactExports.createElement(CloseCircleFilled$1, null))
        })));
      });
      return RangePicker$1;
    }
    var __rest$d = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    function generatePicker$1(generateConfig2) {
      function getPicker(picker, displayName) {
        const consumerName = displayName === "TimePicker" ? "timePicker" : "datePicker";
        const Picker$1 = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
          var _a;
          const {
            prefixCls: customizePrefixCls,
            getPopupContainer: customizeGetPopupContainer,
            style: style2,
            className,
            rootClassName,
            size: customizeSize,
            bordered = true,
            placement,
            placeholder,
            popupClassName,
            dropdownClassName,
            disabled: customDisabled,
            status: customStatus,
            clearIcon,
            allowClear
          } = props, restProps = __rest$d(props, ["prefixCls", "getPopupContainer", "style", "className", "rootClassName", "size", "bordered", "placement", "placeholder", "popupClassName", "dropdownClassName", "disabled", "status", "clearIcon", "allowClear"]);
          const {
            getPrefixCls,
            direction,
            getPopupContainer,
            // Consume different styles according to different names
            [consumerName]: consumerStyle
          } = reactExports.useContext(ConfigContext);
          const prefixCls = getPrefixCls("picker", customizePrefixCls);
          const {
            compactSize,
            compactItemClassnames
          } = useCompactItemContext(prefixCls, direction);
          const innerRef = reactExports.useRef(null);
          const {
            format: format2,
            showTime
          } = props;
          const cssVarCls = useCSSVarCls$1(prefixCls);
          const [wrapCSSVar, hashId] = useStyle$9(prefixCls, cssVarCls);
          reactExports.useImperativeHandle(ref, () => ({
            focus: () => {
              var _a2;
              return (_a2 = innerRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
            },
            blur: () => {
              var _a2;
              return (_a2 = innerRef.current) === null || _a2 === void 0 ? void 0 : _a2.blur();
            }
          }));
          const additionalProps = {
            showToday: true
          };
          let additionalOverrideProps = {};
          if (picker) {
            additionalOverrideProps.picker = picker;
          }
          const mergedPicker = picker || props.picker;
          additionalOverrideProps = Object.assign(Object.assign(Object.assign({}, additionalOverrideProps), showTime ? getTimeProps(Object.assign({
            format: format2,
            picker: mergedPicker
          }, showTime)) : {}), mergedPicker === "time" ? getTimeProps(Object.assign(Object.assign({
            format: format2
          }, props), {
            picker: mergedPicker
          })) : {});
          const rootPrefixCls = getPrefixCls();
          const mergedSize = useSize$1((ctx) => {
            var _a2;
            return (_a2 = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a2 !== void 0 ? _a2 : ctx;
          });
          const disabled = reactExports.useContext(DisabledContext$1);
          const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
          const formItemContext = reactExports.useContext(FormItemInputContext);
          const {
            hasFeedback,
            status: contextStatus,
            feedbackIcon
          } = formItemContext;
          const suffixNode = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, mergedPicker === "time" ? /* @__PURE__ */ reactExports.createElement(ClockCircleOutlined$1, null) : /* @__PURE__ */ reactExports.createElement(CalendarOutlined$1, null), hasFeedback && feedbackIcon);
          const [contextLocale] = useLocale$1("DatePicker", enUS);
          const locale2 = Object.assign(Object.assign({}, contextLocale), props.locale);
          const [zIndex] = useZIndex("DatePicker", (_a = props.popupStyle) === null || _a === void 0 ? void 0 : _a.zIndex);
          return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(Picker, Object.assign({
            ref: innerRef,
            placeholder: getPlaceholder(locale2, mergedPicker, placeholder),
            suffixIcon: suffixNode,
            dropdownAlign: transPlacement2DropdownAlign(direction, placement),
            prevIcon: /* @__PURE__ */ reactExports.createElement("span", {
              className: `${prefixCls}-prev-icon`
            }),
            nextIcon: /* @__PURE__ */ reactExports.createElement("span", {
              className: `${prefixCls}-next-icon`
            }),
            superPrevIcon: /* @__PURE__ */ reactExports.createElement("span", {
              className: `${prefixCls}-super-prev-icon`
            }),
            superNextIcon: /* @__PURE__ */ reactExports.createElement("span", {
              className: `${prefixCls}-super-next-icon`
            }),
            transitionName: `${rootPrefixCls}-slide-up`
          }, additionalProps, restProps, additionalOverrideProps, {
            locale: locale2.lang,
            className: classNames({
              [`${prefixCls}-${mergedSize}`]: mergedSize,
              [`${prefixCls}-borderless`]: !bordered
            }, getStatusClassNames(prefixCls, getMergedStatus(contextStatus, customStatus), hasFeedback), hashId, compactItemClassnames, consumerStyle === null || consumerStyle === void 0 ? void 0 : consumerStyle.className, className, cssVarCls, rootClassName),
            style: Object.assign(Object.assign({}, consumerStyle === null || consumerStyle === void 0 ? void 0 : consumerStyle.style), style2),
            prefixCls,
            getPopupContainer: customizeGetPopupContainer || getPopupContainer,
            generateConfig: generateConfig2,
            components: Components$1,
            direction,
            disabled: mergedDisabled,
            dropdownClassName: classNames(hashId, cssVarCls, rootClassName, popupClassName || dropdownClassName),
            popupStyle: Object.assign(Object.assign({}, props.popupStyle), {
              zIndex
            }),
            allowClear: mergeAllowClear(allowClear, clearIcon, /* @__PURE__ */ reactExports.createElement(CloseCircleFilled$1, null))
          })));
        });
        if (displayName) {
          Picker$1.displayName = displayName;
        }
        return Picker$1;
      }
      const DatePicker2 = getPicker();
      const WeekPicker = getPicker("week", "WeekPicker");
      const MonthPicker = getPicker("month", "MonthPicker");
      const YearPicker = getPicker("year", "YearPicker");
      const TimePicker2 = getPicker("time", "TimePicker");
      const QuarterPicker = getPicker("quarter", "QuarterPicker");
      return {
        DatePicker: DatePicker2,
        WeekPicker,
        MonthPicker,
        YearPicker,
        TimePicker: TimePicker2,
        QuarterPicker
      };
    }
    function generatePicker(generateConfig2) {
      const {
        DatePicker: DatePicker2,
        WeekPicker,
        MonthPicker,
        YearPicker,
        TimePicker: TimePicker2,
        QuarterPicker
      } = generatePicker$1(generateConfig2);
      const RangePicker2 = generateRangePicker(generateConfig2);
      const MergedDatePicker = DatePicker2;
      MergedDatePicker.WeekPicker = WeekPicker;
      MergedDatePicker.MonthPicker = MonthPicker;
      MergedDatePicker.YearPicker = YearPicker;
      MergedDatePicker.RangePicker = RangePicker2;
      MergedDatePicker.TimePicker = TimePicker2;
      MergedDatePicker.QuarterPicker = QuarterPicker;
      return MergedDatePicker;
    }
    const DatePicker = generatePicker(generateConfig);
    function postPureProps(props) {
      const dropdownAlign = transPlacement2DropdownAlign(props.direction, props.placement);
      dropdownAlign.overflow.adjustY = false;
      dropdownAlign.overflow.adjustX = false;
      return Object.assign(Object.assign({}, props), {
        dropdownAlign
      });
    }
    const PurePanel = genPurePanel$1(DatePicker, "picker", null, postPureProps);
    DatePicker._InternalPanelDoNotUseOrYouWillBeFired = PurePanel;
    const PureRangePanel = genPurePanel$1(DatePicker.RangePicker, "picker", null, postPureProps);
    DatePicker._InternalRangePanelDoNotUseOrYouWillBeFired = PureRangePanel;
    DatePicker.generatePicker = generatePicker;
    const DatePicker$1 = DatePicker;
    function isPresetSize(size) {
      return ["small", "middle", "large"].includes(size);
    }
    function isValidGapNumber(size) {
      if (!size) {
        return false;
      }
      return typeof size === "number" && !Number.isNaN(size);
    }
    const SpaceContext = /* @__PURE__ */ React.createContext({
      latestIndex: 0
    });
    const SpaceContextProvider = SpaceContext.Provider;
    const Item$1 = (_ref) => {
      let {
        className,
        index: index2,
        children,
        split,
        style: style2
      } = _ref;
      const {
        latestIndex
      } = reactExports.useContext(SpaceContext);
      if (children === null || children === void 0) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("div", {
        className,
        style: style2
      }, children), index2 < latestIndex && split && /* @__PURE__ */ reactExports.createElement("span", {
        className: `${className}-split`
      }, split));
    };
    const Item$2 = Item$1;
    var __rest$c = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const Space = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      var _a, _b;
      const {
        getPrefixCls,
        space,
        direction: directionConfig
      } = reactExports.useContext(ConfigContext);
      const {
        size = (space === null || space === void 0 ? void 0 : space.size) || "small",
        align,
        className,
        rootClassName,
        children,
        direction = "horizontal",
        prefixCls: customizePrefixCls,
        split,
        style: style2,
        wrap = false,
        classNames: customClassNames,
        styles
      } = props, otherProps = __rest$c(props, ["size", "align", "className", "rootClassName", "children", "direction", "prefixCls", "split", "style", "wrap", "classNames", "styles"]);
      const [horizontalSize, verticalSize] = Array.isArray(size) ? size : [size, size];
      const isPresetVerticalSize = isPresetSize(verticalSize);
      const isPresetHorizontalSize = isPresetSize(horizontalSize);
      const isValidVerticalSize = isValidGapNumber(verticalSize);
      const isValidHorizontalSize = isValidGapNumber(horizontalSize);
      const childNodes = toArray$a(children, {
        keepEmpty: true
      });
      const mergedAlign = align === void 0 && direction === "horizontal" ? "center" : align;
      const prefixCls = getPrefixCls("space", customizePrefixCls);
      const [wrapCSSVar, hashId] = useStyle$k(prefixCls);
      const cls = classNames(prefixCls, space === null || space === void 0 ? void 0 : space.className, hashId, `${prefixCls}-${direction}`, {
        [`${prefixCls}-rtl`]: directionConfig === "rtl",
        [`${prefixCls}-align-${mergedAlign}`]: mergedAlign,
        [`${prefixCls}-gap-row-${verticalSize}`]: isPresetVerticalSize,
        [`${prefixCls}-gap-col-${horizontalSize}`]: isPresetHorizontalSize
      }, className, rootClassName);
      const itemClassName = classNames(`${prefixCls}-item`, (_a = customClassNames === null || customClassNames === void 0 ? void 0 : customClassNames.item) !== null && _a !== void 0 ? _a : (_b = space === null || space === void 0 ? void 0 : space.classNames) === null || _b === void 0 ? void 0 : _b.item);
      let latestIndex = 0;
      const nodes = childNodes.map((child, i) => {
        var _a2, _b2;
        if (child !== null && child !== void 0) {
          latestIndex = i;
        }
        const key = child && child.key || `${itemClassName}-${i}`;
        return /* @__PURE__ */ reactExports.createElement(Item$2, {
          className: itemClassName,
          key,
          index: i,
          split,
          style: (_a2 = styles === null || styles === void 0 ? void 0 : styles.item) !== null && _a2 !== void 0 ? _a2 : (_b2 = space === null || space === void 0 ? void 0 : space.styles) === null || _b2 === void 0 ? void 0 : _b2.item
        }, child);
      });
      const spaceContext = reactExports.useMemo(() => ({
        latestIndex
      }), [latestIndex]);
      if (childNodes.length === 0) {
        return null;
      }
      const gapStyle = {};
      if (wrap) {
        gapStyle.flexWrap = "wrap";
      }
      if (!isPresetHorizontalSize && isValidHorizontalSize) {
        gapStyle.columnGap = horizontalSize;
      }
      if (!isPresetVerticalSize && isValidVerticalSize) {
        gapStyle.rowGap = verticalSize;
      }
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("div", Object.assign({
        ref,
        className: cls,
        style: Object.assign(Object.assign(Object.assign({}, gapStyle), space === null || space === void 0 ? void 0 : space.style), style2)
      }, otherProps), /* @__PURE__ */ reactExports.createElement(SpaceContextProvider, {
        value: spaceContext
      }, nodes)));
    });
    const CompoundedSpace = Space;
    CompoundedSpace.Compact = Compact;
    const Space$1 = CompoundedSpace;
    var __rest$b = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const DropdownButton = (props) => {
      const {
        getPopupContainer: getContextPopupContainer,
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const {
        prefixCls: customizePrefixCls,
        type = "default",
        danger,
        disabled,
        loading,
        onClick,
        htmlType,
        children,
        className,
        menu,
        arrow,
        autoFocus,
        overlay,
        trigger,
        align,
        open,
        onOpenChange,
        placement,
        getPopupContainer,
        href,
        icon = /* @__PURE__ */ reactExports.createElement(EllipsisOutlined$1, null),
        title,
        buttonsRender = (buttons) => buttons,
        mouseEnterDelay,
        mouseLeaveDelay,
        overlayClassName,
        overlayStyle,
        destroyPopupOnHide,
        dropdownRender
      } = props, restProps = __rest$b(props, ["prefixCls", "type", "danger", "disabled", "loading", "onClick", "htmlType", "children", "className", "menu", "arrow", "autoFocus", "overlay", "trigger", "align", "open", "onOpenChange", "placement", "getPopupContainer", "href", "icon", "title", "buttonsRender", "mouseEnterDelay", "mouseLeaveDelay", "overlayClassName", "overlayStyle", "destroyPopupOnHide", "dropdownRender"]);
      const prefixCls = getPrefixCls("dropdown", customizePrefixCls);
      const buttonPrefixCls = `${prefixCls}-button`;
      const dropdownProps = {
        menu,
        arrow,
        autoFocus,
        align,
        disabled,
        trigger: disabled ? [] : trigger,
        onOpenChange,
        getPopupContainer: getPopupContainer || getContextPopupContainer,
        mouseEnterDelay,
        mouseLeaveDelay,
        overlayClassName,
        overlayStyle,
        destroyPopupOnHide,
        dropdownRender
      };
      const {
        compactSize,
        compactItemClassnames
      } = useCompactItemContext(prefixCls, direction);
      const classes = classNames(buttonPrefixCls, compactItemClassnames, className);
      if ("overlay" in props) {
        dropdownProps.overlay = overlay;
      }
      if ("open" in props) {
        dropdownProps.open = open;
      }
      if ("placement" in props) {
        dropdownProps.placement = placement;
      } else {
        dropdownProps.placement = direction === "rtl" ? "bottomLeft" : "bottomRight";
      }
      const leftButton = /* @__PURE__ */ reactExports.createElement(Button$2, {
        type,
        danger,
        disabled,
        loading,
        onClick,
        htmlType,
        href,
        title
      }, children);
      const rightButton = /* @__PURE__ */ reactExports.createElement(Button$2, {
        type,
        danger,
        icon
      });
      const [leftButtonToRender, rightButtonToRender] = buttonsRender([leftButton, rightButton]);
      return /* @__PURE__ */ reactExports.createElement(Space$1.Compact, Object.assign({
        className: classes,
        size: compactSize,
        block: true
      }, restProps), leftButtonToRender, /* @__PURE__ */ reactExports.createElement(InternalDropdown, Object.assign({}, dropdownProps), rightButtonToRender));
    };
    DropdownButton.__ANT_BUTTON = true;
    const DropdownButton$1 = DropdownButton;
    const Dropdown = InternalDropdown;
    Dropdown.Button = DropdownButton$1;
    const Dropdown$1 = Dropdown;
    function useDebounce(value) {
      const [cacheValue, setCacheValue] = reactExports.useState(value);
      reactExports.useEffect(() => {
        const timeout = setTimeout(() => {
          setCacheValue(value);
        }, value.length ? 0 : 10);
        return () => {
          clearTimeout(timeout);
        };
      }, [value]);
      return cacheValue;
    }
    const genFormValidateMotionStyle = (token2) => {
      const {
        componentCls
      } = token2;
      const helpCls = `${componentCls}-show-help`;
      const helpItemCls = `${componentCls}-show-help-item`;
      return {
        [helpCls]: {
          // Explain holder
          transition: `opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut}`,
          "&-appear, &-enter": {
            opacity: 0,
            "&-active": {
              opacity: 1
            }
          },
          "&-leave": {
            opacity: 1,
            "&-active": {
              opacity: 0
            }
          },
          // Explain
          [helpItemCls]: {
            overflow: "hidden",
            transition: `height ${token2.motionDurationSlow} ${token2.motionEaseInOut},
                     opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut},
                     transform ${token2.motionDurationSlow} ${token2.motionEaseInOut} !important`,
            [`&${helpItemCls}-appear, &${helpItemCls}-enter`]: {
              transform: `translateY(-5px)`,
              opacity: 0,
              [`&-active`]: {
                transform: "translateY(0)",
                opacity: 1
              }
            },
            [`&${helpItemCls}-leave-active`]: {
              transform: `translateY(-5px)`
            }
          }
        }
      };
    };
    const genFormValidateMotionStyle$1 = genFormValidateMotionStyle;
    const resetForm = (token2) => ({
      legend: {
        display: "block",
        width: "100%",
        marginBottom: token2.marginLG,
        padding: 0,
        color: token2.colorTextDescription,
        fontSize: token2.fontSizeLG,
        lineHeight: "inherit",
        border: 0,
        borderBottom: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`
      },
      label: {
        fontSize: token2.fontSize
      },
      'input[type="search"]': {
        boxSizing: "border-box"
      },
      // Position radios and checkboxes better
      'input[type="radio"], input[type="checkbox"]': {
        lineHeight: "normal"
      },
      'input[type="file"]': {
        display: "block"
      },
      // Make range inputs behave like textual form controls
      'input[type="range"]': {
        display: "block",
        width: "100%"
      },
      // Make multiple select elements height not fixed
      "select[multiple], select[size]": {
        height: "auto"
      },
      // Focus for file, radio, and checkbox
      [`input[type='file']:focus,
  input[type='radio']:focus,
  input[type='checkbox']:focus`]: {
        outline: 0,
        boxShadow: `0 0 0 ${unit$1(token2.controlOutlineWidth)} ${token2.controlOutline}`
      },
      // Adjust output element
      output: {
        display: "block",
        paddingTop: 15,
        color: token2.colorText,
        fontSize: token2.fontSize,
        lineHeight: token2.lineHeight
      }
    });
    const genFormSize = (token2, height) => {
      const {
        formItemCls
      } = token2;
      return {
        [formItemCls]: {
          [`${formItemCls}-label > label`]: {
            height
          },
          [`${formItemCls}-control-input`]: {
            minHeight: height
          }
        }
      };
    };
    const genFormStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [token2.componentCls]: Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), resetForm(token2)), {
          [`${componentCls}-text`]: {
            display: "inline-block",
            paddingInlineEnd: token2.paddingSM
          },
          // ================================================================
          // =                             Size                             =
          // ================================================================
          "&-small": Object.assign({}, genFormSize(token2, token2.controlHeightSM)),
          "&-large": Object.assign({}, genFormSize(token2, token2.controlHeightLG))
        })
      };
    };
    const genFormItemStyle = (token2) => {
      const {
        formItemCls,
        iconCls,
        componentCls,
        rootPrefixCls,
        labelRequiredMarkColor,
        labelColor,
        labelFontSize,
        labelHeight,
        labelColonMarginInlineStart,
        labelColonMarginInlineEnd,
        itemMarginBottom
      } = token2;
      return {
        [formItemCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
          marginBottom: itemMarginBottom,
          verticalAlign: "top",
          "&-with-help": {
            transition: "none"
          },
          [`&-hidden,
        &-hidden.${rootPrefixCls}-row`]: {
            // https://github.com/ant-design/ant-design/issues/26141
            display: "none"
          },
          "&-has-warning": {
            [`${formItemCls}-split`]: {
              color: token2.colorError
            }
          },
          "&-has-error": {
            [`${formItemCls}-split`]: {
              color: token2.colorWarning
            }
          },
          // ==============================================================
          // =                            Label                           =
          // ==============================================================
          [`${formItemCls}-label`]: {
            flexGrow: 0,
            overflow: "hidden",
            whiteSpace: "nowrap",
            textAlign: "end",
            verticalAlign: "middle",
            "&-left": {
              textAlign: "start"
            },
            "&-wrap": {
              overflow: "unset",
              lineHeight: token2.lineHeight,
              whiteSpace: "unset"
            },
            "> label": {
              position: "relative",
              display: "inline-flex",
              alignItems: "center",
              maxWidth: "100%",
              height: labelHeight,
              color: labelColor,
              fontSize: labelFontSize,
              [`> ${iconCls}`]: {
                fontSize: token2.fontSize,
                verticalAlign: "top"
              },
              // Required mark
              [`&${formItemCls}-required:not(${formItemCls}-required-mark-optional)::before`]: {
                display: "inline-block",
                marginInlineEnd: token2.marginXXS,
                color: labelRequiredMarkColor,
                fontSize: token2.fontSize,
                fontFamily: "SimSun, sans-serif",
                lineHeight: 1,
                content: '"*"',
                [`${componentCls}-hide-required-mark &`]: {
                  display: "none"
                }
              },
              // Optional mark
              [`${formItemCls}-optional`]: {
                display: "inline-block",
                marginInlineStart: token2.marginXXS,
                color: token2.colorTextDescription,
                [`${componentCls}-hide-required-mark &`]: {
                  display: "none"
                }
              },
              // Optional mark
              [`${formItemCls}-tooltip`]: {
                color: token2.colorTextDescription,
                cursor: "help",
                writingMode: "horizontal-tb",
                marginInlineStart: token2.marginXXS
              },
              "&::after": {
                content: '":"',
                position: "relative",
                marginBlock: 0,
                marginInlineStart: labelColonMarginInlineStart,
                marginInlineEnd: labelColonMarginInlineEnd
              },
              [`&${formItemCls}-no-colon::after`]: {
                content: '"\\a0"'
              }
            }
          },
          // ==============================================================
          // =                            Input                           =
          // ==============================================================
          [`${formItemCls}-control`]: {
            ["--ant-display"]: "flex",
            flexDirection: "column",
            flexGrow: 1,
            [`&:first-child:not([class^="'${rootPrefixCls}-col-'"]):not([class*="' ${rootPrefixCls}-col-'"])`]: {
              width: "100%"
            },
            "&-input": {
              position: "relative",
              display: "flex",
              alignItems: "center",
              minHeight: token2.controlHeight,
              "&-content": {
                flex: "auto",
                maxWidth: "100%"
              }
            }
          },
          // ==============================================================
          // =                           Explain                          =
          // ==============================================================
          [formItemCls]: {
            "&-explain, &-extra": {
              clear: "both",
              color: token2.colorTextDescription,
              fontSize: token2.fontSize,
              lineHeight: token2.lineHeight
            },
            "&-explain-connected": {
              width: "100%"
            },
            "&-extra": {
              minHeight: token2.controlHeightSM,
              transition: `color ${token2.motionDurationMid} ${token2.motionEaseOut}`
              // sync input color transition
            },
            "&-explain": {
              "&-error": {
                color: token2.colorError
              },
              "&-warning": {
                color: token2.colorWarning
              }
            }
          },
          [`&-with-help ${formItemCls}-explain`]: {
            height: "auto",
            opacity: 1
          },
          // ==============================================================
          // =                        Feedback Icon                       =
          // ==============================================================
          [`${formItemCls}-feedback-icon`]: {
            fontSize: token2.fontSize,
            textAlign: "center",
            visibility: "visible",
            animationName: zoomIn,
            animationDuration: token2.motionDurationMid,
            animationTimingFunction: token2.motionEaseOutBack,
            pointerEvents: "none",
            "&-success": {
              color: token2.colorSuccess
            },
            "&-error": {
              color: token2.colorError
            },
            "&-warning": {
              color: token2.colorWarning
            },
            "&-validating": {
              color: token2.colorPrimary
            }
          }
        })
      };
    };
    const genHorizontalStyle = (token2) => {
      const {
        componentCls,
        formItemCls
      } = token2;
      return {
        [`${componentCls}-horizontal`]: {
          [`${formItemCls}-label`]: {
            flexGrow: 0
          },
          [`${formItemCls}-control`]: {
            flex: "1 1 0",
            // https://github.com/ant-design/ant-design/issues/32777
            // https://github.com/ant-design/ant-design/issues/33773
            minWidth: 0
          },
          // Do not change this to `ant-col-24`! `-24` match all the responsive rules
          // https://github.com/ant-design/ant-design/issues/32980
          // https://github.com/ant-design/ant-design/issues/34903
          // https://github.com/ant-design/ant-design/issues/44538
          [`${formItemCls}-label[class$='-24'], ${formItemCls}-label[class*='-24 ']`]: {
            [`& + ${formItemCls}-control`]: {
              minWidth: "unset"
            }
          }
        }
      };
    };
    const genInlineStyle = (token2) => {
      const {
        componentCls,
        formItemCls
      } = token2;
      return {
        [`${componentCls}-inline`]: {
          display: "flex",
          flexWrap: "wrap",
          [formItemCls]: {
            flex: "none",
            marginInlineEnd: token2.margin,
            marginBottom: 0,
            "&-row": {
              flexWrap: "nowrap"
            },
            [`> ${formItemCls}-label,
        > ${formItemCls}-control`]: {
              display: "inline-block",
              verticalAlign: "top"
            },
            [`> ${formItemCls}-label`]: {
              flex: "none"
            },
            [`${componentCls}-text`]: {
              display: "inline-block"
            },
            [`${formItemCls}-has-feedback`]: {
              display: "inline-block"
            }
          }
        }
      };
    };
    const makeVerticalLayoutLabel = (token2) => ({
      padding: token2.verticalLabelPadding,
      margin: token2.verticalLabelMargin,
      whiteSpace: "initial",
      textAlign: "start",
      "> label": {
        margin: 0,
        "&::after": {
          // https://github.com/ant-design/ant-design/issues/43538
          visibility: "hidden"
        }
      }
    });
    const makeVerticalLayout = (token2) => {
      const {
        componentCls,
        formItemCls,
        rootPrefixCls
      } = token2;
      return {
        [`${formItemCls} ${formItemCls}-label`]: makeVerticalLayoutLabel(token2),
        // ref: https://github.com/ant-design/ant-design/issues/45122
        [`${componentCls}:not(${componentCls}-inline)`]: {
          [formItemCls]: {
            flexWrap: "wrap",
            [`${formItemCls}-label, ${formItemCls}-control`]: {
              // When developer pass `xs: { span }`,
              // It should follow the `xs` screen config
              // ref: https://github.com/ant-design/ant-design/issues/44386
              [`&:not([class*=" ${rootPrefixCls}-col-xs"])`]: {
                flex: "0 0 100%",
                maxWidth: "100%"
              }
            }
          }
        }
      };
    };
    const genVerticalStyle = (token2) => {
      const {
        componentCls,
        formItemCls,
        rootPrefixCls
      } = token2;
      return {
        [`${componentCls}-vertical`]: {
          [formItemCls]: {
            "&-row": {
              flexDirection: "column"
            },
            "&-label > label": {
              height: "auto"
            },
            [`${componentCls}-item-control`]: {
              width: "100%"
            }
          }
        },
        [`${componentCls}-vertical ${formItemCls}-label,
      .${rootPrefixCls}-col-24${formItemCls}-label,
      .${rootPrefixCls}-col-xl-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2),
        [`@media (max-width: ${unit$1(token2.screenXSMax)})`]: [makeVerticalLayout(token2), {
          [componentCls]: {
            [`.${rootPrefixCls}-col-xs-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
          }
        }],
        [`@media (max-width: ${unit$1(token2.screenSMMax)})`]: {
          [componentCls]: {
            [`.${rootPrefixCls}-col-sm-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
          }
        },
        [`@media (max-width: ${unit$1(token2.screenMDMax)})`]: {
          [componentCls]: {
            [`.${rootPrefixCls}-col-md-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
          }
        },
        [`@media (max-width: ${unit$1(token2.screenLGMax)})`]: {
          [componentCls]: {
            [`.${rootPrefixCls}-col-lg-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
          }
        }
      };
    };
    const prepareComponentToken$6 = (token2) => ({
      labelRequiredMarkColor: token2.colorError,
      labelColor: token2.colorTextHeading,
      labelFontSize: token2.fontSize,
      labelHeight: token2.controlHeight,
      labelColonMarginInlineStart: token2.marginXXS / 2,
      labelColonMarginInlineEnd: token2.marginXS,
      itemMarginBottom: token2.marginLG,
      verticalLabelPadding: `0 0 ${token2.paddingXS}px`,
      verticalLabelMargin: 0
    });
    const prepareToken$1 = (token2, rootPrefixCls) => {
      const formToken = merge$1(token2, {
        formItemCls: `${token2.componentCls}-item`,
        rootPrefixCls
      });
      return formToken;
    };
    const useStyle$6 = genStyleHooks("Form", (token2, _ref) => {
      let {
        rootPrefixCls
      } = _ref;
      const formToken = prepareToken$1(token2, rootPrefixCls);
      return [genFormStyle(formToken), genFormItemStyle(formToken), genFormValidateMotionStyle$1(formToken), genHorizontalStyle(formToken), genInlineStyle(formToken), genVerticalStyle(formToken), genCollapseMotion$1(formToken), zoomIn];
    }, prepareComponentToken$6, {
      // Let From style before the Grid
      // ref https://github.com/ant-design/ant-design/issues/44386
      order: -1e3
    });
    const EMPTY_LIST$2 = [];
    function toErrorEntity(error, prefix, errorStatus) {
      let index2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      return {
        key: typeof error === "string" ? error : `${prefix}-${index2}`,
        error,
        errorStatus
      };
    }
    const ErrorList = (_ref) => {
      let {
        help,
        helpStatus,
        errors = EMPTY_LIST$2,
        warnings = EMPTY_LIST$2,
        className: rootClassName,
        fieldId,
        onVisibleChanged
      } = _ref;
      const {
        prefixCls
      } = reactExports.useContext(FormItemPrefixContext);
      const baseClassName = `${prefixCls}-item-explain`;
      const cssVarCls = useCSSVarCls$1(prefixCls);
      const [wrapCSSVar, hashId] = useStyle$6(prefixCls, cssVarCls);
      const collapseMotion = reactExports.useMemo(() => initCollapseMotion(prefixCls), [prefixCls]);
      const debounceErrors = useDebounce(errors);
      const debounceWarnings = useDebounce(warnings);
      const fullKeyList = reactExports.useMemo(() => {
        if (help !== void 0 && help !== null) {
          return [toErrorEntity(help, "help", helpStatus)];
        }
        return [].concat(_toConsumableArray(debounceErrors.map((error, index2) => toErrorEntity(error, "error", "error", index2))), _toConsumableArray(debounceWarnings.map((warning2, index2) => toErrorEntity(warning2, "warning", "warning", index2))));
      }, [help, helpStatus, debounceErrors, debounceWarnings]);
      const helpProps = {};
      if (fieldId) {
        helpProps.id = `${fieldId}_help`;
      }
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(CSSMotion, {
        motionDeadline: collapseMotion.motionDeadline,
        motionName: `${prefixCls}-show-help`,
        visible: !!fullKeyList.length,
        onVisibleChanged
      }, (holderProps) => {
        const {
          className: holderClassName,
          style: holderStyle
        } = holderProps;
        return /* @__PURE__ */ reactExports.createElement("div", Object.assign({}, helpProps, {
          className: classNames(baseClassName, holderClassName, cssVarCls, rootClassName, hashId),
          style: holderStyle,
          role: "alert"
        }), /* @__PURE__ */ reactExports.createElement(CSSMotionList, Object.assign({
          keys: fullKeyList
        }, initCollapseMotion(prefixCls), {
          motionName: `${prefixCls}-show-help-item`,
          component: false
        }), (itemProps) => {
          const {
            key,
            error,
            errorStatus,
            className: itemClassName,
            style: itemStyle
          } = itemProps;
          return /* @__PURE__ */ reactExports.createElement("div", {
            key,
            className: classNames(itemClassName, {
              [`${baseClassName}-${errorStatus}`]: errorStatus
            }),
            style: itemStyle
          }, error);
        }));
      }));
    };
    const ErrorList$1 = ErrorList;
    const formItemNameBlackList = ["parentNode"];
    const defaultItemNamePrefixCls = "form_item";
    function toArray$4(candidate) {
      if (candidate === void 0 || candidate === false)
        return [];
      return Array.isArray(candidate) ? candidate : [candidate];
    }
    function getFieldId(namePath, formName) {
      if (!namePath.length) {
        return void 0;
      }
      const mergedId = namePath.join("_");
      if (formName) {
        return `${formName}_${mergedId}`;
      }
      const isIllegalName = formItemNameBlackList.includes(mergedId);
      return isIllegalName ? `${defaultItemNamePrefixCls}_${mergedId}` : mergedId;
    }
    function getStatus(errors, warnings, meta, defaultValidateStatus, hasFeedback, validateStatus) {
      let status = defaultValidateStatus;
      if (validateStatus !== void 0) {
        status = validateStatus;
      } else if (meta.validating) {
        status = "validating";
      } else if (errors.length) {
        status = "error";
      } else if (warnings.length) {
        status = "warning";
      } else if (meta.touched || hasFeedback && meta.validated) {
        status = "success";
      }
      return status;
    }
    function toNamePathStr(name) {
      const namePath = toArray$4(name);
      return namePath.join("_");
    }
    function useForm(form) {
      const [rcForm] = useForm$1();
      const itemsRef = reactExports.useRef({});
      const wrapForm = reactExports.useMemo(() => form !== null && form !== void 0 ? form : Object.assign(Object.assign({}, rcForm), {
        __INTERNAL__: {
          itemRef: (name) => (node2) => {
            const namePathStr = toNamePathStr(name);
            if (node2) {
              itemsRef.current[namePathStr] = node2;
            } else {
              delete itemsRef.current[namePathStr];
            }
          }
        },
        scrollToField: function(name) {
          let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          const namePath = toArray$4(name);
          const fieldId = getFieldId(namePath, wrapForm.__INTERNAL__.name);
          const node2 = fieldId ? document.getElementById(fieldId) : null;
          if (node2) {
            e(node2, Object.assign({
              scrollMode: "if-needed",
              block: "nearest"
            }, options));
          }
        },
        getFieldInstance: (name) => {
          const namePathStr = toNamePathStr(name);
          return itemsRef.current[namePathStr];
        }
      }), [form, rcForm]);
      return [wrapForm];
    }
    var __rest$a = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const InternalForm = (props, ref) => {
      const contextDisabled = reactExports.useContext(DisabledContext$1);
      const {
        getPrefixCls,
        direction,
        form: contextForm
      } = reactExports.useContext(ConfigContext);
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        size,
        disabled = contextDisabled,
        form,
        colon,
        labelAlign,
        labelWrap,
        labelCol,
        wrapperCol,
        hideRequiredMark,
        layout = "horizontal",
        scrollToFirstError,
        requiredMark,
        onFinishFailed,
        name,
        style: style2,
        feedbackIcons
      } = props, restFormProps = __rest$a(props, ["prefixCls", "className", "rootClassName", "size", "disabled", "form", "colon", "labelAlign", "labelWrap", "labelCol", "wrapperCol", "hideRequiredMark", "layout", "scrollToFirstError", "requiredMark", "onFinishFailed", "name", "style", "feedbackIcons"]);
      const mergedSize = useSize$1(size);
      const contextValidateMessages = reactExports.useContext(ValidateMessagesContext);
      const mergedRequiredMark = reactExports.useMemo(() => {
        if (requiredMark !== void 0) {
          return requiredMark;
        }
        if (hideRequiredMark) {
          return false;
        }
        if (contextForm && contextForm.requiredMark !== void 0) {
          return contextForm.requiredMark;
        }
        return true;
      }, [hideRequiredMark, requiredMark, contextForm]);
      const mergedColon = colon !== null && colon !== void 0 ? colon : contextForm === null || contextForm === void 0 ? void 0 : contextForm.colon;
      const prefixCls = getPrefixCls("form", customizePrefixCls);
      const cssVarCls = useCSSVarCls$1(prefixCls);
      const [wrapCSSVar, hashId] = useStyle$6(prefixCls, cssVarCls);
      const formClassName = classNames(prefixCls, `${prefixCls}-${layout}`, {
        [`${prefixCls}-hide-required-mark`]: mergedRequiredMark === false,
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-${mergedSize}`]: mergedSize
      }, cssVarCls, hashId, contextForm === null || contextForm === void 0 ? void 0 : contextForm.className, className, rootClassName);
      const [wrapForm] = useForm(form);
      const {
        __INTERNAL__
      } = wrapForm;
      __INTERNAL__.name = name;
      const formContextValue = reactExports.useMemo(() => ({
        name,
        labelAlign,
        labelCol,
        labelWrap,
        wrapperCol,
        vertical: layout === "vertical",
        colon: mergedColon,
        requiredMark: mergedRequiredMark,
        itemRef: __INTERNAL__.itemRef,
        form: wrapForm,
        feedbackIcons
      }), [name, labelAlign, labelCol, wrapperCol, layout, mergedColon, mergedRequiredMark, wrapForm, feedbackIcons]);
      reactExports.useImperativeHandle(ref, () => wrapForm);
      const scrollToField = (options, fieldName) => {
        if (options) {
          let defaultScrollToFirstError = {
            block: "nearest"
          };
          if (typeof options === "object") {
            defaultScrollToFirstError = options;
          }
          wrapForm.scrollToField(fieldName, defaultScrollToFirstError);
        }
      };
      const onInternalFinishFailed = (errorInfo) => {
        onFinishFailed === null || onFinishFailed === void 0 ? void 0 : onFinishFailed(errorInfo);
        if (errorInfo.errorFields.length) {
          const fieldName = errorInfo.errorFields[0].name;
          if (scrollToFirstError !== void 0) {
            scrollToField(scrollToFirstError, fieldName);
            return;
          }
          if (contextForm && contextForm.scrollToFirstError !== void 0) {
            scrollToField(contextForm.scrollToFirstError, fieldName);
          }
        }
      };
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(DisabledContextProvider, {
        disabled
      }, /* @__PURE__ */ reactExports.createElement(SizeContext$1.Provider, {
        value: mergedSize
      }, /* @__PURE__ */ reactExports.createElement(FormProvider, {
        // This is not list in API, we pass with spread
        validateMessages: contextValidateMessages
      }, /* @__PURE__ */ reactExports.createElement(FormContext.Provider, {
        value: formContextValue
      }, /* @__PURE__ */ reactExports.createElement(RefForm, Object.assign({
        id: name
      }, restFormProps, {
        name,
        onFinishFailed: onInternalFinishFailed,
        form: wrapForm,
        style: Object.assign(Object.assign({}, contextForm === null || contextForm === void 0 ? void 0 : contextForm.style), style2),
        className: formClassName
      })))))));
    };
    const Form$2 = /* @__PURE__ */ reactExports.forwardRef(InternalForm);
    const InternalForm$1 = Form$2;
    function useChildren(children) {
      if (typeof children === "function") {
        return children;
      }
      const childList = toArray$a(children);
      return childList.length <= 1 ? childList[0] : childList;
    }
    const useFormItemStatus = () => {
      const {
        status,
        errors = [],
        warnings = []
      } = reactExports.useContext(FormItemInputContext);
      return {
        status,
        errors,
        warnings
      };
    };
    useFormItemStatus.Context = FormItemInputContext;
    const useFormItemStatus$1 = useFormItemStatus;
    function useFrameState(defaultValue) {
      const [value, setValue] = reactExports.useState(defaultValue);
      const frameRef = reactExports.useRef(null);
      const batchRef = reactExports.useRef([]);
      const destroyRef = reactExports.useRef(false);
      reactExports.useEffect(() => {
        destroyRef.current = false;
        return () => {
          destroyRef.current = true;
          wrapperRaf.cancel(frameRef.current);
          frameRef.current = null;
        };
      }, []);
      function setFrameValue(updater) {
        if (destroyRef.current) {
          return;
        }
        if (frameRef.current === null) {
          batchRef.current = [];
          frameRef.current = wrapperRaf(() => {
            frameRef.current = null;
            setValue((prevValue) => {
              let current = prevValue;
              batchRef.current.forEach((func) => {
                current = func(current);
              });
              return current;
            });
          });
        }
        batchRef.current.push(updater);
      }
      return [value, setFrameValue];
    }
    function useItemRef() {
      const {
        itemRef
      } = reactExports.useContext(FormContext);
      const cacheRef = reactExports.useRef({});
      function getRef(name, children) {
        const childrenRef = children && typeof children === "object" && children.ref;
        const nameStr = name.join("_");
        if (cacheRef.current.name !== nameStr || cacheRef.current.originRef !== childrenRef) {
          cacheRef.current.name = nameStr;
          cacheRef.current.originRef = childrenRef;
          cacheRef.current.ref = composeRef(itemRef(name), childrenRef);
        }
        return cacheRef.current.ref;
      }
      return getRef;
    }
    const genFallbackStyle = (token2) => {
      const {
        formItemCls
      } = token2;
      return {
        "@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none)": {
          // Fallback for IE, safe to remove we not support it anymore
          [`${formItemCls}-control`]: {
            display: "flex"
          }
        }
      };
    };
    const FallbackCmp = genSubStyleComponent(["Form", "item-item"], (token2, _ref) => {
      let {
        rootPrefixCls
      } = _ref;
      const formToken = prepareToken$1(token2, rootPrefixCls);
      return [genFallbackStyle(formToken)];
    });
    const FormItemInput = (props) => {
      const {
        prefixCls,
        status,
        wrapperCol,
        children,
        errors,
        warnings,
        _internalItemRender: formItemRender,
        extra,
        help,
        fieldId,
        marginBottom,
        onErrorVisibleChanged
      } = props;
      const baseClassName = `${prefixCls}-item`;
      const formContext = reactExports.useContext(FormContext);
      const mergedWrapperCol = wrapperCol || formContext.wrapperCol || {};
      const className = classNames(`${baseClassName}-control`, mergedWrapperCol.className);
      const subFormContext = reactExports.useMemo(() => Object.assign({}, formContext), [formContext]);
      delete subFormContext.labelCol;
      delete subFormContext.wrapperCol;
      const inputDom = /* @__PURE__ */ reactExports.createElement("div", {
        className: `${baseClassName}-control-input`
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: `${baseClassName}-control-input-content`
      }, children));
      const formItemContext = reactExports.useMemo(() => ({
        prefixCls,
        status
      }), [prefixCls, status]);
      const errorListDom = marginBottom !== null || errors.length || warnings.length ? /* @__PURE__ */ reactExports.createElement("div", {
        style: {
          display: "flex",
          flexWrap: "nowrap"
        }
      }, /* @__PURE__ */ reactExports.createElement(FormItemPrefixContext.Provider, {
        value: formItemContext
      }, /* @__PURE__ */ reactExports.createElement(ErrorList$1, {
        fieldId,
        errors,
        warnings,
        help,
        helpStatus: status,
        className: `${baseClassName}-explain-connected`,
        onVisibleChanged: onErrorVisibleChanged
      })), !!marginBottom && /* @__PURE__ */ reactExports.createElement("div", {
        style: {
          width: 0,
          height: marginBottom
        }
      })) : null;
      const extraProps = {};
      if (fieldId) {
        extraProps.id = `${fieldId}_extra`;
      }
      const extraDom = extra ? /* @__PURE__ */ reactExports.createElement("div", Object.assign({}, extraProps, {
        className: `${baseClassName}-extra`
      }), extra) : null;
      const dom = formItemRender && formItemRender.mark === "pro_table_render" && formItemRender.render ? formItemRender.render(props, {
        input: inputDom,
        errorList: errorListDom,
        extra: extraDom
      }) : /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, inputDom, errorListDom, extraDom);
      return /* @__PURE__ */ reactExports.createElement(FormContext.Provider, {
        value: subFormContext
      }, /* @__PURE__ */ reactExports.createElement(Col$1, Object.assign({}, mergedWrapperCol, {
        className
      }), dom), /* @__PURE__ */ reactExports.createElement(FallbackCmp, {
        prefixCls
      }));
    };
    const FormItemInput$1 = FormItemInput;
    var QuestionCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M623.6 316.7C593.6 290.4 554 276 512 276s-81.6 14.5-111.6 40.7C369.2 344 352 380.7 352 420v7.6c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V420c0-44.1 43.1-80 96-80s96 35.9 96 80c0 31.1-22 59.6-56.1 72.7-21.2 8.1-39.2 22.3-52.1 40.9-13.1 19-19.9 41.8-19.9 64.9V620c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-22.7a48.3 48.3 0 0130.9-44.8c59-22.7 97.1-74.7 97.1-132.5.1-39.3-17.1-76-48.3-103.3zM472 732a40 40 0 1080 0 40 40 0 10-80 0z" } }] }, "name": "question-circle", "theme": "outlined" };
    const QuestionCircleOutlinedSvg = QuestionCircleOutlined$2;
    var QuestionCircleOutlined = function QuestionCircleOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: QuestionCircleOutlinedSvg
      }));
    };
    const QuestionCircleOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(QuestionCircleOutlined);
    var __rest$9 = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    function toTooltipProps(tooltip) {
      if (!tooltip) {
        return null;
      }
      if (typeof tooltip === "object" && !/* @__PURE__ */ reactExports.isValidElement(tooltip)) {
        return tooltip;
      }
      return {
        title: tooltip
      };
    }
    const FormItemLabel = (_ref) => {
      let {
        prefixCls,
        label,
        htmlFor,
        labelCol,
        labelAlign,
        colon,
        required,
        requiredMark,
        tooltip
      } = _ref;
      var _a;
      const [formLocale] = useLocale$1("Form");
      const {
        vertical,
        labelAlign: contextLabelAlign,
        labelCol: contextLabelCol,
        labelWrap,
        colon: contextColon
      } = reactExports.useContext(FormContext);
      if (!label) {
        return null;
      }
      const mergedLabelCol = labelCol || contextLabelCol || {};
      const mergedLabelAlign = labelAlign || contextLabelAlign;
      const labelClsBasic = `${prefixCls}-item-label`;
      const labelColClassName = classNames(labelClsBasic, mergedLabelAlign === "left" && `${labelClsBasic}-left`, mergedLabelCol.className, {
        [`${labelClsBasic}-wrap`]: !!labelWrap
      });
      let labelChildren = label;
      const computedColon = colon === true || contextColon !== false && colon !== false;
      const haveColon = computedColon && !vertical;
      if (haveColon && typeof label === "string" && label.trim() !== "") {
        labelChildren = label.replace(/[:|：]\s*$/, "");
      }
      const tooltipProps = toTooltipProps(tooltip);
      if (tooltipProps) {
        const {
          icon = /* @__PURE__ */ reactExports.createElement(QuestionCircleOutlined$1, null)
        } = tooltipProps, restTooltipProps = __rest$9(tooltipProps, ["icon"]);
        const tooltipNode = /* @__PURE__ */ reactExports.createElement(Tooltip$1, Object.assign({}, restTooltipProps), /* @__PURE__ */ reactExports.cloneElement(icon, {
          className: `${prefixCls}-item-tooltip`,
          title: "",
          onClick: (e2) => {
            e2.preventDefault();
          },
          tabIndex: null
        }));
        labelChildren = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, labelChildren, tooltipNode);
      }
      const isOptionalMark = requiredMark === "optional";
      const isRenderMark = typeof requiredMark === "function";
      if (isRenderMark) {
        labelChildren = requiredMark(labelChildren, {
          required: !!required
        });
      } else if (isOptionalMark && !required) {
        labelChildren = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, labelChildren, /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-item-optional`,
          title: ""
        }, (formLocale === null || formLocale === void 0 ? void 0 : formLocale.optional) || ((_a = defaultLocale.Form) === null || _a === void 0 ? void 0 : _a.optional)));
      }
      const labelClassName = classNames({
        [`${prefixCls}-item-required`]: required,
        [`${prefixCls}-item-required-mark-optional`]: isOptionalMark || isRenderMark,
        [`${prefixCls}-item-no-colon`]: !computedColon
      });
      return /* @__PURE__ */ reactExports.createElement(Col$1, Object.assign({}, mergedLabelCol, {
        className: labelColClassName
      }), /* @__PURE__ */ reactExports.createElement("label", {
        htmlFor,
        className: labelClassName,
        title: typeof label === "string" ? label : ""
      }, labelChildren));
    };
    const FormItemLabel$1 = FormItemLabel;
    const iconMap = {
      success: CheckCircleFilled$1,
      warning: ExclamationCircleFilled$1,
      error: CloseCircleFilled$1,
      validating: LoadingOutlined$1
    };
    function StatusProvider(_ref) {
      let {
        children,
        errors,
        warnings,
        hasFeedback,
        validateStatus,
        prefixCls,
        meta,
        noStyle
      } = _ref;
      const itemPrefixCls = `${prefixCls}-item`;
      const {
        feedbackIcons
      } = reactExports.useContext(FormContext);
      const mergedValidateStatus = getStatus(errors, warnings, meta, null, !!hasFeedback, validateStatus);
      const {
        isFormItemInput: parentIsFormItemInput,
        status: parentStatus,
        hasFeedback: parentHasFeedback,
        feedbackIcon: parentFeedbackIcon
      } = reactExports.useContext(FormItemInputContext);
      const formItemStatusContext = reactExports.useMemo(() => {
        var _a;
        let feedbackIcon;
        if (hasFeedback) {
          const customIcons = hasFeedback !== true && hasFeedback.icons || feedbackIcons;
          const customIconNode = mergedValidateStatus && ((_a = customIcons === null || customIcons === void 0 ? void 0 : customIcons({
            status: mergedValidateStatus,
            errors,
            warnings
          })) === null || _a === void 0 ? void 0 : _a[mergedValidateStatus]);
          const IconNode = mergedValidateStatus && iconMap[mergedValidateStatus];
          feedbackIcon = customIconNode !== false && IconNode ? /* @__PURE__ */ reactExports.createElement("span", {
            className: classNames(`${itemPrefixCls}-feedback-icon`, `${itemPrefixCls}-feedback-icon-${mergedValidateStatus}`)
          }, customIconNode || /* @__PURE__ */ reactExports.createElement(IconNode, null)) : null;
        }
        const context = {
          status: mergedValidateStatus || "",
          errors,
          warnings,
          hasFeedback: !!hasFeedback,
          feedbackIcon,
          isFormItemInput: true
        };
        if (noStyle) {
          context.status = (mergedValidateStatus !== null && mergedValidateStatus !== void 0 ? mergedValidateStatus : parentStatus) || "";
          context.isFormItemInput = parentIsFormItemInput;
          context.hasFeedback = !!(hasFeedback !== null && hasFeedback !== void 0 ? hasFeedback : parentHasFeedback);
          context.feedbackIcon = hasFeedback !== void 0 ? context.feedbackIcon : parentFeedbackIcon;
        }
        return context;
      }, [mergedValidateStatus, hasFeedback, noStyle, parentIsFormItemInput, parentStatus]);
      return /* @__PURE__ */ reactExports.createElement(FormItemInputContext.Provider, {
        value: formItemStatusContext
      }, children);
    }
    var __rest$8 = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    function ItemHolder(props) {
      const {
        prefixCls,
        className,
        rootClassName,
        style: style2,
        help,
        errors,
        warnings,
        validateStatus,
        meta,
        hasFeedback,
        hidden,
        children,
        fieldId,
        required,
        isRequired,
        onSubItemMetaChange
      } = props, restProps = __rest$8(props, ["prefixCls", "className", "rootClassName", "style", "help", "errors", "warnings", "validateStatus", "meta", "hasFeedback", "hidden", "children", "fieldId", "required", "isRequired", "onSubItemMetaChange"]);
      const itemPrefixCls = `${prefixCls}-item`;
      const {
        requiredMark
      } = reactExports.useContext(FormContext);
      const itemRef = reactExports.useRef(null);
      const debounceErrors = useDebounce(errors);
      const debounceWarnings = useDebounce(warnings);
      const hasHelp = help !== void 0 && help !== null;
      const hasError = !!(hasHelp || errors.length || warnings.length);
      const isOnScreen = !!itemRef.current && isVisible(itemRef.current);
      const [marginBottom, setMarginBottom] = reactExports.useState(null);
      useLayoutEffect$1(() => {
        if (hasError && itemRef.current) {
          const itemStyle = getComputedStyle(itemRef.current);
          setMarginBottom(parseInt(itemStyle.marginBottom, 10));
        }
      }, [hasError, isOnScreen]);
      const onErrorVisibleChanged = (nextVisible) => {
        if (!nextVisible) {
          setMarginBottom(null);
        }
      };
      const getValidateState = function() {
        let isDebounce = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        const _errors = isDebounce ? debounceErrors : meta.errors;
        const _warnings = isDebounce ? debounceWarnings : meta.warnings;
        return getStatus(_errors, _warnings, meta, "", !!hasFeedback, validateStatus);
      };
      const mergedValidateStatus = getValidateState();
      const itemClassName = classNames(itemPrefixCls, className, rootClassName, {
        [`${itemPrefixCls}-with-help`]: hasHelp || debounceErrors.length || debounceWarnings.length,
        // Status
        [`${itemPrefixCls}-has-feedback`]: mergedValidateStatus && hasFeedback,
        [`${itemPrefixCls}-has-success`]: mergedValidateStatus === "success",
        [`${itemPrefixCls}-has-warning`]: mergedValidateStatus === "warning",
        [`${itemPrefixCls}-has-error`]: mergedValidateStatus === "error",
        [`${itemPrefixCls}-is-validating`]: mergedValidateStatus === "validating",
        [`${itemPrefixCls}-hidden`]: hidden
      });
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: itemClassName,
        style: style2,
        ref: itemRef
      }, /* @__PURE__ */ reactExports.createElement(Row$1, Object.assign({
        className: `${itemPrefixCls}-row`
      }, omit(restProps, [
        "_internalItemRender",
        "colon",
        "dependencies",
        "extra",
        "fieldKey",
        "getValueFromEvent",
        "getValueProps",
        "htmlFor",
        "id",
        // It is deprecated because `htmlFor` is its replacement.
        "initialValue",
        "isListField",
        "label",
        "labelAlign",
        "labelCol",
        "labelWrap",
        "messageVariables",
        "name",
        "normalize",
        "noStyle",
        "preserve",
        "requiredMark",
        "rules",
        "shouldUpdate",
        "trigger",
        "tooltip",
        "validateFirst",
        "validateTrigger",
        "valuePropName",
        "wrapperCol",
        "validateDebounce"
      ])), /* @__PURE__ */ reactExports.createElement(FormItemLabel$1, Object.assign({
        htmlFor: fieldId
      }, props, {
        requiredMark,
        required: required !== null && required !== void 0 ? required : isRequired,
        prefixCls
      })), /* @__PURE__ */ reactExports.createElement(FormItemInput$1, Object.assign({}, props, meta, {
        errors: debounceErrors,
        warnings: debounceWarnings,
        prefixCls,
        status: mergedValidateStatus,
        help,
        marginBottom,
        onErrorVisibleChanged
      }), /* @__PURE__ */ reactExports.createElement(NoStyleItemContext.Provider, {
        value: onSubItemMetaChange
      }, /* @__PURE__ */ reactExports.createElement(StatusProvider, {
        prefixCls,
        meta,
        errors: meta.errors,
        warnings: meta.warnings,
        hasFeedback,
        // Already calculated
        validateStatus: mergedValidateStatus
      }, children)))), !!marginBottom && /* @__PURE__ */ reactExports.createElement("div", {
        className: `${itemPrefixCls}-margin-offset`,
        style: {
          marginBottom: -marginBottom
        }
      }));
    }
    const NAME_SPLIT = "__SPLIT__";
    const MemoInput = /* @__PURE__ */ reactExports.memo((_ref) => {
      let {
        children
      } = _ref;
      return children;
    }, (prev2, next2) => prev2.value === next2.value && prev2.update === next2.update && prev2.childProps.length === next2.childProps.length && prev2.childProps.every((value, index2) => value === next2.childProps[index2]));
    function genEmptyMeta() {
      return {
        errors: [],
        warnings: [],
        touched: false,
        validating: false,
        name: [],
        validated: false
      };
    }
    function InternalFormItem(props) {
      const {
        name,
        noStyle,
        className,
        dependencies,
        prefixCls: customizePrefixCls,
        shouldUpdate,
        rules: rules2,
        children,
        required,
        label,
        messageVariables,
        trigger = "onChange",
        validateTrigger,
        hidden,
        help
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const {
        name: formName
      } = reactExports.useContext(FormContext);
      const mergedChildren = useChildren(children);
      const isRenderProps = typeof mergedChildren === "function";
      const notifyParentMetaChange = reactExports.useContext(NoStyleItemContext);
      const {
        validateTrigger: contextValidateTrigger
      } = reactExports.useContext(Context);
      const mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : contextValidateTrigger;
      const hasName = !(name === void 0 || name === null);
      const prefixCls = getPrefixCls("form", customizePrefixCls);
      const cssVarCls = useCSSVarCls$1(prefixCls);
      const [wrapCSSVar, hashId] = useStyle$6(prefixCls, cssVarCls);
      devUseWarning();
      const listContext = reactExports.useContext(ListContext);
      const fieldKeyPathRef = reactExports.useRef();
      const [subFieldErrors, setSubFieldErrors] = useFrameState({});
      const [meta, setMeta] = useSafeState(() => genEmptyMeta());
      const onMetaChange = (nextMeta) => {
        const keyInfo = listContext === null || listContext === void 0 ? void 0 : listContext.getKey(nextMeta.name);
        setMeta(nextMeta.destroy ? genEmptyMeta() : nextMeta, true);
        if (noStyle && help !== false && notifyParentMetaChange) {
          let namePath = nextMeta.name;
          if (!nextMeta.destroy) {
            if (keyInfo !== void 0) {
              const [fieldKey, restPath] = keyInfo;
              namePath = [fieldKey].concat(_toConsumableArray(restPath));
              fieldKeyPathRef.current = namePath;
            }
          } else {
            namePath = fieldKeyPathRef.current || namePath;
          }
          notifyParentMetaChange(nextMeta, namePath);
        }
      };
      const onSubItemMetaChange = (subMeta, uniqueKeys) => {
        setSubFieldErrors((prevSubFieldErrors) => {
          const clone2 = Object.assign({}, prevSubFieldErrors);
          const mergedNamePath = [].concat(_toConsumableArray(subMeta.name.slice(0, -1)), _toConsumableArray(uniqueKeys));
          const mergedNameKey = mergedNamePath.join(NAME_SPLIT);
          if (subMeta.destroy) {
            delete clone2[mergedNameKey];
          } else {
            clone2[mergedNameKey] = subMeta;
          }
          return clone2;
        });
      };
      const [mergedErrors, mergedWarnings] = reactExports.useMemo(() => {
        const errorList = _toConsumableArray(meta.errors);
        const warningList = _toConsumableArray(meta.warnings);
        Object.values(subFieldErrors).forEach((subFieldError) => {
          errorList.push.apply(errorList, _toConsumableArray(subFieldError.errors || []));
          warningList.push.apply(warningList, _toConsumableArray(subFieldError.warnings || []));
        });
        return [errorList, warningList];
      }, [subFieldErrors, meta.errors, meta.warnings]);
      const getItemRef = useItemRef();
      function renderLayout(baseChildren, fieldId, isRequired) {
        if (noStyle && !hidden) {
          return /* @__PURE__ */ reactExports.createElement(StatusProvider, {
            prefixCls,
            hasFeedback: props.hasFeedback,
            validateStatus: props.validateStatus,
            meta,
            errors: mergedErrors,
            warnings: mergedWarnings,
            noStyle: true
          }, baseChildren);
        }
        return /* @__PURE__ */ reactExports.createElement(ItemHolder, Object.assign({
          key: "row"
        }, props, {
          className: classNames(className, cssVarCls, hashId),
          prefixCls,
          fieldId,
          isRequired,
          errors: mergedErrors,
          warnings: mergedWarnings,
          meta,
          onSubItemMetaChange
        }), baseChildren);
      }
      if (!hasName && !isRenderProps && !dependencies) {
        return wrapCSSVar(renderLayout(mergedChildren));
      }
      let variables = {};
      if (typeof label === "string") {
        variables.label = label;
      } else if (name) {
        variables.label = String(name);
      }
      if (messageVariables) {
        variables = Object.assign(Object.assign({}, variables), messageVariables);
      }
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(WrapperField, Object.assign({}, props, {
        messageVariables: variables,
        trigger,
        validateTrigger: mergedValidateTrigger,
        onMetaChange
      }), (control, renderMeta, context) => {
        const mergedName = toArray$4(name).length && renderMeta ? renderMeta.name : [];
        const fieldId = getFieldId(mergedName, formName);
        const isRequired = required !== void 0 ? required : !!(rules2 && rules2.some((rule) => {
          if (rule && typeof rule === "object" && rule.required && !rule.warningOnly) {
            return true;
          }
          if (typeof rule === "function") {
            const ruleEntity = rule(context);
            return ruleEntity && ruleEntity.required && !ruleEntity.warningOnly;
          }
          return false;
        }));
        const mergedControl = Object.assign({}, control);
        let childNode = null;
        if (Array.isArray(mergedChildren) && hasName) {
          childNode = mergedChildren;
        } else if (isRenderProps && (!(shouldUpdate || dependencies) || hasName))
          ;
        else if (dependencies && !isRenderProps && !hasName)
          ;
        else if (isValidElement(mergedChildren)) {
          const childProps = Object.assign(Object.assign({}, mergedChildren.props), mergedControl);
          if (!childProps.id) {
            childProps.id = fieldId;
          }
          if (help || mergedErrors.length > 0 || mergedWarnings.length > 0 || props.extra) {
            const describedbyArr = [];
            if (help || mergedErrors.length > 0) {
              describedbyArr.push(`${fieldId}_help`);
            }
            if (props.extra) {
              describedbyArr.push(`${fieldId}_extra`);
            }
            childProps["aria-describedby"] = describedbyArr.join(" ");
          }
          if (mergedErrors.length > 0) {
            childProps["aria-invalid"] = "true";
          }
          if (isRequired) {
            childProps["aria-required"] = "true";
          }
          if (supportRef(mergedChildren)) {
            childProps.ref = getItemRef(mergedName, mergedChildren);
          }
          const triggers = new Set([].concat(_toConsumableArray(toArray$4(trigger)), _toConsumableArray(toArray$4(mergedValidateTrigger))));
          triggers.forEach((eventName) => {
            childProps[eventName] = function() {
              var _a2, _c2;
              var _a, _b, _c;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              (_a = mergedControl[eventName]) === null || _a === void 0 ? void 0 : (_a2 = _a).call.apply(_a2, [mergedControl].concat(args));
              (_c = (_b = mergedChildren.props)[eventName]) === null || _c === void 0 ? void 0 : (_c2 = _c).call.apply(_c2, [_b].concat(args));
            };
          });
          const watchingChildProps = [childProps["aria-required"], childProps["aria-invalid"], childProps["aria-describedby"]];
          childNode = /* @__PURE__ */ reactExports.createElement(MemoInput, {
            value: mergedControl[props.valuePropName || "value"],
            update: mergedChildren,
            childProps: watchingChildProps
          }, cloneElement(mergedChildren, childProps));
        } else if (isRenderProps && (shouldUpdate || dependencies) && !hasName) {
          childNode = mergedChildren(context);
        } else {
          childNode = mergedChildren;
        }
        return renderLayout(childNode, fieldId, isRequired);
      }));
    }
    const FormItem = InternalFormItem;
    FormItem.useStatus = useFormItemStatus$1;
    const Item = FormItem;
    var __rest$7 = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const FormList = (_a) => {
      var {
        prefixCls: customizePrefixCls,
        children
      } = _a, props = __rest$7(_a, ["prefixCls", "children"]);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("form", customizePrefixCls);
      const contextValue = reactExports.useMemo(() => ({
        prefixCls,
        status: "error"
      }), [prefixCls]);
      return /* @__PURE__ */ reactExports.createElement(List$2, Object.assign({}, props), (fields, operation, meta) => /* @__PURE__ */ reactExports.createElement(FormItemPrefixContext.Provider, {
        value: contextValue
      }, children(fields.map((field) => Object.assign(Object.assign({}, field), {
        fieldKey: field.key
      })), operation, {
        errors: meta.errors,
        warnings: meta.warnings
      })));
    };
    const List = FormList;
    function useFormInstance() {
      const {
        form
      } = reactExports.useContext(FormContext);
      return form;
    }
    const Form = InternalForm$1;
    Form.Item = Item;
    Form.List = List;
    Form.ErrorList = ErrorList$1;
    Form.useForm = useForm;
    Form.useFormInstance = useFormInstance;
    Form.useWatch = useWatch$1;
    Form.Provider = FormProvider;
    Form.create = () => {
    };
    const Form$1 = Form;
    function getOffset(node2) {
      var box = node2.getBoundingClientRect();
      var docElem = document.documentElement;
      return {
        left: box.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || document.body.clientLeft || 0),
        top: box.top + (window.pageYOffset || docElem.scrollTop) - (docElem.clientTop || document.body.clientTop || 0)
      };
    }
    function addEventListenerWrap(target, eventType, cb2, option) {
      var callback = ReactDOM.unstable_batchedUpdates ? function run(e2) {
        ReactDOM.unstable_batchedUpdates(cb2, e2);
      } : cb2;
      if (target !== null && target !== void 0 && target.addEventListener) {
        target.addEventListener(eventType, callback, option);
      }
      return {
        remove: function remove() {
          if (target !== null && target !== void 0 && target.removeEventListener) {
            target.removeEventListener(eventType, callback, option);
          }
        }
      };
    }
    const extendsObject = function() {
      const result = Object.assign({}, arguments.length <= 0 ? void 0 : arguments[0]);
      for (let i = 1; i < arguments.length; i++) {
        const obj = i < 0 || arguments.length <= i ? void 0 : arguments[i];
        if (obj) {
          Object.keys(obj).forEach((key) => {
            const val = obj[key];
            if (val !== void 0) {
              result[key] = val;
            }
          });
        }
      }
      return result;
    };
    const extendsObject$1 = extendsObject;
    var DoubleLeftOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M272.9 512l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L186.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H532c6.7 0 10.4-7.7 6.3-12.9L272.9 512zm304 0l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L490.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H836c6.7 0 10.4-7.7 6.3-12.9L576.9 512z" } }] }, "name": "double-left", "theme": "outlined" };
    const DoubleLeftOutlinedSvg = DoubleLeftOutlined$2;
    var DoubleLeftOutlined = function DoubleLeftOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: DoubleLeftOutlinedSvg
      }));
    };
    const DoubleLeftOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(DoubleLeftOutlined);
    var DoubleRightOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M533.2 492.3L277.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H188c-6.7 0-10.4 7.7-6.3 12.9L447.1 512 181.7 851.1A7.98 7.98 0 00188 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5zm304 0L581.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H492c-6.7 0-10.4 7.7-6.3 12.9L751.1 512 485.7 851.1A7.98 7.98 0 00492 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5z" } }] }, "name": "double-right", "theme": "outlined" };
    const DoubleRightOutlinedSvg = DoubleRightOutlined$2;
    var DoubleRightOutlined = function DoubleRightOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: DoubleRightOutlinedSvg
      }));
    };
    const DoubleRightOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(DoubleRightOutlined);
    var locale$5 = {
      // Options
      items_per_page: "条/页",
      jump_to: "跳至",
      jump_to_confirm: "确定",
      page: "页",
      // Pagination
      prev_page: "上一页",
      next_page: "下一页",
      prev_5: "向前 5 页",
      next_5: "向后 5 页",
      prev_3: "向前 3 页",
      next_3: "向后 3 页",
      page_size: "页码"
    };
    var defaultPageSizeOptions = ["10", "20", "50", "100"];
    var Options = function Options2(props) {
      var _props$pageSizeOption = props.pageSizeOptions, pageSizeOptions = _props$pageSizeOption === void 0 ? defaultPageSizeOptions : _props$pageSizeOption, locale2 = props.locale, changeSize = props.changeSize, pageSize = props.pageSize, goButton = props.goButton, quickGo = props.quickGo, rootPrefixCls = props.rootPrefixCls, Select2 = props.selectComponentClass, selectPrefixCls = props.selectPrefixCls, disabled = props.disabled, buildOptionText = props.buildOptionText;
      var _React$useState = React.useState(""), _React$useState2 = _slicedToArray(_React$useState, 2), goInputText = _React$useState2[0], setGoInputText = _React$useState2[1];
      var getValidValue = function getValidValue2() {
        return !goInputText || Number.isNaN(goInputText) ? void 0 : Number(goInputText);
      };
      var mergeBuildOptionText = typeof buildOptionText === "function" ? buildOptionText : function(value) {
        return "".concat(value, " ").concat(locale2.items_per_page);
      };
      var changeSizeHandle = function changeSizeHandle2(value) {
        changeSize === null || changeSize === void 0 || changeSize(Number(value));
      };
      var handleChange = function handleChange2(e2) {
        setGoInputText(e2.target.value);
      };
      var handleBlur = function handleBlur2(e2) {
        if (goButton || goInputText === "") {
          return;
        }
        setGoInputText("");
        if (e2.relatedTarget && (e2.relatedTarget.className.indexOf("".concat(rootPrefixCls, "-item-link")) >= 0 || e2.relatedTarget.className.indexOf("".concat(rootPrefixCls, "-item")) >= 0)) {
          return;
        }
        quickGo === null || quickGo === void 0 || quickGo(getValidValue());
      };
      var go = function go2(e2) {
        if (goInputText === "") {
          return;
        }
        if (e2.keyCode === KeyCode.ENTER || e2.type === "click") {
          setGoInputText("");
          quickGo === null || quickGo === void 0 || quickGo(getValidValue());
        }
      };
      var getPageSizeOptions = function getPageSizeOptions2() {
        if (pageSizeOptions.some(function(option) {
          return option.toString() === pageSize.toString();
        })) {
          return pageSizeOptions;
        }
        return pageSizeOptions.concat([pageSize.toString()]).sort(function(a, b2) {
          var numberA = Number.isNaN(Number(a)) ? 0 : Number(a);
          var numberB = Number.isNaN(Number(b2)) ? 0 : Number(b2);
          return numberA - numberB;
        });
      };
      var prefixCls = "".concat(rootPrefixCls, "-options");
      if (!changeSize && !quickGo) {
        return null;
      }
      var changeSelect = null;
      var goInput = null;
      var gotoButton = null;
      if (changeSize && Select2) {
        var options = getPageSizeOptions().map(function(opt, i) {
          return /* @__PURE__ */ React.createElement(Select2.Option, {
            key: i,
            value: opt.toString()
          }, mergeBuildOptionText(opt));
        });
        changeSelect = /* @__PURE__ */ React.createElement(Select2, {
          disabled,
          prefixCls: selectPrefixCls,
          showSearch: false,
          className: "".concat(prefixCls, "-size-changer"),
          optionLabelProp: "children",
          popupMatchSelectWidth: false,
          value: (pageSize || pageSizeOptions[0]).toString(),
          onChange: changeSizeHandle,
          getPopupContainer: function getPopupContainer(triggerNode) {
            return triggerNode.parentNode;
          },
          "aria-label": locale2.page_size,
          defaultOpen: false
        }, options);
      }
      if (quickGo) {
        if (goButton) {
          gotoButton = typeof goButton === "boolean" ? /* @__PURE__ */ React.createElement("button", {
            type: "button",
            onClick: go,
            onKeyUp: go,
            disabled,
            className: "".concat(prefixCls, "-quick-jumper-button")
          }, locale2.jump_to_confirm) : /* @__PURE__ */ React.createElement("span", {
            onClick: go,
            onKeyUp: go
          }, goButton);
        }
        goInput = /* @__PURE__ */ React.createElement("div", {
          className: "".concat(prefixCls, "-quick-jumper")
        }, locale2.jump_to, /* @__PURE__ */ React.createElement("input", {
          disabled,
          type: "text",
          value: goInputText,
          onChange: handleChange,
          onKeyUp: go,
          onBlur: handleBlur,
          "aria-label": locale2.page
        }), locale2.page, gotoButton);
      }
      return /* @__PURE__ */ React.createElement("li", {
        className: prefixCls
      }, changeSelect, goInput);
    };
    var Pager = function Pager2(props) {
      var _classNames;
      var rootPrefixCls = props.rootPrefixCls, page = props.page, active = props.active, className = props.className, showTitle = props.showTitle, onClick = props.onClick, onKeyPress = props.onKeyPress, itemRender = props.itemRender;
      var prefixCls = "".concat(rootPrefixCls, "-item");
      var cls = classNames(prefixCls, "".concat(prefixCls, "-").concat(page), (_classNames = {}, _defineProperty(_classNames, "".concat(prefixCls, "-active"), active), _defineProperty(_classNames, "".concat(prefixCls, "-disabled"), !page), _classNames), className);
      var handleClick = function handleClick2() {
        onClick(page);
      };
      var handleKeyPress = function handleKeyPress2(e2) {
        onKeyPress(e2, onClick, page);
      };
      var pager = itemRender(page, "page", /* @__PURE__ */ React.createElement("a", {
        rel: "nofollow"
      }, page));
      return pager ? /* @__PURE__ */ React.createElement("li", {
        title: showTitle ? String(page) : null,
        className: cls,
        onClick: handleClick,
        onKeyDown: handleKeyPress,
        tabIndex: 0
      }, pager) : null;
    };
    var defaultItemRender = function defaultItemRender2(page, type, element) {
      return element;
    };
    function noop$2() {
    }
    function isInteger(v2) {
      var value = Number(v2);
      return typeof value === "number" && !Number.isNaN(value) && isFinite(value) && Math.floor(value) === value;
    }
    function calculatePage(p2, pageSize, total) {
      var _pageSize = typeof p2 === "undefined" ? pageSize : p2;
      return Math.floor((total - 1) / _pageSize) + 1;
    }
    var Pagination$2 = function Pagination2(props) {
      var _classNames5;
      var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-pagination" : _props$prefixCls, _props$selectPrefixCl = props.selectPrefixCls, selectPrefixCls = _props$selectPrefixCl === void 0 ? "rc-select" : _props$selectPrefixCl, className = props.className, selectComponentClass = props.selectComponentClass, currentProp = props.current, _props$defaultCurrent = props.defaultCurrent, defaultCurrent = _props$defaultCurrent === void 0 ? 1 : _props$defaultCurrent, _props$total = props.total, total = _props$total === void 0 ? 0 : _props$total, pageSizeProp = props.pageSize, _props$defaultPageSiz = props.defaultPageSize, defaultPageSize = _props$defaultPageSiz === void 0 ? 10 : _props$defaultPageSiz, _props$onChange = props.onChange, onChange = _props$onChange === void 0 ? noop$2 : _props$onChange, hideOnSinglePage = props.hideOnSinglePage, _props$showPrevNextJu = props.showPrevNextJumpers, showPrevNextJumpers = _props$showPrevNextJu === void 0 ? true : _props$showPrevNextJu, showQuickJumper = props.showQuickJumper, showLessItems = props.showLessItems, _props$showTitle = props.showTitle, showTitle = _props$showTitle === void 0 ? true : _props$showTitle, _props$onShowSizeChan = props.onShowSizeChange, onShowSizeChange = _props$onShowSizeChan === void 0 ? noop$2 : _props$onShowSizeChan, _props$locale = props.locale, locale2 = _props$locale === void 0 ? locale$5 : _props$locale, style2 = props.style, _props$totalBoundaryS = props.totalBoundaryShowSizeChanger, totalBoundaryShowSizeChanger = _props$totalBoundaryS === void 0 ? 50 : _props$totalBoundaryS, disabled = props.disabled, simple = props.simple, showTotal = props.showTotal, showSizeChangerProp = props.showSizeChanger, pageSizeOptions = props.pageSizeOptions, _props$itemRender = props.itemRender, itemRender = _props$itemRender === void 0 ? defaultItemRender : _props$itemRender, jumpPrevIcon = props.jumpPrevIcon, jumpNextIcon = props.jumpNextIcon, prevIcon = props.prevIcon, nextIcon = props.nextIcon;
      var paginationRef = React.useRef(null);
      var _useMergedState = useMergedState(10, {
        value: pageSizeProp,
        defaultValue: defaultPageSize
      }), _useMergedState2 = _slicedToArray(_useMergedState, 2), pageSize = _useMergedState2[0], setPageSize = _useMergedState2[1];
      var _useMergedState3 = useMergedState(1, {
        value: currentProp,
        defaultValue: defaultCurrent,
        postState: function postState(c2) {
          return Math.max(1, Math.min(c2, calculatePage(void 0, pageSize, total)));
        }
      }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), current = _useMergedState4[0], setCurrent = _useMergedState4[1];
      var _React$useState = React.useState(current), _React$useState2 = _slicedToArray(_React$useState, 2), internalInputVal = _React$useState2[0], setInternalInputVal = _React$useState2[1];
      reactExports.useEffect(function() {
        setInternalInputVal(current);
      }, [current]);
      var jumpPrevPage = Math.max(1, current - (showLessItems ? 3 : 5));
      var jumpNextPage = Math.min(calculatePage(void 0, pageSize, total), current + (showLessItems ? 3 : 5));
      function getItemIcon(icon, label) {
        var iconNode = icon || /* @__PURE__ */ React.createElement("button", {
          type: "button",
          "aria-label": label,
          className: "".concat(prefixCls, "-item-link")
        });
        if (typeof icon === "function") {
          iconNode = /* @__PURE__ */ React.createElement(icon, _objectSpread2({}, props));
        }
        return iconNode;
      }
      function getValidValue(e2) {
        var inputValue = e2.target.value;
        var allPages2 = calculatePage(void 0, pageSize, total);
        var value;
        if (inputValue === "") {
          value = inputValue;
        } else if (Number.isNaN(Number(inputValue))) {
          value = internalInputVal;
        } else if (inputValue >= allPages2) {
          value = allPages2;
        } else {
          value = Number(inputValue);
        }
        return value;
      }
      function isValid2(page) {
        return isInteger(page) && page !== current && isInteger(total) && total > 0;
      }
      var shouldDisplayQuickJumper = total > pageSize ? showQuickJumper : false;
      function handleKeyDown(event) {
        if (event.keyCode === KeyCode.UP || event.keyCode === KeyCode.DOWN) {
          event.preventDefault();
        }
      }
      function handleKeyUp(event) {
        var value = getValidValue(event);
        if (value !== internalInputVal) {
          setInternalInputVal(value);
        }
        switch (event.keyCode) {
          case KeyCode.ENTER:
            handleChange(value);
            break;
          case KeyCode.UP:
            handleChange(value - 1);
            break;
          case KeyCode.DOWN:
            handleChange(value + 1);
            break;
        }
      }
      function handleBlur(event) {
        handleChange(getValidValue(event));
      }
      function changePageSize(size) {
        var newCurrent = calculatePage(size, pageSize, total);
        var nextCurrent = current > newCurrent && newCurrent !== 0 ? newCurrent : current;
        setPageSize(size);
        setInternalInputVal(nextCurrent);
        onShowSizeChange === null || onShowSizeChange === void 0 || onShowSizeChange(current, size);
        setCurrent(nextCurrent);
        onChange === null || onChange === void 0 || onChange(nextCurrent, size);
      }
      function handleChange(page) {
        if (isValid2(page) && !disabled) {
          var currentPage = calculatePage(void 0, pageSize, total);
          var newPage = page;
          if (page > currentPage) {
            newPage = currentPage;
          } else if (page < 1) {
            newPage = 1;
          }
          if (newPage !== internalInputVal) {
            setInternalInputVal(newPage);
          }
          setCurrent(newPage);
          onChange === null || onChange === void 0 || onChange(newPage, pageSize);
          return newPage;
        }
        return current;
      }
      var hasPrev = current > 1;
      var hasNext = current < calculatePage(void 0, pageSize, total);
      var showSizeChanger = showSizeChangerProp !== null && showSizeChangerProp !== void 0 ? showSizeChangerProp : total > totalBoundaryShowSizeChanger;
      function prevHandle() {
        if (hasPrev)
          handleChange(current - 1);
      }
      function nextHandle() {
        if (hasNext)
          handleChange(current + 1);
      }
      function jumpPrevHandle() {
        handleChange(jumpPrevPage);
      }
      function jumpNextHandle() {
        handleChange(jumpNextPage);
      }
      function runIfEnter(event, callback) {
        if (event.key === "Enter" || event.charCode === KeyCode.ENTER || event.keyCode === KeyCode.ENTER) {
          for (var _len = arguments.length, restParams = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            restParams[_key - 2] = arguments[_key];
          }
          callback.apply(void 0, restParams);
        }
      }
      function runIfEnterPrev(event) {
        runIfEnter(event, prevHandle);
      }
      function runIfEnterNext(event) {
        runIfEnter(event, nextHandle);
      }
      function runIfEnterJumpPrev(event) {
        runIfEnter(event, jumpPrevHandle);
      }
      function runIfEnterJumpNext(event) {
        runIfEnter(event, jumpNextHandle);
      }
      function renderPrev(prevPage2) {
        var prevButton = itemRender(prevPage2, "prev", getItemIcon(prevIcon, "prev page"));
        return /* @__PURE__ */ React.isValidElement(prevButton) ? /* @__PURE__ */ React.cloneElement(prevButton, {
          disabled: !hasPrev
        }) : prevButton;
      }
      function renderNext(nextPage2) {
        var nextButton = itemRender(nextPage2, "next", getItemIcon(nextIcon, "next page"));
        return /* @__PURE__ */ React.isValidElement(nextButton) ? /* @__PURE__ */ React.cloneElement(nextButton, {
          disabled: !hasNext
        }) : nextButton;
      }
      function handleGoTO(event) {
        if (event.type === "click" || event.keyCode === KeyCode.ENTER) {
          handleChange(internalInputVal);
        }
      }
      var jumpPrev = null;
      var dataOrAriaAttributeProps = pickAttrs(props, {
        aria: true,
        data: true
      });
      var totalText = showTotal && /* @__PURE__ */ React.createElement("li", {
        className: "".concat(prefixCls, "-total-text")
      }, showTotal(total, [total === 0 ? 0 : (current - 1) * pageSize + 1, current * pageSize > total ? total : current * pageSize]));
      var jumpNext = null;
      var allPages = calculatePage(void 0, pageSize, total);
      if (hideOnSinglePage && total <= pageSize) {
        return null;
      }
      var pagerList = [];
      var pagerProps = {
        rootPrefixCls: prefixCls,
        onClick: handleChange,
        onKeyPress: runIfEnter,
        showTitle,
        itemRender,
        page: -1
      };
      var prevPage = current - 1 > 0 ? current - 1 : 0;
      var nextPage = current + 1 < allPages ? current + 1 : allPages;
      var goButton = showQuickJumper && showQuickJumper.goButton;
      var gotoButton = goButton;
      var simplePager = null;
      if (simple) {
        if (typeof goButton === "boolean") {
          gotoButton = /* @__PURE__ */ React.createElement("button", {
            type: "button",
            onClick: handleGoTO,
            onKeyUp: handleGoTO
          }, locale2.jump_to_confirm);
        }
        gotoButton = /* @__PURE__ */ React.createElement("li", {
          title: showTitle ? "".concat(locale2.jump_to).concat(current, "/").concat(allPages) : null,
          className: "".concat(prefixCls, "-simple-pager")
        }, gotoButton);
        simplePager = /* @__PURE__ */ React.createElement("li", {
          title: showTitle ? "".concat(current, "/").concat(allPages) : null,
          className: "".concat(prefixCls, "-simple-pager")
        }, /* @__PURE__ */ React.createElement("input", {
          type: "text",
          value: internalInputVal,
          disabled,
          onKeyDown: handleKeyDown,
          onKeyUp: handleKeyUp,
          onChange: handleKeyUp,
          onBlur: handleBlur,
          size: 3
        }), /* @__PURE__ */ React.createElement("span", {
          className: "".concat(prefixCls, "-slash")
        }, "/"), allPages);
      }
      var pageBufferSize = showLessItems ? 1 : 2;
      if (allPages <= 3 + pageBufferSize * 2) {
        if (!allPages) {
          pagerList.push(/* @__PURE__ */ React.createElement(Pager, _extends$1({}, pagerProps, {
            key: "noPager",
            page: 1,
            className: "".concat(prefixCls, "-item-disabled")
          })));
        }
        for (var i = 1; i <= allPages; i += 1) {
          pagerList.push(/* @__PURE__ */ React.createElement(Pager, _extends$1({}, pagerProps, {
            key: i,
            page: i,
            active: current === i
          })));
        }
      } else {
        var prevItemTitle = showLessItems ? locale2.prev_3 : locale2.prev_5;
        var nextItemTitle = showLessItems ? locale2.next_3 : locale2.next_5;
        var jumpPrevContent = itemRender(jumpPrevPage, "jump-prev", getItemIcon(jumpPrevIcon, "prev page"));
        var jumpNextContent = itemRender(jumpNextPage, "jump-next", getItemIcon(jumpNextIcon, "next page"));
        if (showPrevNextJumpers) {
          jumpPrev = jumpPrevContent ? /* @__PURE__ */ React.createElement("li", {
            title: showTitle ? prevItemTitle : null,
            key: "prev",
            onClick: jumpPrevHandle,
            tabIndex: 0,
            onKeyDown: runIfEnterJumpPrev,
            className: classNames("".concat(prefixCls, "-jump-prev"), _defineProperty({}, "".concat(prefixCls, "-jump-prev-custom-icon"), !!jumpPrevIcon))
          }, jumpPrevContent) : null;
          jumpNext = jumpNextContent ? /* @__PURE__ */ React.createElement("li", {
            title: showTitle ? nextItemTitle : null,
            key: "next",
            onClick: jumpNextHandle,
            tabIndex: 0,
            onKeyDown: runIfEnterJumpNext,
            className: classNames("".concat(prefixCls, "-jump-next"), _defineProperty({}, "".concat(prefixCls, "-jump-next-custom-icon"), !!jumpNextIcon))
          }, jumpNextContent) : null;
        }
        var left = Math.max(1, current - pageBufferSize);
        var right = Math.min(current + pageBufferSize, allPages);
        if (current - 1 <= pageBufferSize) {
          right = 1 + pageBufferSize * 2;
        }
        if (allPages - current <= pageBufferSize) {
          left = allPages - pageBufferSize * 2;
        }
        for (var _i = left; _i <= right; _i += 1) {
          pagerList.push(/* @__PURE__ */ React.createElement(Pager, _extends$1({}, pagerProps, {
            key: _i,
            page: _i,
            active: current === _i
          })));
        }
        if (current - 1 >= pageBufferSize * 2 && current !== 1 + 2) {
          pagerList[0] = /* @__PURE__ */ React.cloneElement(pagerList[0], {
            className: classNames("".concat(prefixCls, "-item-after-jump-prev"), pagerList[0].props.className)
          });
          pagerList.unshift(jumpPrev);
        }
        if (allPages - current >= pageBufferSize * 2 && current !== allPages - 2) {
          var lastOne = pagerList[pagerList.length - 1];
          pagerList[pagerList.length - 1] = /* @__PURE__ */ React.cloneElement(lastOne, {
            className: classNames("".concat(prefixCls, "-item-before-jump-next"), lastOne.props.className)
          });
          pagerList.push(jumpNext);
        }
        if (left !== 1) {
          pagerList.unshift(/* @__PURE__ */ React.createElement(Pager, _extends$1({}, pagerProps, {
            key: 1,
            page: 1
          })));
        }
        if (right !== allPages) {
          pagerList.push(/* @__PURE__ */ React.createElement(Pager, _extends$1({}, pagerProps, {
            key: allPages,
            page: allPages
          })));
        }
      }
      var prev2 = renderPrev(prevPage);
      if (prev2) {
        var prevDisabled = !hasPrev || !allPages;
        prev2 = /* @__PURE__ */ React.createElement("li", {
          title: showTitle ? locale2.prev_page : null,
          onClick: prevHandle,
          tabIndex: prevDisabled ? null : 0,
          onKeyDown: runIfEnterPrev,
          className: classNames("".concat(prefixCls, "-prev"), _defineProperty({}, "".concat(prefixCls, "-disabled"), prevDisabled)),
          "aria-disabled": prevDisabled
        }, prev2);
      }
      var next2 = renderNext(nextPage);
      if (next2) {
        var nextDisabled, nextTabIndex;
        if (simple) {
          nextDisabled = !hasNext;
          nextTabIndex = hasPrev ? 0 : null;
        } else {
          nextDisabled = !hasNext || !allPages;
          nextTabIndex = nextDisabled ? null : 0;
        }
        next2 = /* @__PURE__ */ React.createElement("li", {
          title: showTitle ? locale2.next_page : null,
          onClick: nextHandle,
          tabIndex: nextTabIndex,
          onKeyDown: runIfEnterNext,
          className: classNames("".concat(prefixCls, "-next"), _defineProperty({}, "".concat(prefixCls, "-disabled"), nextDisabled)),
          "aria-disabled": nextDisabled
        }, next2);
      }
      var cls = classNames(prefixCls, className, (_classNames5 = {}, _defineProperty(_classNames5, "".concat(prefixCls, "-simple"), simple), _defineProperty(_classNames5, "".concat(prefixCls, "-disabled"), disabled), _classNames5));
      return /* @__PURE__ */ React.createElement("ul", _extends$1({
        className: cls,
        style: style2,
        ref: paginationRef
      }, dataOrAriaAttributeProps), totalText, prev2, simple ? simplePager : pagerList, next2, /* @__PURE__ */ React.createElement(Options, {
        locale: locale2,
        rootPrefixCls: prefixCls,
        disabled,
        selectComponentClass,
        selectPrefixCls,
        changeSize: showSizeChanger ? changePageSize : null,
        pageSize,
        pageSizeOptions,
        quickGo: shouldDisplayQuickJumper ? handleChange : null,
        goButton: gotoButton
      }));
    };
    const MiniSelect = (props) => /* @__PURE__ */ reactExports.createElement(Select$1, Object.assign({}, props, {
      showSearch: true,
      size: "small"
    }));
    const MiddleSelect = (props) => /* @__PURE__ */ reactExports.createElement(Select$1, Object.assign({}, props, {
      showSearch: true,
      size: "middle"
    }));
    MiniSelect.Option = Select$1.Option;
    MiddleSelect.Option = Select$1.Option;
    const genPaginationDisabledStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}-disabled`]: {
          "&, &:hover": {
            cursor: "not-allowed",
            [`${componentCls}-item-link`]: {
              color: token2.colorTextDisabled,
              cursor: "not-allowed"
            }
          },
          "&:focus-visible": {
            cursor: "not-allowed",
            [`${componentCls}-item-link`]: {
              color: token2.colorTextDisabled,
              cursor: "not-allowed"
            }
          }
        },
        [`&${componentCls}-disabled`]: {
          cursor: "not-allowed",
          [`${componentCls}-item`]: {
            cursor: "not-allowed",
            "&:hover, &:active": {
              backgroundColor: "transparent"
            },
            a: {
              color: token2.colorTextDisabled,
              backgroundColor: "transparent",
              border: "none",
              cursor: "not-allowed"
            },
            "&-active": {
              borderColor: token2.colorBorder,
              backgroundColor: token2.itemActiveBgDisabled,
              "&:hover, &:active": {
                backgroundColor: token2.itemActiveBgDisabled
              },
              a: {
                color: token2.itemActiveColorDisabled
              }
            }
          },
          [`${componentCls}-item-link`]: {
            color: token2.colorTextDisabled,
            cursor: "not-allowed",
            "&:hover, &:active": {
              backgroundColor: "transparent"
            },
            [`${componentCls}-simple&`]: {
              backgroundColor: "transparent",
              "&:hover, &:active": {
                backgroundColor: "transparent"
              }
            }
          },
          [`${componentCls}-simple-pager`]: {
            color: token2.colorTextDisabled
          },
          [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
            [`${componentCls}-item-link-icon`]: {
              opacity: 0
            },
            [`${componentCls}-item-ellipsis`]: {
              opacity: 1
            }
          }
        },
        [`&${componentCls}-simple`]: {
          [`${componentCls}-prev, ${componentCls}-next`]: {
            [`&${componentCls}-disabled ${componentCls}-item-link`]: {
              "&:hover, &:active": {
                backgroundColor: "transparent"
              }
            }
          }
        }
      };
    };
    const genPaginationMiniStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`&${componentCls}-mini ${componentCls}-total-text, &${componentCls}-mini ${componentCls}-simple-pager`]: {
          height: token2.itemSizeSM,
          lineHeight: unit$1(token2.itemSizeSM)
        },
        [`&${componentCls}-mini ${componentCls}-item`]: {
          minWidth: token2.itemSizeSM,
          height: token2.itemSizeSM,
          margin: 0,
          lineHeight: unit$1(token2.calc(token2.itemSizeSM).sub(2).equal())
        },
        [`&${componentCls}-mini:not(${componentCls}-disabled) ${componentCls}-item:not(${componentCls}-item-active)`]: {
          backgroundColor: "transparent",
          borderColor: "transparent",
          "&:hover": {
            backgroundColor: token2.colorBgTextHover
          },
          "&:active": {
            backgroundColor: token2.colorBgTextActive
          }
        },
        [`&${componentCls}-mini ${componentCls}-prev, &${componentCls}-mini ${componentCls}-next`]: {
          minWidth: token2.itemSizeSM,
          height: token2.itemSizeSM,
          margin: 0,
          lineHeight: unit$1(token2.itemSizeSM)
        },
        [`&${componentCls}-mini:not(${componentCls}-disabled)`]: {
          [`${componentCls}-prev, ${componentCls}-next`]: {
            [`&:hover ${componentCls}-item-link`]: {
              backgroundColor: token2.colorBgTextHover
            },
            [`&:active ${componentCls}-item-link`]: {
              backgroundColor: token2.colorBgTextActive
            },
            [`&${componentCls}-disabled:hover ${componentCls}-item-link`]: {
              backgroundColor: "transparent"
            }
          }
        },
        [`
    &${componentCls}-mini ${componentCls}-prev ${componentCls}-item-link,
    &${componentCls}-mini ${componentCls}-next ${componentCls}-item-link
    `]: {
          backgroundColor: "transparent",
          borderColor: "transparent",
          "&::after": {
            height: token2.itemSizeSM,
            lineHeight: unit$1(token2.itemSizeSM)
          }
        },
        [`&${componentCls}-mini ${componentCls}-jump-prev, &${componentCls}-mini ${componentCls}-jump-next`]: {
          height: token2.itemSizeSM,
          marginInlineEnd: 0,
          lineHeight: unit$1(token2.itemSizeSM)
        },
        [`&${componentCls}-mini ${componentCls}-options`]: {
          marginInlineStart: token2.paginationMiniOptionsMarginInlineStart,
          [`&-size-changer`]: {
            top: token2.miniOptionsSizeChangerTop
          },
          [`&-quick-jumper`]: {
            height: token2.itemSizeSM,
            lineHeight: unit$1(token2.itemSizeSM),
            input: Object.assign(Object.assign({}, genInputSmallStyle(token2)), {
              width: token2.paginationMiniQuickJumperInputWidth,
              height: token2.controlHeightSM
            })
          }
        }
      };
    };
    const genPaginationSimpleStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`
    &${componentCls}-simple ${componentCls}-prev,
    &${componentCls}-simple ${componentCls}-next
    `]: {
          height: token2.itemSizeSM,
          lineHeight: unit$1(token2.itemSizeSM),
          verticalAlign: "top",
          [`${componentCls}-item-link`]: {
            height: token2.itemSizeSM,
            backgroundColor: "transparent",
            border: 0,
            "&:hover": {
              backgroundColor: token2.colorBgTextHover
            },
            "&:active": {
              backgroundColor: token2.colorBgTextActive
            },
            "&::after": {
              height: token2.itemSizeSM,
              lineHeight: unit$1(token2.itemSizeSM)
            }
          }
        },
        [`&${componentCls}-simple ${componentCls}-simple-pager`]: {
          display: "inline-block",
          height: token2.itemSizeSM,
          marginInlineEnd: token2.marginXS,
          input: {
            boxSizing: "border-box",
            height: "100%",
            marginInlineEnd: token2.marginXS,
            padding: `0 ${unit$1(token2.paginationItemPaddingInline)}`,
            textAlign: "center",
            backgroundColor: token2.itemInputBg,
            border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
            borderRadius: token2.borderRadius,
            outline: "none",
            transition: `border-color ${token2.motionDurationMid}`,
            color: "inherit",
            "&:hover": {
              borderColor: token2.colorPrimary
            },
            "&:focus": {
              borderColor: token2.colorPrimaryHover,
              boxShadow: `${unit$1(token2.inputOutlineOffset)} 0 ${unit$1(token2.controlOutlineWidth)} ${token2.controlOutline}`
            },
            "&[disabled]": {
              color: token2.colorTextDisabled,
              backgroundColor: token2.colorBgContainerDisabled,
              borderColor: token2.colorBorder,
              cursor: "not-allowed"
            }
          }
        }
      };
    };
    const genPaginationJumpStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
          outline: 0,
          [`${componentCls}-item-container`]: {
            position: "relative",
            [`${componentCls}-item-link-icon`]: {
              color: token2.colorPrimary,
              fontSize: token2.fontSizeSM,
              opacity: 0,
              transition: `all ${token2.motionDurationMid}`,
              "&-svg": {
                top: 0,
                insetInlineEnd: 0,
                bottom: 0,
                insetInlineStart: 0,
                margin: "auto"
              }
            },
            [`${componentCls}-item-ellipsis`]: {
              position: "absolute",
              top: 0,
              insetInlineEnd: 0,
              bottom: 0,
              insetInlineStart: 0,
              display: "block",
              margin: "auto",
              color: token2.colorTextDisabled,
              fontFamily: "Arial, Helvetica, sans-serif",
              letterSpacing: token2.paginationEllipsisLetterSpacing,
              textAlign: "center",
              textIndent: token2.paginationEllipsisTextIndent,
              opacity: 1,
              transition: `all ${token2.motionDurationMid}`
            }
          },
          "&:hover": {
            [`${componentCls}-item-link-icon`]: {
              opacity: 1
            },
            [`${componentCls}-item-ellipsis`]: {
              opacity: 0
            }
          }
        },
        [`
    ${componentCls}-prev,
    ${componentCls}-jump-prev,
    ${componentCls}-jump-next
    `]: {
          marginInlineEnd: token2.marginXS
        },
        [`
    ${componentCls}-prev,
    ${componentCls}-next,
    ${componentCls}-jump-prev,
    ${componentCls}-jump-next
    `]: {
          display: "inline-block",
          minWidth: token2.itemSize,
          height: token2.itemSize,
          color: token2.colorText,
          fontFamily: token2.fontFamily,
          lineHeight: `${unit$1(token2.itemSize)}`,
          textAlign: "center",
          verticalAlign: "middle",
          listStyle: "none",
          borderRadius: token2.borderRadius,
          cursor: "pointer",
          transition: `all ${token2.motionDurationMid}`
        },
        [`${componentCls}-prev, ${componentCls}-next`]: {
          fontFamily: "Arial, Helvetica, sans-serif",
          outline: 0,
          button: {
            color: token2.colorText,
            cursor: "pointer",
            userSelect: "none"
          },
          [`${componentCls}-item-link`]: {
            display: "block",
            width: "100%",
            height: "100%",
            padding: 0,
            fontSize: token2.fontSizeSM,
            textAlign: "center",
            backgroundColor: "transparent",
            border: `${unit$1(token2.lineWidth)} ${token2.lineType} transparent`,
            borderRadius: token2.borderRadius,
            outline: "none",
            transition: `all ${token2.motionDurationMid}`
          },
          [`&:hover ${componentCls}-item-link`]: {
            backgroundColor: token2.colorBgTextHover
          },
          [`&:active ${componentCls}-item-link`]: {
            backgroundColor: token2.colorBgTextActive
          },
          [`&${componentCls}-disabled:hover`]: {
            [`${componentCls}-item-link`]: {
              backgroundColor: "transparent"
            }
          }
        },
        [`${componentCls}-slash`]: {
          marginInlineEnd: token2.paginationSlashMarginInlineEnd,
          marginInlineStart: token2.paginationSlashMarginInlineStart
        },
        [`${componentCls}-options`]: {
          display: "inline-block",
          marginInlineStart: token2.margin,
          verticalAlign: "middle",
          "&-size-changer.-select": {
            display: "inline-block",
            width: "auto"
          },
          "&-quick-jumper": {
            display: "inline-block",
            height: token2.controlHeight,
            marginInlineStart: token2.marginXS,
            lineHeight: unit$1(token2.controlHeight),
            verticalAlign: "top",
            input: Object.assign(Object.assign({}, genBasicInputStyle(token2)), {
              width: token2.calc(token2.controlHeightLG).mul(1.25).equal(),
              height: token2.controlHeight,
              boxSizing: "border-box",
              margin: 0,
              marginInlineStart: token2.marginXS,
              marginInlineEnd: token2.marginXS
            })
          }
        }
      };
    };
    const genPaginationItemStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}-item`]: {
          display: "inline-block",
          minWidth: token2.itemSize,
          height: token2.itemSize,
          marginInlineEnd: token2.marginXS,
          fontFamily: token2.fontFamily,
          lineHeight: unit$1(token2.calc(token2.itemSize).sub(2).equal()),
          textAlign: "center",
          verticalAlign: "middle",
          listStyle: "none",
          backgroundColor: "transparent",
          border: `${unit$1(token2.lineWidth)} ${token2.lineType} transparent`,
          borderRadius: token2.borderRadius,
          outline: 0,
          cursor: "pointer",
          userSelect: "none",
          a: {
            display: "block",
            padding: `0 ${unit$1(token2.paginationItemPaddingInline)}`,
            color: token2.colorText,
            "&:hover": {
              textDecoration: "none"
            }
          },
          [`&:not(${componentCls}-item-active)`]: {
            "&:hover": {
              transition: `all ${token2.motionDurationMid}`,
              backgroundColor: token2.colorBgTextHover
            },
            "&:active": {
              backgroundColor: token2.colorBgTextActive
            }
          },
          "&-active": {
            fontWeight: token2.fontWeightStrong,
            backgroundColor: token2.itemActiveBg,
            borderColor: token2.colorPrimary,
            a: {
              color: token2.colorPrimary
            },
            "&:hover": {
              borderColor: token2.colorPrimaryHover
            },
            "&:hover a": {
              color: token2.colorPrimaryHover
            }
          }
        }
      };
    };
    const genPaginationStyle$2 = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
          "ul, ol": {
            margin: 0,
            padding: 0,
            listStyle: "none"
          },
          "&::after": {
            display: "block",
            clear: "both",
            height: 0,
            overflow: "hidden",
            visibility: "hidden",
            content: '""'
          },
          [`${componentCls}-total-text`]: {
            display: "inline-block",
            height: token2.itemSize,
            marginInlineEnd: token2.marginXS,
            lineHeight: unit$1(token2.calc(token2.itemSize).sub(2).equal()),
            verticalAlign: "middle"
          }
        }), genPaginationItemStyle(token2)), genPaginationJumpStyle(token2)), genPaginationSimpleStyle(token2)), genPaginationMiniStyle(token2)), genPaginationDisabledStyle(token2)), {
          // media query style
          [`@media only screen and (max-width: ${token2.screenLG}px)`]: {
            [`${componentCls}-item`]: {
              "&-after-jump-prev, &-before-jump-next": {
                display: "none"
              }
            }
          },
          [`@media only screen and (max-width: ${token2.screenSM}px)`]: {
            [`${componentCls}-options`]: {
              display: "none"
            }
          }
        }),
        // rtl style
        [`&${token2.componentCls}-rtl`]: {
          direction: "rtl"
        }
      };
    };
    const genPaginationFocusStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}:not(${componentCls}-disabled)`]: {
          [`${componentCls}-item`]: Object.assign({}, genFocusStyle(token2)),
          [`${componentCls}-jump-prev, ${componentCls}-jump-next`]: {
            "&:focus-visible": Object.assign({
              [`${componentCls}-item-link-icon`]: {
                opacity: 1
              },
              [`${componentCls}-item-ellipsis`]: {
                opacity: 0
              }
            }, genFocusOutline(token2))
          },
          [`${componentCls}-prev, ${componentCls}-next`]: {
            [`&:focus-visible ${componentCls}-item-link`]: Object.assign({}, genFocusOutline(token2))
          }
        }
      };
    };
    const prepareComponentToken$5 = (token2) => Object.assign({
      itemBg: token2.colorBgContainer,
      itemSize: token2.controlHeight,
      itemSizeSM: token2.controlHeightSM,
      itemActiveBg: token2.colorBgContainer,
      itemLinkBg: token2.colorBgContainer,
      itemActiveColorDisabled: token2.colorTextDisabled,
      itemActiveBgDisabled: token2.controlItemBgActiveDisabled,
      itemInputBg: token2.colorBgContainer,
      miniOptionsSizeChangerTop: 0
    }, initComponentToken$1(token2));
    const prepareToken = (token2) => merge$1(token2, {
      inputOutlineOffset: 0,
      paginationMiniOptionsMarginInlineStart: token2.calc(token2.marginXXS).div(2).equal(),
      paginationMiniQuickJumperInputWidth: token2.calc(token2.controlHeightLG).mul(1.1).equal(),
      paginationItemPaddingInline: token2.calc(token2.marginXXS).mul(1.5).equal(),
      paginationEllipsisLetterSpacing: token2.calc(token2.marginXXS).div(2).equal(),
      paginationSlashMarginInlineStart: token2.marginXXS,
      paginationSlashMarginInlineEnd: token2.marginSM,
      paginationEllipsisTextIndent: "0.13em"
      // magic for ui experience
    }, initInputToken(token2));
    const useStyle$5 = genStyleHooks("Pagination", (token2) => {
      const paginationToken = prepareToken(token2);
      return [genPaginationStyle$2(paginationToken), genPaginationFocusStyle(paginationToken)];
    }, prepareComponentToken$5);
    const genBorderedStyle$2 = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}${componentCls}-bordered${componentCls}-disabled:not(${componentCls}-mini)`]: {
          "&, &:hover": {
            [`${componentCls}-item-link`]: {
              borderColor: token2.colorBorder
            }
          },
          "&:focus-visible": {
            [`${componentCls}-item-link`]: {
              borderColor: token2.colorBorder
            }
          },
          [`${componentCls}-item, ${componentCls}-item-link`]: {
            backgroundColor: token2.colorBgContainerDisabled,
            borderColor: token2.colorBorder,
            [`&:hover:not(${componentCls}-item-active)`]: {
              backgroundColor: token2.colorBgContainerDisabled,
              borderColor: token2.colorBorder,
              a: {
                color: token2.colorTextDisabled
              }
            },
            [`&${componentCls}-item-active`]: {
              backgroundColor: token2.itemActiveBgDisabled
            }
          },
          [`${componentCls}-prev, ${componentCls}-next`]: {
            "&:hover button": {
              backgroundColor: token2.colorBgContainerDisabled,
              borderColor: token2.colorBorder,
              color: token2.colorTextDisabled
            },
            [`${componentCls}-item-link`]: {
              backgroundColor: token2.colorBgContainerDisabled,
              borderColor: token2.colorBorder
            }
          }
        },
        [`${componentCls}${componentCls}-bordered:not(${componentCls}-mini)`]: {
          [`${componentCls}-prev, ${componentCls}-next`]: {
            "&:hover button": {
              borderColor: token2.colorPrimaryHover,
              backgroundColor: token2.itemBg
            },
            [`${componentCls}-item-link`]: {
              backgroundColor: token2.itemLinkBg,
              borderColor: token2.colorBorder
            },
            [`&:hover ${componentCls}-item-link`]: {
              borderColor: token2.colorPrimary,
              backgroundColor: token2.itemBg,
              color: token2.colorPrimary
            },
            [`&${componentCls}-disabled`]: {
              [`${componentCls}-item-link`]: {
                borderColor: token2.colorBorder,
                color: token2.colorTextDisabled
              }
            }
          },
          [`${componentCls}-item`]: {
            backgroundColor: token2.itemBg,
            border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
            [`&:hover:not(${componentCls}-item-active)`]: {
              borderColor: token2.colorPrimary,
              backgroundColor: token2.itemBg,
              a: {
                color: token2.colorPrimary
              }
            },
            "&-active": {
              borderColor: token2.colorPrimary
            }
          }
        }
      };
    };
    const BorderedStyle = genSubStyleComponent(["Pagination", "bordered"], (token2) => {
      const paginationToken = prepareToken(token2);
      return [genBorderedStyle$2(paginationToken)];
    }, prepareComponentToken$5);
    var __rest$6 = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const Pagination = (props) => {
      const {
        prefixCls: customizePrefixCls,
        selectPrefixCls: customizeSelectPrefixCls,
        className,
        rootClassName,
        style: style2,
        size: customizeSize,
        locale: customLocale,
        selectComponentClass,
        responsive,
        showSizeChanger
      } = props, restProps = __rest$6(props, ["prefixCls", "selectPrefixCls", "className", "rootClassName", "style", "size", "locale", "selectComponentClass", "responsive", "showSizeChanger"]);
      const {
        xs
      } = useBreakpoint(responsive);
      const [, token2] = useToken$1();
      const {
        getPrefixCls,
        direction,
        pagination = {}
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("pagination", customizePrefixCls);
      const [wrapCSSVar, hashId] = useStyle$5(prefixCls);
      const mergedShowSizeChanger = showSizeChanger !== null && showSizeChanger !== void 0 ? showSizeChanger : pagination.showSizeChanger;
      const iconsProps = reactExports.useMemo(() => {
        const ellipsis = /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-item-ellipsis`
        }, "•••");
        const prevIcon = /* @__PURE__ */ reactExports.createElement("button", {
          className: `${prefixCls}-item-link`,
          type: "button",
          tabIndex: -1
        }, direction === "rtl" ? /* @__PURE__ */ reactExports.createElement(RightOutlined$1, null) : /* @__PURE__ */ reactExports.createElement(LeftOutlined$1, null));
        const nextIcon = /* @__PURE__ */ reactExports.createElement("button", {
          className: `${prefixCls}-item-link`,
          type: "button",
          tabIndex: -1
        }, direction === "rtl" ? /* @__PURE__ */ reactExports.createElement(LeftOutlined$1, null) : /* @__PURE__ */ reactExports.createElement(RightOutlined$1, null));
        const jumpPrevIcon = /* @__PURE__ */ reactExports.createElement("a", {
          className: `${prefixCls}-item-link`
        }, /* @__PURE__ */ reactExports.createElement("div", {
          className: `${prefixCls}-item-container`
        }, direction === "rtl" ? /* @__PURE__ */ reactExports.createElement(DoubleRightOutlined$1, {
          className: `${prefixCls}-item-link-icon`
        }) : /* @__PURE__ */ reactExports.createElement(DoubleLeftOutlined$1, {
          className: `${prefixCls}-item-link-icon`
        }), ellipsis));
        const jumpNextIcon = /* @__PURE__ */ reactExports.createElement("a", {
          className: `${prefixCls}-item-link`
        }, /* @__PURE__ */ reactExports.createElement("div", {
          className: `${prefixCls}-item-container`
        }, direction === "rtl" ? /* @__PURE__ */ reactExports.createElement(DoubleLeftOutlined$1, {
          className: `${prefixCls}-item-link-icon`
        }) : /* @__PURE__ */ reactExports.createElement(DoubleRightOutlined$1, {
          className: `${prefixCls}-item-link-icon`
        }), ellipsis));
        return {
          prevIcon,
          nextIcon,
          jumpPrevIcon,
          jumpNextIcon
        };
      }, [direction, prefixCls]);
      const [contextLocale] = useLocale$1("Pagination", locale$9);
      const locale2 = Object.assign(Object.assign({}, contextLocale), customLocale);
      const mergedSize = useSize$1(customizeSize);
      const isSmall = mergedSize === "small" || !!(xs && !mergedSize && responsive);
      const selectPrefixCls = getPrefixCls("select", customizeSelectPrefixCls);
      const extendedClassName = classNames({
        [`${prefixCls}-mini`]: isSmall,
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-bordered`]: token2.wireframe
      }, pagination === null || pagination === void 0 ? void 0 : pagination.className, className, rootClassName, hashId);
      const mergedStyle = Object.assign(Object.assign({}, pagination === null || pagination === void 0 ? void 0 : pagination.style), style2);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, token2.wireframe && /* @__PURE__ */ reactExports.createElement(BorderedStyle, {
        prefixCls
      }), /* @__PURE__ */ reactExports.createElement(Pagination$2, Object.assign({}, iconsProps, restProps, {
        style: mergedStyle,
        prefixCls,
        selectPrefixCls,
        className: extendedClassName,
        selectComponentClass: selectComponentClass || (isSmall ? MiniSelect : MiddleSelect),
        locale: locale2,
        showSizeChanger: mergedShowSizeChanger
      }))));
    };
    const Pagination$1 = Pagination;
    const antSpinMove = new Keyframe("antSpinMove", {
      to: {
        opacity: 1
      }
    });
    const antRotate = new Keyframe("antRotate", {
      to: {
        transform: "rotate(405deg)"
      }
    });
    const genSpinStyle = (token2) => {
      const {
        componentCls,
        calc
      } = token2;
      return {
        [`${componentCls}`]: Object.assign(Object.assign({}, resetComponent(token2)), {
          position: "absolute",
          display: "none",
          color: token2.colorPrimary,
          fontSize: 0,
          textAlign: "center",
          verticalAlign: "middle",
          opacity: 0,
          transition: `transform ${token2.motionDurationSlow} ${token2.motionEaseInOutCirc}`,
          "&-spinning": {
            position: "static",
            display: "inline-block",
            opacity: 1
          },
          [`${componentCls}-text`]: {
            fontSize: token2.fontSize,
            paddingTop: calc(calc(token2.dotSize).sub(token2.fontSize)).div(2).add(2).equal()
          },
          "&-fullscreen": {
            position: "fixed",
            width: "100vw",
            height: "100vh",
            backgroundColor: token2.colorBgMask,
            zIndex: token2.zIndexPopupBase,
            inset: 0,
            display: "flex",
            alignItems: "center",
            flexDirection: "column",
            justifyContent: "center",
            opacity: 0,
            visibility: "hidden",
            transition: `all ${token2.motionDurationMid}`,
            "&-show": {
              opacity: 1,
              visibility: "visible"
            },
            [`${componentCls}-dot ${componentCls}-dot-item`]: {
              backgroundColor: token2.colorWhite
            },
            [`${componentCls}-text`]: {
              color: token2.colorTextLightSolid
            }
          },
          "&-nested-loading": {
            position: "relative",
            [`> div > ${componentCls}`]: {
              position: "absolute",
              top: 0,
              insetInlineStart: 0,
              zIndex: 4,
              display: "block",
              width: "100%",
              height: "100%",
              maxHeight: token2.contentHeight,
              [`${componentCls}-dot`]: {
                position: "absolute",
                top: "50%",
                insetInlineStart: "50%",
                margin: calc(token2.dotSize).mul(-1).div(2).equal()
              },
              [`${componentCls}-text`]: {
                position: "absolute",
                top: "50%",
                width: "100%",
                textShadow: `0 1px 2px ${token2.colorBgContainer}`
                // FIXME: shadow
              },
              [`&${componentCls}-show-text ${componentCls}-dot`]: {
                marginTop: calc(token2.dotSize).div(2).mul(-1).sub(10).equal()
              },
              "&-sm": {
                [`${componentCls}-dot`]: {
                  margin: calc(token2.dotSizeSM).mul(-1).div(2).equal()
                },
                [`${componentCls}-text`]: {
                  paddingTop: calc(calc(token2.dotSizeSM).sub(token2.fontSize)).div(2).add(2).equal()
                },
                [`&${componentCls}-show-text ${componentCls}-dot`]: {
                  marginTop: calc(token2.dotSizeSM).div(2).mul(-1).sub(10).equal()
                }
              },
              "&-lg": {
                [`${componentCls}-dot`]: {
                  margin: calc(token2.dotSizeLG).mul(-1).div(2).equal()
                },
                [`${componentCls}-text`]: {
                  paddingTop: calc(calc(token2.dotSizeLG).sub(token2.fontSize)).div(2).add(2).equal()
                },
                [`&${componentCls}-show-text ${componentCls}-dot`]: {
                  marginTop: calc(token2.dotSizeLG).div(2).mul(-1).sub(10).equal()
                }
              }
            },
            [`${componentCls}-container`]: {
              position: "relative",
              transition: `opacity ${token2.motionDurationSlow}`,
              "&::after": {
                position: "absolute",
                top: 0,
                insetInlineEnd: 0,
                bottom: 0,
                insetInlineStart: 0,
                zIndex: 10,
                width: "100%",
                height: "100%",
                background: token2.colorBgContainer,
                opacity: 0,
                transition: `all ${token2.motionDurationSlow}`,
                content: '""',
                pointerEvents: "none"
              }
            },
            [`${componentCls}-blur`]: {
              clear: "both",
              opacity: 0.5,
              userSelect: "none",
              pointerEvents: "none",
              [`&::after`]: {
                opacity: 0.4,
                pointerEvents: "auto"
              }
            }
          },
          // tip
          // ------------------------------
          [`&-tip`]: {
            color: token2.spinDotDefault
          },
          // dots
          // ------------------------------
          [`${componentCls}-dot`]: {
            position: "relative",
            display: "inline-block",
            fontSize: token2.dotSize,
            width: "1em",
            height: "1em",
            "&-item": {
              position: "absolute",
              display: "block",
              width: calc(token2.dotSize).sub(calc(token2.marginXXS).div(2)).div(2).equal(),
              height: calc(token2.dotSize).sub(calc(token2.marginXXS).div(2)).div(2).equal(),
              backgroundColor: token2.colorPrimary,
              borderRadius: "100%",
              transform: "scale(0.75)",
              transformOrigin: "50% 50%",
              opacity: 0.3,
              animationName: antSpinMove,
              animationDuration: "1s",
              animationIterationCount: "infinite",
              animationTimingFunction: "linear",
              animationDirection: "alternate",
              "&:nth-child(1)": {
                top: 0,
                insetInlineStart: 0,
                animationDelay: "0s"
              },
              "&:nth-child(2)": {
                top: 0,
                insetInlineEnd: 0,
                animationDelay: "0.4s"
              },
              "&:nth-child(3)": {
                insetInlineEnd: 0,
                bottom: 0,
                animationDelay: "0.8s"
              },
              "&:nth-child(4)": {
                bottom: 0,
                insetInlineStart: 0,
                animationDelay: "1.2s"
              }
            },
            "&-spin": {
              transform: "rotate(45deg)",
              animationName: antRotate,
              animationDuration: "1.2s",
              animationIterationCount: "infinite",
              animationTimingFunction: "linear"
            }
          },
          // small
          [`&-sm ${componentCls}-dot`]: {
            fontSize: token2.dotSizeSM,
            i: {
              width: calc(calc(token2.dotSizeSM).sub(calc(token2.marginXXS).div(2))).div(2).equal(),
              height: calc(calc(token2.dotSizeSM).sub(calc(token2.marginXXS).div(2))).div(2).equal()
            }
          },
          // large
          [`&-lg ${componentCls}-dot`]: {
            fontSize: token2.dotSizeLG,
            i: {
              width: calc(calc(token2.dotSizeLG).sub(token2.marginXXS)).div(2).equal(),
              height: calc(calc(token2.dotSizeLG).sub(token2.marginXXS)).div(2).equal()
            }
          },
          [`&${componentCls}-show-text ${componentCls}-text`]: {
            display: "block"
          }
        })
      };
    };
    const prepareComponentToken$4 = (token2) => {
      const {
        controlHeightLG,
        controlHeight
      } = token2;
      return {
        contentHeight: 400,
        dotSize: controlHeightLG / 2,
        dotSizeSM: controlHeightLG * 0.35,
        dotSizeLG: controlHeight
      };
    };
    const useStyle$4 = genStyleHooks("Spin", (token2) => {
      const spinToken = merge$1(token2, {
        spinDotDefault: token2.colorTextDescription
      });
      return [genSpinStyle(spinToken)];
    }, prepareComponentToken$4);
    var __rest$5 = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    let defaultIndicator = null;
    function renderIndicator(prefixCls, props) {
      const {
        indicator
      } = props;
      const dotClassName = `${prefixCls}-dot`;
      if (indicator === null) {
        return null;
      }
      if (isValidElement(indicator)) {
        return cloneElement(indicator, {
          className: classNames(indicator.props.className, dotClassName)
        });
      }
      if (isValidElement(defaultIndicator)) {
        return cloneElement(defaultIndicator, {
          className: classNames(defaultIndicator.props.className, dotClassName)
        });
      }
      return /* @__PURE__ */ reactExports.createElement("span", {
        className: classNames(dotClassName, `${prefixCls}-dot-spin`)
      }, /* @__PURE__ */ reactExports.createElement("i", {
        className: `${prefixCls}-dot-item`,
        key: 1
      }), /* @__PURE__ */ reactExports.createElement("i", {
        className: `${prefixCls}-dot-item`,
        key: 2
      }), /* @__PURE__ */ reactExports.createElement("i", {
        className: `${prefixCls}-dot-item`,
        key: 3
      }), /* @__PURE__ */ reactExports.createElement("i", {
        className: `${prefixCls}-dot-item`,
        key: 4
      }));
    }
    function shouldDelay(spinning, delay) {
      return !!spinning && !!delay && !isNaN(Number(delay));
    }
    const Spin = (props) => {
      const {
        spinPrefixCls: prefixCls,
        spinning: customSpinning = true,
        delay = 0,
        className,
        rootClassName,
        size = "default",
        tip,
        wrapperClassName,
        style: style2,
        children,
        hashId,
        fullscreen
      } = props, restProps = __rest$5(props, ["spinPrefixCls", "spinning", "delay", "className", "rootClassName", "size", "tip", "wrapperClassName", "style", "children", "hashId", "fullscreen"]);
      const [spinning, setSpinning] = reactExports.useState(() => customSpinning && !shouldDelay(customSpinning, delay));
      reactExports.useEffect(() => {
        if (customSpinning) {
          const showSpinning = debounce(delay, () => {
            setSpinning(true);
          });
          showSpinning();
          return () => {
            var _a;
            (_a = showSpinning === null || showSpinning === void 0 ? void 0 : showSpinning.cancel) === null || _a === void 0 ? void 0 : _a.call(showSpinning);
          };
        }
        setSpinning(false);
      }, [delay, customSpinning]);
      const isNestedPattern = reactExports.useMemo(() => typeof children !== "undefined" && !fullscreen, [children, fullscreen]);
      const {
        direction,
        spin
      } = reactExports.useContext(ConfigContext);
      const spinClassName = classNames(prefixCls, spin === null || spin === void 0 ? void 0 : spin.className, {
        [`${prefixCls}-sm`]: size === "small",
        [`${prefixCls}-lg`]: size === "large",
        [`${prefixCls}-spinning`]: spinning,
        [`${prefixCls}-show-text`]: !!tip,
        [`${prefixCls}-fullscreen`]: fullscreen,
        [`${prefixCls}-fullscreen-show`]: fullscreen && spinning,
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, className, rootClassName, hashId);
      const containerClassName = classNames(`${prefixCls}-container`, {
        [`${prefixCls}-blur`]: spinning
      });
      const divProps = omit(restProps, ["indicator", "prefixCls"]);
      const mergedStyle = Object.assign(Object.assign({}, spin === null || spin === void 0 ? void 0 : spin.style), style2);
      const spinElement = /* @__PURE__ */ reactExports.createElement("div", Object.assign({}, divProps, {
        style: mergedStyle,
        className: spinClassName,
        "aria-live": "polite",
        "aria-busy": spinning
      }), renderIndicator(prefixCls, props), tip && (isNestedPattern || fullscreen) ? /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-text`
      }, tip) : null);
      if (isNestedPattern) {
        return /* @__PURE__ */ reactExports.createElement("div", Object.assign({}, divProps, {
          className: classNames(`${prefixCls}-nested-loading`, wrapperClassName, hashId)
        }), spinning && /* @__PURE__ */ reactExports.createElement("div", {
          key: "loading"
        }, spinElement), /* @__PURE__ */ reactExports.createElement("div", {
          className: containerClassName,
          key: "container"
        }, children));
      }
      return spinElement;
    };
    const SpinFC = (props) => {
      const {
        prefixCls: customizePrefixCls
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const spinPrefixCls = getPrefixCls("spin", customizePrefixCls);
      const [wrapCSSVar, hashId] = useStyle$4(spinPrefixCls);
      const spinClassProps = Object.assign(Object.assign({}, props), {
        spinPrefixCls,
        hashId
      });
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement(Spin, Object.assign({}, spinClassProps)));
    };
    SpinFC.setDefaultIndicator = (indicator) => {
      defaultIndicator = indicator;
    };
    const Spin$1 = SpinFC;
    var defaultProps = {
      percent: 0,
      prefixCls: "rc-progress",
      strokeColor: "#2db7f5",
      strokeLinecap: "round",
      strokeWidth: 1,
      trailColor: "#D9D9D9",
      trailWidth: 1,
      gapPosition: "bottom"
    };
    var useTransitionDuration = function useTransitionDuration2() {
      var pathsRef = reactExports.useRef([]);
      var prevTimeStamp = reactExports.useRef(null);
      reactExports.useEffect(function() {
        var now2 = Date.now();
        var updated = false;
        pathsRef.current.forEach(function(path) {
          if (!path) {
            return;
          }
          updated = true;
          var pathStyle = path.style;
          pathStyle.transitionDuration = ".3s, .3s, .3s, .06s";
          if (prevTimeStamp.current && now2 - prevTimeStamp.current < 100) {
            pathStyle.transitionDuration = "0s, 0s";
          }
        });
        if (updated) {
          prevTimeStamp.current = Date.now();
        }
      });
      return pathsRef.current;
    };
    var uuid = 0;
    var isBrowserClient = canUseDom();
    function getUUID() {
      var retId;
      if (isBrowserClient) {
        retId = uuid;
        uuid += 1;
      } else {
        retId = "TEST_OR_SSR";
      }
      return retId;
    }
    const useId = function(id2) {
      var _React$useState = reactExports.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
      reactExports.useEffect(function() {
        setInnerId("rc_progress_".concat(getUUID()));
      }, []);
      return id2 || innerId;
    };
    var Block = function Block2(_ref) {
      var bg2 = _ref.bg, children = _ref.children;
      return /* @__PURE__ */ reactExports.createElement("div", {
        style: {
          width: "100%",
          height: "100%",
          background: bg2
        }
      }, children);
    };
    function getPtgColors(color, scale) {
      return Object.keys(color).map(function(key) {
        var parsedKey = parseFloat(key);
        var ptgKey = "".concat(Math.floor(parsedKey * scale), "%");
        return "".concat(color[key], " ").concat(ptgKey);
      });
    }
    var PtgCircle = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var prefixCls = props.prefixCls, color = props.color, gradientId = props.gradientId, radius = props.radius, circleStyleForStack = props.style, ptg = props.ptg, strokeLinecap = props.strokeLinecap, strokeWidth = props.strokeWidth, size = props.size, gapDegree = props.gapDegree;
      var isGradient = color && _typeof(color) === "object";
      var stroke = isGradient ? "#FFF" : void 0;
      var halfSize = size / 2;
      var circleNode = /* @__PURE__ */ reactExports.createElement("circle", {
        className: "".concat(prefixCls, "-circle-path"),
        r: radius,
        cx: halfSize,
        cy: halfSize,
        stroke,
        strokeLinecap,
        strokeWidth,
        opacity: ptg === 0 ? 0 : 1,
        style: circleStyleForStack,
        ref
      });
      if (!isGradient) {
        return circleNode;
      }
      var maskId = "".concat(gradientId, "-conic");
      var fromDeg = gapDegree ? "".concat(180 + gapDegree / 2, "deg") : "0deg";
      var conicColors = getPtgColors(color, (360 - gapDegree) / 360);
      var linearColors = getPtgColors(color, 1);
      var conicColorBg = "conic-gradient(from ".concat(fromDeg, ", ").concat(conicColors.join(", "), ")");
      var linearColorBg = "linear-gradient(to ".concat(gapDegree ? "bottom" : "top", ", ").concat(linearColors.join(", "), ")");
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("mask", {
        id: maskId
      }, circleNode), /* @__PURE__ */ reactExports.createElement("foreignObject", {
        x: 0,
        y: 0,
        width: size,
        height: size,
        mask: "url(#".concat(maskId, ")")
      }, /* @__PURE__ */ reactExports.createElement(Block, {
        bg: linearColorBg
      }, /* @__PURE__ */ reactExports.createElement(Block, {
        bg: conicColorBg
      }))));
    });
    var VIEW_BOX_SIZE = 100;
    var getCircleStyle = function getCircleStyle2(perimeter, perimeterWithoutGap, offset2, percent, rotateDeg, gapDegree, gapPosition, strokeColor, strokeLinecap, strokeWidth) {
      var stepSpace = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : 0;
      var offsetDeg = offset2 / 100 * 360 * ((360 - gapDegree) / 360);
      var positionDeg = gapDegree === 0 ? 0 : {
        bottom: 0,
        top: 180,
        left: 90,
        right: -90
      }[gapPosition];
      var strokeDashoffset = (100 - percent) / 100 * perimeterWithoutGap;
      if (strokeLinecap === "round" && percent !== 100) {
        strokeDashoffset += strokeWidth / 2;
        if (strokeDashoffset >= perimeterWithoutGap) {
          strokeDashoffset = perimeterWithoutGap - 0.01;
        }
      }
      var halfSize = VIEW_BOX_SIZE / 2;
      return {
        stroke: typeof strokeColor === "string" ? strokeColor : void 0,
        strokeDasharray: "".concat(perimeterWithoutGap, "px ").concat(perimeter),
        strokeDashoffset: strokeDashoffset + stepSpace,
        transform: "rotate(".concat(rotateDeg + offsetDeg + positionDeg, "deg)"),
        transformOrigin: "".concat(halfSize, "px ").concat(halfSize, "px"),
        transition: "stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s, opacity .3s ease 0s",
        fillOpacity: 0
      };
    };
    var _excluded$a = ["id", "prefixCls", "steps", "strokeWidth", "trailWidth", "gapDegree", "gapPosition", "trailColor", "strokeLinecap", "style", "className", "strokeColor", "percent"];
    function toArray$3(value) {
      var mergedValue = value !== null && value !== void 0 ? value : [];
      return Array.isArray(mergedValue) ? mergedValue : [mergedValue];
    }
    var Circle$2 = function Circle2(props) {
      var _defaultProps$props = _objectSpread2(_objectSpread2({}, defaultProps), props), id2 = _defaultProps$props.id, prefixCls = _defaultProps$props.prefixCls, steps = _defaultProps$props.steps, strokeWidth = _defaultProps$props.strokeWidth, trailWidth = _defaultProps$props.trailWidth, _defaultProps$props$g = _defaultProps$props.gapDegree, gapDegree = _defaultProps$props$g === void 0 ? 0 : _defaultProps$props$g, gapPosition = _defaultProps$props.gapPosition, trailColor = _defaultProps$props.trailColor, strokeLinecap = _defaultProps$props.strokeLinecap, style2 = _defaultProps$props.style, className = _defaultProps$props.className, strokeColor = _defaultProps$props.strokeColor, percent = _defaultProps$props.percent, restProps = _objectWithoutProperties(_defaultProps$props, _excluded$a);
      var halfSize = VIEW_BOX_SIZE / 2;
      var mergedId = useId(id2);
      var gradientId = "".concat(mergedId, "-gradient");
      var radius = halfSize - strokeWidth / 2;
      var perimeter = Math.PI * 2 * radius;
      var rotateDeg = gapDegree > 0 ? 90 + gapDegree / 2 : -90;
      var perimeterWithoutGap = perimeter * ((360 - gapDegree) / 360);
      var _ref = _typeof(steps) === "object" ? steps : {
        count: steps,
        space: 2
      }, stepCount = _ref.count, stepSpace = _ref.space;
      var percentList = toArray$3(percent);
      var strokeColorList = toArray$3(strokeColor);
      var gradient = strokeColorList.find(function(color) {
        return color && _typeof(color) === "object";
      });
      var isConicGradient = gradient && _typeof(gradient) === "object";
      var mergedStrokeLinecap = isConicGradient ? "butt" : strokeLinecap;
      var circleStyle = getCircleStyle(perimeter, perimeterWithoutGap, 0, 100, rotateDeg, gapDegree, gapPosition, trailColor, mergedStrokeLinecap, strokeWidth);
      var paths = useTransitionDuration();
      var getStokeList = function getStokeList2() {
        var stackPtg = 0;
        return percentList.map(function(ptg, index2) {
          var color = strokeColorList[index2] || strokeColorList[strokeColorList.length - 1];
          var circleStyleForStack = getCircleStyle(perimeter, perimeterWithoutGap, stackPtg, ptg, rotateDeg, gapDegree, gapPosition, color, mergedStrokeLinecap, strokeWidth);
          stackPtg += ptg;
          return /* @__PURE__ */ reactExports.createElement(PtgCircle, {
            key: index2,
            color,
            ptg,
            radius,
            prefixCls,
            gradientId,
            style: circleStyleForStack,
            strokeLinecap: mergedStrokeLinecap,
            strokeWidth,
            gapDegree,
            ref: function ref(elem) {
              paths[index2] = elem;
            },
            size: VIEW_BOX_SIZE
          });
        }).reverse();
      };
      var getStepStokeList = function getStepStokeList2() {
        var current = Math.round(stepCount * (percentList[0] / 100));
        var stepPtg = 100 / stepCount;
        var stackPtg = 0;
        return new Array(stepCount).fill(null).map(function(_, index2) {
          var color = index2 <= current - 1 ? strokeColorList[0] : trailColor;
          var stroke = color && _typeof(color) === "object" ? "url(#".concat(gradientId, ")") : void 0;
          var circleStyleForStack = getCircleStyle(perimeter, perimeterWithoutGap, stackPtg, stepPtg, rotateDeg, gapDegree, gapPosition, color, "butt", strokeWidth, stepSpace);
          stackPtg += (perimeterWithoutGap - circleStyleForStack.strokeDashoffset + stepSpace) * 100 / perimeterWithoutGap;
          return /* @__PURE__ */ reactExports.createElement("circle", {
            key: index2,
            className: "".concat(prefixCls, "-circle-path"),
            r: radius,
            cx: halfSize,
            cy: halfSize,
            stroke,
            strokeWidth,
            opacity: 1,
            style: circleStyleForStack,
            ref: function ref(elem) {
              paths[index2] = elem;
            }
          });
        });
      };
      return /* @__PURE__ */ reactExports.createElement("svg", _extends$1({
        className: classNames("".concat(prefixCls, "-circle"), className),
        viewBox: "0 0 ".concat(VIEW_BOX_SIZE, " ").concat(VIEW_BOX_SIZE),
        style: style2,
        id: id2,
        role: "presentation"
      }, restProps), !stepCount && /* @__PURE__ */ reactExports.createElement("circle", {
        className: "".concat(prefixCls, "-circle-trail"),
        r: radius,
        cx: halfSize,
        cy: halfSize,
        stroke: trailColor,
        strokeLinecap: mergedStrokeLinecap,
        strokeWidth: trailWidth || strokeWidth,
        style: circleStyle
      }), stepCount ? getStepStokeList() : getStokeList());
    };
    function validProgress(progress) {
      if (!progress || progress < 0) {
        return 0;
      }
      if (progress > 100) {
        return 100;
      }
      return progress;
    }
    function getSuccessPercent(_ref) {
      let {
        success,
        successPercent
      } = _ref;
      let percent = successPercent;
      if (success && "progress" in success) {
        percent = success.progress;
      }
      if (success && "percent" in success) {
        percent = success.percent;
      }
      return percent;
    }
    const getPercentage = (_ref2) => {
      let {
        percent,
        success,
        successPercent
      } = _ref2;
      const realSuccessPercent = validProgress(getSuccessPercent({
        success,
        successPercent
      }));
      return [realSuccessPercent, validProgress(validProgress(percent) - realSuccessPercent)];
    };
    const getStrokeColor = (_ref3) => {
      let {
        success = {},
        strokeColor
      } = _ref3;
      const {
        strokeColor: successColor
      } = success;
      return [successColor || presetPrimaryColors.green, strokeColor || null];
    };
    const getSize = (size, type, extra) => {
      var _a, _b, _c, _d;
      let width = -1;
      let height = -1;
      if (type === "step") {
        const steps = extra.steps;
        const strokeWidth = extra.strokeWidth;
        if (typeof size === "string" || typeof size === "undefined") {
          width = size === "small" ? 2 : 14;
          height = strokeWidth !== null && strokeWidth !== void 0 ? strokeWidth : 8;
        } else if (typeof size === "number") {
          [width, height] = [size, size];
        } else {
          [width = 14, height = 8] = size;
        }
        width *= steps;
      } else if (type === "line") {
        const strokeWidth = extra === null || extra === void 0 ? void 0 : extra.strokeWidth;
        if (typeof size === "string" || typeof size === "undefined") {
          height = strokeWidth || (size === "small" ? 6 : 8);
        } else if (typeof size === "number") {
          [width, height] = [size, size];
        } else {
          [width = -1, height = 8] = size;
        }
      } else if (type === "circle" || type === "dashboard") {
        if (typeof size === "string" || typeof size === "undefined") {
          [width, height] = size === "small" ? [60, 60] : [120, 120];
        } else if (typeof size === "number") {
          [width, height] = [size, size];
        } else {
          width = (_b = (_a = size[0]) !== null && _a !== void 0 ? _a : size[1]) !== null && _b !== void 0 ? _b : 120;
          height = (_d = (_c = size[0]) !== null && _c !== void 0 ? _c : size[1]) !== null && _d !== void 0 ? _d : 120;
        }
      }
      return [width, height];
    };
    const CIRCLE_MIN_STROKE_WIDTH = 3;
    const getMinPercent = (width) => CIRCLE_MIN_STROKE_WIDTH / width * 100;
    const Circle = (props) => {
      const {
        prefixCls,
        trailColor = null,
        strokeLinecap = "round",
        gapPosition,
        gapDegree,
        width: originWidth = 120,
        type,
        children,
        success,
        size = originWidth
      } = props;
      const [width, height] = getSize(size, "circle");
      let {
        strokeWidth
      } = props;
      if (strokeWidth === void 0) {
        strokeWidth = Math.max(getMinPercent(width), 6);
      }
      const circleStyle = {
        width,
        height,
        fontSize: width * 0.15 + 6
      };
      const realGapDegree = reactExports.useMemo(() => {
        if (gapDegree || gapDegree === 0) {
          return gapDegree;
        }
        if (type === "dashboard") {
          return 75;
        }
        return void 0;
      }, [gapDegree, type]);
      const gapPos = gapPosition || type === "dashboard" && "bottom" || void 0;
      const isGradient = Object.prototype.toString.call(props.strokeColor) === "[object Object]";
      const strokeColor = getStrokeColor({
        success,
        strokeColor: props.strokeColor
      });
      const wrapperClassName = classNames(`${prefixCls}-inner`, {
        [`${prefixCls}-circle-gradient`]: isGradient
      });
      const circleContent = /* @__PURE__ */ reactExports.createElement(Circle$2, {
        percent: getPercentage(props),
        strokeWidth,
        trailWidth: strokeWidth,
        strokeColor,
        strokeLinecap,
        trailColor,
        prefixCls,
        gapDegree: realGapDegree,
        gapPosition: gapPos
      });
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: wrapperClassName,
        style: circleStyle
      }, width <= 20 ? /* @__PURE__ */ reactExports.createElement(Tooltip$1, {
        title: children
      }, /* @__PURE__ */ reactExports.createElement("span", null, circleContent)) : /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, circleContent, children));
    };
    const Circle$1 = Circle;
    var __rest$4 = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const sortGradient = (gradients) => {
      let tempArr = [];
      Object.keys(gradients).forEach((key) => {
        const formattedKey = parseFloat(key.replace(/%/g, ""));
        if (!isNaN(formattedKey)) {
          tempArr.push({
            key: formattedKey,
            value: gradients[key]
          });
        }
      });
      tempArr = tempArr.sort((a, b2) => a.key - b2.key);
      return tempArr.map((_ref) => {
        let {
          key,
          value
        } = _ref;
        return `${value} ${key}%`;
      }).join(", ");
    };
    const handleGradient = (strokeColor, directionConfig) => {
      const {
        from: from2 = presetPrimaryColors.blue,
        to: to2 = presetPrimaryColors.blue,
        direction = directionConfig === "rtl" ? "to left" : "to right"
      } = strokeColor, rest = __rest$4(strokeColor, ["from", "to", "direction"]);
      if (Object.keys(rest).length !== 0) {
        const sortedGradients = sortGradient(rest);
        return {
          backgroundImage: `linear-gradient(${direction}, ${sortedGradients})`
        };
      }
      return {
        backgroundImage: `linear-gradient(${direction}, ${from2}, ${to2})`
      };
    };
    const Line = (props) => {
      const {
        prefixCls,
        direction: directionConfig,
        percent,
        size,
        strokeWidth,
        strokeColor,
        strokeLinecap = "round",
        children,
        trailColor = null,
        success
      } = props;
      const {
        direction
      } = reactExports.useContext(ConfigContext);
      const backgroundProps = strokeColor && typeof strokeColor !== "string" ? handleGradient(strokeColor, directionConfig) : {
        backgroundColor: strokeColor
      };
      const borderRadius = strokeLinecap === "square" || strokeLinecap === "butt" ? 0 : void 0;
      const trailStyle = {
        backgroundColor: trailColor || void 0,
        borderRadius
      };
      const mergedSize = size !== null && size !== void 0 ? size : [-1, strokeWidth || (size === "small" ? 6 : 8)];
      const [width, height] = getSize(mergedSize, "line", {
        strokeWidth
      });
      const percentStyle = Object.assign({
        width: `100%`,
        height,
        borderRadius,
        clipPath: direction === "rtl" ? `inset(0 0 0 ${100 - validProgress(percent)}% round 100px)` : `inset(0 ${100 - validProgress(percent)}% 0 0 round 100px)`
      }, backgroundProps);
      const successPercent = getSuccessPercent(props);
      const successPercentStyle = {
        width: `100%`,
        height,
        borderRadius,
        clipPath: direction === "rtl" ? `inset(0 0 0 ${100 - validProgress(successPercent)}% round 100px)` : `inset(0 ${100 - validProgress(successPercent)}% 0 0 round 100px)`,
        backgroundColor: success === null || success === void 0 ? void 0 : success.strokeColor
      };
      const outerStyle = {
        width: width < 0 ? "100%" : width,
        height
      };
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-outer`,
        style: outerStyle
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-inner`,
        style: trailStyle
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-bg`,
        style: percentStyle
      }), successPercent !== void 0 ? /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-success-bg`,
        style: successPercentStyle
      }) : null)), children);
    };
    const Line$1 = Line;
    const Steps = (props) => {
      const {
        size,
        steps,
        percent = 0,
        strokeWidth = 8,
        strokeColor,
        trailColor = null,
        prefixCls,
        children
      } = props;
      const current = Math.round(steps * (percent / 100));
      const stepWidth = size === "small" ? 2 : 14;
      const mergedSize = size !== null && size !== void 0 ? size : [stepWidth, strokeWidth];
      const [width, height] = getSize(mergedSize, "step", {
        steps,
        strokeWidth
      });
      const unitWidth = width / steps;
      const styledSteps = new Array(steps);
      for (let i = 0; i < steps; i++) {
        const color = Array.isArray(strokeColor) ? strokeColor[i] : strokeColor;
        styledSteps[i] = /* @__PURE__ */ reactExports.createElement("div", {
          key: i,
          className: classNames(`${prefixCls}-steps-item`, {
            [`${prefixCls}-steps-item-active`]: i <= current - 1
          }),
          style: {
            backgroundColor: i <= current - 1 ? color : trailColor,
            width: unitWidth,
            height
          }
        });
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-steps-outer`
      }, styledSteps, children);
    };
    const Steps$1 = Steps;
    const genAntProgressActive = (isRtl) => {
      const direction = isRtl ? "100%" : "-100%";
      return new Keyframe(`antProgress${isRtl ? "RTL" : "LTR"}Active`, {
        "0%": {
          transform: `translateX(${direction}) scaleX(0)`,
          opacity: 0.1
        },
        "20%": {
          transform: `translateX(${direction}) scaleX(0)`,
          opacity: 0.5
        },
        to: {
          transform: "translateX(0) scaleX(1)",
          opacity: 0
        }
      });
    };
    const genBaseStyle$2 = (token2) => {
      const {
        componentCls: progressCls,
        iconCls: iconPrefixCls
      } = token2;
      return {
        [progressCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
          display: "inline-block",
          "&-rtl": {
            direction: "rtl"
          },
          "&-line": {
            position: "relative",
            width: "100%",
            fontSize: token2.fontSize,
            marginInlineEnd: token2.marginXS,
            marginBottom: token2.marginXS
          },
          [`${progressCls}-outer`]: {
            display: "inline-block",
            width: "100%"
          },
          [`&${progressCls}-show-info`]: {
            [`${progressCls}-outer`]: {
              marginInlineEnd: `calc(-2em - ${unit$1(token2.marginXS)})`,
              paddingInlineEnd: `calc(2em + ${unit$1(token2.paddingXS)})`
            }
          },
          [`${progressCls}-inner`]: {
            position: "relative",
            display: "inline-block",
            width: "100%",
            overflow: "hidden",
            verticalAlign: "middle",
            backgroundColor: token2.remainingColor,
            borderRadius: token2.lineBorderRadius
          },
          [`${progressCls}-inner:not(${progressCls}-circle-gradient)`]: {
            [`${progressCls}-circle-path`]: {
              stroke: token2.defaultColor
            }
          },
          [`${progressCls}-success-bg, ${progressCls}-bg`]: {
            position: "relative",
            backgroundColor: token2.defaultColor,
            borderRadius: token2.lineBorderRadius,
            transition: `all ${token2.motionDurationSlow} ${token2.motionEaseInOutCirc}`
          },
          [`${progressCls}-success-bg`]: {
            position: "absolute",
            insetBlockStart: 0,
            insetInlineStart: 0,
            backgroundColor: token2.colorSuccess
          },
          [`${progressCls}-text`]: {
            display: "inline-block",
            width: "2em",
            marginInlineStart: token2.marginXS,
            color: token2.colorText,
            lineHeight: 1,
            whiteSpace: "nowrap",
            textAlign: "start",
            verticalAlign: "middle",
            wordBreak: "normal",
            [iconPrefixCls]: {
              fontSize: token2.fontSize
            }
          },
          [`&${progressCls}-status-active`]: {
            [`${progressCls}-bg::before`]: {
              position: "absolute",
              inset: 0,
              backgroundColor: token2.colorBgContainer,
              borderRadius: token2.lineBorderRadius,
              opacity: 0,
              animationName: genAntProgressActive(),
              animationDuration: token2.progressActiveMotionDuration,
              animationTimingFunction: token2.motionEaseOutQuint,
              animationIterationCount: "infinite",
              content: '""'
            }
          },
          [`&${progressCls}-rtl${progressCls}-status-active`]: {
            [`${progressCls}-bg::before`]: {
              animationName: genAntProgressActive(true)
            }
          },
          [`&${progressCls}-status-exception`]: {
            [`${progressCls}-bg`]: {
              backgroundColor: token2.colorError
            },
            [`${progressCls}-text`]: {
              color: token2.colorError
            }
          },
          [`&${progressCls}-status-exception ${progressCls}-inner:not(${progressCls}-circle-gradient)`]: {
            [`${progressCls}-circle-path`]: {
              stroke: token2.colorError
            }
          },
          [`&${progressCls}-status-success`]: {
            [`${progressCls}-bg`]: {
              backgroundColor: token2.colorSuccess
            },
            [`${progressCls}-text`]: {
              color: token2.colorSuccess
            }
          },
          [`&${progressCls}-status-success ${progressCls}-inner:not(${progressCls}-circle-gradient)`]: {
            [`${progressCls}-circle-path`]: {
              stroke: token2.colorSuccess
            }
          }
        })
      };
    };
    const genCircleStyle = (token2) => {
      const {
        componentCls: progressCls,
        iconCls: iconPrefixCls
      } = token2;
      return {
        [progressCls]: {
          [`${progressCls}-circle-trail`]: {
            stroke: token2.remainingColor
          },
          [`&${progressCls}-circle ${progressCls}-inner`]: {
            position: "relative",
            lineHeight: 1,
            backgroundColor: "transparent"
          },
          [`&${progressCls}-circle ${progressCls}-text`]: {
            position: "absolute",
            insetBlockStart: "50%",
            insetInlineStart: 0,
            width: "100%",
            margin: 0,
            padding: 0,
            color: token2.circleTextColor,
            fontSize: token2.circleTextFontSize,
            lineHeight: 1,
            whiteSpace: "normal",
            textAlign: "center",
            transform: "translateY(-50%)",
            [iconPrefixCls]: {
              fontSize: token2.circleIconFontSize
            }
          },
          [`${progressCls}-circle&-status-exception`]: {
            [`${progressCls}-text`]: {
              color: token2.colorError
            }
          },
          [`${progressCls}-circle&-status-success`]: {
            [`${progressCls}-text`]: {
              color: token2.colorSuccess
            }
          }
        },
        [`${progressCls}-inline-circle`]: {
          lineHeight: 1,
          [`${progressCls}-inner`]: {
            verticalAlign: "bottom"
          }
        }
      };
    };
    const genStepStyle = (token2) => {
      const {
        componentCls: progressCls
      } = token2;
      return {
        [progressCls]: {
          [`${progressCls}-steps`]: {
            display: "inline-block",
            "&-outer": {
              display: "flex",
              flexDirection: "row",
              alignItems: "center"
            },
            "&-item": {
              flexShrink: 0,
              minWidth: token2.progressStepMinWidth,
              marginInlineEnd: token2.progressStepMarginInlineEnd,
              backgroundColor: token2.remainingColor,
              transition: `all ${token2.motionDurationSlow}`,
              "&-active": {
                backgroundColor: token2.defaultColor
              }
            }
          }
        }
      };
    };
    const genSmallLine = (token2) => {
      const {
        componentCls: progressCls,
        iconCls: iconPrefixCls
      } = token2;
      return {
        [progressCls]: {
          [`${progressCls}-small&-line, ${progressCls}-small&-line ${progressCls}-text ${iconPrefixCls}`]: {
            fontSize: token2.fontSizeSM
          }
        }
      };
    };
    const prepareComponentToken$3 = (token2) => ({
      circleTextColor: token2.colorText,
      defaultColor: token2.colorInfo,
      remainingColor: token2.colorFillSecondary,
      lineBorderRadius: 100,
      // magic for capsule shape, should be a very large number
      circleTextFontSize: "1em",
      circleIconFontSize: `${token2.fontSize / token2.fontSizeSM}em`
    });
    const useStyle$3 = genStyleHooks("Progress", (token2) => {
      const progressStepMarginInlineEnd = token2.calc(token2.marginXXS).div(2).equal();
      const progressToken = merge$1(token2, {
        progressStepMarginInlineEnd,
        progressStepMinWidth: progressStepMarginInlineEnd,
        progressActiveMotionDuration: "2.4s"
      });
      return [genBaseStyle$2(progressToken), genCircleStyle(progressToken), genStepStyle(progressToken), genSmallLine(progressToken)];
    }, prepareComponentToken$3);
    var __rest$3 = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const ProgressStatuses = ["normal", "exception", "active", "success"];
    const Progress = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        steps,
        strokeColor,
        percent = 0,
        size = "default",
        showInfo = true,
        type = "line",
        status,
        format: format2,
        style: style2
      } = props, restProps = __rest$3(props, ["prefixCls", "className", "rootClassName", "steps", "strokeColor", "percent", "size", "showInfo", "type", "status", "format", "style"]);
      const percentNumber = reactExports.useMemo(() => {
        var _a, _b;
        const successPercent = getSuccessPercent(props);
        return parseInt(successPercent !== void 0 ? (_a = successPercent !== null && successPercent !== void 0 ? successPercent : 0) === null || _a === void 0 ? void 0 : _a.toString() : (_b = percent !== null && percent !== void 0 ? percent : 0) === null || _b === void 0 ? void 0 : _b.toString(), 10);
      }, [percent, props.success, props.successPercent]);
      const progressStatus = reactExports.useMemo(() => {
        if (!ProgressStatuses.includes(status) && percentNumber >= 100) {
          return "success";
        }
        return status || "normal";
      }, [status, percentNumber]);
      const {
        getPrefixCls,
        direction,
        progress: progressStyle
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("progress", customizePrefixCls);
      const [wrapCSSVar, hashId] = useStyle$3(prefixCls);
      const progressInfo = reactExports.useMemo(() => {
        if (!showInfo) {
          return null;
        }
        const successPercent = getSuccessPercent(props);
        let text;
        const textFormatter = format2 || ((number) => `${number}%`);
        const isLineType = type === "line";
        if (format2 || progressStatus !== "exception" && progressStatus !== "success") {
          text = textFormatter(validProgress(percent), validProgress(successPercent));
        } else if (progressStatus === "exception") {
          text = isLineType ? /* @__PURE__ */ reactExports.createElement(CloseCircleFilled$1, null) : /* @__PURE__ */ reactExports.createElement(CloseOutlined$1, null);
        } else if (progressStatus === "success") {
          text = isLineType ? /* @__PURE__ */ reactExports.createElement(CheckCircleFilled$1, null) : /* @__PURE__ */ reactExports.createElement(CheckOutlined$1, null);
        }
        return /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-text`,
          title: typeof text === "string" ? text : void 0
        }, text);
      }, [showInfo, percent, percentNumber, progressStatus, type, prefixCls, format2]);
      const strokeColorNotArray = Array.isArray(strokeColor) ? strokeColor[0] : strokeColor;
      const strokeColorNotGradient = typeof strokeColor === "string" || Array.isArray(strokeColor) ? strokeColor : void 0;
      let progress;
      if (type === "line") {
        progress = steps ? /* @__PURE__ */ reactExports.createElement(Steps$1, Object.assign({}, props, {
          strokeColor: strokeColorNotGradient,
          prefixCls,
          steps
        }), progressInfo) : /* @__PURE__ */ reactExports.createElement(Line$1, Object.assign({}, props, {
          strokeColor: strokeColorNotArray,
          prefixCls,
          direction
        }), progressInfo);
      } else if (type === "circle" || type === "dashboard") {
        progress = /* @__PURE__ */ reactExports.createElement(Circle$1, Object.assign({}, props, {
          strokeColor: strokeColorNotArray,
          prefixCls,
          progressStatus
        }), progressInfo);
      }
      const classString = classNames(prefixCls, `${prefixCls}-status-${progressStatus}`, `${prefixCls}-${type === "dashboard" && "circle" || steps && "steps" || type}`, {
        [`${prefixCls}-inline-circle`]: type === "circle" && getSize(size, "circle")[0] <= 20,
        [`${prefixCls}-show-info`]: showInfo,
        [`${prefixCls}-${size}`]: typeof size === "string",
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, progressStyle === null || progressStyle === void 0 ? void 0 : progressStyle.className, className, rootClassName, hashId);
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("div", Object.assign({
        ref,
        style: Object.assign(Object.assign({}, progressStyle === null || progressStyle === void 0 ? void 0 : progressStyle.style), style2),
        className: classString,
        role: "progressbar",
        "aria-valuenow": percentNumber
      }, omit(restProps, ["trailColor", "strokeWidth", "width", "gapDegree", "gapPosition", "strokeLinecap", "success", "successPercent"])), progress));
    });
    const Progress$1 = Progress;
    var EXPAND_COLUMN = {};
    var INTERNAL_HOOKS = "rc-table-internal-hook";
    function createContext(defaultValue) {
      var Context2 = /* @__PURE__ */ reactExports.createContext(void 0);
      var Provider = function Provider2(_ref) {
        var value = _ref.value, children = _ref.children;
        var valueRef = reactExports.useRef(value);
        valueRef.current = value;
        var _React$useState = reactExports.useState(function() {
          return {
            getValue: function getValue2() {
              return valueRef.current;
            },
            listeners: /* @__PURE__ */ new Set()
          };
        }), _React$useState2 = _slicedToArray(_React$useState, 1), context = _React$useState2[0];
        useLayoutEffect$1(function() {
          reactDomExports.unstable_batchedUpdates(function() {
            context.listeners.forEach(function(listener) {
              listener(value);
            });
          });
        }, [value]);
        return /* @__PURE__ */ reactExports.createElement(Context2.Provider, {
          value: context
        }, children);
      };
      return {
        Context: Context2,
        Provider,
        defaultValue
      };
    }
    function useContext(holder, selector) {
      var eventSelector = useEvent(typeof selector === "function" ? selector : function(ctx) {
        if (selector === void 0) {
          return ctx;
        }
        if (!Array.isArray(selector)) {
          return ctx[selector];
        }
        var obj = {};
        selector.forEach(function(key) {
          obj[key] = ctx[key];
        });
        return obj;
      });
      var context = reactExports.useContext(holder === null || holder === void 0 ? void 0 : holder.Context);
      var _ref2 = context || {}, listeners = _ref2.listeners, getValue2 = _ref2.getValue;
      var valueRef = reactExports.useRef();
      valueRef.current = eventSelector(context ? getValue2() : holder === null || holder === void 0 ? void 0 : holder.defaultValue);
      var _React$useState3 = reactExports.useState({}), _React$useState4 = _slicedToArray(_React$useState3, 2), forceUpdate = _React$useState4[1];
      useLayoutEffect$1(function() {
        if (!context) {
          return;
        }
        function trigger(nextValue) {
          var nextSelectorValue = eventSelector(nextValue);
          if (!isEqual$1(valueRef.current, nextSelectorValue, true)) {
            forceUpdate({});
          }
        }
        listeners.add(trigger);
        return function() {
          listeners.delete(trigger);
        };
      }, [context]);
      return valueRef.current;
    }
    function createImmutable() {
      var ImmutableContext = /* @__PURE__ */ reactExports.createContext(null);
      function useImmutableMark2() {
        return reactExports.useContext(ImmutableContext);
      }
      function makeImmutable2(Component, shouldTriggerRender) {
        var refAble = supportRef(Component);
        var ImmutableComponent = function ImmutableComponent2(props, ref) {
          var refProps = refAble ? {
            ref
          } : {};
          var renderTimesRef = reactExports.useRef(0);
          var prevProps = reactExports.useRef(props);
          var mark = useImmutableMark2();
          if (mark !== null) {
            return /* @__PURE__ */ reactExports.createElement(Component, _extends$1({}, props, refProps));
          }
          if (
            // Always trigger re-render if not provide `notTriggerRender`
            !shouldTriggerRender || shouldTriggerRender(prevProps.current, props)
          ) {
            renderTimesRef.current += 1;
          }
          prevProps.current = props;
          return /* @__PURE__ */ reactExports.createElement(ImmutableContext.Provider, {
            value: renderTimesRef.current
          }, /* @__PURE__ */ reactExports.createElement(Component, _extends$1({}, props, refProps)));
        };
        return refAble ? /* @__PURE__ */ reactExports.forwardRef(ImmutableComponent) : ImmutableComponent;
      }
      function responseImmutable2(Component, propsAreEqual) {
        var refAble = supportRef(Component);
        var ImmutableComponent = function ImmutableComponent2(props, ref) {
          var refProps = refAble ? {
            ref
          } : {};
          useImmutableMark2();
          return /* @__PURE__ */ reactExports.createElement(Component, _extends$1({}, props, refProps));
        };
        return refAble ? /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(ImmutableComponent), propsAreEqual) : /* @__PURE__ */ reactExports.memo(ImmutableComponent, propsAreEqual);
      }
      return {
        makeImmutable: makeImmutable2,
        responseImmutable: responseImmutable2,
        useImmutableMark: useImmutableMark2
      };
    }
    var _createImmutable = createImmutable(), makeImmutable = _createImmutable.makeImmutable, responseImmutable = _createImmutable.responseImmutable, useImmutableMark = _createImmutable.useImmutableMark;
    var TableContext = createContext();
    function useRenderTimes(props, debug) {
      var timesRef = reactExports.useRef(0);
      timesRef.current += 1;
      var propsRef = reactExports.useRef(props);
      var keys2 = [];
      Object.keys(props || {}).map(function(key) {
        var _propsRef$current;
        if ((props === null || props === void 0 ? void 0 : props[key]) !== ((_propsRef$current = propsRef.current) === null || _propsRef$current === void 0 ? void 0 : _propsRef$current[key])) {
          keys2.push(key);
        }
      });
      propsRef.current = props;
      var keysRef = reactExports.useRef([]);
      if (keys2.length) {
        keysRef.current = keys2;
      }
      reactExports.useDebugValue(timesRef.current);
      reactExports.useDebugValue(keysRef.current.join(", "));
      if (debug) {
        console.log("".concat(debug, ":"), timesRef.current, keysRef.current);
      }
      return timesRef.current;
    }
    var RenderBlock = /* @__PURE__ */ reactExports.memo(function() {
      var times = useRenderTimes();
      return /* @__PURE__ */ reactExports.createElement("h1", null, "Render Times: ", times);
    });
    RenderBlock.displayName = "RenderBlock";
    var PerfContext = /* @__PURE__ */ reactExports.createContext({
      renderWithProps: false
    });
    var INTERNAL_KEY_PREFIX = "RC_TABLE_KEY";
    function toArray$2(arr) {
      if (arr === void 0 || arr === null) {
        return [];
      }
      return Array.isArray(arr) ? arr : [arr];
    }
    function getColumnsKey(columns) {
      var columnKeys = [];
      var keys2 = {};
      columns.forEach(function(column2) {
        var _ref = column2 || {}, key = _ref.key, dataIndex = _ref.dataIndex;
        var mergedKey = key || toArray$2(dataIndex).join("-") || INTERNAL_KEY_PREFIX;
        while (keys2[mergedKey]) {
          mergedKey = "".concat(mergedKey, "_next");
        }
        keys2[mergedKey] = true;
        columnKeys.push(mergedKey);
      });
      return columnKeys;
    }
    function validateValue(val) {
      return val !== null && val !== void 0;
    }
    function isRenderCell(data) {
      return data && _typeof(data) === "object" && !Array.isArray(data) && !/* @__PURE__ */ reactExports.isValidElement(data);
    }
    function useCellRender(record, dataIndex, renderIndex, children, render2, shouldCellUpdate) {
      var perfRecord = reactExports.useContext(PerfContext);
      var mark = useImmutableMark();
      var retData = useMemo(function() {
        if (validateValue(children)) {
          return [children];
        }
        var path = dataIndex === null || dataIndex === void 0 || dataIndex === "" ? [] : Array.isArray(dataIndex) ? dataIndex : [dataIndex];
        var value = get$3(record, path);
        var returnChildNode = value;
        var returnCellProps = void 0;
        if (render2) {
          var renderData = render2(value, record, renderIndex);
          if (isRenderCell(renderData)) {
            returnChildNode = renderData.children;
            returnCellProps = renderData.props;
            perfRecord.renderWithProps = true;
          } else {
            returnChildNode = renderData;
          }
        }
        return [returnChildNode, returnCellProps];
      }, [
        // Force update deps
        mark,
        // Normal deps
        record,
        children,
        dataIndex,
        render2,
        renderIndex
      ], function(prev2, next2) {
        if (shouldCellUpdate) {
          var _prev = _slicedToArray(prev2, 2), prevRecord = _prev[1];
          var _next = _slicedToArray(next2, 2), nextRecord = _next[1];
          return shouldCellUpdate(nextRecord, prevRecord);
        }
        if (perfRecord.renderWithProps) {
          return true;
        }
        return !isEqual$1(prev2, next2, true);
      });
      return retData;
    }
    function inHoverRange(cellStartRow, cellRowSpan, startRow, endRow) {
      var cellEndRow = cellStartRow + cellRowSpan - 1;
      return cellStartRow <= endRow && cellEndRow >= startRow;
    }
    function useHoverState(rowIndex, rowSpan) {
      return useContext(TableContext, function(ctx) {
        var hovering = inHoverRange(rowIndex, rowSpan || 1, ctx.hoverStartRow, ctx.hoverEndRow);
        return [hovering, ctx.onHover];
      });
    }
    var getTitleFromCellRenderChildren = function getTitleFromCellRenderChildren2(_ref) {
      var ellipsis = _ref.ellipsis, rowType = _ref.rowType, children = _ref.children;
      var title;
      var ellipsisConfig = ellipsis === true ? {
        showTitle: true
      } : ellipsis;
      if (ellipsisConfig && (ellipsisConfig.showTitle || rowType === "header")) {
        if (typeof children === "string" || typeof children === "number") {
          title = children.toString();
        } else if (/* @__PURE__ */ reactExports.isValidElement(children) && typeof children.props.children === "string") {
          title = children.props.children;
        }
      }
      return title;
    };
    function Cell(props) {
      var _ref2, _ref3, _legacyCellProps$colS, _ref4, _ref5, _legacyCellProps$rowS, _additionalProps$titl, _classNames;
      var Component = props.component, children = props.children, ellipsis = props.ellipsis, scope = props.scope, prefixCls = props.prefixCls, className = props.className, align = props.align, record = props.record, render2 = props.render, dataIndex = props.dataIndex, renderIndex = props.renderIndex, shouldCellUpdate = props.shouldCellUpdate, index2 = props.index, rowType = props.rowType, colSpan = props.colSpan, rowSpan = props.rowSpan, fixLeft = props.fixLeft, fixRight = props.fixRight, firstFixLeft = props.firstFixLeft, lastFixLeft = props.lastFixLeft, firstFixRight = props.firstFixRight, lastFixRight = props.lastFixRight, appendNode = props.appendNode, _props$additionalProp = props.additionalProps, additionalProps = _props$additionalProp === void 0 ? {} : _props$additionalProp, isSticky = props.isSticky;
      var cellPrefixCls = "".concat(prefixCls, "-cell");
      var _useContext = useContext(TableContext, ["supportSticky", "allColumnsFixedLeft"]), supportSticky = _useContext.supportSticky, allColumnsFixedLeft = _useContext.allColumnsFixedLeft;
      var _useCellRender = useCellRender(record, dataIndex, renderIndex, children, render2, shouldCellUpdate), _useCellRender2 = _slicedToArray(_useCellRender, 2), childNode = _useCellRender2[0], legacyCellProps = _useCellRender2[1];
      var fixedStyle = {};
      var isFixLeft = typeof fixLeft === "number" && supportSticky;
      var isFixRight = typeof fixRight === "number" && supportSticky;
      if (isFixLeft) {
        fixedStyle.position = "sticky";
        fixedStyle.left = fixLeft;
      }
      if (isFixRight) {
        fixedStyle.position = "sticky";
        fixedStyle.right = fixRight;
      }
      var mergedColSpan = (_ref2 = (_ref3 = (_legacyCellProps$colS = legacyCellProps === null || legacyCellProps === void 0 ? void 0 : legacyCellProps.colSpan) !== null && _legacyCellProps$colS !== void 0 ? _legacyCellProps$colS : additionalProps.colSpan) !== null && _ref3 !== void 0 ? _ref3 : colSpan) !== null && _ref2 !== void 0 ? _ref2 : 1;
      var mergedRowSpan = (_ref4 = (_ref5 = (_legacyCellProps$rowS = legacyCellProps === null || legacyCellProps === void 0 ? void 0 : legacyCellProps.rowSpan) !== null && _legacyCellProps$rowS !== void 0 ? _legacyCellProps$rowS : additionalProps.rowSpan) !== null && _ref5 !== void 0 ? _ref5 : rowSpan) !== null && _ref4 !== void 0 ? _ref4 : 1;
      var _useHoverState = useHoverState(index2, mergedRowSpan), _useHoverState2 = _slicedToArray(_useHoverState, 2), hovering = _useHoverState2[0], onHover = _useHoverState2[1];
      var onMouseEnter = function onMouseEnter2(event) {
        var _additionalProps$onMo;
        if (record) {
          onHover(index2, index2 + mergedRowSpan - 1);
        }
        additionalProps === null || additionalProps === void 0 || (_additionalProps$onMo = additionalProps.onMouseEnter) === null || _additionalProps$onMo === void 0 || _additionalProps$onMo.call(additionalProps, event);
      };
      var onMouseLeave = function onMouseLeave2(event) {
        var _additionalProps$onMo2;
        if (record) {
          onHover(-1, -1);
        }
        additionalProps === null || additionalProps === void 0 || (_additionalProps$onMo2 = additionalProps.onMouseLeave) === null || _additionalProps$onMo2 === void 0 || _additionalProps$onMo2.call(additionalProps, event);
      };
      if (mergedColSpan === 0 || mergedRowSpan === 0) {
        return null;
      }
      var title = (_additionalProps$titl = additionalProps.title) !== null && _additionalProps$titl !== void 0 ? _additionalProps$titl : getTitleFromCellRenderChildren({
        rowType,
        ellipsis,
        children: childNode
      });
      var mergedClassName = classNames(cellPrefixCls, className, (_classNames = {}, _defineProperty(_classNames, "".concat(cellPrefixCls, "-fix-left"), isFixLeft && supportSticky), _defineProperty(_classNames, "".concat(cellPrefixCls, "-fix-left-first"), firstFixLeft && supportSticky), _defineProperty(_classNames, "".concat(cellPrefixCls, "-fix-left-last"), lastFixLeft && supportSticky), _defineProperty(_classNames, "".concat(cellPrefixCls, "-fix-left-all"), lastFixLeft && allColumnsFixedLeft && supportSticky), _defineProperty(_classNames, "".concat(cellPrefixCls, "-fix-right"), isFixRight && supportSticky), _defineProperty(_classNames, "".concat(cellPrefixCls, "-fix-right-first"), firstFixRight && supportSticky), _defineProperty(_classNames, "".concat(cellPrefixCls, "-fix-right-last"), lastFixRight && supportSticky), _defineProperty(_classNames, "".concat(cellPrefixCls, "-ellipsis"), ellipsis), _defineProperty(_classNames, "".concat(cellPrefixCls, "-with-append"), appendNode), _defineProperty(_classNames, "".concat(cellPrefixCls, "-fix-sticky"), (isFixLeft || isFixRight) && isSticky && supportSticky), _defineProperty(_classNames, "".concat(cellPrefixCls, "-row-hover"), !legacyCellProps && hovering), _classNames), additionalProps.className, legacyCellProps === null || legacyCellProps === void 0 ? void 0 : legacyCellProps.className);
      var alignStyle = {};
      if (align) {
        alignStyle.textAlign = align;
      }
      var mergedStyle = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, fixedStyle), additionalProps.style), alignStyle), legacyCellProps === null || legacyCellProps === void 0 ? void 0 : legacyCellProps.style);
      var mergedChildNode = childNode;
      if (_typeof(mergedChildNode) === "object" && !Array.isArray(mergedChildNode) && !/* @__PURE__ */ reactExports.isValidElement(mergedChildNode)) {
        mergedChildNode = null;
      }
      if (ellipsis && (lastFixLeft || firstFixRight)) {
        mergedChildNode = /* @__PURE__ */ reactExports.createElement("span", {
          className: "".concat(cellPrefixCls, "-content")
        }, mergedChildNode);
      }
      return /* @__PURE__ */ reactExports.createElement(Component, _extends$1({}, legacyCellProps, additionalProps, {
        className: mergedClassName,
        style: mergedStyle,
        title,
        scope,
        onMouseEnter,
        onMouseLeave,
        colSpan: mergedColSpan !== 1 ? mergedColSpan : null,
        rowSpan: mergedRowSpan !== 1 ? mergedRowSpan : null
      }), appendNode, mergedChildNode);
    }
    const Cell$1 = /* @__PURE__ */ reactExports.memo(Cell);
    function getCellFixedInfo(colStart, colEnd, columns, stickyOffsets, direction, curColumns) {
      var startColumn = columns[colStart] || {};
      var endColumn = columns[colEnd] || {};
      var fixLeft;
      var fixRight;
      if (startColumn.fixed === "left") {
        fixLeft = stickyOffsets.left[direction === "rtl" ? colEnd : colStart];
      } else if (endColumn.fixed === "right") {
        fixRight = stickyOffsets.right[direction === "rtl" ? colStart : colEnd];
      }
      var lastFixLeft = false;
      var firstFixRight = false;
      var lastFixRight = false;
      var firstFixLeft = false;
      var nextColumn = columns[colEnd + 1];
      var prevColumn = columns[colStart - 1];
      var canLastFix = !(curColumns !== null && curColumns !== void 0 && curColumns.children);
      if (direction === "rtl") {
        if (fixLeft !== void 0) {
          var prevFixLeft = prevColumn && prevColumn.fixed === "left";
          firstFixLeft = !prevFixLeft && canLastFix;
        } else if (fixRight !== void 0) {
          var nextFixRight = nextColumn && nextColumn.fixed === "right";
          lastFixRight = !nextFixRight && canLastFix;
        }
      } else if (fixLeft !== void 0) {
        var nextFixLeft = nextColumn && nextColumn.fixed === "left";
        lastFixLeft = !nextFixLeft && canLastFix;
      } else if (fixRight !== void 0) {
        var prevFixRight = prevColumn && prevColumn.fixed === "right";
        firstFixRight = !prevFixRight && canLastFix;
      }
      return {
        fixLeft,
        fixRight,
        lastFixLeft,
        firstFixRight,
        lastFixRight,
        firstFixLeft,
        isSticky: stickyOffsets.isSticky
      };
    }
    var SummaryContext = /* @__PURE__ */ reactExports.createContext({});
    function SummaryCell(_ref) {
      var className = _ref.className, index2 = _ref.index, children = _ref.children, _ref$colSpan = _ref.colSpan, colSpan = _ref$colSpan === void 0 ? 1 : _ref$colSpan, rowSpan = _ref.rowSpan, align = _ref.align;
      var _useContext = useContext(TableContext, ["prefixCls", "direction"]), prefixCls = _useContext.prefixCls, direction = _useContext.direction;
      var _React$useContext = reactExports.useContext(SummaryContext), scrollColumnIndex = _React$useContext.scrollColumnIndex, stickyOffsets = _React$useContext.stickyOffsets, flattenColumns = _React$useContext.flattenColumns, columns = _React$useContext.columns;
      var lastIndex = index2 + colSpan - 1;
      var mergedColSpan = lastIndex + 1 === scrollColumnIndex ? colSpan + 1 : colSpan;
      var fixedInfo = getCellFixedInfo(index2, index2 + mergedColSpan - 1, flattenColumns, stickyOffsets, direction, columns === null || columns === void 0 ? void 0 : columns[index2]);
      return /* @__PURE__ */ reactExports.createElement(Cell$1, _extends$1({
        className,
        index: index2,
        component: "td",
        prefixCls,
        record: null,
        dataIndex: null,
        align,
        colSpan: mergedColSpan,
        rowSpan,
        render: function render2() {
          return children;
        }
      }, fixedInfo));
    }
    var _excluded$9 = ["children"];
    function FooterRow(_ref) {
      var children = _ref.children, props = _objectWithoutProperties(_ref, _excluded$9);
      return /* @__PURE__ */ reactExports.createElement("tr", props, children);
    }
    function Summary(_ref) {
      var children = _ref.children;
      return children;
    }
    Summary.Row = FooterRow;
    Summary.Cell = SummaryCell;
    function Footer(props) {
      var children = props.children, stickyOffsets = props.stickyOffsets, flattenColumns = props.flattenColumns, columns = props.columns;
      var prefixCls = useContext(TableContext, "prefixCls");
      var lastColumnIndex = flattenColumns.length - 1;
      var scrollColumn = flattenColumns[lastColumnIndex];
      var summaryContext = reactExports.useMemo(function() {
        return {
          stickyOffsets,
          flattenColumns,
          scrollColumnIndex: scrollColumn !== null && scrollColumn !== void 0 && scrollColumn.scrollbar ? lastColumnIndex : null,
          columns
        };
      }, [scrollColumn, flattenColumns, lastColumnIndex, stickyOffsets, columns]);
      return /* @__PURE__ */ reactExports.createElement(SummaryContext.Provider, {
        value: summaryContext
      }, /* @__PURE__ */ reactExports.createElement("tfoot", {
        className: "".concat(prefixCls, "-summary")
      }, children));
    }
    const Footer$1 = responseImmutable(Footer);
    var FooterComponents = Summary;
    function Column$1(_) {
      return null;
    }
    function ColumnGroup$1(_) {
      return null;
    }
    function fillRecords(list, record, indent, childrenColumnName, expandedKeys, getRowKey, index2) {
      list.push({
        record,
        indent,
        index: index2
      });
      var key = getRowKey(record);
      var expanded = expandedKeys === null || expandedKeys === void 0 ? void 0 : expandedKeys.has(key);
      if (record && Array.isArray(record[childrenColumnName]) && expanded) {
        for (var i = 0; i < record[childrenColumnName].length; i += 1) {
          fillRecords(list, record[childrenColumnName][i], indent + 1, childrenColumnName, expandedKeys, getRowKey, i);
        }
      }
    }
    function useFlattenRecords(data, childrenColumnName, expandedKeys, getRowKey) {
      var arr = reactExports.useMemo(function() {
        if (expandedKeys !== null && expandedKeys !== void 0 && expandedKeys.size) {
          var list = [];
          for (var i = 0; i < (data === null || data === void 0 ? void 0 : data.length); i += 1) {
            var record = data[i];
            fillRecords(list, record, 0, childrenColumnName, expandedKeys, getRowKey, i);
          }
          return list;
        }
        return data === null || data === void 0 ? void 0 : data.map(function(item, index2) {
          return {
            record: item,
            indent: 0,
            index: index2
          };
        });
      }, [data, childrenColumnName, expandedKeys, getRowKey]);
      return arr;
    }
    function useRowInfo(record, rowKey, recordIndex, indent) {
      var context = useContext(TableContext, ["prefixCls", "fixedInfoList", "flattenColumns", "expandableType", "expandRowByClick", "onTriggerExpand", "rowClassName", "expandedRowClassName", "indentSize", "expandIcon", "expandedRowRender", "expandIconColumnIndex", "expandedKeys", "childrenColumnName", "rowExpandable", "onRow"]);
      var flattenColumns = context.flattenColumns, expandableType = context.expandableType, expandedKeys = context.expandedKeys, childrenColumnName = context.childrenColumnName, onTriggerExpand = context.onTriggerExpand, rowExpandable = context.rowExpandable, onRow = context.onRow, expandRowByClick = context.expandRowByClick, rowClassName = context.rowClassName;
      var nestExpandable = expandableType === "nest";
      var rowSupportExpand = expandableType === "row" && (!rowExpandable || rowExpandable(record));
      var mergedExpandable = rowSupportExpand || nestExpandable;
      var expanded = expandedKeys && expandedKeys.has(rowKey);
      var hasNestChildren = childrenColumnName && record && record[childrenColumnName];
      var onInternalTriggerExpand = useEvent(onTriggerExpand);
      var rowProps = onRow === null || onRow === void 0 ? void 0 : onRow(record, recordIndex);
      var onRowClick = rowProps === null || rowProps === void 0 ? void 0 : rowProps.onClick;
      var onClick = function onClick2(event) {
        if (expandRowByClick && mergedExpandable) {
          onTriggerExpand(record, event);
        }
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        onRowClick === null || onRowClick === void 0 || onRowClick.apply(void 0, [event].concat(args));
      };
      var computeRowClassName;
      if (typeof rowClassName === "string") {
        computeRowClassName = rowClassName;
      } else if (typeof rowClassName === "function") {
        computeRowClassName = rowClassName(record, recordIndex, indent);
      }
      var columnsKey = getColumnsKey(flattenColumns);
      return _objectSpread2(_objectSpread2({}, context), {}, {
        columnsKey,
        nestExpandable,
        expanded,
        hasNestChildren,
        record,
        onTriggerExpand: onInternalTriggerExpand,
        rowSupportExpand,
        expandable: mergedExpandable,
        rowProps: _objectSpread2(_objectSpread2({}, rowProps), {}, {
          className: classNames(computeRowClassName, rowProps === null || rowProps === void 0 ? void 0 : rowProps.className),
          onClick
        })
      });
    }
    function ExpandedRow(props) {
      var prefixCls = props.prefixCls, children = props.children, Component = props.component, cellComponent = props.cellComponent, className = props.className, expanded = props.expanded, colSpan = props.colSpan, isEmpty = props.isEmpty;
      var _useContext = useContext(TableContext, ["scrollbarSize", "fixHeader", "fixColumn", "componentWidth", "horizonScroll"]), scrollbarSize = _useContext.scrollbarSize, fixHeader = _useContext.fixHeader, fixColumn = _useContext.fixColumn, componentWidth = _useContext.componentWidth, horizonScroll = _useContext.horizonScroll;
      var contentNode = children;
      if (isEmpty ? horizonScroll && componentWidth : fixColumn) {
        contentNode = /* @__PURE__ */ reactExports.createElement("div", {
          style: {
            width: componentWidth - (fixHeader ? scrollbarSize : 0),
            position: "sticky",
            left: 0,
            overflow: "hidden"
          },
          className: "".concat(prefixCls, "-expanded-row-fixed")
        }, contentNode);
      }
      return /* @__PURE__ */ reactExports.createElement(Component, {
        className,
        style: {
          display: expanded ? null : "none"
        }
      }, /* @__PURE__ */ reactExports.createElement(Cell$1, {
        component: cellComponent,
        prefixCls,
        colSpan
      }, contentNode));
    }
    function getCellProps(rowInfo, column2, colIndex, indent, index2) {
      var record = rowInfo.record, prefixCls = rowInfo.prefixCls, columnsKey = rowInfo.columnsKey, fixedInfoList = rowInfo.fixedInfoList, expandIconColumnIndex = rowInfo.expandIconColumnIndex, nestExpandable = rowInfo.nestExpandable, indentSize = rowInfo.indentSize, expandIcon = rowInfo.expandIcon, expanded = rowInfo.expanded, hasNestChildren = rowInfo.hasNestChildren, onTriggerExpand = rowInfo.onTriggerExpand;
      var key = columnsKey[colIndex];
      var fixedInfo = fixedInfoList[colIndex];
      var appendCellNode;
      if (colIndex === (expandIconColumnIndex || 0) && nestExpandable) {
        appendCellNode = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("span", {
          style: {
            paddingLeft: "".concat(indentSize * indent, "px")
          },
          className: "".concat(prefixCls, "-row-indent indent-level-").concat(indent)
        }), expandIcon({
          prefixCls,
          expanded,
          expandable: hasNestChildren,
          record,
          onExpand: onTriggerExpand
        }));
      }
      var additionalCellProps;
      if (column2.onCell) {
        additionalCellProps = column2.onCell(record, index2);
      }
      return {
        key,
        fixedInfo,
        appendCellNode,
        additionalCellProps: additionalCellProps || {}
      };
    }
    function BodyRow(props) {
      var className = props.className, style2 = props.style, record = props.record, index2 = props.index, renderIndex = props.renderIndex, rowKey = props.rowKey, _props$indent = props.indent, indent = _props$indent === void 0 ? 0 : _props$indent, RowComponent = props.rowComponent, cellComponent = props.cellComponent, scopeCellComponent = props.scopeCellComponent;
      var rowInfo = useRowInfo(record, rowKey, index2, indent);
      var prefixCls = rowInfo.prefixCls, flattenColumns = rowInfo.flattenColumns, expandedRowClassName = rowInfo.expandedRowClassName, expandedRowRender = rowInfo.expandedRowRender, rowProps = rowInfo.rowProps, expanded = rowInfo.expanded, rowSupportExpand = rowInfo.rowSupportExpand;
      var expandedRef = reactExports.useRef(false);
      expandedRef.current || (expandedRef.current = expanded);
      var baseRowNode = /* @__PURE__ */ reactExports.createElement(RowComponent, _extends$1({}, rowProps, {
        "data-row-key": rowKey,
        className: classNames(className, "".concat(prefixCls, "-row"), "".concat(prefixCls, "-row-level-").concat(indent), rowProps === null || rowProps === void 0 ? void 0 : rowProps.className),
        style: _objectSpread2(_objectSpread2({}, style2), rowProps === null || rowProps === void 0 ? void 0 : rowProps.style)
      }), flattenColumns.map(function(column2, colIndex) {
        var render2 = column2.render, dataIndex = column2.dataIndex, columnClassName = column2.className;
        var _getCellProps = getCellProps(rowInfo, column2, colIndex, indent, index2), key = _getCellProps.key, fixedInfo = _getCellProps.fixedInfo, appendCellNode = _getCellProps.appendCellNode, additionalCellProps = _getCellProps.additionalCellProps;
        return /* @__PURE__ */ reactExports.createElement(Cell$1, _extends$1({
          className: columnClassName,
          ellipsis: column2.ellipsis,
          align: column2.align,
          scope: column2.rowScope,
          component: column2.rowScope ? scopeCellComponent : cellComponent,
          prefixCls,
          key,
          record,
          index: index2,
          renderIndex,
          dataIndex,
          render: render2,
          shouldCellUpdate: column2.shouldCellUpdate
        }, fixedInfo, {
          appendNode: appendCellNode,
          additionalProps: additionalCellProps
        }));
      }));
      var expandRowNode;
      if (rowSupportExpand && (expandedRef.current || expanded)) {
        var expandContent = expandedRowRender(record, index2, indent + 1, expanded);
        var computedExpandedRowClassName = expandedRowClassName && expandedRowClassName(record, index2, indent);
        expandRowNode = /* @__PURE__ */ reactExports.createElement(ExpandedRow, {
          expanded,
          className: classNames("".concat(prefixCls, "-expanded-row"), "".concat(prefixCls, "-expanded-row-level-").concat(indent + 1), computedExpandedRowClassName),
          prefixCls,
          component: RowComponent,
          cellComponent,
          colSpan: flattenColumns.length,
          isEmpty: false
        }, expandContent);
      }
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, baseRowNode, expandRowNode);
    }
    BodyRow.displayName = "BodyRow";
    const BodyRow$1 = responseImmutable(BodyRow);
    function MeasureCell(_ref) {
      var columnKey = _ref.columnKey, onColumnResize = _ref.onColumnResize;
      var cellRef = reactExports.useRef();
      reactExports.useEffect(function() {
        if (cellRef.current) {
          onColumnResize(columnKey, cellRef.current.offsetWidth);
        }
      }, []);
      return /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
        data: columnKey
      }, /* @__PURE__ */ reactExports.createElement("td", {
        ref: cellRef,
        style: {
          padding: 0,
          border: 0,
          height: 0
        }
      }, /* @__PURE__ */ reactExports.createElement("div", {
        style: {
          height: 0,
          overflow: "hidden"
        }
      }, " ")));
    }
    function MeasureRow(_ref) {
      var prefixCls = _ref.prefixCls, columnsKey = _ref.columnsKey, onColumnResize = _ref.onColumnResize;
      return /* @__PURE__ */ reactExports.createElement("tr", {
        "aria-hidden": "true",
        className: "".concat(prefixCls, "-measure-row"),
        style: {
          height: 0,
          fontSize: 0
        }
      }, /* @__PURE__ */ reactExports.createElement(RefResizeObserver.Collection, {
        onBatchResize: function onBatchResize(infoList) {
          infoList.forEach(function(_ref2) {
            var columnKey = _ref2.data, size = _ref2.size;
            onColumnResize(columnKey, size.offsetWidth);
          });
        }
      }, columnsKey.map(function(columnKey) {
        return /* @__PURE__ */ reactExports.createElement(MeasureCell, {
          key: columnKey,
          columnKey,
          onColumnResize
        });
      })));
    }
    function Body(props) {
      var data = props.data, measureColumnWidth = props.measureColumnWidth;
      var _useContext = useContext(TableContext, ["prefixCls", "getComponent", "onColumnResize", "flattenColumns", "getRowKey", "expandedKeys", "childrenColumnName", "emptyNode"]), prefixCls = _useContext.prefixCls, getComponent = _useContext.getComponent, onColumnResize = _useContext.onColumnResize, flattenColumns = _useContext.flattenColumns, getRowKey = _useContext.getRowKey, expandedKeys = _useContext.expandedKeys, childrenColumnName = _useContext.childrenColumnName, emptyNode = _useContext.emptyNode;
      var flattenData2 = useFlattenRecords(data, childrenColumnName, expandedKeys, getRowKey);
      var perfRef = reactExports.useRef({
        renderWithProps: false
      });
      var WrapperComponent = getComponent(["body", "wrapper"], "tbody");
      var trComponent = getComponent(["body", "row"], "tr");
      var tdComponent = getComponent(["body", "cell"], "td");
      var thComponent = getComponent(["body", "cell"], "th");
      var rows;
      if (data.length) {
        rows = flattenData2.map(function(item, idx) {
          var record = item.record, indent = item.indent, renderIndex = item.index;
          var key = getRowKey(record, idx);
          return /* @__PURE__ */ reactExports.createElement(BodyRow$1, {
            key,
            rowKey: key,
            record,
            index: idx,
            renderIndex,
            rowComponent: trComponent,
            cellComponent: tdComponent,
            scopeCellComponent: thComponent,
            getRowKey,
            indent
          });
        });
      } else {
        rows = /* @__PURE__ */ reactExports.createElement(ExpandedRow, {
          expanded: true,
          className: "".concat(prefixCls, "-placeholder"),
          prefixCls,
          component: trComponent,
          cellComponent: tdComponent,
          colSpan: flattenColumns.length,
          isEmpty: true
        }, emptyNode);
      }
      var columnsKey = getColumnsKey(flattenColumns);
      return /* @__PURE__ */ reactExports.createElement(PerfContext.Provider, {
        value: perfRef.current
      }, /* @__PURE__ */ reactExports.createElement(WrapperComponent, {
        className: "".concat(prefixCls, "-tbody")
      }, measureColumnWidth && /* @__PURE__ */ reactExports.createElement(MeasureRow, {
        prefixCls,
        columnsKey,
        onColumnResize
      }), rows));
    }
    Body.displayName = "Body";
    const Body$1 = responseImmutable(Body);
    var _excluded$8 = ["expandable"];
    var INTERNAL_COL_DEFINE = "RC_TABLE_INTERNAL_COL_DEFINE";
    function getExpandableProps(props) {
      var expandable = props.expandable, legacyExpandableConfig = _objectWithoutProperties(props, _excluded$8);
      var config;
      if ("expandable" in props) {
        config = _objectSpread2(_objectSpread2({}, legacyExpandableConfig), expandable);
      } else {
        config = legacyExpandableConfig;
      }
      if (config.showExpandColumn === false) {
        config.expandIconColumnIndex = -1;
      }
      return config;
    }
    var _excluded$7 = ["columnType"];
    function ColGroup(_ref) {
      var colWidths = _ref.colWidths, columns = _ref.columns, columCount = _ref.columCount;
      var cols = [];
      var len = columCount || columns.length;
      var mustInsert = false;
      for (var i = len - 1; i >= 0; i -= 1) {
        var width = colWidths[i];
        var column2 = columns && columns[i];
        var additionalProps = column2 && column2[INTERNAL_COL_DEFINE];
        if (width || additionalProps || mustInsert) {
          var _ref2 = additionalProps || {};
          _ref2.columnType;
          var restAdditionalProps = _objectWithoutProperties(_ref2, _excluded$7);
          cols.unshift(/* @__PURE__ */ reactExports.createElement("col", _extends$1({
            key: i,
            style: {
              width
            }
          }, restAdditionalProps)));
          mustInsert = true;
        }
      }
      return /* @__PURE__ */ reactExports.createElement("colgroup", null, cols);
    }
    var _excluded$6 = ["className", "noData", "columns", "flattenColumns", "colWidths", "columCount", "stickyOffsets", "direction", "fixHeader", "stickyTopOffset", "stickyBottomOffset", "stickyClassName", "onScroll", "maxContentScroll", "children"];
    function useColumnWidth(colWidths, columCount) {
      return reactExports.useMemo(function() {
        var cloneColumns = [];
        for (var i = 0; i < columCount; i += 1) {
          var val = colWidths[i];
          if (val !== void 0) {
            cloneColumns[i] = val;
          } else {
            return null;
          }
        }
        return cloneColumns;
      }, [colWidths.join("_"), columCount]);
    }
    var FixedHolder = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var className = props.className, noData = props.noData, columns = props.columns, flattenColumns = props.flattenColumns, colWidths = props.colWidths, columCount = props.columCount, stickyOffsets = props.stickyOffsets, direction = props.direction, fixHeader = props.fixHeader, stickyTopOffset = props.stickyTopOffset, stickyBottomOffset = props.stickyBottomOffset, stickyClassName = props.stickyClassName, onScroll = props.onScroll, maxContentScroll = props.maxContentScroll, children = props.children, restProps = _objectWithoutProperties(props, _excluded$6);
      var _useContext = useContext(TableContext, ["prefixCls", "scrollbarSize", "isSticky"]), prefixCls = _useContext.prefixCls, scrollbarSize = _useContext.scrollbarSize, isSticky = _useContext.isSticky;
      var combinationScrollBarSize = isSticky && !fixHeader ? 0 : scrollbarSize;
      var scrollRef = reactExports.useRef(null);
      var setScrollRef = reactExports.useCallback(function(element) {
        fillRef(ref, element);
        fillRef(scrollRef, element);
      }, []);
      reactExports.useEffect(function() {
        var _scrollRef$current;
        function onWheel(e2) {
          var _ref = e2, currentTarget = _ref.currentTarget, deltaX = _ref.deltaX;
          if (deltaX) {
            onScroll({
              currentTarget,
              scrollLeft: currentTarget.scrollLeft + deltaX
            });
            e2.preventDefault();
          }
        }
        (_scrollRef$current = scrollRef.current) === null || _scrollRef$current === void 0 || _scrollRef$current.addEventListener("wheel", onWheel);
        return function() {
          var _scrollRef$current2;
          (_scrollRef$current2 = scrollRef.current) === null || _scrollRef$current2 === void 0 || _scrollRef$current2.removeEventListener("wheel", onWheel);
        };
      }, []);
      var allFlattenColumnsWithWidth = reactExports.useMemo(function() {
        return flattenColumns.every(function(column2) {
          return column2.width;
        });
      }, [flattenColumns]);
      var lastColumn = flattenColumns[flattenColumns.length - 1];
      var ScrollBarColumn = {
        fixed: lastColumn ? lastColumn.fixed : null,
        scrollbar: true,
        onHeaderCell: function onHeaderCell() {
          return {
            className: "".concat(prefixCls, "-cell-scrollbar")
          };
        }
      };
      var columnsWithScrollbar = reactExports.useMemo(function() {
        return combinationScrollBarSize ? [].concat(_toConsumableArray(columns), [ScrollBarColumn]) : columns;
      }, [combinationScrollBarSize, columns]);
      var flattenColumnsWithScrollbar = reactExports.useMemo(function() {
        return combinationScrollBarSize ? [].concat(_toConsumableArray(flattenColumns), [ScrollBarColumn]) : flattenColumns;
      }, [combinationScrollBarSize, flattenColumns]);
      var headerStickyOffsets = reactExports.useMemo(function() {
        var right = stickyOffsets.right, left = stickyOffsets.left;
        return _objectSpread2(_objectSpread2({}, stickyOffsets), {}, {
          left: direction === "rtl" ? [].concat(_toConsumableArray(left.map(function(width) {
            return width + combinationScrollBarSize;
          })), [0]) : left,
          right: direction === "rtl" ? right : [].concat(_toConsumableArray(right.map(function(width) {
            return width + combinationScrollBarSize;
          })), [0]),
          isSticky
        });
      }, [combinationScrollBarSize, stickyOffsets, isSticky]);
      var mergedColumnWidth = useColumnWidth(colWidths, columCount);
      return /* @__PURE__ */ reactExports.createElement("div", {
        style: _objectSpread2({
          overflow: "hidden"
        }, isSticky ? {
          top: stickyTopOffset,
          bottom: stickyBottomOffset
        } : {}),
        ref: setScrollRef,
        className: classNames(className, _defineProperty({}, stickyClassName, !!stickyClassName))
      }, /* @__PURE__ */ reactExports.createElement("table", {
        style: {
          tableLayout: "fixed",
          visibility: noData || mergedColumnWidth ? null : "hidden"
        }
      }, (!noData || !maxContentScroll || allFlattenColumnsWithWidth) && /* @__PURE__ */ reactExports.createElement(ColGroup, {
        colWidths: mergedColumnWidth ? [].concat(_toConsumableArray(mergedColumnWidth), [combinationScrollBarSize]) : [],
        columCount: columCount + 1,
        columns: flattenColumnsWithScrollbar
      }), children(_objectSpread2(_objectSpread2({}, restProps), {}, {
        stickyOffsets: headerStickyOffsets,
        columns: columnsWithScrollbar,
        flattenColumns: flattenColumnsWithScrollbar
      }))));
    });
    FixedHolder.displayName = "FixedHolder";
    const FixedHolder$1 = /* @__PURE__ */ reactExports.memo(FixedHolder);
    function HeaderRow(_ref) {
      var cells = _ref.cells, stickyOffsets = _ref.stickyOffsets, flattenColumns = _ref.flattenColumns, RowComponent = _ref.rowComponent, CellComponent = _ref.cellComponent, tdCellComponent = _ref.tdCellComponent, onHeaderRow = _ref.onHeaderRow, index2 = _ref.index;
      var _useContext = useContext(TableContext, ["prefixCls", "direction"]), prefixCls = _useContext.prefixCls, direction = _useContext.direction;
      var rowProps;
      if (onHeaderRow) {
        rowProps = onHeaderRow(cells.map(function(cell) {
          return cell.column;
        }), index2);
      }
      var columnsKey = getColumnsKey(cells.map(function(cell) {
        return cell.column;
      }));
      return /* @__PURE__ */ reactExports.createElement(RowComponent, rowProps, cells.map(function(cell, cellIndex) {
        var column2 = cell.column;
        var fixedInfo = getCellFixedInfo(cell.colStart, cell.colEnd, flattenColumns, stickyOffsets, direction, column2);
        var additionalProps;
        if (column2 && column2.onHeaderCell) {
          additionalProps = cell.column.onHeaderCell(column2);
        }
        return /* @__PURE__ */ reactExports.createElement(Cell$1, _extends$1({}, cell, {
          scope: column2.title ? cell.colSpan > 1 ? "colgroup" : "col" : null,
          ellipsis: column2.ellipsis,
          align: column2.align,
          component: column2.title ? CellComponent : tdCellComponent,
          prefixCls,
          key: columnsKey[cellIndex]
        }, fixedInfo, {
          additionalProps,
          rowType: "header"
        }));
      }));
    }
    HeaderRow.displayName = "HeaderRow";
    function parseHeaderRows(rootColumns) {
      var rows = [];
      function fillRowCells(columns, colIndex) {
        var rowIndex2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        rows[rowIndex2] = rows[rowIndex2] || [];
        var currentColIndex = colIndex;
        var colSpans = columns.filter(Boolean).map(function(column2) {
          var cell = {
            key: column2.key,
            className: column2.className || "",
            children: column2.title,
            column: column2,
            colStart: currentColIndex
          };
          var colSpan = 1;
          var subColumns = column2.children;
          if (subColumns && subColumns.length > 0) {
            colSpan = fillRowCells(subColumns, currentColIndex, rowIndex2 + 1).reduce(function(total, count) {
              return total + count;
            }, 0);
            cell.hasSubColumns = true;
          }
          if ("colSpan" in column2) {
            colSpan = column2.colSpan;
          }
          if ("rowSpan" in column2) {
            cell.rowSpan = column2.rowSpan;
          }
          cell.colSpan = colSpan;
          cell.colEnd = cell.colStart + colSpan - 1;
          rows[rowIndex2].push(cell);
          currentColIndex += colSpan;
          return colSpan;
        });
        return colSpans;
      }
      fillRowCells(rootColumns, 0);
      var rowCount = rows.length;
      var _loop = function _loop2(rowIndex2) {
        rows[rowIndex2].forEach(function(cell) {
          if (!("rowSpan" in cell) && !cell.hasSubColumns) {
            cell.rowSpan = rowCount - rowIndex2;
          }
        });
      };
      for (var rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {
        _loop(rowIndex);
      }
      return rows;
    }
    function Header(props) {
      var stickyOffsets = props.stickyOffsets, columns = props.columns, flattenColumns = props.flattenColumns, onHeaderRow = props.onHeaderRow;
      var _useContext = useContext(TableContext, ["prefixCls", "getComponent"]), prefixCls = _useContext.prefixCls, getComponent = _useContext.getComponent;
      var rows = reactExports.useMemo(function() {
        return parseHeaderRows(columns);
      }, [columns]);
      var WrapperComponent = getComponent(["header", "wrapper"], "thead");
      var trComponent = getComponent(["header", "row"], "tr");
      var thComponent = getComponent(["header", "cell"], "th");
      var tdComponent = getComponent(["header", "cell"], "td");
      return /* @__PURE__ */ reactExports.createElement(WrapperComponent, {
        className: "".concat(prefixCls, "-thead")
      }, rows.map(function(row, rowIndex) {
        var rowNode = /* @__PURE__ */ reactExports.createElement(HeaderRow, {
          key: rowIndex,
          flattenColumns,
          cells: row,
          stickyOffsets,
          rowComponent: trComponent,
          cellComponent: thComponent,
          tdCellComponent: tdComponent,
          onHeaderRow,
          index: rowIndex
        });
        return rowNode;
      }));
    }
    const Header$1 = responseImmutable(Header);
    function parseColWidth(totalWidth) {
      var width = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      if (typeof width === "number") {
        return width;
      }
      if (width.endsWith("%")) {
        return totalWidth * parseFloat(width) / 100;
      }
      return null;
    }
    function useWidthColumns(flattenColumns, scrollWidth, clientWidth) {
      return reactExports.useMemo(function() {
        if (scrollWidth && scrollWidth > 0) {
          var totalWidth = 0;
          var missWidthCount = 0;
          flattenColumns.forEach(function(col) {
            var colWidth = parseColWidth(scrollWidth, col.width);
            if (colWidth) {
              totalWidth += colWidth;
            } else {
              missWidthCount += 1;
            }
          });
          var maxFitWidth = Math.max(scrollWidth, clientWidth);
          var restWidth = Math.max(maxFitWidth - totalWidth, missWidthCount);
          var restCount = missWidthCount;
          var avgWidth = restWidth / missWidthCount;
          var realTotal = 0;
          var filledColumns = flattenColumns.map(function(col) {
            var clone2 = _objectSpread2({}, col);
            var colWidth = parseColWidth(scrollWidth, clone2.width);
            if (colWidth) {
              clone2.width = colWidth;
            } else {
              var colAvgWidth = Math.floor(avgWidth);
              clone2.width = restCount === 1 ? restWidth : colAvgWidth;
              restWidth -= colAvgWidth;
              restCount -= 1;
            }
            realTotal += clone2.width;
            return clone2;
          });
          if (realTotal < maxFitWidth) {
            var scale = maxFitWidth / realTotal;
            restWidth = maxFitWidth;
            filledColumns.forEach(function(col, index2) {
              var colWidth = Math.floor(col.width * scale);
              col.width = index2 === filledColumns.length - 1 ? restWidth : colWidth;
              restWidth -= colWidth;
            });
          }
          return [filledColumns, Math.max(realTotal, maxFitWidth)];
        }
        return [flattenColumns, scrollWidth];
      }, [flattenColumns, scrollWidth, clientWidth]);
    }
    var _excluded$5 = ["children"], _excluded2 = ["fixed"];
    function convertChildrenToColumns(children) {
      return toArray$a(children).filter(function(node2) {
        return /* @__PURE__ */ reactExports.isValidElement(node2);
      }).map(function(_ref) {
        var key = _ref.key, props = _ref.props;
        var nodeChildren = props.children, restProps = _objectWithoutProperties(props, _excluded$5);
        var column2 = _objectSpread2({
          key
        }, restProps);
        if (nodeChildren) {
          column2.children = convertChildrenToColumns(nodeChildren);
        }
        return column2;
      });
    }
    function flatColumns(columns) {
      var parentKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key";
      return columns.filter(function(column2) {
        return column2 && _typeof(column2) === "object";
      }).reduce(function(list, column2, index2) {
        var fixed = column2.fixed;
        var parsedFixed = fixed === true ? "left" : fixed;
        var mergedKey = "".concat(parentKey, "-").concat(index2);
        var subColumns = column2.children;
        if (subColumns && subColumns.length > 0) {
          return [].concat(_toConsumableArray(list), _toConsumableArray(flatColumns(subColumns, mergedKey).map(function(subColum) {
            return _objectSpread2({
              fixed: parsedFixed
            }, subColum);
          })));
        }
        return [].concat(_toConsumableArray(list), [_objectSpread2(_objectSpread2({
          key: mergedKey
        }, column2), {}, {
          fixed: parsedFixed
        })]);
      }, []);
    }
    function revertForRtl(columns) {
      return columns.map(function(column2) {
        var fixed = column2.fixed, restProps = _objectWithoutProperties(column2, _excluded2);
        var parsedFixed = fixed;
        if (fixed === "left") {
          parsedFixed = "right";
        } else if (fixed === "right") {
          parsedFixed = "left";
        }
        return _objectSpread2({
          fixed: parsedFixed
        }, restProps);
      });
    }
    function useColumns(_ref2, transformColumns) {
      var prefixCls = _ref2.prefixCls, columns = _ref2.columns, children = _ref2.children, expandable = _ref2.expandable, expandedKeys = _ref2.expandedKeys, columnTitle = _ref2.columnTitle, getRowKey = _ref2.getRowKey, onTriggerExpand = _ref2.onTriggerExpand, expandIcon = _ref2.expandIcon, rowExpandable = _ref2.rowExpandable, expandIconColumnIndex = _ref2.expandIconColumnIndex, direction = _ref2.direction, expandRowByClick = _ref2.expandRowByClick, columnWidth = _ref2.columnWidth, fixed = _ref2.fixed, scrollWidth = _ref2.scrollWidth, clientWidth = _ref2.clientWidth;
      var baseColumns = reactExports.useMemo(function() {
        return columns || convertChildrenToColumns(children);
      }, [columns, children]);
      var withExpandColumns = reactExports.useMemo(function() {
        if (expandable) {
          var _expandColumn;
          var cloneColumns = baseColumns.slice();
          if (!cloneColumns.includes(EXPAND_COLUMN)) {
            var expandColIndex = expandIconColumnIndex || 0;
            if (expandColIndex >= 0) {
              cloneColumns.splice(expandColIndex, 0, EXPAND_COLUMN);
            }
          }
          var expandColumnIndex = cloneColumns.indexOf(EXPAND_COLUMN);
          cloneColumns = cloneColumns.filter(function(column2, index2) {
            return column2 !== EXPAND_COLUMN || index2 === expandColumnIndex;
          });
          var prevColumn = baseColumns[expandColumnIndex];
          var fixedColumn;
          if ((fixed === "left" || fixed) && !expandIconColumnIndex) {
            fixedColumn = "left";
          } else if ((fixed === "right" || fixed) && expandIconColumnIndex === baseColumns.length) {
            fixedColumn = "right";
          } else {
            fixedColumn = prevColumn ? prevColumn.fixed : null;
          }
          var expandColumn = (_expandColumn = {}, _defineProperty(_expandColumn, INTERNAL_COL_DEFINE, {
            className: "".concat(prefixCls, "-expand-icon-col"),
            columnType: "EXPAND_COLUMN"
          }), _defineProperty(_expandColumn, "title", columnTitle), _defineProperty(_expandColumn, "fixed", fixedColumn), _defineProperty(_expandColumn, "className", "".concat(prefixCls, "-row-expand-icon-cell")), _defineProperty(_expandColumn, "width", columnWidth), _defineProperty(_expandColumn, "render", function render2(_, record, index2) {
            var rowKey = getRowKey(record, index2);
            var expanded = expandedKeys.has(rowKey);
            var recordExpandable = rowExpandable ? rowExpandable(record) : true;
            var icon = expandIcon({
              prefixCls,
              expanded,
              expandable: recordExpandable,
              record,
              onExpand: onTriggerExpand
            });
            if (expandRowByClick) {
              return /* @__PURE__ */ reactExports.createElement("span", {
                onClick: function onClick(e2) {
                  return e2.stopPropagation();
                }
              }, icon);
            }
            return icon;
          }), _expandColumn);
          return cloneColumns.map(function(col) {
            return col === EXPAND_COLUMN ? expandColumn : col;
          });
        }
        return baseColumns.filter(function(col) {
          return col !== EXPAND_COLUMN;
        });
      }, [expandable, baseColumns, getRowKey, expandedKeys, expandIcon, direction]);
      var mergedColumns = reactExports.useMemo(function() {
        var finalColumns = withExpandColumns;
        if (transformColumns) {
          finalColumns = transformColumns(finalColumns);
        }
        if (!finalColumns.length) {
          finalColumns = [{
            render: function render2() {
              return null;
            }
          }];
        }
        return finalColumns;
      }, [transformColumns, withExpandColumns, direction]);
      var flattenColumns = reactExports.useMemo(function() {
        if (direction === "rtl") {
          return revertForRtl(flatColumns(mergedColumns));
        }
        return flatColumns(mergedColumns);
      }, [mergedColumns, direction, scrollWidth]);
      var _useWidthColumns = useWidthColumns(flattenColumns, scrollWidth, clientWidth), _useWidthColumns2 = _slicedToArray(_useWidthColumns, 2), filledColumns = _useWidthColumns2[0], realScrollWidth = _useWidthColumns2[1];
      return [mergedColumns, filledColumns, realScrollWidth];
    }
    function renderExpandIcon$1(_ref) {
      var _classNames;
      var prefixCls = _ref.prefixCls, record = _ref.record, onExpand = _ref.onExpand, expanded = _ref.expanded, expandable = _ref.expandable;
      var expandClassName = "".concat(prefixCls, "-row-expand-icon");
      if (!expandable) {
        return /* @__PURE__ */ reactExports.createElement("span", {
          className: classNames(expandClassName, "".concat(prefixCls, "-row-spaced"))
        });
      }
      var onClick = function onClick2(event) {
        onExpand(record, event);
        event.stopPropagation();
      };
      return /* @__PURE__ */ reactExports.createElement("span", {
        className: classNames(expandClassName, (_classNames = {}, _defineProperty(_classNames, "".concat(prefixCls, "-row-expanded"), expanded), _defineProperty(_classNames, "".concat(prefixCls, "-row-collapsed"), !expanded), _classNames)),
        onClick
      });
    }
    function findAllChildrenKeys(data, getRowKey, childrenColumnName) {
      var keys2 = [];
      function dig(list) {
        (list || []).forEach(function(item, index2) {
          keys2.push(getRowKey(item, index2));
          dig(item[childrenColumnName]);
        });
      }
      dig(data);
      return keys2;
    }
    function useExpand(props, mergedData, getRowKey) {
      var expandableConfig = getExpandableProps(props);
      var expandIcon = expandableConfig.expandIcon, expandedRowKeys = expandableConfig.expandedRowKeys, defaultExpandedRowKeys = expandableConfig.defaultExpandedRowKeys, defaultExpandAllRows = expandableConfig.defaultExpandAllRows, expandedRowRender = expandableConfig.expandedRowRender, onExpand = expandableConfig.onExpand, onExpandedRowsChange = expandableConfig.onExpandedRowsChange, childrenColumnName = expandableConfig.childrenColumnName;
      var mergedExpandIcon = expandIcon || renderExpandIcon$1;
      var mergedChildrenColumnName = childrenColumnName || "children";
      var expandableType = reactExports.useMemo(function() {
        if (expandedRowRender) {
          return "row";
        }
        if (props.expandable && props.internalHooks === INTERNAL_HOOKS && props.expandable.__PARENT_RENDER_ICON__ || mergedData.some(function(record) {
          return record && _typeof(record) === "object" && record[mergedChildrenColumnName];
        })) {
          return "nest";
        }
        return false;
      }, [!!expandedRowRender, mergedData]);
      var _React$useState = reactExports.useState(function() {
        if (defaultExpandedRowKeys) {
          return defaultExpandedRowKeys;
        }
        if (defaultExpandAllRows) {
          return findAllChildrenKeys(mergedData, getRowKey, mergedChildrenColumnName);
        }
        return [];
      }), _React$useState2 = _slicedToArray(_React$useState, 2), innerExpandedKeys = _React$useState2[0], setInnerExpandedKeys = _React$useState2[1];
      var mergedExpandedKeys = reactExports.useMemo(function() {
        return new Set(expandedRowKeys || innerExpandedKeys || []);
      }, [expandedRowKeys, innerExpandedKeys]);
      var onTriggerExpand = reactExports.useCallback(function(record) {
        var key = getRowKey(record, mergedData.indexOf(record));
        var newExpandedKeys;
        var hasKey = mergedExpandedKeys.has(key);
        if (hasKey) {
          mergedExpandedKeys.delete(key);
          newExpandedKeys = _toConsumableArray(mergedExpandedKeys);
        } else {
          newExpandedKeys = [].concat(_toConsumableArray(mergedExpandedKeys), [key]);
        }
        setInnerExpandedKeys(newExpandedKeys);
        if (onExpand) {
          onExpand(!hasKey, record);
        }
        if (onExpandedRowsChange) {
          onExpandedRowsChange(newExpandedKeys);
        }
      }, [getRowKey, mergedExpandedKeys, mergedData, onExpand, onExpandedRowsChange]);
      return [expandableConfig, expandableType, mergedExpandedKeys, mergedExpandIcon, mergedChildrenColumnName, onTriggerExpand];
    }
    function useFixedInfo(flattenColumns, stickyOffsets, direction, columns) {
      var fixedInfoList = flattenColumns.map(function(_, colIndex) {
        return getCellFixedInfo(colIndex, colIndex, flattenColumns, stickyOffsets, direction, columns === null || columns === void 0 ? void 0 : columns[colIndex]);
      });
      return useMemo(function() {
        return fixedInfoList;
      }, [fixedInfoList], function(prev2, next2) {
        return !isEqual$1(prev2, next2);
      });
    }
    function useLayoutState(defaultState) {
      var stateRef = reactExports.useRef(defaultState);
      var _useState = reactExports.useState({}), _useState2 = _slicedToArray(_useState, 2), forceUpdate = _useState2[1];
      var lastPromiseRef = reactExports.useRef(null);
      var updateBatchRef = reactExports.useRef([]);
      function setFrameState(updater) {
        updateBatchRef.current.push(updater);
        var promise = Promise.resolve();
        lastPromiseRef.current = promise;
        promise.then(function() {
          if (lastPromiseRef.current === promise) {
            var prevBatch = updateBatchRef.current;
            var prevState = stateRef.current;
            updateBatchRef.current = [];
            prevBatch.forEach(function(batchUpdater) {
              stateRef.current = batchUpdater(stateRef.current);
            });
            lastPromiseRef.current = null;
            if (prevState !== stateRef.current) {
              forceUpdate({});
            }
          }
        });
      }
      reactExports.useEffect(function() {
        return function() {
          lastPromiseRef.current = null;
        };
      }, []);
      return [stateRef.current, setFrameState];
    }
    function useTimeoutLock(defaultState) {
      var frameRef = reactExports.useRef(defaultState || null);
      var timeoutRef = reactExports.useRef();
      function cleanUp() {
        window.clearTimeout(timeoutRef.current);
      }
      function setState(newState) {
        frameRef.current = newState;
        cleanUp();
        timeoutRef.current = window.setTimeout(function() {
          frameRef.current = null;
          timeoutRef.current = void 0;
        }, 100);
      }
      function getState() {
        return frameRef.current;
      }
      reactExports.useEffect(function() {
        return cleanUp;
      }, []);
      return [setState, getState];
    }
    function useHover() {
      var _React$useState = reactExports.useState(-1), _React$useState2 = _slicedToArray(_React$useState, 2), startRow = _React$useState2[0], setStartRow = _React$useState2[1];
      var _React$useState3 = reactExports.useState(-1), _React$useState4 = _slicedToArray(_React$useState3, 2), endRow = _React$useState4[0], setEndRow = _React$useState4[1];
      var onHover = reactExports.useCallback(function(start, end) {
        setStartRow(start);
        setEndRow(end);
      }, []);
      return [startRow, endRow, onHover];
    }
    var defaultContainer = canUseDom() ? window : null;
    function useSticky(sticky, prefixCls) {
      var _ref = _typeof(sticky) === "object" ? sticky : {}, _ref$offsetHeader = _ref.offsetHeader, offsetHeader = _ref$offsetHeader === void 0 ? 0 : _ref$offsetHeader, _ref$offsetSummary = _ref.offsetSummary, offsetSummary = _ref$offsetSummary === void 0 ? 0 : _ref$offsetSummary, _ref$offsetScroll = _ref.offsetScroll, offsetScroll = _ref$offsetScroll === void 0 ? 0 : _ref$offsetScroll, _ref$getContainer = _ref.getContainer, getContainer2 = _ref$getContainer === void 0 ? function() {
        return defaultContainer;
      } : _ref$getContainer;
      var container = getContainer2() || defaultContainer;
      return reactExports.useMemo(function() {
        var isSticky = !!sticky;
        return {
          isSticky,
          stickyClassName: isSticky ? "".concat(prefixCls, "-sticky-holder") : "",
          offsetHeader,
          offsetSummary,
          offsetScroll,
          container
        };
      }, [offsetScroll, offsetHeader, offsetSummary, prefixCls, container]);
    }
    function useStickyOffsets(colWidths, columnCount, direction) {
      var stickyOffsets = reactExports.useMemo(function() {
        var leftOffsets = [];
        var rightOffsets = [];
        var left = 0;
        var right = 0;
        for (var start = 0; start < columnCount; start += 1) {
          if (direction === "rtl") {
            rightOffsets[start] = right;
            right += colWidths[start] || 0;
            var end = columnCount - start - 1;
            leftOffsets[end] = left;
            left += colWidths[end] || 0;
          } else {
            leftOffsets[start] = left;
            left += colWidths[start] || 0;
            var _end = columnCount - start - 1;
            rightOffsets[_end] = right;
            right += colWidths[_end] || 0;
          }
        }
        return {
          left: leftOffsets,
          right: rightOffsets
        };
      }, [colWidths, columnCount, direction]);
      return stickyOffsets;
    }
    function Panel(_ref) {
      var className = _ref.className, children = _ref.children;
      return /* @__PURE__ */ reactExports.createElement("div", {
        className
      }, children);
    }
    var StickyScrollBar = function StickyScrollBar2(_ref, ref) {
      var _scrollBodyRef$curren, _scrollBodyRef$curren2;
      var scrollBodyRef = _ref.scrollBodyRef, onScroll = _ref.onScroll, offsetScroll = _ref.offsetScroll, container = _ref.container;
      var prefixCls = useContext(TableContext, "prefixCls");
      var bodyScrollWidth = ((_scrollBodyRef$curren = scrollBodyRef.current) === null || _scrollBodyRef$curren === void 0 ? void 0 : _scrollBodyRef$curren.scrollWidth) || 0;
      var bodyWidth = ((_scrollBodyRef$curren2 = scrollBodyRef.current) === null || _scrollBodyRef$curren2 === void 0 ? void 0 : _scrollBodyRef$curren2.clientWidth) || 0;
      var scrollBarWidth = bodyScrollWidth && bodyWidth * (bodyWidth / bodyScrollWidth);
      var scrollBarRef = reactExports.useRef();
      var _useLayoutState = useLayoutState({
        scrollLeft: 0,
        isHiddenScrollBar: false
      }), _useLayoutState2 = _slicedToArray(_useLayoutState, 2), scrollState = _useLayoutState2[0], setScrollState = _useLayoutState2[1];
      var refState = reactExports.useRef({
        delta: 0,
        x: 0
      });
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), isActive2 = _React$useState2[0], setActive = _React$useState2[1];
      var onMouseUp = function onMouseUp2() {
        setActive(false);
      };
      var onMouseDown = function onMouseDown2(event) {
        event.persist();
        refState.current.delta = event.pageX - scrollState.scrollLeft;
        refState.current.x = 0;
        setActive(true);
        event.preventDefault();
      };
      var onMouseMove = function onMouseMove2(event) {
        var _window;
        var _ref2 = event || ((_window = window) === null || _window === void 0 ? void 0 : _window.event), buttons = _ref2.buttons;
        if (!isActive2 || buttons === 0) {
          if (isActive2) {
            setActive(false);
          }
          return;
        }
        var left = refState.current.x + event.pageX - refState.current.x - refState.current.delta;
        if (left <= 0) {
          left = 0;
        }
        if (left + scrollBarWidth >= bodyWidth) {
          left = bodyWidth - scrollBarWidth;
        }
        onScroll({
          scrollLeft: left / bodyWidth * (bodyScrollWidth + 2)
        });
        refState.current.x = event.pageX;
      };
      var onContainerScroll = function onContainerScroll2() {
        if (!scrollBodyRef.current) {
          return;
        }
        var tableOffsetTop = getOffset(scrollBodyRef.current).top;
        var tableBottomOffset = tableOffsetTop + scrollBodyRef.current.offsetHeight;
        var currentClientOffset = container === window ? document.documentElement.scrollTop + window.innerHeight : getOffset(container).top + container.clientHeight;
        if (tableBottomOffset - getScrollBarSize() <= currentClientOffset || tableOffsetTop >= currentClientOffset - offsetScroll) {
          setScrollState(function(state) {
            return _objectSpread2(_objectSpread2({}, state), {}, {
              isHiddenScrollBar: true
            });
          });
        } else {
          setScrollState(function(state) {
            return _objectSpread2(_objectSpread2({}, state), {}, {
              isHiddenScrollBar: false
            });
          });
        }
      };
      var setScrollLeft = function setScrollLeft2(left) {
        setScrollState(function(state) {
          return _objectSpread2(_objectSpread2({}, state), {}, {
            scrollLeft: left / bodyScrollWidth * bodyWidth || 0
          });
        });
      };
      reactExports.useImperativeHandle(ref, function() {
        return {
          setScrollLeft
        };
      });
      reactExports.useEffect(function() {
        var onMouseUpListener = addEventListenerWrap(document.body, "mouseup", onMouseUp, false);
        var onMouseMoveListener = addEventListenerWrap(document.body, "mousemove", onMouseMove, false);
        onContainerScroll();
        return function() {
          onMouseUpListener.remove();
          onMouseMoveListener.remove();
        };
      }, [scrollBarWidth, isActive2]);
      reactExports.useEffect(function() {
        var onScrollListener = addEventListenerWrap(container, "scroll", onContainerScroll, false);
        var onResizeListener = addEventListenerWrap(window, "resize", onContainerScroll, false);
        return function() {
          onScrollListener.remove();
          onResizeListener.remove();
        };
      }, [container]);
      reactExports.useEffect(function() {
        if (!scrollState.isHiddenScrollBar) {
          setScrollState(function(state) {
            var bodyNode = scrollBodyRef.current;
            if (!bodyNode) {
              return state;
            }
            return _objectSpread2(_objectSpread2({}, state), {}, {
              scrollLeft: bodyNode.scrollLeft / bodyNode.scrollWidth * bodyNode.clientWidth
            });
          });
        }
      }, [scrollState.isHiddenScrollBar]);
      if (bodyScrollWidth <= bodyWidth || !scrollBarWidth || scrollState.isHiddenScrollBar) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        style: {
          height: getScrollBarSize(),
          width: bodyWidth,
          bottom: offsetScroll
        },
        className: "".concat(prefixCls, "-sticky-scroll")
      }, /* @__PURE__ */ reactExports.createElement("div", {
        onMouseDown,
        ref: scrollBarRef,
        className: classNames("".concat(prefixCls, "-sticky-scroll-bar"), _defineProperty({}, "".concat(prefixCls, "-sticky-scroll-bar-active"), isActive2)),
        style: {
          width: "".concat(scrollBarWidth, "px"),
          transform: "translate3d(".concat(scrollState.scrollLeft, "px, 0, 0)")
        }
      }));
    };
    const StickyScrollBar$1 = /* @__PURE__ */ reactExports.forwardRef(StickyScrollBar);
    var DEFAULT_PREFIX = "rc-table";
    var EMPTY_DATA = [];
    var EMPTY_SCROLL_TARGET = {};
    function defaultEmpty() {
      return "No Data";
    }
    function Table$2(tableProps, ref) {
      var _classNames;
      var props = _objectSpread2({
        rowKey: "key",
        prefixCls: DEFAULT_PREFIX,
        emptyText: defaultEmpty
      }, tableProps);
      var prefixCls = props.prefixCls, className = props.className, rowClassName = props.rowClassName, style2 = props.style, data = props.data, rowKey = props.rowKey, scroll = props.scroll, tableLayout = props.tableLayout, direction = props.direction, title = props.title, footer = props.footer, summary = props.summary, caption = props.caption, id2 = props.id, showHeader = props.showHeader, components = props.components, emptyText = props.emptyText, onRow = props.onRow, onHeaderRow = props.onHeaderRow, internalHooks = props.internalHooks, transformColumns = props.transformColumns, internalRefs = props.internalRefs, tailor = props.tailor, getContainerWidth = props.getContainerWidth, sticky = props.sticky;
      var mergedData = data || EMPTY_DATA;
      var hasData = !!mergedData.length;
      var useInternalHooks = internalHooks === INTERNAL_HOOKS;
      var getComponent = reactExports.useCallback(function(path, defaultComponent) {
        return get$3(components, path) || defaultComponent;
      }, [components]);
      var getRowKey = reactExports.useMemo(function() {
        if (typeof rowKey === "function") {
          return rowKey;
        }
        return function(record) {
          var key = record && record[rowKey];
          return key;
        };
      }, [rowKey]);
      var customizeScrollBody = getComponent(["body"]);
      var _useHover = useHover(), _useHover2 = _slicedToArray(_useHover, 3), startRow = _useHover2[0], endRow = _useHover2[1], onHover = _useHover2[2];
      var _useExpand = useExpand(props, mergedData, getRowKey), _useExpand2 = _slicedToArray(_useExpand, 6), expandableConfig = _useExpand2[0], expandableType = _useExpand2[1], mergedExpandedKeys = _useExpand2[2], mergedExpandIcon = _useExpand2[3], mergedChildrenColumnName = _useExpand2[4], onTriggerExpand = _useExpand2[5];
      var scrollX = scroll === null || scroll === void 0 ? void 0 : scroll.x;
      var _React$useState = reactExports.useState(0), _React$useState2 = _slicedToArray(_React$useState, 2), componentWidth = _React$useState2[0], setComponentWidth = _React$useState2[1];
      var _useColumns = useColumns(_objectSpread2(_objectSpread2(_objectSpread2({}, props), expandableConfig), {}, {
        expandable: !!expandableConfig.expandedRowRender,
        columnTitle: expandableConfig.columnTitle,
        expandedKeys: mergedExpandedKeys,
        getRowKey,
        // https://github.com/ant-design/ant-design/issues/23894
        onTriggerExpand,
        expandIcon: mergedExpandIcon,
        expandIconColumnIndex: expandableConfig.expandIconColumnIndex,
        direction,
        scrollWidth: useInternalHooks && tailor && typeof scrollX === "number" ? scrollX : null,
        clientWidth: componentWidth
      }), useInternalHooks ? transformColumns : null), _useColumns2 = _slicedToArray(_useColumns, 3), columns = _useColumns2[0], flattenColumns = _useColumns2[1], flattenScrollX = _useColumns2[2];
      var mergedScrollX = flattenScrollX !== null && flattenScrollX !== void 0 ? flattenScrollX : scrollX;
      var columnContext = reactExports.useMemo(function() {
        return {
          columns,
          flattenColumns
        };
      }, [columns, flattenColumns]);
      var fullTableRef = reactExports.useRef();
      var scrollHeaderRef = reactExports.useRef();
      var scrollBodyRef = reactExports.useRef();
      var scrollBodyContainerRef = reactExports.useRef();
      reactExports.useImperativeHandle(ref, function() {
        return {
          nativeElement: fullTableRef.current,
          scrollTo: function scrollTo2(config) {
            var _scrollBodyRef$curren3;
            if (scrollBodyRef.current instanceof HTMLElement) {
              var index2 = config.index, top = config.top, key = config.key;
              if (top) {
                var _scrollBodyRef$curren;
                (_scrollBodyRef$curren = scrollBodyRef.current) === null || _scrollBodyRef$curren === void 0 || _scrollBodyRef$curren.scrollTo({
                  top
                });
              } else {
                var _scrollBodyRef$curren2;
                var mergedKey = key !== null && key !== void 0 ? key : getRowKey(mergedData[index2]);
                (_scrollBodyRef$curren2 = scrollBodyRef.current.querySelector('[data-row-key="'.concat(mergedKey, '"]'))) === null || _scrollBodyRef$curren2 === void 0 || _scrollBodyRef$curren2.scrollIntoView();
              }
            } else if ((_scrollBodyRef$curren3 = scrollBodyRef.current) !== null && _scrollBodyRef$curren3 !== void 0 && _scrollBodyRef$curren3.scrollTo) {
              scrollBodyRef.current.scrollTo(config);
            }
          }
        };
      });
      var scrollSummaryRef = reactExports.useRef();
      var _React$useState3 = reactExports.useState(false), _React$useState4 = _slicedToArray(_React$useState3, 2), pingedLeft = _React$useState4[0], setPingedLeft = _React$useState4[1];
      var _React$useState5 = reactExports.useState(false), _React$useState6 = _slicedToArray(_React$useState5, 2), pingedRight = _React$useState6[0], setPingedRight = _React$useState6[1];
      var _useLayoutState = useLayoutState(/* @__PURE__ */ new Map()), _useLayoutState2 = _slicedToArray(_useLayoutState, 2), colsWidths = _useLayoutState2[0], updateColsWidths = _useLayoutState2[1];
      var colsKeys = getColumnsKey(flattenColumns);
      var pureColWidths = colsKeys.map(function(columnKey) {
        return colsWidths.get(columnKey);
      });
      var colWidths = reactExports.useMemo(function() {
        return pureColWidths;
      }, [pureColWidths.join("_")]);
      var stickyOffsets = useStickyOffsets(colWidths, flattenColumns.length, direction);
      var fixHeader = scroll && validateValue(scroll.y);
      var horizonScroll = scroll && validateValue(mergedScrollX) || Boolean(expandableConfig.fixed);
      var fixColumn = horizonScroll && flattenColumns.some(function(_ref) {
        var fixed = _ref.fixed;
        return fixed;
      });
      var stickyRef = reactExports.useRef();
      var _useSticky = useSticky(sticky, prefixCls), isSticky = _useSticky.isSticky, offsetHeader = _useSticky.offsetHeader, offsetSummary = _useSticky.offsetSummary, offsetScroll = _useSticky.offsetScroll, stickyClassName = _useSticky.stickyClassName, container = _useSticky.container;
      var summaryNode = reactExports.useMemo(function() {
        return summary === null || summary === void 0 ? void 0 : summary(mergedData);
      }, [summary, mergedData]);
      var fixFooter = (fixHeader || isSticky) && /* @__PURE__ */ reactExports.isValidElement(summaryNode) && summaryNode.type === Summary && summaryNode.props.fixed;
      var scrollXStyle;
      var scrollYStyle;
      var scrollTableStyle;
      if (fixHeader) {
        scrollYStyle = {
          overflowY: "scroll",
          maxHeight: scroll.y
        };
      }
      if (horizonScroll) {
        scrollXStyle = {
          overflowX: "auto"
        };
        if (!fixHeader) {
          scrollYStyle = {
            overflowY: "hidden"
          };
        }
        scrollTableStyle = {
          width: mergedScrollX === true ? "auto" : mergedScrollX,
          minWidth: "100%"
        };
      }
      var onColumnResize = reactExports.useCallback(function(columnKey, width) {
        if (isVisible(fullTableRef.current)) {
          updateColsWidths(function(widths) {
            if (widths.get(columnKey) !== width) {
              var newWidths = new Map(widths);
              newWidths.set(columnKey, width);
              return newWidths;
            }
            return widths;
          });
        }
      }, []);
      var _useTimeoutLock = useTimeoutLock(null), _useTimeoutLock2 = _slicedToArray(_useTimeoutLock, 2), setScrollTarget = _useTimeoutLock2[0], getScrollTarget = _useTimeoutLock2[1];
      function forceScroll(scrollLeft, target) {
        if (!target) {
          return;
        }
        if (typeof target === "function") {
          target(scrollLeft);
        } else if (target.scrollLeft !== scrollLeft) {
          target.scrollLeft = scrollLeft;
          if (target.scrollLeft !== scrollLeft) {
            setTimeout(function() {
              target.scrollLeft = scrollLeft;
            }, 0);
          }
        }
      }
      var onScroll = useEvent(function(_ref2) {
        var currentTarget = _ref2.currentTarget, scrollLeft = _ref2.scrollLeft;
        var isRTL = direction === "rtl";
        var mergedScrollLeft = typeof scrollLeft === "number" ? scrollLeft : currentTarget.scrollLeft;
        var compareTarget = currentTarget || EMPTY_SCROLL_TARGET;
        if (!getScrollTarget() || getScrollTarget() === compareTarget) {
          var _stickyRef$current;
          setScrollTarget(compareTarget);
          forceScroll(mergedScrollLeft, scrollHeaderRef.current);
          forceScroll(mergedScrollLeft, scrollBodyRef.current);
          forceScroll(mergedScrollLeft, scrollSummaryRef.current);
          forceScroll(mergedScrollLeft, (_stickyRef$current = stickyRef.current) === null || _stickyRef$current === void 0 ? void 0 : _stickyRef$current.setScrollLeft);
        }
        var measureTarget = currentTarget || scrollHeaderRef.current;
        if (measureTarget) {
          var scrollWidth = measureTarget.scrollWidth, clientWidth = measureTarget.clientWidth;
          if (scrollWidth === clientWidth) {
            setPingedLeft(false);
            setPingedRight(false);
            return;
          }
          if (isRTL) {
            setPingedLeft(-mergedScrollLeft < scrollWidth - clientWidth);
            setPingedRight(-mergedScrollLeft > 0);
          } else {
            setPingedLeft(mergedScrollLeft > 0);
            setPingedRight(mergedScrollLeft < scrollWidth - clientWidth);
          }
        }
      });
      var triggerOnScroll = function triggerOnScroll2() {
        if (horizonScroll && scrollBodyRef.current) {
          onScroll({
            currentTarget: scrollBodyRef.current
          });
        } else {
          setPingedLeft(false);
          setPingedRight(false);
        }
      };
      var onFullTableResize = function onFullTableResize2(_ref3) {
        var width = _ref3.width;
        var mergedWidth = fullTableRef.current ? fullTableRef.current.offsetWidth : width;
        if (useInternalHooks && getContainerWidth && fullTableRef.current) {
          mergedWidth = getContainerWidth(fullTableRef.current, mergedWidth) || mergedWidth;
        }
        if (mergedWidth !== componentWidth) {
          triggerOnScroll();
          setComponentWidth(mergedWidth);
        }
      };
      var mounted = reactExports.useRef(false);
      reactExports.useEffect(function() {
        if (mounted.current) {
          triggerOnScroll();
        }
      }, [horizonScroll, data, columns.length]);
      reactExports.useEffect(function() {
        mounted.current = true;
      }, []);
      var _React$useState7 = reactExports.useState(0), _React$useState8 = _slicedToArray(_React$useState7, 2), scrollbarSize = _React$useState8[0], setScrollbarSize = _React$useState8[1];
      var _React$useState9 = reactExports.useState(true), _React$useState10 = _slicedToArray(_React$useState9, 2), supportSticky = _React$useState10[0], setSupportSticky = _React$useState10[1];
      reactExports.useEffect(function() {
        if (!tailor || !useInternalHooks) {
          if (scrollBodyRef.current instanceof Element) {
            setScrollbarSize(getTargetScrollBarSize(scrollBodyRef.current).width);
          } else {
            setScrollbarSize(getTargetScrollBarSize(scrollBodyContainerRef.current).width);
          }
        }
        setSupportSticky(isStyleSupport("position", "sticky"));
      }, []);
      reactExports.useEffect(function() {
        if (useInternalHooks && internalRefs) {
          internalRefs.body.current = scrollBodyRef.current;
        }
      });
      var renderFixedHeaderTable = reactExports.useCallback(function(fixedHolderPassProps) {
        return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Header$1, fixedHolderPassProps), fixFooter === "top" && /* @__PURE__ */ reactExports.createElement(Footer$1, fixedHolderPassProps, summaryNode));
      }, [fixFooter, summaryNode]);
      var renderFixedFooterTable = reactExports.useCallback(function(fixedHolderPassProps) {
        return /* @__PURE__ */ reactExports.createElement(Footer$1, fixedHolderPassProps, summaryNode);
      }, [summaryNode]);
      var TableComponent = getComponent(["table"], "table");
      var mergedTableLayout = reactExports.useMemo(function() {
        if (tableLayout) {
          return tableLayout;
        }
        if (fixColumn) {
          return mergedScrollX === "max-content" ? "auto" : "fixed";
        }
        if (fixHeader || isSticky || flattenColumns.some(function(_ref4) {
          var ellipsis = _ref4.ellipsis;
          return ellipsis;
        })) {
          return "fixed";
        }
        return "auto";
      }, [fixHeader, fixColumn, flattenColumns, tableLayout, isSticky]);
      var groupTableNode;
      var headerProps = {
        colWidths,
        columCount: flattenColumns.length,
        stickyOffsets,
        onHeaderRow,
        fixHeader,
        scroll
      };
      var emptyNode = reactExports.useMemo(function() {
        if (hasData) {
          return null;
        }
        if (typeof emptyText === "function") {
          return emptyText();
        }
        return emptyText;
      }, [hasData, emptyText]);
      var bodyTable = /* @__PURE__ */ reactExports.createElement(Body$1, {
        data: mergedData,
        measureColumnWidth: fixHeader || horizonScroll || isSticky
      });
      var bodyColGroup = /* @__PURE__ */ reactExports.createElement(ColGroup, {
        colWidths: flattenColumns.map(function(_ref5) {
          var width = _ref5.width;
          return width;
        }),
        columns: flattenColumns
      });
      var captionElement = caption !== null && caption !== void 0 ? /* @__PURE__ */ reactExports.createElement("caption", {
        className: "".concat(prefixCls, "-caption")
      }, caption) : void 0;
      var dataProps = pickAttrs(props, {
        data: true
      });
      var ariaProps = pickAttrs(props, {
        aria: true
      });
      if (fixHeader || isSticky) {
        var bodyContent;
        if (typeof customizeScrollBody === "function") {
          bodyContent = customizeScrollBody(mergedData, {
            scrollbarSize,
            ref: scrollBodyRef,
            onScroll
          });
          headerProps.colWidths = flattenColumns.map(function(_ref6, index2) {
            var width = _ref6.width;
            var colWidth = index2 === flattenColumns.length - 1 ? width - scrollbarSize : width;
            if (typeof colWidth === "number" && !Number.isNaN(colWidth)) {
              return colWidth;
            }
            return 0;
          });
        } else {
          bodyContent = /* @__PURE__ */ reactExports.createElement("div", {
            style: _objectSpread2(_objectSpread2({}, scrollXStyle), scrollYStyle),
            onScroll,
            ref: scrollBodyRef,
            className: classNames("".concat(prefixCls, "-body"))
          }, /* @__PURE__ */ reactExports.createElement(TableComponent, _extends$1({
            style: _objectSpread2(_objectSpread2({}, scrollTableStyle), {}, {
              tableLayout: mergedTableLayout
            })
          }, ariaProps), captionElement, bodyColGroup, bodyTable, !fixFooter && summaryNode && /* @__PURE__ */ reactExports.createElement(Footer$1, {
            stickyOffsets,
            flattenColumns,
            columns
          }, summaryNode)));
        }
        var fixedHolderProps = _objectSpread2(_objectSpread2(_objectSpread2({
          noData: !mergedData.length,
          maxContentScroll: horizonScroll && mergedScrollX === "max-content"
        }, headerProps), columnContext), {}, {
          direction,
          stickyClassName,
          onScroll
        });
        groupTableNode = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, showHeader !== false && /* @__PURE__ */ reactExports.createElement(FixedHolder$1, _extends$1({}, fixedHolderProps, {
          stickyTopOffset: offsetHeader,
          className: "".concat(prefixCls, "-header"),
          ref: scrollHeaderRef
        }), renderFixedHeaderTable), bodyContent, fixFooter && fixFooter !== "top" && /* @__PURE__ */ reactExports.createElement(FixedHolder$1, _extends$1({}, fixedHolderProps, {
          stickyBottomOffset: offsetSummary,
          className: "".concat(prefixCls, "-summary"),
          ref: scrollSummaryRef
        }), renderFixedFooterTable), isSticky && scrollBodyRef.current && scrollBodyRef.current instanceof Element && /* @__PURE__ */ reactExports.createElement(StickyScrollBar$1, {
          ref: stickyRef,
          offsetScroll,
          scrollBodyRef,
          onScroll,
          container
        }));
      } else {
        groupTableNode = /* @__PURE__ */ reactExports.createElement("div", {
          style: _objectSpread2(_objectSpread2({}, scrollXStyle), scrollYStyle),
          className: classNames("".concat(prefixCls, "-content")),
          onScroll,
          ref: scrollBodyRef
        }, /* @__PURE__ */ reactExports.createElement(TableComponent, _extends$1({
          style: _objectSpread2(_objectSpread2({}, scrollTableStyle), {}, {
            tableLayout: mergedTableLayout
          })
        }, ariaProps), captionElement, bodyColGroup, showHeader !== false && /* @__PURE__ */ reactExports.createElement(Header$1, _extends$1({}, headerProps, columnContext)), bodyTable, summaryNode && /* @__PURE__ */ reactExports.createElement(Footer$1, {
          stickyOffsets,
          flattenColumns,
          columns
        }, summaryNode)));
      }
      var fullTable = /* @__PURE__ */ reactExports.createElement("div", _extends$1({
        className: classNames(prefixCls, className, (_classNames = {}, _defineProperty(_classNames, "".concat(prefixCls, "-rtl"), direction === "rtl"), _defineProperty(_classNames, "".concat(prefixCls, "-ping-left"), pingedLeft), _defineProperty(_classNames, "".concat(prefixCls, "-ping-right"), pingedRight), _defineProperty(_classNames, "".concat(prefixCls, "-layout-fixed"), tableLayout === "fixed"), _defineProperty(_classNames, "".concat(prefixCls, "-fixed-header"), fixHeader), _defineProperty(_classNames, "".concat(prefixCls, "-fixed-column"), fixColumn), _defineProperty(_classNames, "".concat(prefixCls, "-scroll-horizontal"), horizonScroll), _defineProperty(_classNames, "".concat(prefixCls, "-has-fix-left"), flattenColumns[0] && flattenColumns[0].fixed), _defineProperty(_classNames, "".concat(prefixCls, "-has-fix-right"), flattenColumns[flattenColumns.length - 1] && flattenColumns[flattenColumns.length - 1].fixed === "right"), _classNames)),
        style: style2,
        id: id2,
        ref: fullTableRef
      }, dataProps), title && /* @__PURE__ */ reactExports.createElement(Panel, {
        className: "".concat(prefixCls, "-title")
      }, title(mergedData)), /* @__PURE__ */ reactExports.createElement("div", {
        ref: scrollBodyContainerRef,
        className: "".concat(prefixCls, "-container")
      }, groupTableNode), footer && /* @__PURE__ */ reactExports.createElement(Panel, {
        className: "".concat(prefixCls, "-footer")
      }, footer(mergedData)));
      if (horizonScroll) {
        fullTable = /* @__PURE__ */ reactExports.createElement(RefResizeObserver, {
          onResize: onFullTableResize
        }, fullTable);
      }
      var fixedInfoList = useFixedInfo(flattenColumns, stickyOffsets, direction, columns);
      var TableContextValue = reactExports.useMemo(function() {
        return {
          // Scroll
          scrollX: mergedScrollX,
          // Table
          prefixCls,
          getComponent,
          scrollbarSize,
          direction,
          fixedInfoList,
          isSticky,
          supportSticky,
          componentWidth,
          fixHeader,
          fixColumn,
          horizonScroll,
          // Body
          tableLayout: mergedTableLayout,
          rowClassName,
          expandedRowClassName: expandableConfig.expandedRowClassName,
          expandIcon: mergedExpandIcon,
          expandableType,
          expandRowByClick: expandableConfig.expandRowByClick,
          expandedRowRender: expandableConfig.expandedRowRender,
          onTriggerExpand,
          expandIconColumnIndex: expandableConfig.expandIconColumnIndex,
          indentSize: expandableConfig.indentSize,
          allColumnsFixedLeft: flattenColumns.every(function(col) {
            return col.fixed === "left";
          }),
          emptyNode,
          // Column
          columns,
          flattenColumns,
          onColumnResize,
          // Row
          hoverStartRow: startRow,
          hoverEndRow: endRow,
          onHover,
          rowExpandable: expandableConfig.rowExpandable,
          onRow,
          getRowKey,
          expandedKeys: mergedExpandedKeys,
          childrenColumnName: mergedChildrenColumnName
        };
      }, [
        // Scroll
        mergedScrollX,
        // Table
        prefixCls,
        getComponent,
        scrollbarSize,
        direction,
        fixedInfoList,
        isSticky,
        supportSticky,
        componentWidth,
        fixHeader,
        fixColumn,
        horizonScroll,
        // Body
        mergedTableLayout,
        rowClassName,
        expandableConfig.expandedRowClassName,
        mergedExpandIcon,
        expandableType,
        expandableConfig.expandRowByClick,
        expandableConfig.expandedRowRender,
        onTriggerExpand,
        expandableConfig.expandIconColumnIndex,
        expandableConfig.indentSize,
        emptyNode,
        // Column
        columns,
        flattenColumns,
        onColumnResize,
        // Row
        startRow,
        endRow,
        onHover,
        expandableConfig.rowExpandable,
        onRow,
        getRowKey,
        mergedExpandedKeys,
        mergedChildrenColumnName
      ]);
      return /* @__PURE__ */ reactExports.createElement(TableContext.Provider, {
        value: TableContextValue
      }, fullTable);
    }
    var RefTable = /* @__PURE__ */ reactExports.forwardRef(Table$2);
    function genTable(shouldTriggerRender) {
      return makeImmutable(RefTable, shouldTriggerRender);
    }
    var ImmutableTable = genTable();
    ImmutableTable.EXPAND_COLUMN = EXPAND_COLUMN;
    ImmutableTable.INTERNAL_HOOKS = INTERNAL_HOOKS;
    ImmutableTable.Column = Column$1;
    ImmutableTable.ColumnGroup = ColumnGroup$1;
    ImmutableTable.Summary = FooterComponents;
    var StaticContext = createContext(null);
    var GridContext = createContext(null);
    function getColumnWidth(colIndex, colSpan, columnsOffset) {
      var mergedColSpan = colSpan || 1;
      return columnsOffset[colIndex + mergedColSpan] - (columnsOffset[colIndex] || 0);
    }
    function VirtualCell(props) {
      var rowInfo = props.rowInfo, column2 = props.column, colIndex = props.colIndex, indent = props.indent, index2 = props.index, renderIndex = props.renderIndex, record = props.record, style2 = props.style, className = props.className, inverse = props.inverse, getHeight = props.getHeight;
      var render2 = column2.render, dataIndex = column2.dataIndex, columnClassName = column2.className, colWidth = column2.width;
      var _useContext = useContext(GridContext, ["columnsOffset"]), columnsOffset = _useContext.columnsOffset;
      var _getCellProps = getCellProps(rowInfo, column2, colIndex, indent, index2), key = _getCellProps.key, fixedInfo = _getCellProps.fixedInfo, appendCellNode = _getCellProps.appendCellNode, additionalCellProps = _getCellProps.additionalCellProps;
      var cellStyle = additionalCellProps.style, _additionalCellProps$ = additionalCellProps.colSpan, colSpan = _additionalCellProps$ === void 0 ? 1 : _additionalCellProps$, _additionalCellProps$2 = additionalCellProps.rowSpan, rowSpan = _additionalCellProps$2 === void 0 ? 1 : _additionalCellProps$2;
      var startColIndex = colIndex - 1;
      var concatColWidth = getColumnWidth(startColIndex, colSpan, columnsOffset);
      var marginOffset = colSpan > 1 ? colWidth - concatColWidth : 0;
      var mergedStyle = _objectSpread2(_objectSpread2(_objectSpread2({}, cellStyle), style2), {}, {
        flex: "0 0 ".concat(concatColWidth, "px"),
        width: "".concat(concatColWidth, "px"),
        marginRight: marginOffset,
        pointerEvents: "auto"
      });
      var needHide = reactExports.useMemo(function() {
        if (inverse) {
          return rowSpan <= 1;
        } else {
          return colSpan === 0 || rowSpan === 0 || rowSpan > 1;
        }
      }, [rowSpan, colSpan, inverse]);
      if (needHide) {
        mergedStyle.visibility = "hidden";
      } else if (inverse) {
        mergedStyle.height = getHeight === null || getHeight === void 0 ? void 0 : getHeight(rowSpan);
      }
      var mergedRender = needHide ? function() {
        return null;
      } : render2;
      var cellSpan = {};
      if (rowSpan === 0 || colSpan === 0) {
        cellSpan.rowSpan = 1;
        cellSpan.colSpan = 1;
      }
      return /* @__PURE__ */ reactExports.createElement(Cell$1, _extends$1({
        className: classNames(columnClassName, className),
        ellipsis: column2.ellipsis,
        align: column2.align,
        scope: column2.rowScope,
        component: "div",
        prefixCls: rowInfo.prefixCls,
        key,
        record,
        index: index2,
        renderIndex,
        dataIndex,
        render: mergedRender,
        shouldCellUpdate: column2.shouldCellUpdate
      }, fixedInfo, {
        appendNode: appendCellNode,
        additionalProps: _objectSpread2(_objectSpread2({}, additionalCellProps), {}, {
          style: mergedStyle
        }, cellSpan)
      }));
    }
    var _excluded$4 = ["data", "index", "className", "rowKey", "style", "extra", "getHeight"];
    var BodyLine = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var data = props.data, index2 = props.index, className = props.className, rowKey = props.rowKey, style2 = props.style, extra = props.extra, getHeight = props.getHeight, restProps = _objectWithoutProperties(props, _excluded$4);
      var record = data.record, indent = data.indent, renderIndex = data.index;
      var _useContext = useContext(TableContext, ["prefixCls", "flattenColumns", "fixColumn", "componentWidth", "scrollX"]), scrollX = _useContext.scrollX, flattenColumns = _useContext.flattenColumns, prefixCls = _useContext.prefixCls, fixColumn = _useContext.fixColumn, componentWidth = _useContext.componentWidth;
      var rowInfo = useRowInfo(record, rowKey, index2, indent);
      var rowSupportExpand = rowInfo.rowSupportExpand, expanded = rowInfo.expanded, rowProps = rowInfo.rowProps, expandedRowRender = rowInfo.expandedRowRender, expandedRowClassName = rowInfo.expandedRowClassName;
      var expandRowNode;
      if (rowSupportExpand && expanded) {
        var expandContent = expandedRowRender(record, index2, indent + 1, expanded);
        var computedExpandedRowClassName = expandedRowClassName === null || expandedRowClassName === void 0 ? void 0 : expandedRowClassName(record, index2, indent);
        var additionalProps = {};
        if (fixColumn) {
          additionalProps = {
            style: _defineProperty({}, "--virtual-width", "".concat(componentWidth, "px"))
          };
        }
        var rowCellCls = "".concat(prefixCls, "-expanded-row-cell");
        expandRowNode = /* @__PURE__ */ reactExports.createElement("div", {
          className: classNames("".concat(prefixCls, "-expanded-row"), "".concat(prefixCls, "-expanded-row-level-").concat(indent + 1), computedExpandedRowClassName)
        }, /* @__PURE__ */ reactExports.createElement(Cell$1, {
          component: "div",
          prefixCls,
          className: classNames(rowCellCls, _defineProperty({}, "".concat(rowCellCls, "-fixed"), fixColumn)),
          additionalProps
        }, expandContent));
      }
      var rowStyle = _objectSpread2(_objectSpread2({}, style2), {}, {
        width: scrollX
      });
      if (extra) {
        rowStyle.position = "absolute";
        rowStyle.pointerEvents = "none";
      }
      var rowNode = /* @__PURE__ */ reactExports.createElement("div", _extends$1({}, rowProps, restProps, {
        ref: rowSupportExpand ? null : ref,
        className: classNames(className, "".concat(prefixCls, "-row"), rowProps === null || rowProps === void 0 ? void 0 : rowProps.className, _defineProperty({}, "".concat(prefixCls, "-row-extra"), extra)),
        style: _objectSpread2(_objectSpread2({}, rowStyle), rowProps === null || rowProps === void 0 ? void 0 : rowProps.style)
      }), flattenColumns.map(function(column2, colIndex) {
        return /* @__PURE__ */ reactExports.createElement(VirtualCell, {
          key: colIndex,
          rowInfo,
          column: column2,
          colIndex,
          indent,
          index: index2,
          renderIndex,
          record,
          inverse: extra,
          getHeight
        });
      }));
      if (rowSupportExpand) {
        return /* @__PURE__ */ reactExports.createElement("div", {
          ref
        }, rowNode, expandRowNode);
      }
      return rowNode;
    });
    var ResponseBodyLine = responseImmutable(BodyLine);
    var Grid = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var data = props.data, onScroll = props.onScroll;
      var _useContext = useContext(TableContext, ["flattenColumns", "onColumnResize", "getRowKey", "prefixCls", "expandedKeys", "childrenColumnName", "emptyNode", "scrollX"]), flattenColumns = _useContext.flattenColumns, onColumnResize = _useContext.onColumnResize, getRowKey = _useContext.getRowKey, expandedKeys = _useContext.expandedKeys, prefixCls = _useContext.prefixCls, childrenColumnName = _useContext.childrenColumnName, emptyNode = _useContext.emptyNode, scrollX = _useContext.scrollX;
      var _useContext2 = useContext(StaticContext), sticky = _useContext2.sticky, scrollY = _useContext2.scrollY, listItemHeight = _useContext2.listItemHeight;
      var listRef = reactExports.useRef();
      var flattenData2 = useFlattenRecords(data, childrenColumnName, expandedKeys, getRowKey);
      var columnsWidth = reactExports.useMemo(function() {
        var total = 0;
        return flattenColumns.map(function(_ref) {
          var width = _ref.width, key = _ref.key;
          total += width;
          return [key, width, total];
        });
      }, [flattenColumns]);
      var columnsOffset = reactExports.useMemo(function() {
        return columnsWidth.map(function(colWidth) {
          return colWidth[2];
        });
      }, [columnsWidth]);
      reactExports.useEffect(function() {
        columnsWidth.forEach(function(_ref2) {
          var _ref3 = _slicedToArray(_ref2, 2), key = _ref3[0], width = _ref3[1];
          onColumnResize(key, width);
        });
      }, [columnsWidth]);
      reactExports.useImperativeHandle(ref, function() {
        var obj = {
          scrollTo: function scrollTo2(config) {
            var _listRef$current;
            (_listRef$current = listRef.current) === null || _listRef$current === void 0 || _listRef$current.scrollTo(config);
          }
        };
        Object.defineProperty(obj, "scrollLeft", {
          get: function get2() {
            var _listRef$current2;
            return ((_listRef$current2 = listRef.current) === null || _listRef$current2 === void 0 ? void 0 : _listRef$current2.getScrollInfo().x) || 0;
          },
          set: function set2(value) {
            var _listRef$current3;
            (_listRef$current3 = listRef.current) === null || _listRef$current3 === void 0 || _listRef$current3.scrollTo({
              left: value
            });
          }
        });
        return obj;
      });
      var getRowSpan = function getRowSpan2(column2, index2) {
        var _flattenData$index;
        var record = (_flattenData$index = flattenData2[index2]) === null || _flattenData$index === void 0 ? void 0 : _flattenData$index.record;
        var onCell = column2.onCell;
        if (onCell) {
          var _cellProps$rowSpan;
          var cellProps = onCell(record, index2);
          return (_cellProps$rowSpan = cellProps === null || cellProps === void 0 ? void 0 : cellProps.rowSpan) !== null && _cellProps$rowSpan !== void 0 ? _cellProps$rowSpan : 1;
        }
        return 1;
      };
      var extraRender = function extraRender2(info) {
        var start = info.start, end = info.end, getSize2 = info.getSize, offsetY = info.offsetY;
        if (end < 0) {
          return null;
        }
        var firstRowSpanColumns = flattenColumns.filter(
          // rowSpan is 0
          function(column2) {
            return getRowSpan(column2, start) === 0;
          }
        );
        var startIndex = start;
        var _loop = function _loop4(i2) {
          firstRowSpanColumns = firstRowSpanColumns.filter(function(column2) {
            return getRowSpan(column2, i2) === 0;
          });
          if (!firstRowSpanColumns.length) {
            startIndex = i2;
            return 1;
          }
        };
        for (var i = start; i >= 0; i -= 1) {
          if (_loop(i))
            break;
        }
        var lastRowSpanColumns = flattenColumns.filter(
          // rowSpan is not 1
          function(column2) {
            return getRowSpan(column2, end) !== 1;
          }
        );
        var endIndex = end;
        var _loop2 = function _loop22(_i3) {
          lastRowSpanColumns = lastRowSpanColumns.filter(function(column2) {
            return getRowSpan(column2, _i3) !== 1;
          });
          if (!lastRowSpanColumns.length) {
            endIndex = Math.max(_i3 - 1, end);
            return 1;
          }
        };
        for (var _i = end; _i < flattenData2.length; _i += 1) {
          if (_loop2(_i))
            break;
        }
        var spanLines = [];
        var _loop3 = function _loop32(_i22) {
          var item = flattenData2[_i22];
          if (!item) {
            return 1;
          }
          if (flattenColumns.some(function(column2) {
            return getRowSpan(column2, _i22) > 1;
          })) {
            spanLines.push(_i22);
          }
        };
        for (var _i2 = startIndex; _i2 <= endIndex; _i2 += 1) {
          if (_loop3(_i2))
            continue;
        }
        var nodes = spanLines.map(function(index2) {
          var item = flattenData2[index2];
          var rowKey = getRowKey(item.record, index2);
          var getHeight = function getHeight2(rowSpan) {
            var endItemIndex = index2 + rowSpan - 1;
            var endItemKey = getRowKey(flattenData2[endItemIndex].record, endItemIndex);
            var sizeInfo2 = getSize2(rowKey, endItemKey);
            return sizeInfo2.bottom - sizeInfo2.top;
          };
          var sizeInfo = getSize2(rowKey);
          return /* @__PURE__ */ reactExports.createElement(ResponseBodyLine, {
            key: index2,
            data: item,
            rowKey,
            index: index2,
            style: {
              top: -offsetY + sizeInfo.top
            },
            extra: true,
            getHeight
          });
        });
        return nodes;
      };
      var gridContext = reactExports.useMemo(function() {
        return {
          columnsOffset
        };
      }, [columnsOffset]);
      var tblPrefixCls = "".concat(prefixCls, "-tbody");
      var bodyContent;
      if (flattenData2.length) {
        var horizontalScrollBarStyle = {};
        if (sticky) {
          horizontalScrollBarStyle.position = "sticky";
          horizontalScrollBarStyle.bottom = 0;
          if (_typeof(sticky) === "object" && sticky.offsetScroll) {
            horizontalScrollBarStyle.bottom = sticky.offsetScroll;
          }
        }
        bodyContent = /* @__PURE__ */ reactExports.createElement(List$1, {
          fullHeight: false,
          ref: listRef,
          styles: {
            horizontalScrollBar: horizontalScrollBarStyle
          },
          className: classNames(tblPrefixCls, "".concat(tblPrefixCls, "-virtual")),
          height: scrollY,
          itemHeight: listItemHeight || 24,
          data: flattenData2,
          itemKey: function itemKey2(item) {
            return getRowKey(item.record);
          },
          scrollWidth: scrollX,
          onVirtualScroll: function onVirtualScroll(_ref4) {
            var x2 = _ref4.x;
            onScroll({
              scrollLeft: x2
            });
          },
          extraRender
        }, function(item, index2, itemProps) {
          var rowKey = getRowKey(item.record, index2);
          return /* @__PURE__ */ reactExports.createElement(ResponseBodyLine, _extends$1({
            data: item,
            rowKey,
            index: index2
          }, itemProps));
        });
      } else {
        bodyContent = /* @__PURE__ */ reactExports.createElement("div", {
          className: classNames("".concat(prefixCls, "-placeholder"))
        }, /* @__PURE__ */ reactExports.createElement(Cell$1, {
          component: "div",
          prefixCls
        }, emptyNode));
      }
      return /* @__PURE__ */ reactExports.createElement(GridContext.Provider, {
        value: gridContext
      }, bodyContent);
    });
    var ResponseGrid = responseImmutable(Grid);
    var renderBody = function renderBody2(rawData, props) {
      var ref = props.ref, onScroll = props.onScroll;
      return /* @__PURE__ */ reactExports.createElement(ResponseGrid, {
        ref,
        data: rawData,
        onScroll
      });
    };
    function VirtualTable(props, ref) {
      var columns = props.columns, scroll = props.scroll, sticky = props.sticky, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? DEFAULT_PREFIX : _props$prefixCls, className = props.className, listItemHeight = props.listItemHeight, components = props.components;
      var _ref = scroll || {}, scrollX = _ref.x, scrollY = _ref.y;
      if (typeof scrollX !== "number") {
        scrollX = 1;
      }
      if (typeof scrollY !== "number") {
        scrollY = 500;
      }
      var context = reactExports.useMemo(function() {
        return {
          sticky,
          scrollY,
          listItemHeight
        };
      }, [sticky, scrollY, listItemHeight]);
      return /* @__PURE__ */ reactExports.createElement(StaticContext.Provider, {
        value: context
      }, /* @__PURE__ */ reactExports.createElement(ImmutableTable, _extends$1({}, props, {
        className: classNames(className, "".concat(prefixCls, "-virtual")),
        scroll: _objectSpread2(_objectSpread2({}, scroll), {}, {
          x: scrollX
        }),
        components: _objectSpread2(_objectSpread2({}, components), {}, {
          body: renderBody
        }),
        columns,
        internalHooks: INTERNAL_HOOKS,
        tailor: true,
        ref
      })));
    }
    var RefVirtualTable = /* @__PURE__ */ reactExports.forwardRef(VirtualTable);
    function genVirtualTable(shouldTriggerRender) {
      return makeImmutable(RefVirtualTable, shouldTriggerRender);
    }
    genVirtualTable();
    function Column(_) {
      return null;
    }
    function ColumnGroup(_) {
      return null;
    }
    var TreeContext = /* @__PURE__ */ reactExports.createContext(null);
    var Indent = function Indent2(_ref) {
      var prefixCls = _ref.prefixCls, level = _ref.level, isStart = _ref.isStart, isEnd = _ref.isEnd;
      var baseClassName = "".concat(prefixCls, "-indent-unit");
      var list = [];
      for (var i = 0; i < level; i += 1) {
        var _classNames;
        list.push(/* @__PURE__ */ reactExports.createElement("span", {
          key: i,
          className: classNames(baseClassName, (_classNames = {}, _defineProperty(_classNames, "".concat(baseClassName, "-start"), isStart[i]), _defineProperty(_classNames, "".concat(baseClassName, "-end"), isEnd[i]), _classNames))
        }));
      }
      return /* @__PURE__ */ reactExports.createElement("span", {
        "aria-hidden": "true",
        className: "".concat(prefixCls, "-indent")
      }, list);
    };
    const Indent$1 = /* @__PURE__ */ reactExports.memo(Indent);
    var _excluded$3 = ["eventKey", "className", "style", "dragOver", "dragOverGapTop", "dragOverGapBottom", "isLeaf", "isStart", "isEnd", "expanded", "selected", "checked", "halfChecked", "loading", "domRef", "active", "data", "onMouseMove", "selectable"];
    var ICON_OPEN = "open";
    var ICON_CLOSE = "close";
    var defaultTitle = "---";
    var InternalTreeNode = /* @__PURE__ */ function(_React$Component) {
      _inherits(InternalTreeNode2, _React$Component);
      var _super = _createSuper(InternalTreeNode2);
      function InternalTreeNode2() {
        var _this;
        _classCallCheck(this, InternalTreeNode2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _this.state = {
          dragNodeHighlight: false
        };
        _this.selectHandle = void 0;
        _this.cacheIndent = void 0;
        _this.onSelectorClick = function(e2) {
          var onNodeClick = _this.props.context.onNodeClick;
          onNodeClick(e2, convertNodePropsToEventData(_this.props));
          if (_this.isSelectable()) {
            _this.onSelect(e2);
          } else {
            _this.onCheck(e2);
          }
        };
        _this.onSelectorDoubleClick = function(e2) {
          var onNodeDoubleClick = _this.props.context.onNodeDoubleClick;
          onNodeDoubleClick(e2, convertNodePropsToEventData(_this.props));
        };
        _this.onSelect = function(e2) {
          if (_this.isDisabled())
            return;
          var onNodeSelect = _this.props.context.onNodeSelect;
          onNodeSelect(e2, convertNodePropsToEventData(_this.props));
        };
        _this.onCheck = function(e2) {
          if (_this.isDisabled())
            return;
          var _this$props = _this.props, disableCheckbox = _this$props.disableCheckbox, checked = _this$props.checked;
          var onNodeCheck = _this.props.context.onNodeCheck;
          if (!_this.isCheckable() || disableCheckbox)
            return;
          var targetChecked = !checked;
          onNodeCheck(e2, convertNodePropsToEventData(_this.props), targetChecked);
        };
        _this.onMouseEnter = function(e2) {
          var onNodeMouseEnter = _this.props.context.onNodeMouseEnter;
          onNodeMouseEnter(e2, convertNodePropsToEventData(_this.props));
        };
        _this.onMouseLeave = function(e2) {
          var onNodeMouseLeave = _this.props.context.onNodeMouseLeave;
          onNodeMouseLeave(e2, convertNodePropsToEventData(_this.props));
        };
        _this.onContextMenu = function(e2) {
          var onNodeContextMenu = _this.props.context.onNodeContextMenu;
          onNodeContextMenu(e2, convertNodePropsToEventData(_this.props));
        };
        _this.onDragStart = function(e2) {
          var onNodeDragStart = _this.props.context.onNodeDragStart;
          e2.stopPropagation();
          _this.setState({
            dragNodeHighlight: true
          });
          onNodeDragStart(e2, _assertThisInitialized(_this));
          try {
            e2.dataTransfer.setData("text/plain", "");
          } catch (error) {
          }
        };
        _this.onDragEnter = function(e2) {
          var onNodeDragEnter = _this.props.context.onNodeDragEnter;
          e2.preventDefault();
          e2.stopPropagation();
          onNodeDragEnter(e2, _assertThisInitialized(_this));
        };
        _this.onDragOver = function(e2) {
          var onNodeDragOver = _this.props.context.onNodeDragOver;
          e2.preventDefault();
          e2.stopPropagation();
          onNodeDragOver(e2, _assertThisInitialized(_this));
        };
        _this.onDragLeave = function(e2) {
          var onNodeDragLeave = _this.props.context.onNodeDragLeave;
          e2.stopPropagation();
          onNodeDragLeave(e2, _assertThisInitialized(_this));
        };
        _this.onDragEnd = function(e2) {
          var onNodeDragEnd = _this.props.context.onNodeDragEnd;
          e2.stopPropagation();
          _this.setState({
            dragNodeHighlight: false
          });
          onNodeDragEnd(e2, _assertThisInitialized(_this));
        };
        _this.onDrop = function(e2) {
          var onNodeDrop = _this.props.context.onNodeDrop;
          e2.preventDefault();
          e2.stopPropagation();
          _this.setState({
            dragNodeHighlight: false
          });
          onNodeDrop(e2, _assertThisInitialized(_this));
        };
        _this.onExpand = function(e2) {
          var _this$props2 = _this.props, loading = _this$props2.loading, onNodeExpand = _this$props2.context.onNodeExpand;
          if (loading)
            return;
          onNodeExpand(e2, convertNodePropsToEventData(_this.props));
        };
        _this.setSelectHandle = function(node2) {
          _this.selectHandle = node2;
        };
        _this.getNodeState = function() {
          var expanded = _this.props.expanded;
          if (_this.isLeaf()) {
            return null;
          }
          return expanded ? ICON_OPEN : ICON_CLOSE;
        };
        _this.hasChildren = function() {
          var eventKey = _this.props.eventKey;
          var keyEntities = _this.props.context.keyEntities;
          var _ref = getEntity(keyEntities, eventKey) || {}, children = _ref.children;
          return !!(children || []).length;
        };
        _this.isLeaf = function() {
          var _this$props3 = _this.props, isLeaf = _this$props3.isLeaf, loaded = _this$props3.loaded;
          var loadData = _this.props.context.loadData;
          var hasChildren = _this.hasChildren();
          if (isLeaf === false) {
            return false;
          }
          return isLeaf || !loadData && !hasChildren || loadData && loaded && !hasChildren;
        };
        _this.isDisabled = function() {
          var disabled = _this.props.disabled;
          var treeDisabled = _this.props.context.disabled;
          return !!(treeDisabled || disabled);
        };
        _this.isCheckable = function() {
          var checkable = _this.props.checkable;
          var treeCheckable = _this.props.context.checkable;
          if (!treeCheckable || checkable === false)
            return false;
          return treeCheckable;
        };
        _this.syncLoadData = function(props) {
          var expanded = props.expanded, loading = props.loading, loaded = props.loaded;
          var _this$props$context = _this.props.context, loadData = _this$props$context.loadData, onNodeLoad = _this$props$context.onNodeLoad;
          if (loading) {
            return;
          }
          if (loadData && expanded && !_this.isLeaf()) {
            if (!_this.hasChildren() && !loaded) {
              onNodeLoad(convertNodePropsToEventData(_this.props));
            }
          }
        };
        _this.isDraggable = function() {
          var _this$props4 = _this.props, data = _this$props4.data, draggable = _this$props4.context.draggable;
          return !!(draggable && (!draggable.nodeDraggable || draggable.nodeDraggable(data)));
        };
        _this.renderDragHandler = function() {
          var _this$props$context2 = _this.props.context, draggable = _this$props$context2.draggable, prefixCls = _this$props$context2.prefixCls;
          return (draggable === null || draggable === void 0 ? void 0 : draggable.icon) ? /* @__PURE__ */ reactExports.createElement("span", {
            className: "".concat(prefixCls, "-draggable-icon")
          }, draggable.icon) : null;
        };
        _this.renderSwitcherIconDom = function(isLeaf) {
          var switcherIconFromProps = _this.props.switcherIcon;
          var switcherIconFromCtx = _this.props.context.switcherIcon;
          var switcherIcon = switcherIconFromProps || switcherIconFromCtx;
          if (typeof switcherIcon === "function") {
            return switcherIcon(_objectSpread2(_objectSpread2({}, _this.props), {}, {
              isLeaf
            }));
          }
          return switcherIcon;
        };
        _this.renderSwitcher = function() {
          var expanded = _this.props.expanded;
          var prefixCls = _this.props.context.prefixCls;
          if (_this.isLeaf()) {
            var _switcherIconDom = _this.renderSwitcherIconDom(true);
            return _switcherIconDom !== false ? /* @__PURE__ */ reactExports.createElement("span", {
              className: classNames("".concat(prefixCls, "-switcher"), "".concat(prefixCls, "-switcher-noop"))
            }, _switcherIconDom) : null;
          }
          var switcherCls = classNames("".concat(prefixCls, "-switcher"), "".concat(prefixCls, "-switcher_").concat(expanded ? ICON_OPEN : ICON_CLOSE));
          var switcherIconDom = _this.renderSwitcherIconDom(false);
          return switcherIconDom !== false ? /* @__PURE__ */ reactExports.createElement("span", {
            onClick: _this.onExpand,
            className: switcherCls
          }, switcherIconDom) : null;
        };
        _this.renderCheckbox = function() {
          var _this$props5 = _this.props, checked = _this$props5.checked, halfChecked = _this$props5.halfChecked, disableCheckbox = _this$props5.disableCheckbox;
          var prefixCls = _this.props.context.prefixCls;
          var disabled = _this.isDisabled();
          var checkable = _this.isCheckable();
          if (!checkable)
            return null;
          var $custom = typeof checkable !== "boolean" ? checkable : null;
          return /* @__PURE__ */ reactExports.createElement("span", {
            className: classNames("".concat(prefixCls, "-checkbox"), checked && "".concat(prefixCls, "-checkbox-checked"), !checked && halfChecked && "".concat(prefixCls, "-checkbox-indeterminate"), (disabled || disableCheckbox) && "".concat(prefixCls, "-checkbox-disabled")),
            onClick: _this.onCheck
          }, $custom);
        };
        _this.renderIcon = function() {
          var loading = _this.props.loading;
          var prefixCls = _this.props.context.prefixCls;
          return /* @__PURE__ */ reactExports.createElement("span", {
            className: classNames("".concat(prefixCls, "-iconEle"), "".concat(prefixCls, "-icon__").concat(_this.getNodeState() || "docu"), loading && "".concat(prefixCls, "-icon_loading"))
          });
        };
        _this.renderSelector = function() {
          var dragNodeHighlight = _this.state.dragNodeHighlight;
          var _this$props6 = _this.props, _this$props6$title = _this$props6.title, title = _this$props6$title === void 0 ? defaultTitle : _this$props6$title, selected = _this$props6.selected, icon = _this$props6.icon, loading = _this$props6.loading, data = _this$props6.data;
          var _this$props$context3 = _this.props.context, prefixCls = _this$props$context3.prefixCls, showIcon = _this$props$context3.showIcon, treeIcon = _this$props$context3.icon, loadData = _this$props$context3.loadData, titleRender = _this$props$context3.titleRender;
          var disabled = _this.isDisabled();
          var wrapClass = "".concat(prefixCls, "-node-content-wrapper");
          var $icon;
          if (showIcon) {
            var currentIcon = icon || treeIcon;
            $icon = currentIcon ? /* @__PURE__ */ reactExports.createElement("span", {
              className: classNames("".concat(prefixCls, "-iconEle"), "".concat(prefixCls, "-icon__customize"))
            }, typeof currentIcon === "function" ? currentIcon(_this.props) : currentIcon) : _this.renderIcon();
          } else if (loadData && loading) {
            $icon = _this.renderIcon();
          }
          var titleNode;
          if (typeof title === "function") {
            titleNode = title(data);
          } else if (titleRender) {
            titleNode = titleRender(data);
          } else {
            titleNode = title;
          }
          var $title = /* @__PURE__ */ reactExports.createElement("span", {
            className: "".concat(prefixCls, "-title")
          }, titleNode);
          return /* @__PURE__ */ reactExports.createElement("span", {
            ref: _this.setSelectHandle,
            title: typeof title === "string" ? title : "",
            className: classNames("".concat(wrapClass), "".concat(wrapClass, "-").concat(_this.getNodeState() || "normal"), !disabled && (selected || dragNodeHighlight) && "".concat(prefixCls, "-node-selected")),
            onMouseEnter: _this.onMouseEnter,
            onMouseLeave: _this.onMouseLeave,
            onContextMenu: _this.onContextMenu,
            onClick: _this.onSelectorClick,
            onDoubleClick: _this.onSelectorDoubleClick
          }, $icon, $title, _this.renderDropIndicator());
        };
        _this.renderDropIndicator = function() {
          var _this$props7 = _this.props, disabled = _this$props7.disabled, eventKey = _this$props7.eventKey;
          var _this$props$context4 = _this.props.context, draggable = _this$props$context4.draggable, dropLevelOffset = _this$props$context4.dropLevelOffset, dropPosition = _this$props$context4.dropPosition, prefixCls = _this$props$context4.prefixCls, indent = _this$props$context4.indent, dropIndicatorRender2 = _this$props$context4.dropIndicatorRender, dragOverNodeKey = _this$props$context4.dragOverNodeKey, direction = _this$props$context4.direction;
          var rootDraggable = !!draggable;
          var showIndicator = !disabled && rootDraggable && dragOverNodeKey === eventKey;
          var mergedIndent = indent !== null && indent !== void 0 ? indent : _this.cacheIndent;
          _this.cacheIndent = indent;
          return showIndicator ? dropIndicatorRender2({
            dropPosition,
            dropLevelOffset,
            indent: mergedIndent,
            prefixCls,
            direction
          }) : null;
        };
        return _this;
      }
      _createClass(InternalTreeNode2, [{
        key: "componentDidMount",
        value: (
          // Isomorphic needn't load data in server side
          function componentDidMount() {
            this.syncLoadData(this.props);
          }
        )
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate() {
          this.syncLoadData(this.props);
        }
      }, {
        key: "isSelectable",
        value: function isSelectable() {
          var selectable = this.props.selectable;
          var treeSelectable = this.props.context.selectable;
          if (typeof selectable === "boolean") {
            return selectable;
          }
          return treeSelectable;
        }
      }, {
        key: "render",
        value: (
          // =========================== Render ===========================
          function render2() {
            var _classNames;
            var _this$props8 = this.props, eventKey = _this$props8.eventKey, className = _this$props8.className, style2 = _this$props8.style, dragOver = _this$props8.dragOver, dragOverGapTop = _this$props8.dragOverGapTop, dragOverGapBottom = _this$props8.dragOverGapBottom, isLeaf = _this$props8.isLeaf, isStart = _this$props8.isStart, isEnd = _this$props8.isEnd, expanded = _this$props8.expanded, selected = _this$props8.selected, checked = _this$props8.checked, halfChecked = _this$props8.halfChecked, loading = _this$props8.loading, domRef = _this$props8.domRef, active = _this$props8.active;
            _this$props8.data;
            var onMouseMove = _this$props8.onMouseMove, selectable = _this$props8.selectable, otherProps = _objectWithoutProperties(_this$props8, _excluded$3);
            var _this$props$context5 = this.props.context, prefixCls = _this$props$context5.prefixCls, filterTreeNode = _this$props$context5.filterTreeNode, keyEntities = _this$props$context5.keyEntities, dropContainerKey = _this$props$context5.dropContainerKey, dropTargetKey = _this$props$context5.dropTargetKey, draggingNodeKey = _this$props$context5.draggingNodeKey;
            var disabled = this.isDisabled();
            var dataOrAriaAttributeProps = pickAttrs(otherProps, {
              aria: true,
              data: true
            });
            var _ref2 = getEntity(keyEntities, eventKey) || {}, level = _ref2.level;
            var isEndNode = isEnd[isEnd.length - 1];
            var mergedDraggable = this.isDraggable();
            var draggableWithoutDisabled = !disabled && mergedDraggable;
            var dragging = draggingNodeKey === eventKey;
            var ariaSelected = selectable !== void 0 ? {
              "aria-selected": !!selectable
            } : void 0;
            return /* @__PURE__ */ reactExports.createElement("div", _extends$1({
              ref: domRef,
              className: classNames(className, "".concat(prefixCls, "-treenode"), (_classNames = {}, _defineProperty(_classNames, "".concat(prefixCls, "-treenode-disabled"), disabled), _defineProperty(_classNames, "".concat(prefixCls, "-treenode-switcher-").concat(expanded ? "open" : "close"), !isLeaf), _defineProperty(_classNames, "".concat(prefixCls, "-treenode-checkbox-checked"), checked), _defineProperty(_classNames, "".concat(prefixCls, "-treenode-checkbox-indeterminate"), halfChecked), _defineProperty(_classNames, "".concat(prefixCls, "-treenode-selected"), selected), _defineProperty(_classNames, "".concat(prefixCls, "-treenode-loading"), loading), _defineProperty(_classNames, "".concat(prefixCls, "-treenode-active"), active), _defineProperty(_classNames, "".concat(prefixCls, "-treenode-leaf-last"), isEndNode), _defineProperty(_classNames, "".concat(prefixCls, "-treenode-draggable"), mergedDraggable), _defineProperty(_classNames, "dragging", dragging), _defineProperty(_classNames, "drop-target", dropTargetKey === eventKey), _defineProperty(_classNames, "drop-container", dropContainerKey === eventKey), _defineProperty(_classNames, "drag-over", !disabled && dragOver), _defineProperty(_classNames, "drag-over-gap-top", !disabled && dragOverGapTop), _defineProperty(_classNames, "drag-over-gap-bottom", !disabled && dragOverGapBottom), _defineProperty(_classNames, "filter-node", filterTreeNode && filterTreeNode(convertNodePropsToEventData(this.props))), _classNames)),
              style: style2,
              draggable: draggableWithoutDisabled,
              "aria-grabbed": dragging,
              onDragStart: draggableWithoutDisabled ? this.onDragStart : void 0,
              onDragEnter: mergedDraggable ? this.onDragEnter : void 0,
              onDragOver: mergedDraggable ? this.onDragOver : void 0,
              onDragLeave: mergedDraggable ? this.onDragLeave : void 0,
              onDrop: mergedDraggable ? this.onDrop : void 0,
              onDragEnd: mergedDraggable ? this.onDragEnd : void 0,
              onMouseMove
            }, ariaSelected, dataOrAriaAttributeProps), /* @__PURE__ */ reactExports.createElement(Indent$1, {
              prefixCls,
              level,
              isStart,
              isEnd
            }), this.renderDragHandler(), this.renderSwitcher(), this.renderCheckbox(), this.renderSelector());
          }
        )
      }]);
      return InternalTreeNode2;
    }(reactExports.Component);
    var ContextTreeNode = function ContextTreeNode2(props) {
      return /* @__PURE__ */ reactExports.createElement(TreeContext.Consumer, null, function(context) {
        return /* @__PURE__ */ reactExports.createElement(InternalTreeNode, _extends$1({}, props, {
          context
        }));
      });
    };
    ContextTreeNode.displayName = "TreeNode";
    ContextTreeNode.isTreeNode = 1;
    function arrDel(list, value) {
      if (!list)
        return [];
      var clone2 = list.slice();
      var index2 = clone2.indexOf(value);
      if (index2 >= 0) {
        clone2.splice(index2, 1);
      }
      return clone2;
    }
    function arrAdd(list, value) {
      var clone2 = (list || []).slice();
      if (clone2.indexOf(value) === -1) {
        clone2.push(value);
      }
      return clone2;
    }
    function posToArr(pos) {
      return pos.split("-");
    }
    function getDragChildrenKeys(dragNodeKey, keyEntities) {
      var dragChildrenKeys = [];
      var entity = getEntity(keyEntities, dragNodeKey);
      function dig() {
        var list = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        list.forEach(function(_ref) {
          var key = _ref.key, children = _ref.children;
          dragChildrenKeys.push(key);
          dig(children);
        });
      }
      dig(entity.children);
      return dragChildrenKeys;
    }
    function isLastChild(treeNodeEntity) {
      if (treeNodeEntity.parent) {
        var posArr = posToArr(treeNodeEntity.pos);
        return Number(posArr[posArr.length - 1]) === treeNodeEntity.parent.children.length - 1;
      }
      return false;
    }
    function isFirstChild(treeNodeEntity) {
      var posArr = posToArr(treeNodeEntity.pos);
      return Number(posArr[posArr.length - 1]) === 0;
    }
    function calcDropPosition(event, dragNode, targetNode, indent, startMousePosition, allowDrop, flattenedNodes, keyEntities, expandKeys, direction) {
      var _abstractDropNodeEnti;
      var clientX = event.clientX, clientY = event.clientY;
      var _event$target$getBoun = event.target.getBoundingClientRect(), top = _event$target$getBoun.top, height = _event$target$getBoun.height;
      var horizontalMouseOffset = (direction === "rtl" ? -1 : 1) * (((startMousePosition === null || startMousePosition === void 0 ? void 0 : startMousePosition.x) || 0) - clientX);
      var rawDropLevelOffset = (horizontalMouseOffset - 12) / indent;
      var abstractDropNodeEntity = getEntity(keyEntities, targetNode.props.eventKey);
      if (clientY < top + height / 2) {
        var nodeIndex = flattenedNodes.findIndex(function(flattenedNode) {
          return flattenedNode.key === abstractDropNodeEntity.key;
        });
        var prevNodeIndex = nodeIndex <= 0 ? 0 : nodeIndex - 1;
        var prevNodeKey = flattenedNodes[prevNodeIndex].key;
        abstractDropNodeEntity = getEntity(keyEntities, prevNodeKey);
      }
      var initialAbstractDropNodeKey = abstractDropNodeEntity.key;
      var abstractDragOverEntity = abstractDropNodeEntity;
      var dragOverNodeKey = abstractDropNodeEntity.key;
      var dropPosition = 0;
      var dropLevelOffset = 0;
      if (!expandKeys.includes(initialAbstractDropNodeKey)) {
        for (var i = 0; i < rawDropLevelOffset; i += 1) {
          if (isLastChild(abstractDropNodeEntity)) {
            abstractDropNodeEntity = abstractDropNodeEntity.parent;
            dropLevelOffset += 1;
          } else {
            break;
          }
        }
      }
      var abstractDragDataNode = dragNode.props.data;
      var abstractDropDataNode = abstractDropNodeEntity.node;
      var dropAllowed = true;
      if (isFirstChild(abstractDropNodeEntity) && abstractDropNodeEntity.level === 0 && clientY < top + height / 2 && allowDrop({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: -1
      }) && abstractDropNodeEntity.key === targetNode.props.eventKey) {
        dropPosition = -1;
      } else if ((abstractDragOverEntity.children || []).length && expandKeys.includes(dragOverNodeKey)) {
        if (allowDrop({
          dragNode: abstractDragDataNode,
          dropNode: abstractDropDataNode,
          dropPosition: 0
        })) {
          dropPosition = 0;
        } else {
          dropAllowed = false;
        }
      } else if (dropLevelOffset === 0) {
        if (rawDropLevelOffset > -1.5) {
          if (allowDrop({
            dragNode: abstractDragDataNode,
            dropNode: abstractDropDataNode,
            dropPosition: 1
          })) {
            dropPosition = 1;
          } else {
            dropAllowed = false;
          }
        } else {
          if (allowDrop({
            dragNode: abstractDragDataNode,
            dropNode: abstractDropDataNode,
            dropPosition: 0
          })) {
            dropPosition = 0;
          } else if (allowDrop({
            dragNode: abstractDragDataNode,
            dropNode: abstractDropDataNode,
            dropPosition: 1
          })) {
            dropPosition = 1;
          } else {
            dropAllowed = false;
          }
        }
      } else {
        if (allowDrop({
          dragNode: abstractDragDataNode,
          dropNode: abstractDropDataNode,
          dropPosition: 1
        })) {
          dropPosition = 1;
        } else {
          dropAllowed = false;
        }
      }
      return {
        dropPosition,
        dropLevelOffset,
        dropTargetKey: abstractDropNodeEntity.key,
        dropTargetPos: abstractDropNodeEntity.pos,
        dragOverNodeKey,
        dropContainerKey: dropPosition === 0 ? null : ((_abstractDropNodeEnti = abstractDropNodeEntity.parent) === null || _abstractDropNodeEnti === void 0 ? void 0 : _abstractDropNodeEnti.key) || null,
        dropAllowed
      };
    }
    function calcSelectedKeys(selectedKeys, props) {
      if (!selectedKeys)
        return void 0;
      var multiple = props.multiple;
      if (multiple) {
        return selectedKeys.slice();
      }
      if (selectedKeys.length) {
        return [selectedKeys[0]];
      }
      return selectedKeys;
    }
    function parseCheckedKeys(keys2) {
      if (!keys2) {
        return null;
      }
      var keyProps;
      if (Array.isArray(keys2)) {
        keyProps = {
          checkedKeys: keys2,
          halfCheckedKeys: void 0
        };
      } else if (_typeof(keys2) === "object") {
        keyProps = {
          checkedKeys: keys2.checked || void 0,
          halfCheckedKeys: keys2.halfChecked || void 0
        };
      } else {
        warningOnce(false, "`checkedKeys` is not an array or an object");
        return null;
      }
      return keyProps;
    }
    function conductExpandParent(keyList, keyEntities) {
      var expandedKeys = /* @__PURE__ */ new Set();
      function conductUp(key) {
        if (expandedKeys.has(key))
          return;
        var entity = getEntity(keyEntities, key);
        if (!entity)
          return;
        expandedKeys.add(key);
        var parent = entity.parent, node2 = entity.node;
        if (node2.disabled)
          return;
        if (parent) {
          conductUp(parent.key);
        }
      }
      (keyList || []).forEach(function(key) {
        conductUp(key);
      });
      return _toConsumableArray(expandedKeys);
    }
    function useMultipleSelect(getKey2) {
      const [prevSelectedIndex, setPrevSelectedIndex] = reactExports.useState(null);
      const multipleSelect = reactExports.useCallback((currentSelectedIndex, data, selectedKeys) => {
        const configPrevSelectedIndex = prevSelectedIndex !== null && prevSelectedIndex !== void 0 ? prevSelectedIndex : currentSelectedIndex;
        const startIndex = Math.min(configPrevSelectedIndex || 0, currentSelectedIndex);
        const endIndex = Math.max(configPrevSelectedIndex || 0, currentSelectedIndex);
        const rangeKeys = data.slice(startIndex, endIndex + 1).map((item) => getKey2(item));
        const shouldSelected = rangeKeys.some((rangeKey) => !selectedKeys.has(rangeKey));
        const changedKeys = [];
        rangeKeys.forEach((item) => {
          if (shouldSelected) {
            if (!selectedKeys.has(item)) {
              changedKeys.push(item);
            }
            selectedKeys.add(item);
          } else {
            selectedKeys.delete(item);
            changedKeys.push(item);
          }
        });
        setPrevSelectedIndex(shouldSelected ? endIndex : null);
        return changedKeys;
      }, [prevSelectedIndex]);
      const updatePrevSelectedIndex = (val) => {
        setPrevSelectedIndex(val);
      };
      return [multipleSelect, updatePrevSelectedIndex];
    }
    const SELECTION_COLUMN = {};
    const SELECTION_ALL = "SELECT_ALL";
    const SELECTION_INVERT = "SELECT_INVERT";
    const SELECTION_NONE = "SELECT_NONE";
    const EMPTY_LIST$1 = [];
    const flattenData = (childrenColumnName, data) => {
      let list = [];
      (data || []).forEach((record) => {
        list.push(record);
        if (record && typeof record === "object" && childrenColumnName in record) {
          list = [].concat(_toConsumableArray(list), _toConsumableArray(flattenData(childrenColumnName, record[childrenColumnName])));
        }
      });
      return list;
    };
    const useSelection = (config, rowSelection) => {
      const {
        preserveSelectedRowKeys,
        selectedRowKeys,
        defaultSelectedRowKeys,
        getCheckboxProps,
        onChange: onSelectionChange,
        onSelect,
        onSelectAll,
        onSelectInvert,
        onSelectNone,
        onSelectMultiple,
        columnWidth: selectionColWidth,
        type: selectionType,
        selections,
        fixed,
        renderCell: customizeRenderCell,
        hideSelectAll,
        checkStrictly = true
      } = rowSelection || {};
      const {
        prefixCls,
        data,
        pageData,
        getRecordByKey,
        getRowKey,
        expandType,
        childrenColumnName,
        locale: tableLocale,
        getPopupContainer
      } = config;
      const warning2 = devUseWarning();
      const [multipleSelect, updatePrevSelectedIndex] = useMultipleSelect((item) => item);
      const [mergedSelectedKeys, setMergedSelectedKeys] = useMergedState(selectedRowKeys || defaultSelectedRowKeys || EMPTY_LIST$1, {
        value: selectedRowKeys
      });
      const preserveRecordsRef = reactExports.useRef(/* @__PURE__ */ new Map());
      const updatePreserveRecordsCache = reactExports.useCallback((keys2) => {
        if (preserveSelectedRowKeys) {
          const newCache = /* @__PURE__ */ new Map();
          keys2.forEach((key) => {
            let record = getRecordByKey(key);
            if (!record && preserveRecordsRef.current.has(key)) {
              record = preserveRecordsRef.current.get(key);
            }
            newCache.set(key, record);
          });
          preserveRecordsRef.current = newCache;
        }
      }, [getRecordByKey, preserveSelectedRowKeys]);
      reactExports.useEffect(() => {
        updatePreserveRecordsCache(mergedSelectedKeys);
      }, [mergedSelectedKeys]);
      const {
        keyEntities
      } = reactExports.useMemo(() => {
        if (checkStrictly) {
          return {
            keyEntities: null
          };
        }
        let convertData = data;
        if (preserveSelectedRowKeys) {
          const keysSet = new Set(data.map((record, index2) => getRowKey(record, index2)));
          const preserveRecords = Array.from(preserveRecordsRef.current).reduce((total, _ref) => {
            let [key, value] = _ref;
            return keysSet.has(key) ? total : total.concat(value);
          }, []);
          convertData = [].concat(_toConsumableArray(convertData), _toConsumableArray(preserveRecords));
        }
        return convertDataToEntities(convertData, {
          externalGetKey: getRowKey,
          childrenPropName: childrenColumnName
        });
      }, [data, getRowKey, checkStrictly, childrenColumnName, preserveSelectedRowKeys]);
      const flattedData = reactExports.useMemo(() => flattenData(childrenColumnName, pageData), [childrenColumnName, pageData]);
      const checkboxPropsMap = reactExports.useMemo(() => {
        const map2 = /* @__PURE__ */ new Map();
        flattedData.forEach((record, index2) => {
          const key = getRowKey(record, index2);
          const checkboxProps = (getCheckboxProps ? getCheckboxProps(record) : null) || {};
          map2.set(key, checkboxProps);
        });
        return map2;
      }, [flattedData, getRowKey, getCheckboxProps]);
      const isCheckboxDisabled = reactExports.useCallback((r2) => {
        var _a;
        return !!((_a = checkboxPropsMap.get(getRowKey(r2))) === null || _a === void 0 ? void 0 : _a.disabled);
      }, [checkboxPropsMap, getRowKey]);
      const [derivedSelectedKeys, derivedHalfSelectedKeys] = reactExports.useMemo(() => {
        if (checkStrictly) {
          return [mergedSelectedKeys || [], []];
        }
        const {
          checkedKeys,
          halfCheckedKeys
        } = conductCheck(mergedSelectedKeys, true, keyEntities, isCheckboxDisabled);
        return [checkedKeys || [], halfCheckedKeys];
      }, [mergedSelectedKeys, checkStrictly, keyEntities, isCheckboxDisabled]);
      const derivedSelectedKeySet = reactExports.useMemo(() => {
        const keys2 = selectionType === "radio" ? derivedSelectedKeys.slice(0, 1) : derivedSelectedKeys;
        return new Set(keys2);
      }, [derivedSelectedKeys, selectionType]);
      const derivedHalfSelectedKeySet = reactExports.useMemo(() => selectionType === "radio" ? /* @__PURE__ */ new Set() : new Set(derivedHalfSelectedKeys), [derivedHalfSelectedKeys, selectionType]);
      reactExports.useEffect(() => {
        if (!rowSelection) {
          setMergedSelectedKeys(EMPTY_LIST$1);
        }
      }, [!!rowSelection]);
      const setSelectedKeys = reactExports.useCallback((keys2, method) => {
        let availableKeys;
        let records;
        updatePreserveRecordsCache(keys2);
        if (preserveSelectedRowKeys) {
          availableKeys = keys2;
          records = keys2.map((key) => preserveRecordsRef.current.get(key));
        } else {
          availableKeys = [];
          records = [];
          keys2.forEach((key) => {
            const record = getRecordByKey(key);
            if (record !== void 0) {
              availableKeys.push(key);
              records.push(record);
            }
          });
        }
        setMergedSelectedKeys(availableKeys);
        onSelectionChange === null || onSelectionChange === void 0 ? void 0 : onSelectionChange(availableKeys, records, {
          type: method
        });
      }, [setMergedSelectedKeys, getRecordByKey, onSelectionChange, preserveSelectedRowKeys]);
      const triggerSingleSelection = reactExports.useCallback((key, selected, keys2, event) => {
        if (onSelect) {
          const rows = keys2.map((k2) => getRecordByKey(k2));
          onSelect(getRecordByKey(key), selected, rows, event);
        }
        setSelectedKeys(keys2, "single");
      }, [onSelect, getRecordByKey, setSelectedKeys]);
      const mergedSelections = reactExports.useMemo(() => {
        if (!selections || hideSelectAll) {
          return null;
        }
        const selectionList = selections === true ? [SELECTION_ALL, SELECTION_INVERT, SELECTION_NONE] : selections;
        return selectionList.map((selection) => {
          if (selection === SELECTION_ALL) {
            return {
              key: "all",
              text: tableLocale.selectionAll,
              onSelect() {
                setSelectedKeys(data.map((record, index2) => getRowKey(record, index2)).filter((key) => {
                  const checkProps = checkboxPropsMap.get(key);
                  return !(checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled) || derivedSelectedKeySet.has(key);
                }), "all");
              }
            };
          }
          if (selection === SELECTION_INVERT) {
            return {
              key: "invert",
              text: tableLocale.selectInvert,
              onSelect() {
                const keySet = new Set(derivedSelectedKeySet);
                pageData.forEach((record, index2) => {
                  const key = getRowKey(record, index2);
                  const checkProps = checkboxPropsMap.get(key);
                  if (!(checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled)) {
                    if (keySet.has(key)) {
                      keySet.delete(key);
                    } else {
                      keySet.add(key);
                    }
                  }
                });
                const keys2 = Array.from(keySet);
                if (onSelectInvert) {
                  warning2.deprecated(false, "onSelectInvert", "onChange");
                  onSelectInvert(keys2);
                }
                setSelectedKeys(keys2, "invert");
              }
            };
          }
          if (selection === SELECTION_NONE) {
            return {
              key: "none",
              text: tableLocale.selectNone,
              onSelect() {
                onSelectNone === null || onSelectNone === void 0 ? void 0 : onSelectNone();
                setSelectedKeys(Array.from(derivedSelectedKeySet).filter((key) => {
                  const checkProps = checkboxPropsMap.get(key);
                  return checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled;
                }), "none");
              }
            };
          }
          return selection;
        }).map((selection) => Object.assign(Object.assign({}, selection), {
          onSelect: function() {
            var _a2;
            var _a;
            for (var _len = arguments.length, rest = new Array(_len), _key = 0; _key < _len; _key++) {
              rest[_key] = arguments[_key];
            }
            (_a = selection.onSelect) === null || _a === void 0 ? void 0 : (_a2 = _a).call.apply(_a2, [selection].concat(rest));
            updatePrevSelectedIndex(null);
          }
        }));
      }, [selections, derivedSelectedKeySet, pageData, getRowKey, onSelectInvert, setSelectedKeys]);
      const transformColumns = reactExports.useCallback((columns) => {
        var _a;
        if (!rowSelection) {
          return columns.filter((col) => col !== SELECTION_COLUMN);
        }
        let cloneColumns = _toConsumableArray(columns);
        const keySet = new Set(derivedSelectedKeySet);
        const recordKeys = flattedData.map(getRowKey).filter((key) => !checkboxPropsMap.get(key).disabled);
        const checkedCurrentAll = recordKeys.every((key) => keySet.has(key));
        const checkedCurrentSome = recordKeys.some((key) => keySet.has(key));
        const onSelectAllChange = () => {
          const changeKeys = [];
          if (checkedCurrentAll) {
            recordKeys.forEach((key) => {
              keySet.delete(key);
              changeKeys.push(key);
            });
          } else {
            recordKeys.forEach((key) => {
              if (!keySet.has(key)) {
                keySet.add(key);
                changeKeys.push(key);
              }
            });
          }
          const keys2 = Array.from(keySet);
          onSelectAll === null || onSelectAll === void 0 ? void 0 : onSelectAll(!checkedCurrentAll, keys2.map((k2) => getRecordByKey(k2)), changeKeys.map((k2) => getRecordByKey(k2)));
          setSelectedKeys(keys2, "all");
          updatePrevSelectedIndex(null);
        };
        let title;
        let columnTitleCheckbox;
        if (selectionType !== "radio") {
          let customizeSelections;
          if (mergedSelections) {
            const menu = {
              getPopupContainer,
              items: mergedSelections.map((selection, index2) => {
                const {
                  key,
                  text,
                  onSelect: onSelectionClick
                } = selection;
                return {
                  key: key !== null && key !== void 0 ? key : index2,
                  onClick: () => {
                    onSelectionClick === null || onSelectionClick === void 0 ? void 0 : onSelectionClick(recordKeys);
                  },
                  label: text
                };
              })
            };
            customizeSelections = /* @__PURE__ */ reactExports.createElement("div", {
              className: `${prefixCls}-selection-extra`
            }, /* @__PURE__ */ reactExports.createElement(Dropdown$1, {
              menu,
              getPopupContainer
            }, /* @__PURE__ */ reactExports.createElement("span", null, /* @__PURE__ */ reactExports.createElement(DownOutlined$1, null))));
          }
          const allDisabledData = flattedData.map((record, index2) => {
            const key = getRowKey(record, index2);
            const checkboxProps = checkboxPropsMap.get(key) || {};
            return Object.assign({
              checked: keySet.has(key)
            }, checkboxProps);
          }).filter((_ref2) => {
            let {
              disabled
            } = _ref2;
            return disabled;
          });
          const allDisabled = !!allDisabledData.length && allDisabledData.length === flattedData.length;
          const allDisabledAndChecked = allDisabled && allDisabledData.every((_ref3) => {
            let {
              checked
            } = _ref3;
            return checked;
          });
          const allDisabledSomeChecked = allDisabled && allDisabledData.some((_ref4) => {
            let {
              checked
            } = _ref4;
            return checked;
          });
          columnTitleCheckbox = /* @__PURE__ */ reactExports.createElement(Checkbox$1, {
            checked: !allDisabled ? !!flattedData.length && checkedCurrentAll : allDisabledAndChecked,
            indeterminate: !allDisabled ? !checkedCurrentAll && checkedCurrentSome : !allDisabledAndChecked && allDisabledSomeChecked,
            onChange: onSelectAllChange,
            disabled: flattedData.length === 0 || allDisabled,
            "aria-label": customizeSelections ? "Custom selection" : "Select all",
            skipGroup: true
          });
          title = !hideSelectAll && /* @__PURE__ */ reactExports.createElement("div", {
            className: `${prefixCls}-selection`
          }, columnTitleCheckbox, customizeSelections);
        }
        let renderCell;
        if (selectionType === "radio") {
          renderCell = (_, record, index2) => {
            const key = getRowKey(record, index2);
            const checked = keySet.has(key);
            return {
              node: /* @__PURE__ */ reactExports.createElement(Radio$1, Object.assign({}, checkboxPropsMap.get(key), {
                checked,
                onClick: (e2) => e2.stopPropagation(),
                onChange: (event) => {
                  if (!keySet.has(key)) {
                    triggerSingleSelection(key, true, [key], event.nativeEvent);
                  }
                }
              })),
              checked
            };
          };
        } else {
          renderCell = (_, record, index2) => {
            var _a2;
            const key = getRowKey(record, index2);
            const checked = keySet.has(key);
            const indeterminate = derivedHalfSelectedKeySet.has(key);
            const checkboxProps = checkboxPropsMap.get(key);
            let mergedIndeterminate;
            if (expandType === "nest") {
              mergedIndeterminate = indeterminate;
            } else {
              mergedIndeterminate = (_a2 = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.indeterminate) !== null && _a2 !== void 0 ? _a2 : indeterminate;
            }
            return {
              node: /* @__PURE__ */ reactExports.createElement(Checkbox$1, Object.assign({}, checkboxProps, {
                indeterminate: mergedIndeterminate,
                checked,
                skipGroup: true,
                onClick: (e2) => e2.stopPropagation(),
                onChange: (_ref5) => {
                  let {
                    nativeEvent
                  } = _ref5;
                  const {
                    shiftKey
                  } = nativeEvent;
                  const currentSelectedIndex = recordKeys.findIndex((item) => item === key);
                  const isMultiple2 = derivedSelectedKeys.some((item) => recordKeys.includes(item));
                  if (shiftKey && checkStrictly && isMultiple2) {
                    const changedKeys = multipleSelect(currentSelectedIndex, recordKeys, keySet);
                    const keys2 = Array.from(keySet);
                    onSelectMultiple === null || onSelectMultiple === void 0 ? void 0 : onSelectMultiple(!checked, keys2.map((recordKey) => getRecordByKey(recordKey)), changedKeys.map((recordKey) => getRecordByKey(recordKey)));
                    setSelectedKeys(keys2, "multiple");
                  } else {
                    const originCheckedKeys = derivedSelectedKeys;
                    if (checkStrictly) {
                      const checkedKeys = checked ? arrDel(originCheckedKeys, key) : arrAdd(originCheckedKeys, key);
                      triggerSingleSelection(key, !checked, checkedKeys, nativeEvent);
                    } else {
                      const result = conductCheck([].concat(_toConsumableArray(originCheckedKeys), [key]), true, keyEntities, isCheckboxDisabled);
                      const {
                        checkedKeys,
                        halfCheckedKeys
                      } = result;
                      let nextCheckedKeys = checkedKeys;
                      if (checked) {
                        const tempKeySet = new Set(checkedKeys);
                        tempKeySet.delete(key);
                        nextCheckedKeys = conductCheck(Array.from(tempKeySet), {
                          checked: false,
                          halfCheckedKeys
                        }, keyEntities, isCheckboxDisabled).checkedKeys;
                      }
                      triggerSingleSelection(key, !checked, nextCheckedKeys, nativeEvent);
                    }
                  }
                  if (checked) {
                    updatePrevSelectedIndex(null);
                  } else {
                    updatePrevSelectedIndex(currentSelectedIndex);
                  }
                }
              })),
              checked
            };
          };
        }
        const renderSelectionCell = (_, record, index2) => {
          const {
            node: node2,
            checked
          } = renderCell(_, record, index2);
          if (customizeRenderCell) {
            return customizeRenderCell(checked, record, index2, node2);
          }
          return node2;
        };
        if (!cloneColumns.includes(SELECTION_COLUMN)) {
          if (cloneColumns.findIndex((col) => {
            var _a2;
            return ((_a2 = col[INTERNAL_COL_DEFINE]) === null || _a2 === void 0 ? void 0 : _a2.columnType) === "EXPAND_COLUMN";
          }) === 0) {
            const [expandColumn, ...restColumns] = cloneColumns;
            cloneColumns = [expandColumn, SELECTION_COLUMN].concat(_toConsumableArray(restColumns));
          } else {
            cloneColumns = [SELECTION_COLUMN].concat(_toConsumableArray(cloneColumns));
          }
        }
        const selectionColumnIndex = cloneColumns.indexOf(SELECTION_COLUMN);
        cloneColumns = cloneColumns.filter((column2, index2) => column2 !== SELECTION_COLUMN || index2 === selectionColumnIndex);
        const prevCol = cloneColumns[selectionColumnIndex - 1];
        const nextCol = cloneColumns[selectionColumnIndex + 1];
        let mergedFixed = fixed;
        if (mergedFixed === void 0) {
          if ((nextCol === null || nextCol === void 0 ? void 0 : nextCol.fixed) !== void 0) {
            mergedFixed = nextCol.fixed;
          } else if ((prevCol === null || prevCol === void 0 ? void 0 : prevCol.fixed) !== void 0) {
            mergedFixed = prevCol.fixed;
          }
        }
        if (mergedFixed && prevCol && ((_a = prevCol[INTERNAL_COL_DEFINE]) === null || _a === void 0 ? void 0 : _a.columnType) === "EXPAND_COLUMN" && prevCol.fixed === void 0) {
          prevCol.fixed = mergedFixed;
        }
        const columnCls = classNames(`${prefixCls}-selection-col`, {
          [`${prefixCls}-selection-col-with-dropdown`]: selections && selectionType === "checkbox"
        });
        const renderColumnTitle2 = () => {
          if (!(rowSelection === null || rowSelection === void 0 ? void 0 : rowSelection.columnTitle)) {
            return title;
          }
          if (typeof rowSelection.columnTitle === "function") {
            return rowSelection.columnTitle(columnTitleCheckbox);
          }
          return rowSelection.columnTitle;
        };
        const selectionColumn = {
          fixed: mergedFixed,
          width: selectionColWidth,
          className: `${prefixCls}-selection-column`,
          title: renderColumnTitle2(),
          render: renderSelectionCell,
          onCell: rowSelection.onCell,
          [INTERNAL_COL_DEFINE]: {
            className: columnCls
          }
        };
        return cloneColumns.map((col) => col === SELECTION_COLUMN ? selectionColumn : col);
      }, [getRowKey, flattedData, rowSelection, derivedSelectedKeys, derivedSelectedKeySet, derivedHalfSelectedKeySet, selectionColWidth, mergedSelections, expandType, checkboxPropsMap, onSelectMultiple, triggerSingleSelection, isCheckboxDisabled]);
      return [transformColumns, derivedSelectedKeySet];
    };
    function fillProxy(element, handler) {
      element._antProxy = element._antProxy || {};
      Object.keys(handler).forEach((key) => {
        if (!(key in element._antProxy)) {
          const ori = element[key];
          element._antProxy[key] = ori;
          element[key] = handler[key];
        }
      });
      return element;
    }
    function useProxyImperativeHandle(ref, init) {
      return reactExports.useImperativeHandle(ref, () => {
        const refObj = init();
        const {
          nativeElement
        } = refObj;
        if (typeof Proxy !== "undefined") {
          return new Proxy(nativeElement, {
            get(obj, prop) {
              if (refObj[prop]) {
                return refObj[prop];
              }
              return Reflect.get(obj, prop);
            }
          });
        }
        return fillProxy(nativeElement, refObj);
      });
    }
    function renderExpandIcon(locale2) {
      return function expandIcon(_ref) {
        let {
          prefixCls,
          onExpand,
          record,
          expanded,
          expandable
        } = _ref;
        const iconPrefix = `${prefixCls}-row-expand-icon`;
        return /* @__PURE__ */ reactExports.createElement("button", {
          type: "button",
          onClick: (e2) => {
            onExpand(record, e2);
            e2.stopPropagation();
          },
          className: classNames(iconPrefix, {
            [`${iconPrefix}-spaced`]: !expandable,
            [`${iconPrefix}-expanded`]: expandable && expanded,
            [`${iconPrefix}-collapsed`]: expandable && !expanded
          }),
          "aria-label": expanded ? locale2.collapse : locale2.expand,
          "aria-expanded": expanded
        });
      };
    }
    function useContainerWidth(prefixCls) {
      const getContainerWidth = (ele, width) => {
        const container = ele.querySelector(`.${prefixCls}-container`);
        let returnWidth = width;
        if (container) {
          const style2 = getComputedStyle(container);
          const borderLeft = parseInt(style2.borderLeftWidth, 10);
          const borderRight = parseInt(style2.borderRightWidth, 10);
          returnWidth = width - borderLeft - borderRight;
        }
        return returnWidth;
      };
      return getContainerWidth;
    }
    function getColumnKey(column2, defaultKey) {
      if ("key" in column2 && column2.key !== void 0 && column2.key !== null) {
        return column2.key;
      }
      if (column2.dataIndex) {
        return Array.isArray(column2.dataIndex) ? column2.dataIndex.join(".") : column2.dataIndex;
      }
      return defaultKey;
    }
    function getColumnPos(index2, pos) {
      return pos ? `${pos}-${index2}` : `${index2}`;
    }
    function renderColumnTitle(title, props) {
      if (typeof title === "function") {
        return title(props);
      }
      return title;
    }
    function safeColumnTitle(title, props) {
      const res = renderColumnTitle(title, props);
      if (Object.prototype.toString.call(res) === "[object Object]")
        return "";
      return res;
    }
    var FilterFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M349 838c0 17.7 14.2 32 31.8 32h262.4c17.6 0 31.8-14.3 31.8-32V642H349v196zm531.1-684H143.9c-24.5 0-39.8 26.7-27.5 48l221.3 376h348.8l221.3-376c12.1-21.3-3.2-48-27.7-48z" } }] }, "name": "filter", "theme": "filled" };
    const FilterFilledSvg = FilterFilled$2;
    var FilterFilled = function FilterFilled2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: FilterFilledSvg
      }));
    };
    const FilterFilled$1 = /* @__PURE__ */ reactExports.forwardRef(FilterFilled);
    function useSyncState(initialValue) {
      const ref = reactExports.useRef(initialValue);
      const forceUpdate = useForceUpdate();
      return [() => ref.current, (newValue) => {
        ref.current = newValue;
        forceUpdate();
      }];
    }
    function DropIndicator(_ref) {
      var dropPosition = _ref.dropPosition, dropLevelOffset = _ref.dropLevelOffset, indent = _ref.indent;
      var style2 = {
        pointerEvents: "none",
        position: "absolute",
        right: 0,
        backgroundColor: "red",
        height: 2
      };
      switch (dropPosition) {
        case -1:
          style2.top = 0;
          style2.left = -dropLevelOffset * indent;
          break;
        case 1:
          style2.bottom = 0;
          style2.left = -dropLevelOffset * indent;
          break;
        case 0:
          style2.bottom = 0;
          style2.left = indent;
          break;
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        style: style2
      });
    }
    function _objectDestructuringEmpty(obj) {
      if (obj == null)
        throw new TypeError("Cannot destructure " + obj);
    }
    function useUnmount(triggerStart, triggerEnd) {
      var _React$useState = reactExports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), firstMount = _React$useState2[0], setFirstMount = _React$useState2[1];
      useLayoutEffect$1(function() {
        if (firstMount) {
          triggerStart();
          return function() {
            triggerEnd();
          };
        }
      }, [firstMount]);
      useLayoutEffect$1(function() {
        setFirstMount(true);
        return function() {
          setFirstMount(false);
        };
      }, []);
    }
    var _excluded$2 = ["className", "style", "motion", "motionNodes", "motionType", "onMotionStart", "onMotionEnd", "active", "treeNodeRequiredProps"];
    var MotionTreeNode = function MotionTreeNode2(_ref, ref) {
      var className = _ref.className, style2 = _ref.style, motion = _ref.motion, motionNodes = _ref.motionNodes, motionType = _ref.motionType, onOriginMotionStart = _ref.onMotionStart, onOriginMotionEnd = _ref.onMotionEnd, active = _ref.active, treeNodeRequiredProps = _ref.treeNodeRequiredProps, props = _objectWithoutProperties(_ref, _excluded$2);
      var _React$useState = reactExports.useState(true), _React$useState2 = _slicedToArray(_React$useState, 2), visible = _React$useState2[0], setVisible = _React$useState2[1];
      var _React$useContext = reactExports.useContext(TreeContext), prefixCls = _React$useContext.prefixCls;
      var targetVisible = motionNodes && motionType !== "hide";
      useLayoutEffect$1(function() {
        if (motionNodes) {
          if (targetVisible !== visible) {
            setVisible(targetVisible);
          }
        }
      }, [motionNodes]);
      var triggerMotionStart = function triggerMotionStart2() {
        if (motionNodes) {
          onOriginMotionStart();
        }
      };
      var triggerMotionEndRef = reactExports.useRef(false);
      var triggerMotionEnd = function triggerMotionEnd2() {
        if (motionNodes && !triggerMotionEndRef.current) {
          triggerMotionEndRef.current = true;
          onOriginMotionEnd();
        }
      };
      useUnmount(triggerMotionStart, triggerMotionEnd);
      var onVisibleChanged = function onVisibleChanged2(nextVisible) {
        if (targetVisible === nextVisible) {
          triggerMotionEnd();
        }
      };
      if (motionNodes) {
        return /* @__PURE__ */ reactExports.createElement(CSSMotion, _extends$1({
          ref,
          visible
        }, motion, {
          motionAppear: motionType === "show",
          onVisibleChanged
        }), function(_ref2, motionRef) {
          var motionClassName = _ref2.className, motionStyle = _ref2.style;
          return /* @__PURE__ */ reactExports.createElement("div", {
            ref: motionRef,
            className: classNames("".concat(prefixCls, "-treenode-motion"), motionClassName),
            style: motionStyle
          }, motionNodes.map(function(treeNode) {
            var restProps = _extends$1({}, (_objectDestructuringEmpty(treeNode.data), treeNode.data)), title = treeNode.title, key = treeNode.key, isStart = treeNode.isStart, isEnd = treeNode.isEnd;
            delete restProps.children;
            var treeNodeProps = getTreeNodeProps(key, treeNodeRequiredProps);
            return /* @__PURE__ */ reactExports.createElement(ContextTreeNode, _extends$1({}, restProps, treeNodeProps, {
              title,
              active,
              data: treeNode.data,
              key,
              isStart,
              isEnd
            }));
          }));
        });
      }
      return /* @__PURE__ */ reactExports.createElement(ContextTreeNode, _extends$1({
        domRef: ref,
        className,
        style: style2
      }, props, {
        active
      }));
    };
    MotionTreeNode.displayName = "MotionTreeNode";
    var RefMotionTreeNode = /* @__PURE__ */ reactExports.forwardRef(MotionTreeNode);
    function findExpandedKeys() {
      var prev2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var next2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var prevLen = prev2.length;
      var nextLen = next2.length;
      if (Math.abs(prevLen - nextLen) !== 1) {
        return {
          add: false,
          key: null
        };
      }
      function find(shorter, longer) {
        var cache = /* @__PURE__ */ new Map();
        shorter.forEach(function(key) {
          cache.set(key, true);
        });
        var keys2 = longer.filter(function(key) {
          return !cache.has(key);
        });
        return keys2.length === 1 ? keys2[0] : null;
      }
      if (prevLen < nextLen) {
        return {
          add: true,
          key: find(prev2, next2)
        };
      }
      return {
        add: false,
        key: find(next2, prev2)
      };
    }
    function getExpandRange(shorter, longer, key) {
      var shorterStartIndex = shorter.findIndex(function(data) {
        return data.key === key;
      });
      var shorterEndNode = shorter[shorterStartIndex + 1];
      var longerStartIndex = longer.findIndex(function(data) {
        return data.key === key;
      });
      if (shorterEndNode) {
        var longerEndIndex = longer.findIndex(function(data) {
          return data.key === shorterEndNode.key;
        });
        return longer.slice(longerStartIndex + 1, longerEndIndex);
      }
      return longer.slice(longerStartIndex + 1);
    }
    var _excluded$1 = ["prefixCls", "data", "selectable", "checkable", "expandedKeys", "selectedKeys", "checkedKeys", "loadedKeys", "loadingKeys", "halfCheckedKeys", "keyEntities", "disabled", "dragging", "dragOverNodeKey", "dropPosition", "motion", "height", "itemHeight", "virtual", "focusable", "activeItem", "focused", "tabIndex", "onKeyDown", "onFocus", "onBlur", "onActiveChange", "onListChangeStart", "onListChangeEnd"];
    var HIDDEN_STYLE = {
      width: 0,
      height: 0,
      display: "flex",
      overflow: "hidden",
      opacity: 0,
      border: 0,
      padding: 0,
      margin: 0
    };
    var noop$1 = function noop2() {
    };
    var MOTION_KEY = "RC_TREE_MOTION_".concat(Math.random());
    var MotionNode = {
      key: MOTION_KEY
    };
    var MotionEntity = {
      key: MOTION_KEY,
      level: 0,
      index: 0,
      pos: "0",
      node: MotionNode,
      nodes: [MotionNode]
    };
    var MotionFlattenData = {
      parent: null,
      children: [],
      pos: MotionEntity.pos,
      data: MotionNode,
      title: null,
      key: MOTION_KEY,
      /** Hold empty list here since we do not use it */
      isStart: [],
      isEnd: []
    };
    function getMinimumRangeTransitionRange(list, virtual, height, itemHeight) {
      if (virtual === false || !height) {
        return list;
      }
      return list.slice(0, Math.ceil(height / itemHeight) + 1);
    }
    function itemKey(item) {
      var key = item.key, pos = item.pos;
      return getKey(key, pos);
    }
    function getAccessibilityPath(item) {
      var path = String(item.data.key);
      var current = item;
      while (current.parent) {
        current = current.parent;
        path = "".concat(current.data.key, " > ").concat(path);
      }
      return path;
    }
    var NodeList = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
      var prefixCls = props.prefixCls, data = props.data;
      props.selectable;
      props.checkable;
      var expandedKeys = props.expandedKeys, selectedKeys = props.selectedKeys, checkedKeys = props.checkedKeys, loadedKeys = props.loadedKeys, loadingKeys = props.loadingKeys, halfCheckedKeys = props.halfCheckedKeys, keyEntities = props.keyEntities, disabled = props.disabled, dragging = props.dragging, dragOverNodeKey = props.dragOverNodeKey, dropPosition = props.dropPosition, motion = props.motion, height = props.height, itemHeight = props.itemHeight, virtual = props.virtual, focusable2 = props.focusable, activeItem = props.activeItem, focused = props.focused, tabIndex = props.tabIndex, onKeyDown2 = props.onKeyDown, onFocus = props.onFocus, onBlur = props.onBlur, onActiveChange = props.onActiveChange, onListChangeStart = props.onListChangeStart, onListChangeEnd = props.onListChangeEnd, domProps = _objectWithoutProperties(props, _excluded$1);
      var listRef = reactExports.useRef(null);
      var indentMeasurerRef = reactExports.useRef(null);
      reactExports.useImperativeHandle(ref, function() {
        return {
          scrollTo: function scrollTo2(scroll) {
            listRef.current.scrollTo(scroll);
          },
          getIndentWidth: function getIndentWidth() {
            return indentMeasurerRef.current.offsetWidth;
          }
        };
      });
      var _React$useState = reactExports.useState(expandedKeys), _React$useState2 = _slicedToArray(_React$useState, 2), prevExpandedKeys = _React$useState2[0], setPrevExpandedKeys = _React$useState2[1];
      var _React$useState3 = reactExports.useState(data), _React$useState4 = _slicedToArray(_React$useState3, 2), prevData = _React$useState4[0], setPrevData = _React$useState4[1];
      var _React$useState5 = reactExports.useState(data), _React$useState6 = _slicedToArray(_React$useState5, 2), transitionData = _React$useState6[0], setTransitionData = _React$useState6[1];
      var _React$useState7 = reactExports.useState([]), _React$useState8 = _slicedToArray(_React$useState7, 2), transitionRange = _React$useState8[0], setTransitionRange = _React$useState8[1];
      var _React$useState9 = reactExports.useState(null), _React$useState10 = _slicedToArray(_React$useState9, 2), motionType = _React$useState10[0], setMotionType = _React$useState10[1];
      var dataRef = reactExports.useRef(data);
      dataRef.current = data;
      function onMotionEnd() {
        var latestData = dataRef.current;
        setPrevData(latestData);
        setTransitionData(latestData);
        setTransitionRange([]);
        setMotionType(null);
        onListChangeEnd();
      }
      useLayoutEffect$1(function() {
        setPrevExpandedKeys(expandedKeys);
        var diffExpanded = findExpandedKeys(prevExpandedKeys, expandedKeys);
        if (diffExpanded.key !== null) {
          if (diffExpanded.add) {
            var keyIndex = prevData.findIndex(function(_ref) {
              var key = _ref.key;
              return key === diffExpanded.key;
            });
            var rangeNodes = getMinimumRangeTransitionRange(getExpandRange(prevData, data, diffExpanded.key), virtual, height, itemHeight);
            var newTransitionData = prevData.slice();
            newTransitionData.splice(keyIndex + 1, 0, MotionFlattenData);
            setTransitionData(newTransitionData);
            setTransitionRange(rangeNodes);
            setMotionType("show");
          } else {
            var _keyIndex = data.findIndex(function(_ref2) {
              var key = _ref2.key;
              return key === diffExpanded.key;
            });
            var _rangeNodes = getMinimumRangeTransitionRange(getExpandRange(data, prevData, diffExpanded.key), virtual, height, itemHeight);
            var _newTransitionData = data.slice();
            _newTransitionData.splice(_keyIndex + 1, 0, MotionFlattenData);
            setTransitionData(_newTransitionData);
            setTransitionRange(_rangeNodes);
            setMotionType("hide");
          }
        } else if (prevData !== data) {
          setPrevData(data);
          setTransitionData(data);
        }
      }, [expandedKeys, data]);
      reactExports.useEffect(function() {
        if (!dragging) {
          onMotionEnd();
        }
      }, [dragging]);
      var mergedData = motion ? transitionData : data;
      var treeNodeRequiredProps = {
        expandedKeys,
        selectedKeys,
        loadedKeys,
        loadingKeys,
        checkedKeys,
        halfCheckedKeys,
        dragOverNodeKey,
        dropPosition,
        keyEntities
      };
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, focused && activeItem && /* @__PURE__ */ reactExports.createElement("span", {
        style: HIDDEN_STYLE,
        "aria-live": "assertive"
      }, getAccessibilityPath(activeItem)), /* @__PURE__ */ reactExports.createElement("div", null, /* @__PURE__ */ reactExports.createElement("input", {
        style: HIDDEN_STYLE,
        disabled: focusable2 === false || disabled,
        tabIndex: focusable2 !== false ? tabIndex : null,
        onKeyDown: onKeyDown2,
        onFocus,
        onBlur,
        value: "",
        onChange: noop$1,
        "aria-label": "for screen reader"
      })), /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-treenode"),
        "aria-hidden": true,
        style: {
          position: "absolute",
          pointerEvents: "none",
          visibility: "hidden",
          height: 0,
          overflow: "hidden",
          border: 0,
          padding: 0
        }
      }, /* @__PURE__ */ reactExports.createElement("div", {
        className: "".concat(prefixCls, "-indent")
      }, /* @__PURE__ */ reactExports.createElement("div", {
        ref: indentMeasurerRef,
        className: "".concat(prefixCls, "-indent-unit")
      }))), /* @__PURE__ */ reactExports.createElement(List$1, _extends$1({}, domProps, {
        data: mergedData,
        itemKey,
        height,
        fullHeight: false,
        virtual,
        itemHeight,
        prefixCls: "".concat(prefixCls, "-list"),
        ref: listRef,
        onVisibleChange: function onVisibleChange(originList, fullList) {
          var originSet = new Set(originList);
          var restList = fullList.filter(function(item) {
            return !originSet.has(item);
          });
          if (restList.some(function(item) {
            return itemKey(item) === MOTION_KEY;
          })) {
            onMotionEnd();
          }
        }
      }), function(treeNode) {
        var pos = treeNode.pos, restProps = _extends$1({}, (_objectDestructuringEmpty(treeNode.data), treeNode.data)), title = treeNode.title, key = treeNode.key, isStart = treeNode.isStart, isEnd = treeNode.isEnd;
        var mergedKey = getKey(key, pos);
        delete restProps.key;
        delete restProps.children;
        var treeNodeProps = getTreeNodeProps(mergedKey, treeNodeRequiredProps);
        return /* @__PURE__ */ reactExports.createElement(RefMotionTreeNode, _extends$1({}, restProps, treeNodeProps, {
          title,
          active: !!activeItem && key === activeItem.key,
          pos,
          data: treeNode.data,
          isStart,
          isEnd,
          motion,
          motionNodes: key === MOTION_KEY ? transitionRange : null,
          motionType,
          onMotionStart: onListChangeStart,
          onMotionEnd,
          treeNodeRequiredProps,
          onMouseMove: function onMouseMove() {
            onActiveChange(null);
          }
        }));
      }));
    });
    NodeList.displayName = "NodeList";
    var MAX_RETRY_TIMES = 10;
    var Tree$3 = /* @__PURE__ */ function(_React$Component) {
      _inherits(Tree2, _React$Component);
      var _super = _createSuper(Tree2);
      function Tree2() {
        var _this;
        _classCallCheck(this, Tree2);
        for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
          _args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(_args));
        _this.destroyed = false;
        _this.delayedDragEnterLogic = void 0;
        _this.loadingRetryTimes = {};
        _this.state = {
          keyEntities: {},
          indent: null,
          selectedKeys: [],
          checkedKeys: [],
          halfCheckedKeys: [],
          loadedKeys: [],
          loadingKeys: [],
          expandedKeys: [],
          draggingNodeKey: null,
          dragChildrenKeys: [],
          // dropTargetKey is the key of abstract-drop-node
          // the abstract-drop-node is the real drop node when drag and drop
          // not the DOM drag over node
          dropTargetKey: null,
          dropPosition: null,
          dropContainerKey: null,
          dropLevelOffset: null,
          dropTargetPos: null,
          dropAllowed: true,
          // the abstract-drag-over-node
          // if mouse is on the bottom of top dom node or no the top of the bottom dom node
          // abstract-drag-over-node is the top node
          dragOverNodeKey: null,
          treeData: [],
          flattenNodes: [],
          focused: false,
          activeKey: null,
          listChanging: false,
          prevProps: null,
          fieldNames: fillFieldNames()
        };
        _this.dragStartMousePosition = null;
        _this.dragNode = void 0;
        _this.currentMouseOverDroppableNodeKey = null;
        _this.listRef = /* @__PURE__ */ reactExports.createRef();
        _this.onNodeDragStart = function(event, node2) {
          var _this$state = _this.state, expandedKeys = _this$state.expandedKeys, keyEntities = _this$state.keyEntities;
          var onDragStart = _this.props.onDragStart;
          var eventKey = node2.props.eventKey;
          _this.dragNode = node2;
          _this.dragStartMousePosition = {
            x: event.clientX,
            y: event.clientY
          };
          var newExpandedKeys = arrDel(expandedKeys, eventKey);
          _this.setState({
            draggingNodeKey: eventKey,
            dragChildrenKeys: getDragChildrenKeys(eventKey, keyEntities),
            indent: _this.listRef.current.getIndentWidth()
          });
          _this.setExpandedKeys(newExpandedKeys);
          window.addEventListener("dragend", _this.onWindowDragEnd);
          onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart({
            event,
            node: convertNodePropsToEventData(node2.props)
          });
        };
        _this.onNodeDragEnter = function(event, node2) {
          var _this$state2 = _this.state, expandedKeys = _this$state2.expandedKeys, keyEntities = _this$state2.keyEntities, dragChildrenKeys = _this$state2.dragChildrenKeys, flattenNodes = _this$state2.flattenNodes, indent = _this$state2.indent;
          var _this$props = _this.props, onDragEnter = _this$props.onDragEnter, onExpand = _this$props.onExpand, allowDrop2 = _this$props.allowDrop, direction = _this$props.direction;
          var _node$props = node2.props, pos = _node$props.pos, eventKey = _node$props.eventKey;
          var _assertThisInitialize = _assertThisInitialized(_this), dragNode = _assertThisInitialize.dragNode;
          if (_this.currentMouseOverDroppableNodeKey !== eventKey) {
            _this.currentMouseOverDroppableNodeKey = eventKey;
          }
          if (!dragNode) {
            _this.resetDragState();
            return;
          }
          var _calcDropPosition = calcDropPosition(event, dragNode, node2, indent, _this.dragStartMousePosition, allowDrop2, flattenNodes, keyEntities, expandedKeys, direction), dropPosition = _calcDropPosition.dropPosition, dropLevelOffset = _calcDropPosition.dropLevelOffset, dropTargetKey = _calcDropPosition.dropTargetKey, dropContainerKey = _calcDropPosition.dropContainerKey, dropTargetPos = _calcDropPosition.dropTargetPos, dropAllowed = _calcDropPosition.dropAllowed, dragOverNodeKey = _calcDropPosition.dragOverNodeKey;
          if (
            // don't allow drop inside its children
            dragChildrenKeys.indexOf(dropTargetKey) !== -1 || // don't allow drop when drop is not allowed caculated by calcDropPosition
            !dropAllowed
          ) {
            _this.resetDragState();
            return;
          }
          if (!_this.delayedDragEnterLogic) {
            _this.delayedDragEnterLogic = {};
          }
          Object.keys(_this.delayedDragEnterLogic).forEach(function(key) {
            clearTimeout(_this.delayedDragEnterLogic[key]);
          });
          if (dragNode.props.eventKey !== node2.props.eventKey) {
            event.persist();
            _this.delayedDragEnterLogic[pos] = window.setTimeout(function() {
              if (_this.state.draggingNodeKey === null)
                return;
              var newExpandedKeys = _toConsumableArray(expandedKeys);
              var entity = getEntity(keyEntities, node2.props.eventKey);
              if (entity && (entity.children || []).length) {
                newExpandedKeys = arrAdd(expandedKeys, node2.props.eventKey);
              }
              if (!("expandedKeys" in _this.props)) {
                _this.setExpandedKeys(newExpandedKeys);
              }
              onExpand === null || onExpand === void 0 ? void 0 : onExpand(newExpandedKeys, {
                node: convertNodePropsToEventData(node2.props),
                expanded: true,
                nativeEvent: event.nativeEvent
              });
            }, 800);
          }
          if (dragNode.props.eventKey === dropTargetKey && dropLevelOffset === 0) {
            _this.resetDragState();
            return;
          }
          _this.setState({
            dragOverNodeKey,
            dropPosition,
            dropLevelOffset,
            dropTargetKey,
            dropContainerKey,
            dropTargetPos,
            dropAllowed
          });
          onDragEnter === null || onDragEnter === void 0 ? void 0 : onDragEnter({
            event,
            node: convertNodePropsToEventData(node2.props),
            expandedKeys
          });
        };
        _this.onNodeDragOver = function(event, node2) {
          var _this$state3 = _this.state, dragChildrenKeys = _this$state3.dragChildrenKeys, flattenNodes = _this$state3.flattenNodes, keyEntities = _this$state3.keyEntities, expandedKeys = _this$state3.expandedKeys, indent = _this$state3.indent;
          var _this$props2 = _this.props, onDragOver = _this$props2.onDragOver, allowDrop2 = _this$props2.allowDrop, direction = _this$props2.direction;
          var _assertThisInitialize2 = _assertThisInitialized(_this), dragNode = _assertThisInitialize2.dragNode;
          if (!dragNode) {
            return;
          }
          var _calcDropPosition2 = calcDropPosition(event, dragNode, node2, indent, _this.dragStartMousePosition, allowDrop2, flattenNodes, keyEntities, expandedKeys, direction), dropPosition = _calcDropPosition2.dropPosition, dropLevelOffset = _calcDropPosition2.dropLevelOffset, dropTargetKey = _calcDropPosition2.dropTargetKey, dropContainerKey = _calcDropPosition2.dropContainerKey, dropAllowed = _calcDropPosition2.dropAllowed, dropTargetPos = _calcDropPosition2.dropTargetPos, dragOverNodeKey = _calcDropPosition2.dragOverNodeKey;
          if (dragChildrenKeys.indexOf(dropTargetKey) !== -1 || !dropAllowed) {
            return;
          }
          if (dragNode.props.eventKey === dropTargetKey && dropLevelOffset === 0) {
            if (!(_this.state.dropPosition === null && _this.state.dropLevelOffset === null && _this.state.dropTargetKey === null && _this.state.dropContainerKey === null && _this.state.dropTargetPos === null && _this.state.dropAllowed === false && _this.state.dragOverNodeKey === null)) {
              _this.resetDragState();
            }
          } else if (!(dropPosition === _this.state.dropPosition && dropLevelOffset === _this.state.dropLevelOffset && dropTargetKey === _this.state.dropTargetKey && dropContainerKey === _this.state.dropContainerKey && dropTargetPos === _this.state.dropTargetPos && dropAllowed === _this.state.dropAllowed && dragOverNodeKey === _this.state.dragOverNodeKey)) {
            _this.setState({
              dropPosition,
              dropLevelOffset,
              dropTargetKey,
              dropContainerKey,
              dropTargetPos,
              dropAllowed,
              dragOverNodeKey
            });
          }
          onDragOver === null || onDragOver === void 0 ? void 0 : onDragOver({
            event,
            node: convertNodePropsToEventData(node2.props)
          });
        };
        _this.onNodeDragLeave = function(event, node2) {
          if (_this.currentMouseOverDroppableNodeKey === node2.props.eventKey && !event.currentTarget.contains(event.relatedTarget)) {
            _this.resetDragState();
            _this.currentMouseOverDroppableNodeKey = null;
          }
          var onDragLeave = _this.props.onDragLeave;
          onDragLeave === null || onDragLeave === void 0 ? void 0 : onDragLeave({
            event,
            node: convertNodePropsToEventData(node2.props)
          });
        };
        _this.onWindowDragEnd = function(event) {
          _this.onNodeDragEnd(event, null, true);
          window.removeEventListener("dragend", _this.onWindowDragEnd);
        };
        _this.onNodeDragEnd = function(event, node2) {
          var onDragEnd = _this.props.onDragEnd;
          _this.setState({
            dragOverNodeKey: null
          });
          _this.cleanDragState();
          onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd({
            event,
            node: convertNodePropsToEventData(node2.props)
          });
          _this.dragNode = null;
          window.removeEventListener("dragend", _this.onWindowDragEnd);
        };
        _this.onNodeDrop = function(event, node2) {
          var _this$getActiveItem;
          var outsideTree = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          var _this$state4 = _this.state, dragChildrenKeys = _this$state4.dragChildrenKeys, dropPosition = _this$state4.dropPosition, dropTargetKey = _this$state4.dropTargetKey, dropTargetPos = _this$state4.dropTargetPos, dropAllowed = _this$state4.dropAllowed;
          if (!dropAllowed)
            return;
          var onDrop = _this.props.onDrop;
          _this.setState({
            dragOverNodeKey: null
          });
          _this.cleanDragState();
          if (dropTargetKey === null)
            return;
          var abstractDropNodeProps = _objectSpread2(_objectSpread2({}, getTreeNodeProps(dropTargetKey, _this.getTreeNodeRequiredProps())), {}, {
            active: ((_this$getActiveItem = _this.getActiveItem()) === null || _this$getActiveItem === void 0 ? void 0 : _this$getActiveItem.key) === dropTargetKey,
            data: getEntity(_this.state.keyEntities, dropTargetKey).node
          });
          var dropToChild = dragChildrenKeys.indexOf(dropTargetKey) !== -1;
          warningOnce(!dropToChild, "Can not drop to dragNode's children node. This is a bug of rc-tree. Please report an issue.");
          var posArr = posToArr(dropTargetPos);
          var dropResult = {
            event,
            node: convertNodePropsToEventData(abstractDropNodeProps),
            dragNode: _this.dragNode ? convertNodePropsToEventData(_this.dragNode.props) : null,
            dragNodesKeys: [_this.dragNode.props.eventKey].concat(dragChildrenKeys),
            dropToGap: dropPosition !== 0,
            dropPosition: dropPosition + Number(posArr[posArr.length - 1])
          };
          if (!outsideTree) {
            onDrop === null || onDrop === void 0 ? void 0 : onDrop(dropResult);
          }
          _this.dragNode = null;
        };
        _this.cleanDragState = function() {
          var draggingNodeKey = _this.state.draggingNodeKey;
          if (draggingNodeKey !== null) {
            _this.setState({
              draggingNodeKey: null,
              dropPosition: null,
              dropContainerKey: null,
              dropTargetKey: null,
              dropLevelOffset: null,
              dropAllowed: true,
              dragOverNodeKey: null
            });
          }
          _this.dragStartMousePosition = null;
          _this.currentMouseOverDroppableNodeKey = null;
        };
        _this.triggerExpandActionExpand = function(e2, treeNode) {
          var _this$state5 = _this.state, expandedKeys = _this$state5.expandedKeys, flattenNodes = _this$state5.flattenNodes;
          var expanded = treeNode.expanded, key = treeNode.key, isLeaf = treeNode.isLeaf;
          if (isLeaf || e2.shiftKey || e2.metaKey || e2.ctrlKey) {
            return;
          }
          var node2 = flattenNodes.filter(function(nodeItem) {
            return nodeItem.key === key;
          })[0];
          var eventNode = convertNodePropsToEventData(_objectSpread2(_objectSpread2({}, getTreeNodeProps(key, _this.getTreeNodeRequiredProps())), {}, {
            data: node2.data
          }));
          _this.setExpandedKeys(expanded ? arrDel(expandedKeys, key) : arrAdd(expandedKeys, key));
          _this.onNodeExpand(e2, eventNode);
        };
        _this.onNodeClick = function(e2, treeNode) {
          var _this$props3 = _this.props, onClick = _this$props3.onClick, expandAction = _this$props3.expandAction;
          if (expandAction === "click") {
            _this.triggerExpandActionExpand(e2, treeNode);
          }
          onClick === null || onClick === void 0 ? void 0 : onClick(e2, treeNode);
        };
        _this.onNodeDoubleClick = function(e2, treeNode) {
          var _this$props4 = _this.props, onDoubleClick = _this$props4.onDoubleClick, expandAction = _this$props4.expandAction;
          if (expandAction === "doubleClick") {
            _this.triggerExpandActionExpand(e2, treeNode);
          }
          onDoubleClick === null || onDoubleClick === void 0 ? void 0 : onDoubleClick(e2, treeNode);
        };
        _this.onNodeSelect = function(e2, treeNode) {
          var selectedKeys = _this.state.selectedKeys;
          var _this$state6 = _this.state, keyEntities = _this$state6.keyEntities, fieldNames = _this$state6.fieldNames;
          var _this$props5 = _this.props, onSelect = _this$props5.onSelect, multiple = _this$props5.multiple;
          var selected = treeNode.selected;
          var key = treeNode[fieldNames.key];
          var targetSelected = !selected;
          if (!targetSelected) {
            selectedKeys = arrDel(selectedKeys, key);
          } else if (!multiple) {
            selectedKeys = [key];
          } else {
            selectedKeys = arrAdd(selectedKeys, key);
          }
          var selectedNodes = selectedKeys.map(function(selectedKey) {
            var entity = getEntity(keyEntities, selectedKey);
            if (!entity)
              return null;
            return entity.node;
          }).filter(function(node2) {
            return node2;
          });
          _this.setUncontrolledState({
            selectedKeys
          });
          onSelect === null || onSelect === void 0 ? void 0 : onSelect(selectedKeys, {
            event: "select",
            selected: targetSelected,
            node: treeNode,
            selectedNodes,
            nativeEvent: e2.nativeEvent
          });
        };
        _this.onNodeCheck = function(e2, treeNode, checked) {
          var _this$state7 = _this.state, keyEntities = _this$state7.keyEntities, oriCheckedKeys = _this$state7.checkedKeys, oriHalfCheckedKeys = _this$state7.halfCheckedKeys;
          var _this$props6 = _this.props, checkStrictly = _this$props6.checkStrictly, onCheck = _this$props6.onCheck;
          var key = treeNode.key;
          var checkedObj;
          var eventObj = {
            event: "check",
            node: treeNode,
            checked,
            nativeEvent: e2.nativeEvent
          };
          if (checkStrictly) {
            var checkedKeys = checked ? arrAdd(oriCheckedKeys, key) : arrDel(oriCheckedKeys, key);
            var halfCheckedKeys = arrDel(oriHalfCheckedKeys, key);
            checkedObj = {
              checked: checkedKeys,
              halfChecked: halfCheckedKeys
            };
            eventObj.checkedNodes = checkedKeys.map(function(checkedKey) {
              return getEntity(keyEntities, checkedKey);
            }).filter(function(entity) {
              return entity;
            }).map(function(entity) {
              return entity.node;
            });
            _this.setUncontrolledState({
              checkedKeys
            });
          } else {
            var _conductCheck = conductCheck([].concat(_toConsumableArray(oriCheckedKeys), [key]), true, keyEntities), _checkedKeys = _conductCheck.checkedKeys, _halfCheckedKeys = _conductCheck.halfCheckedKeys;
            if (!checked) {
              var keySet = new Set(_checkedKeys);
              keySet.delete(key);
              var _conductCheck2 = conductCheck(Array.from(keySet), {
                checked: false,
                halfCheckedKeys: _halfCheckedKeys
              }, keyEntities);
              _checkedKeys = _conductCheck2.checkedKeys;
              _halfCheckedKeys = _conductCheck2.halfCheckedKeys;
            }
            checkedObj = _checkedKeys;
            eventObj.checkedNodes = [];
            eventObj.checkedNodesPositions = [];
            eventObj.halfCheckedKeys = _halfCheckedKeys;
            _checkedKeys.forEach(function(checkedKey) {
              var entity = getEntity(keyEntities, checkedKey);
              if (!entity)
                return;
              var node2 = entity.node, pos = entity.pos;
              eventObj.checkedNodes.push(node2);
              eventObj.checkedNodesPositions.push({
                node: node2,
                pos
              });
            });
            _this.setUncontrolledState({
              checkedKeys: _checkedKeys
            }, false, {
              halfCheckedKeys: _halfCheckedKeys
            });
          }
          onCheck === null || onCheck === void 0 ? void 0 : onCheck(checkedObj, eventObj);
        };
        _this.onNodeLoad = function(treeNode) {
          var key = treeNode.key;
          var loadPromise = new Promise(function(resolve, reject) {
            _this.setState(function(_ref) {
              var _ref$loadedKeys = _ref.loadedKeys, loadedKeys = _ref$loadedKeys === void 0 ? [] : _ref$loadedKeys, _ref$loadingKeys = _ref.loadingKeys, loadingKeys = _ref$loadingKeys === void 0 ? [] : _ref$loadingKeys;
              var _this$props7 = _this.props, loadData = _this$props7.loadData, onLoad = _this$props7.onLoad;
              if (!loadData || loadedKeys.indexOf(key) !== -1 || loadingKeys.indexOf(key) !== -1) {
                return null;
              }
              var promise = loadData(treeNode);
              promise.then(function() {
                var currentLoadedKeys = _this.state.loadedKeys;
                var newLoadedKeys = arrAdd(currentLoadedKeys, key);
                onLoad === null || onLoad === void 0 ? void 0 : onLoad(newLoadedKeys, {
                  event: "load",
                  node: treeNode
                });
                _this.setUncontrolledState({
                  loadedKeys: newLoadedKeys
                });
                _this.setState(function(prevState) {
                  return {
                    loadingKeys: arrDel(prevState.loadingKeys, key)
                  };
                });
                resolve();
              }).catch(function(e2) {
                _this.setState(function(prevState) {
                  return {
                    loadingKeys: arrDel(prevState.loadingKeys, key)
                  };
                });
                _this.loadingRetryTimes[key] = (_this.loadingRetryTimes[key] || 0) + 1;
                if (_this.loadingRetryTimes[key] >= MAX_RETRY_TIMES) {
                  var currentLoadedKeys = _this.state.loadedKeys;
                  warningOnce(false, "Retry for `loadData` many times but still failed. No more retry.");
                  _this.setUncontrolledState({
                    loadedKeys: arrAdd(currentLoadedKeys, key)
                  });
                  resolve();
                }
                reject(e2);
              });
              return {
                loadingKeys: arrAdd(loadingKeys, key)
              };
            });
          });
          loadPromise.catch(function() {
          });
          return loadPromise;
        };
        _this.onNodeMouseEnter = function(event, node2) {
          var onMouseEnter = _this.props.onMouseEnter;
          onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter({
            event,
            node: node2
          });
        };
        _this.onNodeMouseLeave = function(event, node2) {
          var onMouseLeave = _this.props.onMouseLeave;
          onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave({
            event,
            node: node2
          });
        };
        _this.onNodeContextMenu = function(event, node2) {
          var onRightClick = _this.props.onRightClick;
          if (onRightClick) {
            event.preventDefault();
            onRightClick({
              event,
              node: node2
            });
          }
        };
        _this.onFocus = function() {
          var onFocus = _this.props.onFocus;
          _this.setState({
            focused: true
          });
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          onFocus === null || onFocus === void 0 ? void 0 : onFocus.apply(void 0, args);
        };
        _this.onBlur = function() {
          var onBlur = _this.props.onBlur;
          _this.setState({
            focused: false
          });
          _this.onActiveChange(null);
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }
          onBlur === null || onBlur === void 0 ? void 0 : onBlur.apply(void 0, args);
        };
        _this.getTreeNodeRequiredProps = function() {
          var _this$state8 = _this.state, expandedKeys = _this$state8.expandedKeys, selectedKeys = _this$state8.selectedKeys, loadedKeys = _this$state8.loadedKeys, loadingKeys = _this$state8.loadingKeys, checkedKeys = _this$state8.checkedKeys, halfCheckedKeys = _this$state8.halfCheckedKeys, dragOverNodeKey = _this$state8.dragOverNodeKey, dropPosition = _this$state8.dropPosition, keyEntities = _this$state8.keyEntities;
          return {
            expandedKeys: expandedKeys || [],
            selectedKeys: selectedKeys || [],
            loadedKeys: loadedKeys || [],
            loadingKeys: loadingKeys || [],
            checkedKeys: checkedKeys || [],
            halfCheckedKeys: halfCheckedKeys || [],
            dragOverNodeKey,
            dropPosition,
            keyEntities
          };
        };
        _this.setExpandedKeys = function(expandedKeys) {
          var _this$state9 = _this.state, treeData = _this$state9.treeData, fieldNames = _this$state9.fieldNames;
          var flattenNodes = flattenTreeData(treeData, expandedKeys, fieldNames);
          _this.setUncontrolledState({
            expandedKeys,
            flattenNodes
          }, true);
        };
        _this.onNodeExpand = function(e2, treeNode) {
          var expandedKeys = _this.state.expandedKeys;
          var _this$state10 = _this.state, listChanging = _this$state10.listChanging, fieldNames = _this$state10.fieldNames;
          var _this$props8 = _this.props, onExpand = _this$props8.onExpand, loadData = _this$props8.loadData;
          var expanded = treeNode.expanded;
          var key = treeNode[fieldNames.key];
          if (listChanging) {
            return;
          }
          var index2 = expandedKeys.indexOf(key);
          var targetExpanded = !expanded;
          warningOnce(expanded && index2 !== -1 || !expanded && index2 === -1, "Expand state not sync with index check");
          if (targetExpanded) {
            expandedKeys = arrAdd(expandedKeys, key);
          } else {
            expandedKeys = arrDel(expandedKeys, key);
          }
          _this.setExpandedKeys(expandedKeys);
          onExpand === null || onExpand === void 0 ? void 0 : onExpand(expandedKeys, {
            node: treeNode,
            expanded: targetExpanded,
            nativeEvent: e2.nativeEvent
          });
          if (targetExpanded && loadData) {
            var loadPromise = _this.onNodeLoad(treeNode);
            if (loadPromise) {
              loadPromise.then(function() {
                var newFlattenTreeData = flattenTreeData(_this.state.treeData, expandedKeys, fieldNames);
                _this.setUncontrolledState({
                  flattenNodes: newFlattenTreeData
                });
              }).catch(function() {
                var currentExpandedKeys = _this.state.expandedKeys;
                var expandedKeysToRestore = arrDel(currentExpandedKeys, key);
                _this.setExpandedKeys(expandedKeysToRestore);
              });
            }
          }
        };
        _this.onListChangeStart = function() {
          _this.setUncontrolledState({
            listChanging: true
          });
        };
        _this.onListChangeEnd = function() {
          setTimeout(function() {
            _this.setUncontrolledState({
              listChanging: false
            });
          });
        };
        _this.onActiveChange = function(newActiveKey) {
          var activeKey = _this.state.activeKey;
          var _this$props9 = _this.props, onActiveChange = _this$props9.onActiveChange, _this$props9$itemScro = _this$props9.itemScrollOffset, itemScrollOffset = _this$props9$itemScro === void 0 ? 0 : _this$props9$itemScro;
          if (activeKey === newActiveKey) {
            return;
          }
          _this.setState({
            activeKey: newActiveKey
          });
          if (newActiveKey !== null) {
            _this.scrollTo({
              key: newActiveKey,
              offset: itemScrollOffset
            });
          }
          onActiveChange === null || onActiveChange === void 0 ? void 0 : onActiveChange(newActiveKey);
        };
        _this.getActiveItem = function() {
          var _this$state11 = _this.state, activeKey = _this$state11.activeKey, flattenNodes = _this$state11.flattenNodes;
          if (activeKey === null) {
            return null;
          }
          return flattenNodes.find(function(_ref2) {
            var key = _ref2.key;
            return key === activeKey;
          }) || null;
        };
        _this.offsetActiveKey = function(offset2) {
          var _this$state12 = _this.state, flattenNodes = _this$state12.flattenNodes, activeKey = _this$state12.activeKey;
          var index2 = flattenNodes.findIndex(function(_ref3) {
            var key2 = _ref3.key;
            return key2 === activeKey;
          });
          if (index2 === -1 && offset2 < 0) {
            index2 = flattenNodes.length;
          }
          index2 = (index2 + offset2 + flattenNodes.length) % flattenNodes.length;
          var item = flattenNodes[index2];
          if (item) {
            var key = item.key;
            _this.onActiveChange(key);
          } else {
            _this.onActiveChange(null);
          }
        };
        _this.onKeyDown = function(event) {
          var _this$state13 = _this.state, activeKey = _this$state13.activeKey, expandedKeys = _this$state13.expandedKeys, checkedKeys = _this$state13.checkedKeys, fieldNames = _this$state13.fieldNames;
          var _this$props10 = _this.props, onKeyDown2 = _this$props10.onKeyDown, checkable = _this$props10.checkable, selectable = _this$props10.selectable;
          switch (event.which) {
            case KeyCode.UP: {
              _this.offsetActiveKey(-1);
              event.preventDefault();
              break;
            }
            case KeyCode.DOWN: {
              _this.offsetActiveKey(1);
              event.preventDefault();
              break;
            }
          }
          var activeItem = _this.getActiveItem();
          if (activeItem && activeItem.data) {
            var treeNodeRequiredProps = _this.getTreeNodeRequiredProps();
            var expandable = activeItem.data.isLeaf === false || !!(activeItem.data[fieldNames.children] || []).length;
            var eventNode = convertNodePropsToEventData(_objectSpread2(_objectSpread2({}, getTreeNodeProps(activeKey, treeNodeRequiredProps)), {}, {
              data: activeItem.data,
              active: true
            }));
            switch (event.which) {
              case KeyCode.LEFT: {
                if (expandable && expandedKeys.includes(activeKey)) {
                  _this.onNodeExpand({}, eventNode);
                } else if (activeItem.parent) {
                  _this.onActiveChange(activeItem.parent.key);
                }
                event.preventDefault();
                break;
              }
              case KeyCode.RIGHT: {
                if (expandable && !expandedKeys.includes(activeKey)) {
                  _this.onNodeExpand({}, eventNode);
                } else if (activeItem.children && activeItem.children.length) {
                  _this.onActiveChange(activeItem.children[0].key);
                }
                event.preventDefault();
                break;
              }
              case KeyCode.ENTER:
              case KeyCode.SPACE: {
                if (checkable && !eventNode.disabled && eventNode.checkable !== false && !eventNode.disableCheckbox) {
                  _this.onNodeCheck({}, eventNode, !checkedKeys.includes(activeKey));
                } else if (!checkable && selectable && !eventNode.disabled && eventNode.selectable !== false) {
                  _this.onNodeSelect({}, eventNode);
                }
                break;
              }
            }
          }
          onKeyDown2 === null || onKeyDown2 === void 0 ? void 0 : onKeyDown2(event);
        };
        _this.setUncontrolledState = function(state) {
          var atomic = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var forceState = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          if (!_this.destroyed) {
            var needSync = false;
            var allPassed = true;
            var newState = {};
            Object.keys(state).forEach(function(name) {
              if (name in _this.props) {
                allPassed = false;
                return;
              }
              needSync = true;
              newState[name] = state[name];
            });
            if (needSync && (!atomic || allPassed)) {
              _this.setState(_objectSpread2(_objectSpread2({}, newState), forceState));
            }
          }
        };
        _this.scrollTo = function(scroll) {
          _this.listRef.current.scrollTo(scroll);
        };
        return _this;
      }
      _createClass(Tree2, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          this.destroyed = false;
          this.onUpdated();
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate() {
          this.onUpdated();
        }
      }, {
        key: "onUpdated",
        value: function onUpdated() {
          var _this$props11 = this.props, activeKey = _this$props11.activeKey, _this$props11$itemScr = _this$props11.itemScrollOffset, itemScrollOffset = _this$props11$itemScr === void 0 ? 0 : _this$props11$itemScr;
          if (activeKey !== void 0 && activeKey !== this.state.activeKey) {
            this.setState({
              activeKey
            });
            if (activeKey !== null) {
              this.scrollTo({
                key: activeKey,
                offset: itemScrollOffset
              });
            }
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          window.removeEventListener("dragend", this.onWindowDragEnd);
          this.destroyed = true;
        }
      }, {
        key: "resetDragState",
        value: function resetDragState() {
          this.setState({
            dragOverNodeKey: null,
            dropPosition: null,
            dropLevelOffset: null,
            dropTargetKey: null,
            dropContainerKey: null,
            dropTargetPos: null,
            dropAllowed: false
          });
        }
      }, {
        key: "render",
        value: function render2() {
          var _classNames;
          var _this$state14 = this.state, focused = _this$state14.focused, flattenNodes = _this$state14.flattenNodes, keyEntities = _this$state14.keyEntities, draggingNodeKey = _this$state14.draggingNodeKey, activeKey = _this$state14.activeKey, dropLevelOffset = _this$state14.dropLevelOffset, dropContainerKey = _this$state14.dropContainerKey, dropTargetKey = _this$state14.dropTargetKey, dropPosition = _this$state14.dropPosition, dragOverNodeKey = _this$state14.dragOverNodeKey, indent = _this$state14.indent;
          var _this$props12 = this.props, prefixCls = _this$props12.prefixCls, className = _this$props12.className, style2 = _this$props12.style, showLine = _this$props12.showLine, focusable2 = _this$props12.focusable, _this$props12$tabInde = _this$props12.tabIndex, tabIndex = _this$props12$tabInde === void 0 ? 0 : _this$props12$tabInde, selectable = _this$props12.selectable, showIcon = _this$props12.showIcon, icon = _this$props12.icon, switcherIcon = _this$props12.switcherIcon, draggable = _this$props12.draggable, checkable = _this$props12.checkable, checkStrictly = _this$props12.checkStrictly, disabled = _this$props12.disabled, motion = _this$props12.motion, loadData = _this$props12.loadData, filterTreeNode = _this$props12.filterTreeNode, height = _this$props12.height, itemHeight = _this$props12.itemHeight, virtual = _this$props12.virtual, titleRender = _this$props12.titleRender, dropIndicatorRender2 = _this$props12.dropIndicatorRender, onContextMenu = _this$props12.onContextMenu, onScroll = _this$props12.onScroll, direction = _this$props12.direction, rootClassName = _this$props12.rootClassName, rootStyle = _this$props12.rootStyle;
          var domProps = pickAttrs(this.props, {
            aria: true,
            data: true
          });
          var draggableConfig;
          if (draggable) {
            if (_typeof(draggable) === "object") {
              draggableConfig = draggable;
            } else if (typeof draggable === "function") {
              draggableConfig = {
                nodeDraggable: draggable
              };
            } else {
              draggableConfig = {};
            }
          }
          return /* @__PURE__ */ reactExports.createElement(TreeContext.Provider, {
            value: {
              prefixCls,
              selectable,
              showIcon,
              icon,
              switcherIcon,
              draggable: draggableConfig,
              draggingNodeKey,
              checkable,
              checkStrictly,
              disabled,
              keyEntities,
              dropLevelOffset,
              dropContainerKey,
              dropTargetKey,
              dropPosition,
              dragOverNodeKey,
              indent,
              direction,
              dropIndicatorRender: dropIndicatorRender2,
              loadData,
              filterTreeNode,
              titleRender,
              onNodeClick: this.onNodeClick,
              onNodeDoubleClick: this.onNodeDoubleClick,
              onNodeExpand: this.onNodeExpand,
              onNodeSelect: this.onNodeSelect,
              onNodeCheck: this.onNodeCheck,
              onNodeLoad: this.onNodeLoad,
              onNodeMouseEnter: this.onNodeMouseEnter,
              onNodeMouseLeave: this.onNodeMouseLeave,
              onNodeContextMenu: this.onNodeContextMenu,
              onNodeDragStart: this.onNodeDragStart,
              onNodeDragEnter: this.onNodeDragEnter,
              onNodeDragOver: this.onNodeDragOver,
              onNodeDragLeave: this.onNodeDragLeave,
              onNodeDragEnd: this.onNodeDragEnd,
              onNodeDrop: this.onNodeDrop
            }
          }, /* @__PURE__ */ reactExports.createElement("div", {
            role: "tree",
            className: classNames(prefixCls, className, rootClassName, (_classNames = {}, _defineProperty(_classNames, "".concat(prefixCls, "-show-line"), showLine), _defineProperty(_classNames, "".concat(prefixCls, "-focused"), focused), _defineProperty(_classNames, "".concat(prefixCls, "-active-focused"), activeKey !== null), _classNames)),
            style: rootStyle
          }, /* @__PURE__ */ reactExports.createElement(NodeList, _extends$1({
            ref: this.listRef,
            prefixCls,
            style: style2,
            data: flattenNodes,
            disabled,
            selectable,
            checkable: !!checkable,
            motion,
            dragging: draggingNodeKey !== null,
            height,
            itemHeight,
            virtual,
            focusable: focusable2,
            focused,
            tabIndex,
            activeItem: this.getActiveItem(),
            onFocus: this.onFocus,
            onBlur: this.onBlur,
            onKeyDown: this.onKeyDown,
            onActiveChange: this.onActiveChange,
            onListChangeStart: this.onListChangeStart,
            onListChangeEnd: this.onListChangeEnd,
            onContextMenu,
            onScroll
          }, this.getTreeNodeRequiredProps(), domProps))));
        }
      }], [{
        key: "getDerivedStateFromProps",
        value: function getDerivedStateFromProps(props, prevState) {
          var prevProps = prevState.prevProps;
          var newState = {
            prevProps: props
          };
          function needSync(name) {
            return !prevProps && name in props || prevProps && prevProps[name] !== props[name];
          }
          var treeData;
          var fieldNames = prevState.fieldNames;
          if (needSync("fieldNames")) {
            fieldNames = fillFieldNames(props.fieldNames);
            newState.fieldNames = fieldNames;
          }
          if (needSync("treeData")) {
            treeData = props.treeData;
          } else if (needSync("children")) {
            warningOnce(false, "`children` of Tree is deprecated. Please use `treeData` instead.");
            treeData = convertTreeToData(props.children);
          }
          if (treeData) {
            newState.treeData = treeData;
            var entitiesMap = convertDataToEntities(treeData, {
              fieldNames
            });
            newState.keyEntities = _objectSpread2(_defineProperty({}, MOTION_KEY, MotionEntity), entitiesMap.keyEntities);
          }
          var keyEntities = newState.keyEntities || prevState.keyEntities;
          if (needSync("expandedKeys") || prevProps && needSync("autoExpandParent")) {
            newState.expandedKeys = props.autoExpandParent || !prevProps && props.defaultExpandParent ? conductExpandParent(props.expandedKeys, keyEntities) : props.expandedKeys;
          } else if (!prevProps && props.defaultExpandAll) {
            var cloneKeyEntities = _objectSpread2({}, keyEntities);
            delete cloneKeyEntities[MOTION_KEY];
            newState.expandedKeys = Object.keys(cloneKeyEntities).map(function(key) {
              return cloneKeyEntities[key].key;
            });
          } else if (!prevProps && props.defaultExpandedKeys) {
            newState.expandedKeys = props.autoExpandParent || props.defaultExpandParent ? conductExpandParent(props.defaultExpandedKeys, keyEntities) : props.defaultExpandedKeys;
          }
          if (!newState.expandedKeys) {
            delete newState.expandedKeys;
          }
          if (treeData || newState.expandedKeys) {
            var flattenNodes = flattenTreeData(treeData || prevState.treeData, newState.expandedKeys || prevState.expandedKeys, fieldNames);
            newState.flattenNodes = flattenNodes;
          }
          if (props.selectable) {
            if (needSync("selectedKeys")) {
              newState.selectedKeys = calcSelectedKeys(props.selectedKeys, props);
            } else if (!prevProps && props.defaultSelectedKeys) {
              newState.selectedKeys = calcSelectedKeys(props.defaultSelectedKeys, props);
            }
          }
          if (props.checkable) {
            var checkedKeyEntity;
            if (needSync("checkedKeys")) {
              checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {};
            } else if (!prevProps && props.defaultCheckedKeys) {
              checkedKeyEntity = parseCheckedKeys(props.defaultCheckedKeys) || {};
            } else if (treeData) {
              checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {
                checkedKeys: prevState.checkedKeys,
                halfCheckedKeys: prevState.halfCheckedKeys
              };
            }
            if (checkedKeyEntity) {
              var _checkedKeyEntity = checkedKeyEntity, _checkedKeyEntity$che = _checkedKeyEntity.checkedKeys, checkedKeys = _checkedKeyEntity$che === void 0 ? [] : _checkedKeyEntity$che, _checkedKeyEntity$hal = _checkedKeyEntity.halfCheckedKeys, halfCheckedKeys = _checkedKeyEntity$hal === void 0 ? [] : _checkedKeyEntity$hal;
              if (!props.checkStrictly) {
                var conductKeys = conductCheck(checkedKeys, true, keyEntities);
                checkedKeys = conductKeys.checkedKeys;
                halfCheckedKeys = conductKeys.halfCheckedKeys;
              }
              newState.checkedKeys = checkedKeys;
              newState.halfCheckedKeys = halfCheckedKeys;
            }
          }
          if (needSync("loadedKeys")) {
            newState.loadedKeys = props.loadedKeys;
          }
          return newState;
        }
      }]);
      return Tree2;
    }(reactExports.Component);
    Tree$3.defaultProps = {
      prefixCls: "rc-tree",
      showLine: false,
      showIcon: true,
      selectable: true,
      multiple: false,
      checkable: false,
      disabled: false,
      checkStrictly: false,
      draggable: false,
      defaultExpandParent: true,
      autoExpandParent: false,
      defaultExpandAll: false,
      defaultExpandedKeys: [],
      defaultCheckedKeys: [],
      defaultSelectedKeys: [],
      dropIndicatorRender: DropIndicator,
      allowDrop: function allowDrop() {
        return true;
      },
      expandAction: false
    };
    Tree$3.TreeNode = ContextTreeNode;
    var FileOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494z" } }] }, "name": "file", "theme": "outlined" };
    const FileOutlinedSvg = FileOutlined$2;
    var FileOutlined = function FileOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: FileOutlinedSvg
      }));
    };
    const FileOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(FileOutlined);
    var FolderOpenOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M928 444H820V330.4c0-17.7-14.3-32-32-32H473L355.7 186.2a8.15 8.15 0 00-5.5-2.2H96c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h698c13 0 24.8-7.9 29.7-20l134-332c1.5-3.8 2.3-7.9 2.3-12 0-17.7-14.3-32-32-32zM136 256h188.5l119.6 114.4H748V444H238c-13 0-24.8 7.9-29.7 20L136 643.2V256zm635.3 512H159l103.3-256h612.4L771.3 768z" } }] }, "name": "folder-open", "theme": "outlined" };
    const FolderOpenOutlinedSvg = FolderOpenOutlined$2;
    var FolderOpenOutlined = function FolderOpenOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: FolderOpenOutlinedSvg
      }));
    };
    const FolderOpenOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(FolderOpenOutlined);
    var FolderOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M880 298.4H521L403.7 186.2a8.15 8.15 0 00-5.5-2.2H144c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V330.4c0-17.7-14.3-32-32-32zM840 768H184V256h188.5l119.6 114.4H840V768z" } }] }, "name": "folder", "theme": "outlined" };
    const FolderOutlinedSvg = FolderOutlined$2;
    var FolderOutlined = function FolderOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: FolderOutlinedSvg
      }));
    };
    const FolderOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(FolderOutlined);
    var HolderOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M300 276.5a56 56 0 1056-97 56 56 0 00-56 97zm0 284a56 56 0 1056-97 56 56 0 00-56 97zM640 228a56 56 0 10112 0 56 56 0 00-112 0zm0 284a56 56 0 10112 0 56 56 0 00-112 0zM300 844.5a56 56 0 1056-97 56 56 0 00-56 97zM640 796a56 56 0 10112 0 56 56 0 00-112 0z" } }] }, "name": "holder", "theme": "outlined" };
    const HolderOutlinedSvg = HolderOutlined$2;
    var HolderOutlined = function HolderOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: HolderOutlinedSvg
      }));
    };
    const HolderOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(HolderOutlined);
    const treeNodeFX = new Keyframe("ant-tree-node-fx-do-not-use", {
      "0%": {
        opacity: 0
      },
      "100%": {
        opacity: 1
      }
    });
    const getSwitchStyle = (prefixCls, token2) => ({
      [`.${prefixCls}-switcher-icon`]: {
        display: "inline-block",
        fontSize: 10,
        verticalAlign: "baseline",
        svg: {
          transition: `transform ${token2.motionDurationSlow}`
        }
      }
    });
    const getDropIndicatorStyle = (prefixCls, token2) => ({
      [`.${prefixCls}-drop-indicator`]: {
        position: "absolute",
        // it should displayed over the following node
        zIndex: 1,
        height: 2,
        backgroundColor: token2.colorPrimary,
        borderRadius: 1,
        pointerEvents: "none",
        "&:after": {
          position: "absolute",
          top: -3,
          insetInlineStart: -6,
          width: 8,
          height: 8,
          backgroundColor: "transparent",
          border: `${unit$1(token2.lineWidthBold)} solid ${token2.colorPrimary}`,
          borderRadius: "50%",
          content: '""'
        }
      }
    });
    const genBaseStyle$1 = (prefixCls, token2) => {
      const {
        treeCls,
        treeNodeCls,
        treeNodePadding,
        titleHeight,
        nodeSelectedBg,
        nodeHoverBg
      } = token2;
      const treeCheckBoxMarginHorizontal = token2.paddingXS;
      return {
        [treeCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
          background: token2.colorBgContainer,
          borderRadius: token2.borderRadius,
          transition: `background-color ${token2.motionDurationSlow}`,
          [`&${treeCls}-rtl`]: {
            // >>> Switcher
            [`${treeCls}-switcher`]: {
              "&_close": {
                [`${treeCls}-switcher-icon`]: {
                  svg: {
                    transform: "rotate(90deg)"
                  }
                }
              }
            }
          },
          [`&-focused:not(:hover):not(${treeCls}-active-focused)`]: Object.assign({}, genFocusOutline(token2)),
          // =================== Virtual List ===================
          [`${treeCls}-list-holder-inner`]: {
            alignItems: "flex-start"
          },
          [`&${treeCls}-block-node`]: {
            [`${treeCls}-list-holder-inner`]: {
              alignItems: "stretch",
              // >>> Title
              [`${treeCls}-node-content-wrapper`]: {
                flex: "auto"
              },
              // >>> Drag
              [`${treeNodeCls}.dragging`]: {
                position: "relative",
                "&:after": {
                  position: "absolute",
                  top: 0,
                  insetInlineEnd: 0,
                  bottom: treeNodePadding,
                  insetInlineStart: 0,
                  border: `1px solid ${token2.colorPrimary}`,
                  opacity: 0,
                  animationName: treeNodeFX,
                  animationDuration: token2.motionDurationSlow,
                  animationPlayState: "running",
                  animationFillMode: "forwards",
                  content: '""',
                  pointerEvents: "none"
                }
              }
            }
          },
          // ===================== TreeNode =====================
          [`${treeNodeCls}`]: {
            display: "flex",
            alignItems: "flex-start",
            padding: `0 0 ${unit$1(treeNodePadding)} 0`,
            outline: "none",
            "&-rtl": {
              direction: "rtl"
            },
            // Disabled
            "&-disabled": {
              // >>> Title
              [`${treeCls}-node-content-wrapper`]: {
                color: token2.colorTextDisabled,
                cursor: "not-allowed",
                "&:hover": {
                  background: "transparent"
                }
              }
            },
            [`&-active ${treeCls}-node-content-wrapper`]: Object.assign({}, genFocusOutline(token2)),
            [`&:not(${treeNodeCls}-disabled).filter-node ${treeCls}-title`]: {
              color: "inherit",
              fontWeight: 500
            },
            "&-draggable": {
              [`${treeCls}-draggable-icon`]: {
                // https://github.com/ant-design/ant-design/issues/41915
                flexShrink: 0,
                width: titleHeight,
                lineHeight: `${unit$1(titleHeight)}`,
                textAlign: "center",
                visibility: "visible",
                opacity: 0.2,
                transition: `opacity ${token2.motionDurationSlow}`,
                [`${treeNodeCls}:hover &`]: {
                  opacity: 0.45
                }
              },
              [`&${treeNodeCls}-disabled`]: {
                [`${treeCls}-draggable-icon`]: {
                  visibility: "hidden"
                }
              }
            }
          },
          // >>> Indent
          [`${treeCls}-indent`]: {
            alignSelf: "stretch",
            whiteSpace: "nowrap",
            userSelect: "none",
            "&-unit": {
              display: "inline-block",
              width: titleHeight
            }
          },
          // >>> Drag Handler
          [`${treeCls}-draggable-icon`]: {
            visibility: "hidden"
          },
          // >>> Switcher
          [`${treeCls}-switcher`]: Object.assign(Object.assign({}, getSwitchStyle(prefixCls, token2)), {
            position: "relative",
            flex: "none",
            alignSelf: "stretch",
            width: titleHeight,
            margin: 0,
            lineHeight: `${unit$1(titleHeight)}`,
            textAlign: "center",
            cursor: "pointer",
            userSelect: "none",
            "&-noop": {
              cursor: "default"
            },
            "&_close": {
              [`${treeCls}-switcher-icon`]: {
                svg: {
                  transform: "rotate(-90deg)"
                }
              }
            },
            "&-loading-icon": {
              color: token2.colorPrimary
            },
            "&-leaf-line": {
              position: "relative",
              zIndex: 1,
              display: "inline-block",
              width: "100%",
              height: "100%",
              // https://github.com/ant-design/ant-design/issues/31884
              "&:before": {
                position: "absolute",
                top: 0,
                insetInlineEnd: token2.calc(titleHeight).div(2).equal(),
                bottom: token2.calc(treeNodePadding).mul(-1).equal(),
                marginInlineStart: -1,
                borderInlineEnd: `1px solid ${token2.colorBorder}`,
                content: '""'
              },
              "&:after": {
                position: "absolute",
                width: token2.calc(token2.calc(titleHeight).div(2).equal()).mul(0.8).equal(),
                height: token2.calc(titleHeight).div(2).equal(),
                borderBottom: `1px solid ${token2.colorBorder}`,
                content: '""'
              }
            }
          }),
          // >>> Checkbox
          [`${treeCls}-checkbox`]: {
            top: "initial",
            marginInlineEnd: treeCheckBoxMarginHorizontal,
            alignSelf: "flex-start",
            marginTop: token2.marginXXS
          },
          // >>> Title
          // add `${treeCls}-checkbox + span` to cover checkbox `${checkboxCls} + span`
          [`${treeCls}-node-content-wrapper, ${treeCls}-checkbox + span`]: {
            position: "relative",
            zIndex: "auto",
            minHeight: titleHeight,
            margin: 0,
            padding: `0 ${unit$1(token2.calc(token2.paddingXS).div(2).equal())}`,
            color: "inherit",
            lineHeight: `${unit$1(titleHeight)}`,
            background: "transparent",
            borderRadius: token2.borderRadius,
            cursor: "pointer",
            transition: `all ${token2.motionDurationMid}, border 0s, line-height 0s, box-shadow 0s`,
            "&:hover": {
              backgroundColor: nodeHoverBg
            },
            [`&${treeCls}-node-selected`]: {
              backgroundColor: nodeSelectedBg
            },
            // Icon
            [`${treeCls}-iconEle`]: {
              display: "inline-block",
              width: titleHeight,
              height: titleHeight,
              lineHeight: `${unit$1(titleHeight)}`,
              textAlign: "center",
              verticalAlign: "top",
              "&:empty": {
                display: "none"
              }
            }
          },
          // https://github.com/ant-design/ant-design/issues/28217
          [`${treeCls}-unselectable ${treeCls}-node-content-wrapper:hover`]: {
            backgroundColor: "transparent"
          },
          // ==================== Draggable =====================
          [`${treeCls}-node-content-wrapper`]: Object.assign({
            lineHeight: `${unit$1(titleHeight)}`,
            userSelect: "none"
          }, getDropIndicatorStyle(prefixCls, token2)),
          [`${treeNodeCls}.drop-container`]: {
            "> [draggable]": {
              boxShadow: `0 0 0 2px ${token2.colorPrimary}`
            }
          },
          // ==================== Show Line =====================
          "&-show-line": {
            // ================ Indent lines ================
            [`${treeCls}-indent`]: {
              "&-unit": {
                position: "relative",
                height: "100%",
                "&:before": {
                  position: "absolute",
                  top: 0,
                  insetInlineEnd: token2.calc(titleHeight).div(2).equal(),
                  bottom: token2.calc(treeNodePadding).mul(-1).equal(),
                  borderInlineEnd: `1px solid ${token2.colorBorder}`,
                  content: '""'
                },
                "&-end": {
                  "&:before": {
                    display: "none"
                  }
                }
              }
            },
            // ============== Cover Background ==============
            [`${treeCls}-switcher`]: {
              background: "transparent",
              "&-line-icon": {
                // https://github.com/ant-design/ant-design/issues/32813
                verticalAlign: "-0.15em"
              }
            }
          },
          [`${treeNodeCls}-leaf-last`]: {
            [`${treeCls}-switcher`]: {
              "&-leaf-line": {
                "&:before": {
                  top: "auto !important",
                  bottom: "auto !important",
                  height: `${unit$1(token2.calc(titleHeight).div(2).equal())} !important`
                }
              }
            }
          }
        })
      };
    };
    const genDirectoryStyle = (token2) => {
      const {
        treeCls,
        treeNodeCls,
        treeNodePadding,
        directoryNodeSelectedBg,
        directoryNodeSelectedColor
      } = token2;
      return {
        [`${treeCls}${treeCls}-directory`]: {
          // ================== TreeNode ==================
          [treeNodeCls]: {
            position: "relative",
            // Hover color
            "&:before": {
              position: "absolute",
              top: 0,
              insetInlineEnd: 0,
              bottom: treeNodePadding,
              insetInlineStart: 0,
              transition: `background-color ${token2.motionDurationMid}`,
              content: '""',
              pointerEvents: "none"
            },
            "&:hover": {
              "&:before": {
                background: token2.controlItemBgHover
              }
            },
            // Elements
            "> *": {
              zIndex: 1
            },
            // >>> Switcher
            [`${treeCls}-switcher`]: {
              transition: `color ${token2.motionDurationMid}`
            },
            // >>> Title
            [`${treeCls}-node-content-wrapper`]: {
              borderRadius: 0,
              userSelect: "none",
              "&:hover": {
                background: "transparent"
              },
              [`&${treeCls}-node-selected`]: {
                color: directoryNodeSelectedColor,
                background: "transparent"
              }
            },
            // ============= Selected =============
            "&-selected": {
              [`
            &:hover::before,
            &::before
          `]: {
                background: directoryNodeSelectedBg
              },
              // >>> Switcher
              [`${treeCls}-switcher`]: {
                color: directoryNodeSelectedColor
              },
              // >>> Title
              [`${treeCls}-node-content-wrapper`]: {
                color: directoryNodeSelectedColor,
                background: "transparent"
              }
            }
          }
        }
      };
    };
    const genTreeStyle = (prefixCls, token2) => {
      const treeCls = `.${prefixCls}`;
      const treeNodeCls = `${treeCls}-treenode`;
      const treeNodePadding = token2.calc(token2.paddingXS).div(2).equal();
      const treeToken = merge$1(token2, {
        treeCls,
        treeNodeCls,
        treeNodePadding
      });
      return [
        // Basic
        genBaseStyle$1(prefixCls, treeToken),
        // Directory
        genDirectoryStyle(treeToken)
      ];
    };
    const initComponentToken = (token2) => {
      const {
        controlHeightSM
      } = token2;
      return {
        titleHeight: controlHeightSM,
        nodeHoverBg: token2.controlItemBgHover,
        nodeSelectedBg: token2.controlItemBgActive
      };
    };
    const prepareComponentToken$2 = (token2) => {
      const {
        colorTextLightSolid,
        colorPrimary
      } = token2;
      return Object.assign(Object.assign({}, initComponentToken(token2)), {
        directoryNodeSelectedColor: colorTextLightSolid,
        directoryNodeSelectedBg: colorPrimary
      });
    };
    const useStyle$2 = genStyleHooks("Tree", (token2, _ref) => {
      let {
        prefixCls
      } = _ref;
      return [{
        [token2.componentCls]: getStyle(`${prefixCls}-checkbox`, token2)
      }, genTreeStyle(prefixCls, token2), genCollapseMotion$1(token2)];
    }, prepareComponentToken$2);
    const offset$1 = 4;
    function dropIndicatorRender(props) {
      const {
        dropPosition,
        dropLevelOffset,
        prefixCls,
        indent,
        direction = "ltr"
      } = props;
      const startPosition = direction === "ltr" ? "left" : "right";
      const endPosition = direction === "ltr" ? "right" : "left";
      const style2 = {
        [startPosition]: -dropLevelOffset * indent + offset$1,
        [endPosition]: 0
      };
      switch (dropPosition) {
        case -1:
          style2.top = -3;
          break;
        case 1:
          style2.bottom = -3;
          break;
        default:
          style2.bottom = -3;
          style2[startPosition] = indent + offset$1;
          break;
      }
      return /* @__PURE__ */ React.createElement("div", {
        style: style2,
        className: `${prefixCls}-drop-indicator`
      });
    }
    var CaretDownFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, "name": "caret-down", "theme": "filled" };
    const CaretDownFilledSvg = CaretDownFilled$2;
    var CaretDownFilled = function CaretDownFilled2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: CaretDownFilledSvg
      }));
    };
    const CaretDownFilled$1 = /* @__PURE__ */ reactExports.forwardRef(CaretDownFilled);
    var MinusSquareOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M328 544h368c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { "tag": "path", "attrs": { "d": "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, "name": "minus-square", "theme": "outlined" };
    const MinusSquareOutlinedSvg = MinusSquareOutlined$2;
    var MinusSquareOutlined = function MinusSquareOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: MinusSquareOutlinedSvg
      }));
    };
    const MinusSquareOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(MinusSquareOutlined);
    var PlusSquareOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M328 544h152v152c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V544h152c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H544V328c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v152H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { "tag": "path", "attrs": { "d": "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, "name": "plus-square", "theme": "outlined" };
    const PlusSquareOutlinedSvg = PlusSquareOutlined$2;
    var PlusSquareOutlined = function PlusSquareOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: PlusSquareOutlinedSvg
      }));
    };
    const PlusSquareOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(PlusSquareOutlined);
    const SwitcherIconCom = (props) => {
      const {
        prefixCls,
        switcherIcon,
        treeNodeProps,
        showLine
      } = props;
      const {
        isLeaf,
        expanded,
        loading
      } = treeNodeProps;
      if (loading) {
        return /* @__PURE__ */ reactExports.createElement(LoadingOutlined$1, {
          className: `${prefixCls}-switcher-loading-icon`
        });
      }
      let showLeafIcon;
      if (showLine && typeof showLine === "object") {
        showLeafIcon = showLine.showLeafIcon;
      }
      if (isLeaf) {
        if (!showLine) {
          return null;
        }
        if (typeof showLeafIcon !== "boolean" && !!showLeafIcon) {
          const leafIcon = typeof showLeafIcon === "function" ? showLeafIcon(treeNodeProps) : showLeafIcon;
          const leafCls = `${prefixCls}-switcher-line-custom-icon`;
          if (isValidElement(leafIcon)) {
            return cloneElement(leafIcon, {
              className: classNames(leafIcon.props.className || "", leafCls)
            });
          }
          return leafIcon;
        }
        return showLeafIcon ? /* @__PURE__ */ reactExports.createElement(FileOutlined$1, {
          className: `${prefixCls}-switcher-line-icon`
        }) : /* @__PURE__ */ reactExports.createElement("span", {
          className: `${prefixCls}-switcher-leaf-line`
        });
      }
      const switcherCls = `${prefixCls}-switcher-icon`;
      const switcher = typeof switcherIcon === "function" ? switcherIcon(treeNodeProps) : switcherIcon;
      if (isValidElement(switcher)) {
        return cloneElement(switcher, {
          className: classNames(switcher.props.className || "", switcherCls)
        });
      }
      if (switcher !== void 0) {
        return switcher;
      }
      if (showLine) {
        return expanded ? /* @__PURE__ */ reactExports.createElement(MinusSquareOutlined$1, {
          className: `${prefixCls}-switcher-line-icon`
        }) : /* @__PURE__ */ reactExports.createElement(PlusSquareOutlined$1, {
          className: `${prefixCls}-switcher-line-icon`
        });
      }
      return /* @__PURE__ */ reactExports.createElement(CaretDownFilled$1, {
        className: switcherCls
      });
    };
    const SwitcherIconCom$1 = SwitcherIconCom;
    const Tree$2 = /* @__PURE__ */ React.forwardRef((props, ref) => {
      const {
        getPrefixCls,
        direction,
        virtual,
        tree
      } = React.useContext(ConfigContext);
      const {
        prefixCls: customizePrefixCls,
        className,
        showIcon = false,
        showLine,
        switcherIcon,
        blockNode = false,
        children,
        checkable = false,
        selectable = true,
        draggable,
        motion: customMotion,
        style: style2
      } = props;
      const prefixCls = getPrefixCls("tree", customizePrefixCls);
      const rootPrefixCls = getPrefixCls();
      const motion = customMotion !== null && customMotion !== void 0 ? customMotion : Object.assign(Object.assign({}, initCollapseMotion(rootPrefixCls)), {
        motionAppear: false
      });
      const newProps = Object.assign(Object.assign({}, props), {
        checkable,
        selectable,
        showIcon,
        motion,
        blockNode,
        showLine: Boolean(showLine),
        dropIndicatorRender
      });
      const [wrapCSSVar, hashId] = useStyle$2(prefixCls);
      const draggableConfig = React.useMemo(() => {
        if (!draggable) {
          return false;
        }
        let mergedDraggable = {};
        switch (typeof draggable) {
          case "function":
            mergedDraggable.nodeDraggable = draggable;
            break;
          case "object":
            mergedDraggable = Object.assign({}, draggable);
            break;
        }
        if (mergedDraggable.icon !== false) {
          mergedDraggable.icon = mergedDraggable.icon || /* @__PURE__ */ React.createElement(HolderOutlined$1, null);
        }
        return mergedDraggable;
      }, [draggable]);
      const renderSwitcherIcon = (nodeProps) => /* @__PURE__ */ React.createElement(SwitcherIconCom$1, {
        prefixCls,
        switcherIcon,
        treeNodeProps: nodeProps,
        showLine
      });
      return wrapCSSVar(/* @__PURE__ */ React.createElement(Tree$3, Object.assign({
        itemHeight: 20,
        ref,
        virtual
      }, newProps, {
        // newProps may contain style so declare style below it
        style: Object.assign(Object.assign({}, tree === null || tree === void 0 ? void 0 : tree.style), style2),
        prefixCls,
        className: classNames({
          [`${prefixCls}-icon-hide`]: !showIcon,
          [`${prefixCls}-block-node`]: blockNode,
          [`${prefixCls}-unselectable`]: !selectable,
          [`${prefixCls}-rtl`]: direction === "rtl"
        }, tree === null || tree === void 0 ? void 0 : tree.className, className, hashId),
        direction,
        checkable: checkable ? /* @__PURE__ */ React.createElement("span", {
          className: `${prefixCls}-checkbox-inner`
        }) : checkable,
        selectable,
        switcherIcon: renderSwitcherIcon,
        draggable: draggableConfig
      }), children));
    });
    const TreePure = Tree$2;
    var Record;
    (function(Record2) {
      Record2[Record2["None"] = 0] = "None";
      Record2[Record2["Start"] = 1] = "Start";
      Record2[Record2["End"] = 2] = "End";
    })(Record || (Record = {}));
    function traverseNodesKey(treeData, callback, fieldNames) {
      const {
        key: fieldKey,
        children: fieldChildren
      } = fieldNames;
      function processNode(dataNode) {
        const key = dataNode[fieldKey];
        const children = dataNode[fieldChildren];
        if (callback(key, dataNode) !== false) {
          traverseNodesKey(children || [], callback, fieldNames);
        }
      }
      treeData.forEach(processNode);
    }
    function calcRangeKeys(_ref) {
      let {
        treeData,
        expandedKeys,
        startKey,
        endKey,
        fieldNames
      } = _ref;
      const keys2 = [];
      let record = Record.None;
      if (startKey && startKey === endKey) {
        return [startKey];
      }
      if (!startKey || !endKey) {
        return [];
      }
      function matchKey(key) {
        return key === startKey || key === endKey;
      }
      traverseNodesKey(treeData, (key) => {
        if (record === Record.End) {
          return false;
        }
        if (matchKey(key)) {
          keys2.push(key);
          if (record === Record.None) {
            record = Record.Start;
          } else if (record === Record.Start) {
            record = Record.End;
            return false;
          }
        } else if (record === Record.Start) {
          keys2.push(key);
        }
        return expandedKeys.includes(key);
      }, fillFieldNames(fieldNames));
      return keys2;
    }
    function convertDirectoryKeysToNodes(treeData, keys2, fieldNames) {
      const restKeys = _toConsumableArray(keys2);
      const nodes = [];
      traverseNodesKey(treeData, (key, node2) => {
        const index2 = restKeys.indexOf(key);
        if (index2 !== -1) {
          nodes.push(node2);
          restKeys.splice(index2, 1);
        }
        return !!restKeys.length;
      }, fillFieldNames(fieldNames));
      return nodes;
    }
    var __rest$2 = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    function getIcon(props) {
      const {
        isLeaf,
        expanded
      } = props;
      if (isLeaf) {
        return /* @__PURE__ */ reactExports.createElement(FileOutlined$1, null);
      }
      return expanded ? /* @__PURE__ */ reactExports.createElement(FolderOpenOutlined$1, null) : /* @__PURE__ */ reactExports.createElement(FolderOutlined$1, null);
    }
    function getTreeData(_ref) {
      let {
        treeData,
        children
      } = _ref;
      return treeData || convertTreeToData(children);
    }
    const DirectoryTree = (_a, ref) => {
      var {
        defaultExpandAll,
        defaultExpandParent,
        defaultExpandedKeys
      } = _a, props = __rest$2(_a, ["defaultExpandAll", "defaultExpandParent", "defaultExpandedKeys"]);
      const lastSelectedKey = reactExports.useRef();
      const cachedSelectedKeys = reactExports.useRef();
      const getInitExpandedKeys = () => {
        const {
          keyEntities
        } = convertDataToEntities(getTreeData(props));
        let initExpandedKeys;
        if (defaultExpandAll) {
          initExpandedKeys = Object.keys(keyEntities);
        } else if (defaultExpandParent) {
          initExpandedKeys = conductExpandParent(props.expandedKeys || defaultExpandedKeys || [], keyEntities);
        } else {
          initExpandedKeys = props.expandedKeys || defaultExpandedKeys;
        }
        return initExpandedKeys;
      };
      const [selectedKeys, setSelectedKeys] = reactExports.useState(props.selectedKeys || props.defaultSelectedKeys || []);
      const [expandedKeys, setExpandedKeys] = reactExports.useState(() => getInitExpandedKeys());
      reactExports.useEffect(() => {
        if ("selectedKeys" in props) {
          setSelectedKeys(props.selectedKeys);
        }
      }, [props.selectedKeys]);
      reactExports.useEffect(() => {
        if ("expandedKeys" in props) {
          setExpandedKeys(props.expandedKeys);
        }
      }, [props.expandedKeys]);
      const onExpand = (keys2, info) => {
        var _a2;
        if (!("expandedKeys" in props)) {
          setExpandedKeys(keys2);
        }
        return (_a2 = props.onExpand) === null || _a2 === void 0 ? void 0 : _a2.call(props, keys2, info);
      };
      const onSelect = (keys2, event) => {
        var _a2;
        const {
          multiple,
          fieldNames
        } = props;
        const {
          node: node2,
          nativeEvent
        } = event;
        const {
          key = ""
        } = node2;
        const treeData = getTreeData(props);
        const newEvent = Object.assign(Object.assign({}, event), {
          selected: true
        });
        const ctrlPick = (nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.ctrlKey) || (nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.metaKey);
        const shiftPick = nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.shiftKey;
        let newSelectedKeys;
        if (multiple && ctrlPick) {
          newSelectedKeys = keys2;
          lastSelectedKey.current = key;
          cachedSelectedKeys.current = newSelectedKeys;
          newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys, fieldNames);
        } else if (multiple && shiftPick) {
          newSelectedKeys = Array.from(new Set([].concat(_toConsumableArray(cachedSelectedKeys.current || []), _toConsumableArray(calcRangeKeys({
            treeData,
            expandedKeys,
            startKey: key,
            endKey: lastSelectedKey.current,
            fieldNames
          })))));
          newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys, fieldNames);
        } else {
          newSelectedKeys = [key];
          lastSelectedKey.current = key;
          cachedSelectedKeys.current = newSelectedKeys;
          newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys, fieldNames);
        }
        (_a2 = props.onSelect) === null || _a2 === void 0 ? void 0 : _a2.call(props, newSelectedKeys, newEvent);
        if (!("selectedKeys" in props)) {
          setSelectedKeys(newSelectedKeys);
        }
      };
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const {
        prefixCls: customizePrefixCls,
        className,
        showIcon = true,
        expandAction = "click"
      } = props, otherProps = __rest$2(props, ["prefixCls", "className", "showIcon", "expandAction"]);
      const prefixCls = getPrefixCls("tree", customizePrefixCls);
      const connectClassName = classNames(`${prefixCls}-directory`, {
        [`${prefixCls}-directory-rtl`]: direction === "rtl"
      }, className);
      return /* @__PURE__ */ reactExports.createElement(TreePure, Object.assign({
        icon: getIcon,
        ref,
        blockNode: true
      }, otherProps, {
        showIcon,
        expandAction,
        prefixCls,
        className: connectClassName,
        expandedKeys,
        selectedKeys,
        onSelect,
        onExpand
      }));
    };
    const ForwardDirectoryTree = /* @__PURE__ */ reactExports.forwardRef(DirectoryTree);
    const DirectoryTree$1 = ForwardDirectoryTree;
    const Tree = TreePure;
    Tree.DirectoryTree = DirectoryTree$1;
    Tree.TreeNode = ContextTreeNode;
    const Tree$1 = Tree;
    function FilterSearch(_ref) {
      let {
        value,
        onChange,
        filterSearch,
        tablePrefixCls,
        locale: locale2
      } = _ref;
      if (!filterSearch) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: `${tablePrefixCls}-filter-dropdown-search`
      }, /* @__PURE__ */ reactExports.createElement(Input$1, {
        prefix: /* @__PURE__ */ reactExports.createElement(SearchOutlined$1, null),
        placeholder: locale2.filterSearchPlaceholder,
        onChange,
        value,
        // for skip min-width of input
        htmlSize: 1,
        className: `${tablePrefixCls}-filter-dropdown-search-input`
      }));
    }
    const onKeyDown = (event) => {
      const {
        keyCode
      } = event;
      if (keyCode === KeyCode.ENTER) {
        event.stopPropagation();
      }
    };
    const FilterDropdownMenuWrapper = /* @__PURE__ */ reactExports.forwardRef((props, ref) => /* @__PURE__ */ reactExports.createElement("div", {
      className: props.className,
      onClick: (e2) => e2.stopPropagation(),
      onKeyDown,
      ref
    }, props.children));
    const FilterDropdownMenuWrapper$1 = FilterDropdownMenuWrapper;
    function flattenKeys(filters) {
      let keys2 = [];
      (filters || []).forEach((_ref) => {
        let {
          value,
          children
        } = _ref;
        keys2.push(value);
        if (children) {
          keys2 = [].concat(_toConsumableArray(keys2), _toConsumableArray(flattenKeys(children)));
        }
      });
      return keys2;
    }
    function hasSubMenu(filters) {
      return filters.some((_ref2) => {
        let {
          children
        } = _ref2;
        return children;
      });
    }
    function searchValueMatched(searchValue, text) {
      if (typeof text === "string" || typeof text === "number") {
        return text === null || text === void 0 ? void 0 : text.toString().toLowerCase().includes(searchValue.trim().toLowerCase());
      }
      return false;
    }
    function renderFilterItems(_ref3) {
      let {
        filters,
        prefixCls,
        filteredKeys,
        filterMultiple,
        searchValue,
        filterSearch
      } = _ref3;
      return filters.map((filter, index2) => {
        const key = String(filter.value);
        if (filter.children) {
          return {
            key: key || index2,
            label: filter.text,
            popupClassName: `${prefixCls}-dropdown-submenu`,
            children: renderFilterItems({
              filters: filter.children,
              prefixCls,
              filteredKeys,
              filterMultiple,
              searchValue,
              filterSearch
            })
          };
        }
        const Component = filterMultiple ? Checkbox$1 : Radio$1;
        const item = {
          key: filter.value !== void 0 ? key : index2,
          label: /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Component, {
            checked: filteredKeys.includes(key)
          }), /* @__PURE__ */ reactExports.createElement("span", null, filter.text))
        };
        if (searchValue.trim()) {
          if (typeof filterSearch === "function") {
            return filterSearch(searchValue, filter) ? item : null;
          }
          return searchValueMatched(searchValue, filter.text) ? item : null;
        }
        return item;
      });
    }
    function wrapStringListType(keys2) {
      return keys2 || [];
    }
    function FilterDropdown(props) {
      var _a, _b;
      const {
        tablePrefixCls,
        prefixCls,
        column: column2,
        dropdownPrefixCls,
        columnKey,
        filterMultiple,
        filterMode = "menu",
        filterSearch = false,
        filterState,
        triggerFilter,
        locale: locale2,
        children,
        getPopupContainer,
        rootClassName
      } = props;
      const {
        filterDropdownOpen,
        onFilterDropdownOpenChange,
        filterResetToDefaultFilteredValue,
        defaultFilteredValue,
        // Deprecated
        filterDropdownVisible,
        onFilterDropdownVisibleChange
      } = column2;
      const [visible, setVisible] = reactExports.useState(false);
      const filtered = !!(filterState && (((_a = filterState.filteredKeys) === null || _a === void 0 ? void 0 : _a.length) || filterState.forceFiltered));
      const triggerVisible = (newVisible) => {
        setVisible(newVisible);
        onFilterDropdownOpenChange === null || onFilterDropdownOpenChange === void 0 ? void 0 : onFilterDropdownOpenChange(newVisible);
        onFilterDropdownVisibleChange === null || onFilterDropdownVisibleChange === void 0 ? void 0 : onFilterDropdownVisibleChange(newVisible);
      };
      const mergedVisible = (_b = filterDropdownOpen !== null && filterDropdownOpen !== void 0 ? filterDropdownOpen : filterDropdownVisible) !== null && _b !== void 0 ? _b : visible;
      const propFilteredKeys = filterState === null || filterState === void 0 ? void 0 : filterState.filteredKeys;
      const [getFilteredKeysSync, setFilteredKeysSync] = useSyncState(wrapStringListType(propFilteredKeys));
      const onSelectKeys = (_ref5) => {
        let {
          selectedKeys
        } = _ref5;
        setFilteredKeysSync(selectedKeys);
      };
      const onCheck = (keys2, _ref6) => {
        let {
          node: node2,
          checked
        } = _ref6;
        if (!filterMultiple) {
          onSelectKeys({
            selectedKeys: checked && node2.key ? [node2.key] : []
          });
        } else {
          onSelectKeys({
            selectedKeys: keys2
          });
        }
      };
      reactExports.useEffect(() => {
        if (!visible) {
          return;
        }
        onSelectKeys({
          selectedKeys: wrapStringListType(propFilteredKeys)
        });
      }, [propFilteredKeys]);
      const [openKeys, setOpenKeys] = reactExports.useState([]);
      const onOpenChange = (keys2) => {
        setOpenKeys(keys2);
      };
      const [searchValue, setSearchValue] = reactExports.useState("");
      const onSearch = (e2) => {
        const {
          value
        } = e2.target;
        setSearchValue(value);
      };
      reactExports.useEffect(() => {
        if (!visible) {
          setSearchValue("");
        }
      }, [visible]);
      const internalTriggerFilter = (keys2) => {
        const mergedKeys = keys2 && keys2.length ? keys2 : null;
        if (mergedKeys === null && (!filterState || !filterState.filteredKeys)) {
          return null;
        }
        if (isEqual$1(mergedKeys, filterState === null || filterState === void 0 ? void 0 : filterState.filteredKeys, true)) {
          return null;
        }
        triggerFilter({
          column: column2,
          key: columnKey,
          filteredKeys: mergedKeys
        });
      };
      const onConfirm = () => {
        triggerVisible(false);
        internalTriggerFilter(getFilteredKeysSync());
      };
      const onReset = function() {
        let {
          confirm: confirm2,
          closeDropdown
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
          confirm: false,
          closeDropdown: false
        };
        if (confirm2) {
          internalTriggerFilter([]);
        }
        if (closeDropdown) {
          triggerVisible(false);
        }
        setSearchValue("");
        if (filterResetToDefaultFilteredValue) {
          setFilteredKeysSync((defaultFilteredValue || []).map((key) => String(key)));
        } else {
          setFilteredKeysSync([]);
        }
      };
      const doFilter = function() {
        let {
          closeDropdown
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
          closeDropdown: true
        };
        if (closeDropdown) {
          triggerVisible(false);
        }
        internalTriggerFilter(getFilteredKeysSync());
      };
      const onVisibleChange = (newVisible, info) => {
        if (info.source === "trigger") {
          if (newVisible && propFilteredKeys !== void 0) {
            setFilteredKeysSync(wrapStringListType(propFilteredKeys));
          }
          triggerVisible(newVisible);
          if (!newVisible && !column2.filterDropdown) {
            onConfirm();
          }
        }
      };
      const dropdownMenuClass = classNames({
        [`${dropdownPrefixCls}-menu-without-submenu`]: !hasSubMenu(column2.filters || [])
      });
      const onCheckAll = (e2) => {
        if (e2.target.checked) {
          const allFilterKeys = flattenKeys(column2 === null || column2 === void 0 ? void 0 : column2.filters).map((key) => String(key));
          setFilteredKeysSync(allFilterKeys);
        } else {
          setFilteredKeysSync([]);
        }
      };
      const getTreeData2 = (_ref7) => {
        let {
          filters
        } = _ref7;
        return (filters || []).map((filter, index2) => {
          const key = String(filter.value);
          const item = {
            title: filter.text,
            key: filter.value !== void 0 ? key : String(index2)
          };
          if (filter.children) {
            item.children = getTreeData2({
              filters: filter.children
            });
          }
          return item;
        });
      };
      const getFilterData2 = (node2) => {
        var _a2;
        return Object.assign(Object.assign({}, node2), {
          text: node2.title,
          value: node2.key,
          children: ((_a2 = node2.children) === null || _a2 === void 0 ? void 0 : _a2.map((item) => getFilterData2(item))) || []
        });
      };
      let dropdownContent;
      if (typeof column2.filterDropdown === "function") {
        dropdownContent = column2.filterDropdown({
          prefixCls: `${dropdownPrefixCls}-custom`,
          setSelectedKeys: (selectedKeys) => onSelectKeys({
            selectedKeys
          }),
          selectedKeys: getFilteredKeysSync(),
          confirm: doFilter,
          clearFilters: onReset,
          filters: column2.filters,
          visible: mergedVisible,
          close: () => {
            triggerVisible(false);
          }
        });
      } else if (column2.filterDropdown) {
        dropdownContent = column2.filterDropdown;
      } else {
        const selectedKeys = getFilteredKeysSync() || [];
        const getFilterComponent = () => {
          if ((column2.filters || []).length === 0) {
            return /* @__PURE__ */ reactExports.createElement(Empty$1, {
              image: Empty$1.PRESENTED_IMAGE_SIMPLE,
              description: locale2.filterEmptyText,
              imageStyle: {
                height: 24
              },
              style: {
                margin: 0,
                padding: "16px 0"
              }
            });
          }
          if (filterMode === "tree") {
            return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(FilterSearch, {
              filterSearch,
              value: searchValue,
              onChange: onSearch,
              tablePrefixCls,
              locale: locale2
            }), /* @__PURE__ */ reactExports.createElement("div", {
              className: `${tablePrefixCls}-filter-dropdown-tree`
            }, filterMultiple ? /* @__PURE__ */ reactExports.createElement(Checkbox$1, {
              checked: selectedKeys.length === flattenKeys(column2.filters).length,
              indeterminate: selectedKeys.length > 0 && selectedKeys.length < flattenKeys(column2.filters).length,
              className: `${tablePrefixCls}-filter-dropdown-checkall`,
              onChange: onCheckAll
            }, locale2.filterCheckall) : null, /* @__PURE__ */ reactExports.createElement(Tree$1, {
              checkable: true,
              selectable: false,
              blockNode: true,
              multiple: filterMultiple,
              checkStrictly: !filterMultiple,
              className: `${dropdownPrefixCls}-menu`,
              onCheck,
              checkedKeys: selectedKeys,
              selectedKeys,
              showIcon: false,
              treeData: getTreeData2({
                filters: column2.filters
              }),
              autoExpandParent: true,
              defaultExpandAll: true,
              filterTreeNode: searchValue.trim() ? (node2) => {
                if (typeof filterSearch === "function") {
                  return filterSearch(searchValue, getFilterData2(node2));
                }
                return searchValueMatched(searchValue, node2.title);
              } : void 0
            })));
          }
          return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(FilterSearch, {
            filterSearch,
            value: searchValue,
            onChange: onSearch,
            tablePrefixCls,
            locale: locale2
          }), /* @__PURE__ */ reactExports.createElement(Menu$1, {
            selectable: true,
            multiple: filterMultiple,
            prefixCls: `${dropdownPrefixCls}-menu`,
            className: dropdownMenuClass,
            onSelect: onSelectKeys,
            onDeselect: onSelectKeys,
            selectedKeys,
            getPopupContainer,
            openKeys,
            onOpenChange,
            items: renderFilterItems({
              filters: column2.filters || [],
              filterSearch,
              prefixCls,
              filteredKeys: getFilteredKeysSync(),
              filterMultiple,
              searchValue
            })
          }));
        };
        const getResetDisabled = () => {
          if (filterResetToDefaultFilteredValue) {
            return isEqual$1((defaultFilteredValue || []).map((key) => String(key)), selectedKeys, true);
          }
          return selectedKeys.length === 0;
        };
        dropdownContent = /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, getFilterComponent(), /* @__PURE__ */ reactExports.createElement("div", {
          className: `${prefixCls}-dropdown-btns`
        }, /* @__PURE__ */ reactExports.createElement(Button$2, {
          type: "link",
          size: "small",
          disabled: getResetDisabled(),
          onClick: () => onReset()
        }, locale2.filterReset), /* @__PURE__ */ reactExports.createElement(Button$2, {
          type: "primary",
          size: "small",
          onClick: onConfirm
        }, locale2.filterConfirm)));
      }
      if (column2.filterDropdown) {
        dropdownContent = /* @__PURE__ */ reactExports.createElement(OverrideProvider, {
          selectable: void 0
        }, dropdownContent);
      }
      const menu = () => /* @__PURE__ */ reactExports.createElement(FilterDropdownMenuWrapper$1, {
        className: `${prefixCls}-dropdown`
      }, dropdownContent);
      let filterIcon;
      if (typeof column2.filterIcon === "function") {
        filterIcon = column2.filterIcon(filtered);
      } else if (column2.filterIcon) {
        filterIcon = column2.filterIcon;
      } else {
        filterIcon = /* @__PURE__ */ reactExports.createElement(FilterFilled$1, null);
      }
      const {
        direction
      } = reactExports.useContext(ConfigContext);
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-column`
      }, /* @__PURE__ */ reactExports.createElement("span", {
        className: `${tablePrefixCls}-column-title`
      }, children), /* @__PURE__ */ reactExports.createElement(Dropdown$1, {
        dropdownRender: menu,
        trigger: ["click"],
        open: mergedVisible,
        onOpenChange: onVisibleChange,
        getPopupContainer,
        placement: direction === "rtl" ? "bottomLeft" : "bottomRight",
        rootClassName
      }, /* @__PURE__ */ reactExports.createElement("span", {
        role: "button",
        tabIndex: -1,
        className: classNames(`${prefixCls}-trigger`, {
          active: filtered
        }),
        onClick: (e2) => {
          e2.stopPropagation();
        }
      }, filterIcon)));
    }
    function collectFilterStates(columns, init, pos) {
      let filterStates = [];
      (columns || []).forEach((column2, index2) => {
        var _a;
        const columnPos = getColumnPos(index2, pos);
        if (column2.filters || "filterDropdown" in column2 || "onFilter" in column2) {
          if ("filteredValue" in column2) {
            let filteredValues = column2.filteredValue;
            if (!("filterDropdown" in column2)) {
              filteredValues = (_a = filteredValues === null || filteredValues === void 0 ? void 0 : filteredValues.map(String)) !== null && _a !== void 0 ? _a : filteredValues;
            }
            filterStates.push({
              column: column2,
              key: getColumnKey(column2, columnPos),
              filteredKeys: filteredValues,
              forceFiltered: column2.filtered
            });
          } else {
            filterStates.push({
              column: column2,
              key: getColumnKey(column2, columnPos),
              filteredKeys: init && column2.defaultFilteredValue ? column2.defaultFilteredValue : void 0,
              forceFiltered: column2.filtered
            });
          }
        }
        if ("children" in column2) {
          filterStates = [].concat(_toConsumableArray(filterStates), _toConsumableArray(collectFilterStates(column2.children, init, columnPos)));
        }
      });
      return filterStates;
    }
    function injectFilter(prefixCls, dropdownPrefixCls, columns, filterStates, locale2, triggerFilter, getPopupContainer, pos, rootClassName) {
      return columns.map((column2, index2) => {
        const columnPos = getColumnPos(index2, pos);
        const {
          filterMultiple = true,
          filterMode,
          filterSearch
        } = column2;
        let newColumn = column2;
        if (newColumn.filters || newColumn.filterDropdown) {
          const columnKey = getColumnKey(newColumn, columnPos);
          const filterState = filterStates.find((_ref) => {
            let {
              key
            } = _ref;
            return columnKey === key;
          });
          newColumn = Object.assign(Object.assign({}, newColumn), {
            title: (renderProps) => /* @__PURE__ */ reactExports.createElement(FilterDropdown, {
              tablePrefixCls: prefixCls,
              prefixCls: `${prefixCls}-filter`,
              dropdownPrefixCls,
              column: newColumn,
              columnKey,
              filterState,
              filterMultiple,
              filterMode,
              filterSearch,
              triggerFilter,
              locale: locale2,
              getPopupContainer,
              rootClassName
            }, renderColumnTitle(column2.title, renderProps))
          });
        }
        if ("children" in newColumn) {
          newColumn = Object.assign(Object.assign({}, newColumn), {
            children: injectFilter(prefixCls, dropdownPrefixCls, newColumn.children, filterStates, locale2, triggerFilter, getPopupContainer, columnPos, rootClassName)
          });
        }
        return newColumn;
      });
    }
    function generateFilterInfo(filterStates) {
      const currentFilters = {};
      filterStates.forEach((_ref2) => {
        let {
          key,
          filteredKeys,
          column: column2
        } = _ref2;
        const keyAsString = key;
        const {
          filters,
          filterDropdown
        } = column2;
        if (filterDropdown) {
          currentFilters[keyAsString] = filteredKeys || null;
        } else if (Array.isArray(filteredKeys)) {
          const keys2 = flattenKeys(filters);
          currentFilters[keyAsString] = keys2.filter((originKey) => filteredKeys.includes(String(originKey)));
        } else {
          currentFilters[keyAsString] = null;
        }
      });
      return currentFilters;
    }
    function getFilterData(data, filterStates) {
      return filterStates.reduce((currentData, filterState) => {
        const {
          column: {
            onFilter,
            filters
          },
          filteredKeys
        } = filterState;
        if (onFilter && filteredKeys && filteredKeys.length) {
          return currentData.filter((record) => filteredKeys.some((key) => {
            const keys2 = flattenKeys(filters);
            const keyIndex = keys2.findIndex((k2) => String(k2) === String(key));
            const realKey = keyIndex !== -1 ? keys2[keyIndex] : key;
            return onFilter(realKey, record);
          }));
        }
        return currentData;
      }, data);
    }
    const getMergedColumns = (rawMergedColumns) => rawMergedColumns.flatMap((column2) => {
      if ("children" in column2) {
        return [column2].concat(_toConsumableArray(getMergedColumns(column2.children || [])));
      }
      return [column2];
    });
    function useFilter(_ref3) {
      let {
        prefixCls,
        dropdownPrefixCls,
        mergedColumns: rawMergedColumns,
        onFilterChange,
        getPopupContainer,
        locale: tableLocale,
        rootClassName
      } = _ref3;
      devUseWarning();
      const mergedColumns = reactExports.useMemo(() => getMergedColumns(rawMergedColumns || []), [rawMergedColumns]);
      const [filterStates, setFilterStates] = reactExports.useState(() => collectFilterStates(mergedColumns, true));
      const mergedFilterStates = reactExports.useMemo(() => {
        const collectedStates = collectFilterStates(mergedColumns, false);
        if (collectedStates.length === 0) {
          return collectedStates;
        }
        let filteredKeysIsAllNotControlled = true;
        collectedStates.forEach((_ref4) => {
          let {
            filteredKeys
          } = _ref4;
          if (filteredKeys !== void 0) {
            filteredKeysIsAllNotControlled = false;
          }
        });
        if (filteredKeysIsAllNotControlled) {
          const keyList = (mergedColumns || []).map((column2, index2) => getColumnKey(column2, getColumnPos(index2)));
          return filterStates.filter((_ref5) => {
            let {
              key
            } = _ref5;
            return keyList.includes(key);
          }).map((item) => {
            const col = mergedColumns[keyList.findIndex((key) => key === item.key)];
            return Object.assign(Object.assign({}, item), {
              column: Object.assign(Object.assign({}, item.column), col),
              forceFiltered: col.filtered
            });
          });
        }
        return collectedStates;
      }, [mergedColumns, filterStates]);
      const filters = reactExports.useMemo(() => generateFilterInfo(mergedFilterStates), [mergedFilterStates]);
      const triggerFilter = (filterState) => {
        const newFilterStates = mergedFilterStates.filter((_ref6) => {
          let {
            key
          } = _ref6;
          return key !== filterState.key;
        });
        newFilterStates.push(filterState);
        setFilterStates(newFilterStates);
        onFilterChange(generateFilterInfo(newFilterStates), newFilterStates);
      };
      const transformColumns = (innerColumns) => injectFilter(prefixCls, dropdownPrefixCls, innerColumns, mergedFilterStates, tableLocale, triggerFilter, getPopupContainer, void 0, rootClassName);
      return [transformColumns, mergedFilterStates, filters];
    }
    function useLazyKVMap(data, childrenColumnName, getRowKey) {
      const mapCacheRef = reactExports.useRef({});
      function getRecordByKey(key) {
        if (!mapCacheRef.current || mapCacheRef.current.data !== data || mapCacheRef.current.childrenColumnName !== childrenColumnName || mapCacheRef.current.getRowKey !== getRowKey) {
          let dig2 = function(records) {
            records.forEach((record, index2) => {
              const rowKey = getRowKey(record, index2);
              kvMap.set(rowKey, record);
              if (record && typeof record === "object" && childrenColumnName in record) {
                dig2(record[childrenColumnName] || []);
              }
            });
          };
          var dig = dig2;
          const kvMap = /* @__PURE__ */ new Map();
          dig2(data);
          mapCacheRef.current = {
            data,
            childrenColumnName,
            kvMap,
            getRowKey
          };
        }
        return mapCacheRef.current.kvMap.get(key);
      }
      return [getRecordByKey];
    }
    var __rest$1 = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const DEFAULT_PAGE_SIZE = 10;
    function getPaginationParam(mergedPagination, pagination) {
      const param = {
        current: mergedPagination.current,
        pageSize: mergedPagination.pageSize
      };
      const paginationObj = pagination && typeof pagination === "object" ? pagination : {};
      Object.keys(paginationObj).forEach((pageProp) => {
        const value = mergedPagination[pageProp];
        if (typeof value !== "function") {
          param[pageProp] = value;
        }
      });
      return param;
    }
    function usePagination(total, onChange, pagination) {
      const _a = pagination && typeof pagination === "object" ? pagination : {}, {
        total: paginationTotal = 0
      } = _a, paginationObj = __rest$1(_a, ["total"]);
      const [innerPagination, setInnerPagination] = reactExports.useState(() => ({
        current: "defaultCurrent" in paginationObj ? paginationObj.defaultCurrent : 1,
        pageSize: "defaultPageSize" in paginationObj ? paginationObj.defaultPageSize : DEFAULT_PAGE_SIZE
      }));
      const mergedPagination = extendsObject$1(innerPagination, paginationObj, {
        total: paginationTotal > 0 ? paginationTotal : total
      });
      const maxPage = Math.ceil((paginationTotal || total) / mergedPagination.pageSize);
      if (mergedPagination.current > maxPage) {
        mergedPagination.current = maxPage || 1;
      }
      const refreshPagination = (current, pageSize) => {
        setInnerPagination({
          current: current !== null && current !== void 0 ? current : 1,
          pageSize: pageSize || mergedPagination.pageSize
        });
      };
      const onInternalChange = (current, pageSize) => {
        var _a2;
        if (pagination) {
          (_a2 = pagination.onChange) === null || _a2 === void 0 ? void 0 : _a2.call(pagination, current, pageSize);
        }
        refreshPagination(current, pageSize);
        onChange(current, pageSize || (mergedPagination === null || mergedPagination === void 0 ? void 0 : mergedPagination.pageSize));
      };
      if (pagination === false) {
        return [{}, () => {
        }];
      }
      return [Object.assign(Object.assign({}, mergedPagination), {
        onChange: onInternalChange
      }), refreshPagination];
    }
    var CaretDownOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, "name": "caret-down", "theme": "outlined" };
    const CaretDownOutlinedSvg = CaretDownOutlined$2;
    var CaretDownOutlined = function CaretDownOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: CaretDownOutlinedSvg
      }));
    };
    const CaretDownOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(CaretDownOutlined);
    var CaretUpOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M858.9 689L530.5 308.2c-9.4-10.9-27.5-10.9-37 0L165.1 689c-12.2 14.2-1.2 35 18.5 35h656.8c19.7 0 30.7-20.8 18.5-35z" } }] }, "name": "caret-up", "theme": "outlined" };
    const CaretUpOutlinedSvg = CaretUpOutlined$2;
    var CaretUpOutlined = function CaretUpOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: CaretUpOutlinedSvg
      }));
    };
    const CaretUpOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(CaretUpOutlined);
    const ASCEND = "ascend";
    const DESCEND = "descend";
    function getMultiplePriority(column2) {
      if (typeof column2.sorter === "object" && typeof column2.sorter.multiple === "number") {
        return column2.sorter.multiple;
      }
      return false;
    }
    function getSortFunction(sorter) {
      if (typeof sorter === "function") {
        return sorter;
      }
      if (sorter && typeof sorter === "object" && sorter.compare) {
        return sorter.compare;
      }
      return false;
    }
    function nextSortDirection(sortDirections, current) {
      if (!current) {
        return sortDirections[0];
      }
      return sortDirections[sortDirections.indexOf(current) + 1];
    }
    function collectSortStates(columns, init, pos) {
      let sortStates = [];
      function pushState(column2, columnPos) {
        sortStates.push({
          column: column2,
          key: getColumnKey(column2, columnPos),
          multiplePriority: getMultiplePriority(column2),
          sortOrder: column2.sortOrder
        });
      }
      (columns || []).forEach((column2, index2) => {
        const columnPos = getColumnPos(index2, pos);
        if (column2.children) {
          if ("sortOrder" in column2) {
            pushState(column2, columnPos);
          }
          sortStates = [].concat(_toConsumableArray(sortStates), _toConsumableArray(collectSortStates(column2.children, init, columnPos)));
        } else if (column2.sorter) {
          if ("sortOrder" in column2) {
            pushState(column2, columnPos);
          } else if (init && column2.defaultSortOrder) {
            sortStates.push({
              column: column2,
              key: getColumnKey(column2, columnPos),
              multiplePriority: getMultiplePriority(column2),
              sortOrder: column2.defaultSortOrder
            });
          }
        }
      });
      return sortStates;
    }
    function injectSorter(prefixCls, columns, sorterStates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, pos) {
      return (columns || []).map((column2, index2) => {
        const columnPos = getColumnPos(index2, pos);
        let newColumn = column2;
        if (newColumn.sorter) {
          const sortDirections = newColumn.sortDirections || defaultSortDirections;
          const showSorterTooltip = newColumn.showSorterTooltip === void 0 ? tableShowSorterTooltip : newColumn.showSorterTooltip;
          const columnKey = getColumnKey(newColumn, columnPos);
          const sorterState = sorterStates.find((_ref) => {
            let {
              key
            } = _ref;
            return key === columnKey;
          });
          const sortOrder = sorterState ? sorterState.sortOrder : null;
          const nextSortOrder = nextSortDirection(sortDirections, sortOrder);
          let sorter;
          if (column2.sortIcon) {
            sorter = column2.sortIcon({
              sortOrder
            });
          } else {
            const upNode = sortDirections.includes(ASCEND) && /* @__PURE__ */ reactExports.createElement(CaretUpOutlined$1, {
              className: classNames(`${prefixCls}-column-sorter-up`, {
                active: sortOrder === ASCEND
              })
            });
            const downNode = sortDirections.includes(DESCEND) && /* @__PURE__ */ reactExports.createElement(CaretDownOutlined$1, {
              className: classNames(`${prefixCls}-column-sorter-down`, {
                active: sortOrder === DESCEND
              })
            });
            sorter = /* @__PURE__ */ reactExports.createElement("span", {
              className: classNames(`${prefixCls}-column-sorter`, {
                [`${prefixCls}-column-sorter-full`]: !!(upNode && downNode)
              })
            }, /* @__PURE__ */ reactExports.createElement("span", {
              className: `${prefixCls}-column-sorter-inner`,
              "aria-hidden": "true"
            }, upNode, downNode));
          }
          const {
            cancelSort,
            triggerAsc,
            triggerDesc
          } = tableLocale || {};
          let sortTip = cancelSort;
          if (nextSortOrder === DESCEND) {
            sortTip = triggerDesc;
          } else if (nextSortOrder === ASCEND) {
            sortTip = triggerAsc;
          }
          const tooltipProps = typeof showSorterTooltip === "object" ? Object.assign({
            title: sortTip
          }, showSorterTooltip) : {
            title: sortTip
          };
          newColumn = Object.assign(Object.assign({}, newColumn), {
            className: classNames(newColumn.className, {
              [`${prefixCls}-column-sort`]: sortOrder
            }),
            title: (renderProps) => {
              const renderSortTitle = /* @__PURE__ */ reactExports.createElement("div", {
                className: `${prefixCls}-column-sorters`
              }, /* @__PURE__ */ reactExports.createElement("span", {
                className: `${prefixCls}-column-title`
              }, renderColumnTitle(column2.title, renderProps)), sorter);
              return showSorterTooltip ? /* @__PURE__ */ reactExports.createElement(Tooltip$1, Object.assign({}, tooltipProps), renderSortTitle) : renderSortTitle;
            },
            onHeaderCell: (col) => {
              const cell = column2.onHeaderCell && column2.onHeaderCell(col) || {};
              const originOnClick = cell.onClick;
              const originOKeyDown = cell.onKeyDown;
              cell.onClick = (event) => {
                triggerSorter({
                  column: column2,
                  key: columnKey,
                  sortOrder: nextSortOrder,
                  multiplePriority: getMultiplePriority(column2)
                });
                originOnClick === null || originOnClick === void 0 ? void 0 : originOnClick(event);
              };
              cell.onKeyDown = (event) => {
                if (event.keyCode === KeyCode.ENTER) {
                  triggerSorter({
                    column: column2,
                    key: columnKey,
                    sortOrder: nextSortOrder,
                    multiplePriority: getMultiplePriority(column2)
                  });
                  originOKeyDown === null || originOKeyDown === void 0 ? void 0 : originOKeyDown(event);
                }
              };
              const renderTitle = safeColumnTitle(column2.title, {});
              const displayTitle = renderTitle === null || renderTitle === void 0 ? void 0 : renderTitle.toString();
              if (sortOrder) {
                cell["aria-sort"] = sortOrder === "ascend" ? "ascending" : "descending";
              } else {
                cell["aria-label"] = displayTitle || "";
              }
              cell.className = classNames(cell.className, `${prefixCls}-column-has-sorters`);
              cell.tabIndex = 0;
              if (column2.ellipsis) {
                cell.title = (renderTitle !== null && renderTitle !== void 0 ? renderTitle : "").toString();
              }
              return cell;
            }
          });
        }
        if ("children" in newColumn) {
          newColumn = Object.assign(Object.assign({}, newColumn), {
            children: injectSorter(prefixCls, newColumn.children, sorterStates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, columnPos)
          });
        }
        return newColumn;
      });
    }
    function stateToInfo(sorterStates) {
      const {
        column: column2,
        sortOrder
      } = sorterStates;
      return {
        column: column2,
        order: sortOrder,
        field: column2.dataIndex,
        columnKey: column2.key
      };
    }
    function generateSorterInfo(sorterStates) {
      const list = sorterStates.filter((_ref2) => {
        let {
          sortOrder
        } = _ref2;
        return sortOrder;
      }).map(stateToInfo);
      if (list.length === 0 && sorterStates.length) {
        return Object.assign(Object.assign({}, stateToInfo(sorterStates[sorterStates.length - 1])), {
          column: void 0
        });
      }
      if (list.length <= 1) {
        return list[0] || {};
      }
      return list;
    }
    function getSortData(data, sortStates, childrenColumnName) {
      const innerSorterStates = sortStates.slice().sort((a, b2) => b2.multiplePriority - a.multiplePriority);
      const cloneData = data.slice();
      const runningSorters = innerSorterStates.filter((_ref3) => {
        let {
          column: {
            sorter
          },
          sortOrder
        } = _ref3;
        return getSortFunction(sorter) && sortOrder;
      });
      if (!runningSorters.length) {
        return cloneData;
      }
      return cloneData.sort((record1, record2) => {
        for (let i = 0; i < runningSorters.length; i += 1) {
          const sorterState = runningSorters[i];
          const {
            column: {
              sorter
            },
            sortOrder
          } = sorterState;
          const compareFn = getSortFunction(sorter);
          if (compareFn && sortOrder) {
            const compareResult = compareFn(record1, record2, sortOrder);
            if (compareResult !== 0) {
              return sortOrder === ASCEND ? compareResult : -compareResult;
            }
          }
        }
        return 0;
      }).map((record) => {
        const subRecords = record[childrenColumnName];
        if (subRecords) {
          return Object.assign(Object.assign({}, record), {
            [childrenColumnName]: getSortData(subRecords, sortStates, childrenColumnName)
          });
        }
        return record;
      });
    }
    function useFilterSorter(_ref4) {
      let {
        prefixCls,
        mergedColumns,
        onSorterChange,
        sortDirections,
        tableLocale,
        showSorterTooltip
      } = _ref4;
      const [sortStates, setSortStates] = reactExports.useState(collectSortStates(mergedColumns, true));
      const mergedSorterStates = reactExports.useMemo(() => {
        let validate = true;
        const collectedStates = collectSortStates(mergedColumns, false);
        if (!collectedStates.length) {
          return sortStates;
        }
        const validateStates = [];
        function patchStates(state) {
          if (validate) {
            validateStates.push(state);
          } else {
            validateStates.push(Object.assign(Object.assign({}, state), {
              sortOrder: null
            }));
          }
        }
        let multipleMode = null;
        collectedStates.forEach((state) => {
          if (multipleMode === null) {
            patchStates(state);
            if (state.sortOrder) {
              if (state.multiplePriority === false) {
                validate = false;
              } else {
                multipleMode = true;
              }
            }
          } else if (multipleMode && state.multiplePriority !== false) {
            patchStates(state);
          } else {
            validate = false;
            patchStates(state);
          }
        });
        return validateStates;
      }, [mergedColumns, sortStates]);
      const columnTitleSorterProps = reactExports.useMemo(() => {
        const sortColumns = mergedSorterStates.map((_ref5) => {
          let {
            column: column2,
            sortOrder
          } = _ref5;
          return {
            column: column2,
            order: sortOrder
          };
        });
        return {
          sortColumns,
          // Legacy
          sortColumn: sortColumns[0] && sortColumns[0].column,
          sortOrder: sortColumns[0] && sortColumns[0].order
        };
      }, [mergedSorterStates]);
      function triggerSorter(sortState) {
        let newSorterStates;
        if (sortState.multiplePriority === false || !mergedSorterStates.length || mergedSorterStates[0].multiplePriority === false) {
          newSorterStates = [sortState];
        } else {
          newSorterStates = [].concat(_toConsumableArray(mergedSorterStates.filter((_ref6) => {
            let {
              key
            } = _ref6;
            return key !== sortState.key;
          })), [sortState]);
        }
        setSortStates(newSorterStates);
        onSorterChange(generateSorterInfo(newSorterStates), newSorterStates);
      }
      const transformColumns = (innerColumns) => injectSorter(prefixCls, innerColumns, mergedSorterStates, triggerSorter, sortDirections, tableLocale, showSorterTooltip);
      const getSorters = () => generateSorterInfo(mergedSorterStates);
      return [transformColumns, mergedSorterStates, columnTitleSorterProps, getSorters];
    }
    function fillTitle(columns, columnTitleProps) {
      return columns.map((column2) => {
        const cloneColumn = Object.assign({}, column2);
        cloneColumn.title = renderColumnTitle(column2.title, columnTitleProps);
        if ("children" in cloneColumn) {
          cloneColumn.children = fillTitle(cloneColumn.children, columnTitleProps);
        }
        return cloneColumn;
      });
    }
    function useTitleColumns(columnTitleProps) {
      const filledColumns = reactExports.useCallback((columns) => fillTitle(columns, columnTitleProps), [columnTitleProps]);
      return [filledColumns];
    }
    const RcTable = genTable((prev2, next2) => {
      const {
        _renderTimes: prevRenderTimes
      } = prev2;
      const {
        _renderTimes: nextRenderTimes
      } = next2;
      return prevRenderTimes !== nextRenderTimes;
    });
    const RcVirtualTable = genVirtualTable((prev2, next2) => {
      const {
        _renderTimes: prevRenderTimes
      } = prev2;
      const {
        _renderTimes: nextRenderTimes
      } = next2;
      return prevRenderTimes !== nextRenderTimes;
    });
    const genBorderedStyle = (token2) => {
      const {
        componentCls,
        lineWidth,
        lineType,
        tableBorderColor,
        tableHeaderBg,
        tablePaddingVertical,
        tablePaddingHorizontal,
        calc
      } = token2;
      const tableBorder = `${unit$1(lineWidth)} ${lineType} ${tableBorderColor}`;
      const getSizeBorderStyle = (size, paddingVertical, paddingHorizontal) => ({
        [`&${componentCls}-${size}`]: {
          [`> ${componentCls}-container`]: {
            [`> ${componentCls}-content, > ${componentCls}-body`]: {
              [`
            > table > tbody > tr > th,
            > table > tbody > tr > td
          `]: {
                [`> ${componentCls}-expanded-row-fixed`]: {
                  margin: `${unit$1(calc(paddingVertical).mul(-1).equal())}
              ${unit$1(calc(calc(paddingHorizontal).add(lineWidth)).mul(-1).equal())}`
                }
              }
            }
          }
        }
      });
      return {
        [`${componentCls}-wrapper`]: {
          [`${componentCls}${componentCls}-bordered`]: Object.assign(Object.assign(Object.assign({
            // ============================ Title =============================
            [`> ${componentCls}-title`]: {
              border: tableBorder,
              borderBottom: 0
            },
            // ============================ Content ============================
            [`> ${componentCls}-container`]: {
              borderInlineStart: tableBorder,
              borderTop: tableBorder,
              [`
            > ${componentCls}-content,
            > ${componentCls}-header,
            > ${componentCls}-body,
            > ${componentCls}-summary
          `]: {
                "> table": {
                  // ============================= Cell =============================
                  [`
                > thead > tr > th,
                > thead > tr > td,
                > tbody > tr > th,
                > tbody > tr > td,
                > tfoot > tr > th,
                > tfoot > tr > td
              `]: {
                    borderInlineEnd: tableBorder
                  },
                  // ============================ Header ============================
                  "> thead": {
                    "> tr:not(:last-child) > th": {
                      borderBottom: tableBorder
                    },
                    "> tr > th::before": {
                      backgroundColor: "transparent !important"
                    }
                  },
                  // Fixed right should provides additional border
                  [`
                > thead > tr,
                > tbody > tr,
                > tfoot > tr
              `]: {
                    [`> ${componentCls}-cell-fix-right-first::after`]: {
                      borderInlineEnd: tableBorder
                    }
                  },
                  // ========================== Expandable ==========================
                  [`
                > tbody > tr > th,
                > tbody > tr > td
              `]: {
                    [`> ${componentCls}-expanded-row-fixed`]: {
                      margin: `${unit$1(calc(tablePaddingVertical).mul(-1).equal())} ${unit$1(calc(calc(tablePaddingHorizontal).add(lineWidth)).mul(-1).equal())}`,
                      "&::after": {
                        position: "absolute",
                        top: 0,
                        insetInlineEnd: lineWidth,
                        bottom: 0,
                        borderInlineEnd: tableBorder,
                        content: '""'
                      }
                    }
                  }
                }
              }
            },
            // ============================ Scroll ============================
            [`&${componentCls}-scroll-horizontal`]: {
              [`> ${componentCls}-container > ${componentCls}-body`]: {
                "> table > tbody": {
                  [`
                > tr${componentCls}-expanded-row,
                > tr${componentCls}-placeholder
              `]: {
                    [`> th, > td`]: {
                      borderInlineEnd: 0
                    }
                  }
                }
              }
            }
          }, getSizeBorderStyle("middle", token2.tablePaddingVerticalMiddle, token2.tablePaddingHorizontalMiddle)), getSizeBorderStyle("small", token2.tablePaddingVerticalSmall, token2.tablePaddingHorizontalSmall)), {
            // ============================ Footer ============================
            [`> ${componentCls}-footer`]: {
              border: tableBorder,
              borderTop: 0
            }
          }),
          // ============================ Nested ============================
          [`${componentCls}-cell`]: {
            [`${componentCls}-container:first-child`]: {
              // :first-child to avoid the case when bordered and title is set
              borderTop: 0
            },
            // https://github.com/ant-design/ant-design/issues/35577
            "&-scrollbar:not([rowspan])": {
              boxShadow: `0 ${unit$1(lineWidth)} 0 ${unit$1(lineWidth)} ${tableHeaderBg}`
            }
          },
          [`${componentCls}-bordered ${componentCls}-cell-scrollbar`]: {
            borderInlineEnd: tableBorder
          }
        }
      };
    };
    const genBorderedStyle$1 = genBorderedStyle;
    const genEllipsisStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}-wrapper`]: {
          [`${componentCls}-cell-ellipsis`]: Object.assign(Object.assign({}, textEllipsis), {
            wordBreak: "keep-all",
            // Fixed first or last should special process
            [`
          &${componentCls}-cell-fix-left-last,
          &${componentCls}-cell-fix-right-first
        `]: {
              overflow: "visible",
              [`${componentCls}-cell-content`]: {
                display: "block",
                overflow: "hidden",
                textOverflow: "ellipsis"
              }
            },
            [`${componentCls}-column-title`]: {
              overflow: "hidden",
              textOverflow: "ellipsis",
              wordBreak: "keep-all"
            }
          })
        }
      };
    };
    const genEllipsisStyle$1 = genEllipsisStyle;
    const genEmptyStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}-wrapper`]: {
          [`${componentCls}-tbody > tr${componentCls}-placeholder`]: {
            textAlign: "center",
            color: token2.colorTextDisabled,
            [`
          &:hover > th,
          &:hover > td,
        `]: {
              background: token2.colorBgContainer
            }
          }
        }
      };
    };
    const genEmptyStyle$1 = genEmptyStyle;
    const genExpandStyle = (token2) => {
      const {
        componentCls,
        antCls,
        motionDurationSlow,
        lineWidth,
        paddingXS,
        lineType,
        tableBorderColor,
        tableExpandIconBg,
        tableExpandColumnWidth,
        borderRadius,
        tablePaddingVertical,
        tablePaddingHorizontal,
        tableExpandedRowBg,
        paddingXXS,
        expandIconMarginTop,
        expandIconSize,
        expandIconHalfInner,
        expandIconScale,
        calc
      } = token2;
      const tableBorder = `${unit$1(lineWidth)} ${lineType} ${tableBorderColor}`;
      const expandIconLineOffset = calc(paddingXXS).sub(lineWidth).equal();
      return {
        [`${componentCls}-wrapper`]: {
          [`${componentCls}-expand-icon-col`]: {
            width: tableExpandColumnWidth
          },
          [`${componentCls}-row-expand-icon-cell`]: {
            textAlign: "center",
            [`${componentCls}-row-expand-icon`]: {
              display: "inline-flex",
              float: "none",
              verticalAlign: "sub"
            }
          },
          [`${componentCls}-row-indent`]: {
            height: 1,
            float: "left"
          },
          [`${componentCls}-row-expand-icon`]: Object.assign(Object.assign({}, operationUnit(token2)), {
            position: "relative",
            float: "left",
            boxSizing: "border-box",
            width: expandIconSize,
            height: expandIconSize,
            padding: 0,
            color: "inherit",
            lineHeight: unit$1(expandIconSize),
            background: tableExpandIconBg,
            border: tableBorder,
            borderRadius,
            transform: `scale(${expandIconScale})`,
            transition: `all ${motionDurationSlow}`,
            userSelect: "none",
            [`&:focus, &:hover, &:active`]: {
              borderColor: "currentcolor"
            },
            [`&::before, &::after`]: {
              position: "absolute",
              background: "currentcolor",
              transition: `transform ${motionDurationSlow} ease-out`,
              content: '""'
            },
            "&::before": {
              top: expandIconHalfInner,
              insetInlineEnd: expandIconLineOffset,
              insetInlineStart: expandIconLineOffset,
              height: lineWidth
            },
            "&::after": {
              top: expandIconLineOffset,
              bottom: expandIconLineOffset,
              insetInlineStart: expandIconHalfInner,
              width: lineWidth,
              transform: "rotate(90deg)"
            },
            // Motion effect
            "&-collapsed::before": {
              transform: "rotate(-180deg)"
            },
            "&-collapsed::after": {
              transform: "rotate(0deg)"
            },
            "&-spaced": {
              "&::before, &::after": {
                display: "none",
                content: "none"
              },
              background: "transparent",
              border: 0,
              visibility: "hidden"
            }
          }),
          [`${componentCls}-row-indent + ${componentCls}-row-expand-icon`]: {
            marginTop: expandIconMarginTop,
            marginInlineEnd: paddingXS
          },
          [`tr${componentCls}-expanded-row`]: {
            "&, &:hover": {
              [`> th, > td`]: {
                background: tableExpandedRowBg
              }
            },
            // https://github.com/ant-design/ant-design/issues/25573
            [`${antCls}-descriptions-view`]: {
              display: "flex",
              table: {
                flex: "auto",
                width: "auto"
              }
            }
          },
          // With fixed
          [`${componentCls}-expanded-row-fixed`]: {
            position: "relative",
            margin: `${unit$1(calc(tablePaddingVertical).mul(-1).equal())} ${unit$1(calc(tablePaddingHorizontal).mul(-1).equal())}`,
            padding: `${unit$1(tablePaddingVertical)} ${unit$1(tablePaddingHorizontal)}`
          }
        }
      };
    };
    const genExpandStyle$1 = genExpandStyle;
    const genFilterStyle = (token2) => {
      const {
        componentCls,
        antCls,
        iconCls,
        tableFilterDropdownWidth,
        tableFilterDropdownSearchWidth,
        paddingXXS,
        paddingXS,
        colorText,
        lineWidth,
        lineType,
        tableBorderColor,
        headerIconColor,
        fontSizeSM,
        tablePaddingHorizontal,
        borderRadius,
        motionDurationSlow,
        colorTextDescription,
        colorPrimary,
        tableHeaderFilterActiveBg,
        colorTextDisabled,
        tableFilterDropdownBg,
        tableFilterDropdownHeight,
        controlItemBgHover,
        controlItemBgActive,
        boxShadowSecondary,
        filterDropdownMenuBg,
        calc
      } = token2;
      const dropdownPrefixCls = `${antCls}-dropdown`;
      const tableFilterDropdownPrefixCls = `${componentCls}-filter-dropdown`;
      const treePrefixCls = `${antCls}-tree`;
      const tableBorder = `${unit$1(lineWidth)} ${lineType} ${tableBorderColor}`;
      return [
        {
          [`${componentCls}-wrapper`]: {
            [`${componentCls}-filter-column`]: {
              display: "flex",
              justifyContent: "space-between"
            },
            [`${componentCls}-filter-trigger`]: {
              position: "relative",
              display: "flex",
              alignItems: "center",
              marginBlock: calc(paddingXXS).mul(-1).equal(),
              marginInline: `${unit$1(paddingXXS)} ${unit$1(calc(tablePaddingHorizontal).div(2).mul(-1).equal())}`,
              padding: `0 ${unit$1(paddingXXS)}`,
              color: headerIconColor,
              fontSize: fontSizeSM,
              borderRadius,
              cursor: "pointer",
              transition: `all ${motionDurationSlow}`,
              "&:hover": {
                color: colorTextDescription,
                background: tableHeaderFilterActiveBg
              },
              "&.active": {
                color: colorPrimary
              }
            }
          }
        },
        {
          // Dropdown
          [`${antCls}-dropdown`]: {
            [tableFilterDropdownPrefixCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
              minWidth: tableFilterDropdownWidth,
              backgroundColor: tableFilterDropdownBg,
              borderRadius,
              boxShadow: boxShadowSecondary,
              overflow: "hidden",
              // Reset menu
              [`${dropdownPrefixCls}-menu`]: {
                // https://github.com/ant-design/ant-design/issues/4916
                // https://github.com/ant-design/ant-design/issues/19542
                maxHeight: tableFilterDropdownHeight,
                overflowX: "hidden",
                border: 0,
                boxShadow: "none",
                borderRadius: "unset",
                backgroundColor: filterDropdownMenuBg,
                "&:empty::after": {
                  display: "block",
                  padding: `${unit$1(paddingXS)} 0`,
                  color: colorTextDisabled,
                  fontSize: fontSizeSM,
                  textAlign: "center",
                  content: '"Not Found"'
                }
              },
              [`${tableFilterDropdownPrefixCls}-tree`]: {
                paddingBlock: `${unit$1(paddingXS)} 0`,
                paddingInline: paddingXS,
                [treePrefixCls]: {
                  padding: 0
                },
                [`${treePrefixCls}-treenode ${treePrefixCls}-node-content-wrapper:hover`]: {
                  backgroundColor: controlItemBgHover
                },
                [`${treePrefixCls}-treenode-checkbox-checked ${treePrefixCls}-node-content-wrapper`]: {
                  "&, &:hover": {
                    backgroundColor: controlItemBgActive
                  }
                }
              },
              [`${tableFilterDropdownPrefixCls}-search`]: {
                padding: paddingXS,
                borderBottom: tableBorder,
                "&-input": {
                  input: {
                    minWidth: tableFilterDropdownSearchWidth
                  },
                  [iconCls]: {
                    color: colorTextDisabled
                  }
                }
              },
              [`${tableFilterDropdownPrefixCls}-checkall`]: {
                width: "100%",
                marginBottom: paddingXXS,
                marginInlineStart: paddingXXS
              },
              // Operation
              [`${tableFilterDropdownPrefixCls}-btns`]: {
                display: "flex",
                justifyContent: "space-between",
                padding: `${unit$1(calc(paddingXS).sub(lineWidth).equal())} ${unit$1(paddingXS)}`,
                overflow: "hidden",
                borderTop: tableBorder
              }
            })
          }
        },
        // Dropdown Menu & SubMenu
        {
          // submenu of table filter dropdown
          [`${antCls}-dropdown ${tableFilterDropdownPrefixCls}, ${tableFilterDropdownPrefixCls}-submenu`]: {
            // Checkbox
            [`${antCls}-checkbox-wrapper + span`]: {
              paddingInlineStart: paddingXS,
              color: colorText
            },
            [`> ul`]: {
              maxHeight: "calc(100vh - 130px)",
              overflowX: "hidden",
              overflowY: "auto"
            }
          }
        }
      ];
    };
    const genFilterStyle$1 = genFilterStyle;
    const genFixedStyle = (token2) => {
      const {
        componentCls,
        lineWidth,
        colorSplit,
        motionDurationSlow,
        zIndexTableFixed,
        tableBg,
        zIndexTableSticky,
        calc
      } = token2;
      const shadowColor = colorSplit;
      return {
        [`${componentCls}-wrapper`]: {
          [`
        ${componentCls}-cell-fix-left,
        ${componentCls}-cell-fix-right
      `]: {
            position: "sticky !important",
            zIndex: zIndexTableFixed,
            background: tableBg
          },
          [`
        ${componentCls}-cell-fix-left-first::after,
        ${componentCls}-cell-fix-left-last::after
      `]: {
            position: "absolute",
            top: 0,
            right: {
              _skip_check_: true,
              value: 0
            },
            bottom: calc(lineWidth).mul(-1).equal(),
            width: 30,
            transform: "translateX(100%)",
            transition: `box-shadow ${motionDurationSlow}`,
            content: '""',
            pointerEvents: "none"
          },
          [`${componentCls}-cell-fix-left-all::after`]: {
            display: "none"
          },
          [`
        ${componentCls}-cell-fix-right-first::after,
        ${componentCls}-cell-fix-right-last::after
      `]: {
            position: "absolute",
            top: 0,
            bottom: calc(lineWidth).mul(-1).equal(),
            left: {
              _skip_check_: true,
              value: 0
            },
            width: 30,
            transform: "translateX(-100%)",
            transition: `box-shadow ${motionDurationSlow}`,
            content: '""',
            pointerEvents: "none"
          },
          [`${componentCls}-container`]: {
            "&::before, &::after": {
              position: "absolute",
              top: 0,
              bottom: 0,
              zIndex: calc(zIndexTableSticky).add(1).equal({
                unit: false
              }),
              width: 30,
              transition: `box-shadow ${motionDurationSlow}`,
              content: '""',
              pointerEvents: "none"
            },
            "&::before": {
              insetInlineStart: 0
            },
            "&::after": {
              insetInlineEnd: 0
            }
          },
          [`${componentCls}-ping-left`]: {
            [`&:not(${componentCls}-has-fix-left) ${componentCls}-container`]: {
              position: "relative",
              "&::before": {
                boxShadow: `inset 10px 0 8px -8px ${shadowColor}`
              }
            },
            [`
          ${componentCls}-cell-fix-left-first::after,
          ${componentCls}-cell-fix-left-last::after
        `]: {
              boxShadow: `inset 10px 0 8px -8px ${shadowColor}`
            },
            [`${componentCls}-cell-fix-left-last::before`]: {
              backgroundColor: "transparent !important"
            }
          },
          [`${componentCls}-ping-right`]: {
            [`&:not(${componentCls}-has-fix-right) ${componentCls}-container`]: {
              position: "relative",
              "&::after": {
                boxShadow: `inset -10px 0 8px -8px ${shadowColor}`
              }
            },
            [`
          ${componentCls}-cell-fix-right-first::after,
          ${componentCls}-cell-fix-right-last::after
        `]: {
              boxShadow: `inset -10px 0 8px -8px ${shadowColor}`
            }
          }
        }
      };
    };
    const genFixedStyle$1 = genFixedStyle;
    const genPaginationStyle = (token2) => {
      const {
        componentCls,
        antCls,
        margin
      } = token2;
      return {
        [`${componentCls}-wrapper`]: {
          // ========================== Pagination ==========================
          [`${componentCls}-pagination${antCls}-pagination`]: {
            margin: `${unit$1(margin)} 0`
          },
          [`${componentCls}-pagination`]: {
            display: "flex",
            flexWrap: "wrap",
            rowGap: token2.paddingXS,
            "> *": {
              flex: "none"
            },
            "&-left": {
              justifyContent: "flex-start"
            },
            "&-center": {
              justifyContent: "center"
            },
            "&-right": {
              justifyContent: "flex-end"
            }
          }
        }
      };
    };
    const genPaginationStyle$1 = genPaginationStyle;
    const genRadiusStyle = (token2) => {
      const {
        componentCls,
        tableRadius
      } = token2;
      return {
        [`${componentCls}-wrapper`]: {
          [componentCls]: {
            // https://github.com/ant-design/ant-design/issues/39115#issuecomment-1362314574
            [`${componentCls}-title, ${componentCls}-header`]: {
              borderRadius: `${unit$1(tableRadius)} ${unit$1(tableRadius)} 0 0`
            },
            [`${componentCls}-title + ${componentCls}-container`]: {
              borderStartStartRadius: 0,
              borderStartEndRadius: 0,
              // https://github.com/ant-design/ant-design/issues/41975
              [`${componentCls}-header, table`]: {
                borderRadius: 0
              },
              "table > thead > tr:first-child": {
                "th:first-child, th:last-child, td:first-child, td:last-child": {
                  borderRadius: 0
                }
              }
            },
            "&-container": {
              borderStartStartRadius: tableRadius,
              borderStartEndRadius: tableRadius,
              "table > thead > tr:first-child": {
                "> *:first-child": {
                  borderStartStartRadius: tableRadius
                },
                "> *:last-child": {
                  borderStartEndRadius: tableRadius
                }
              }
            },
            "&-footer": {
              borderRadius: `0 0 ${unit$1(tableRadius)} ${unit$1(tableRadius)}`
            }
          }
        }
      };
    };
    const genRadiusStyle$1 = genRadiusStyle;
    const genStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}-wrapper-rtl`]: {
          direction: "rtl",
          table: {
            direction: "rtl"
          },
          [`${componentCls}-pagination-left`]: {
            justifyContent: "flex-end"
          },
          [`${componentCls}-pagination-right`]: {
            justifyContent: "flex-start"
          },
          [`${componentCls}-row-expand-icon`]: {
            float: "right",
            "&::after": {
              transform: "rotate(-90deg)"
            },
            "&-collapsed::before": {
              transform: "rotate(180deg)"
            },
            "&-collapsed::after": {
              transform: "rotate(0deg)"
            }
          },
          [`${componentCls}-container`]: {
            "&::before": {
              insetInlineStart: "unset",
              insetInlineEnd: 0
            },
            "&::after": {
              insetInlineStart: 0,
              insetInlineEnd: "unset"
            },
            [`${componentCls}-row-indent`]: {
              float: "right"
            }
          }
        }
      };
    };
    const genRtlStyle$2 = genStyle;
    const genSelectionStyle = (token2) => {
      const {
        componentCls,
        antCls,
        iconCls,
        fontSizeIcon,
        padding,
        paddingXS,
        headerIconColor,
        headerIconHoverColor,
        tableSelectionColumnWidth,
        tableSelectedRowBg,
        tableSelectedRowHoverBg,
        tableRowHoverBg,
        tablePaddingHorizontal,
        calc
      } = token2;
      return {
        [`${componentCls}-wrapper`]: {
          // ========================== Selections ==========================
          [`${componentCls}-selection-col`]: {
            width: tableSelectionColumnWidth,
            [`&${componentCls}-selection-col-with-dropdown`]: {
              width: calc(tableSelectionColumnWidth).add(fontSizeIcon).add(calc(padding).div(4)).equal()
            }
          },
          [`${componentCls}-bordered ${componentCls}-selection-col`]: {
            width: calc(tableSelectionColumnWidth).add(calc(paddingXS).mul(2)).equal(),
            [`&${componentCls}-selection-col-with-dropdown`]: {
              width: calc(tableSelectionColumnWidth).add(fontSizeIcon).add(calc(padding).div(4)).add(calc(paddingXS).mul(2)).equal()
            }
          },
          [`
        table tr th${componentCls}-selection-column,
        table tr td${componentCls}-selection-column,
        ${componentCls}-selection-column
      `]: {
            paddingInlineEnd: token2.paddingXS,
            paddingInlineStart: token2.paddingXS,
            textAlign: "center",
            [`${antCls}-radio-wrapper`]: {
              marginInlineEnd: 0
            }
          },
          [`table tr th${componentCls}-selection-column${componentCls}-cell-fix-left`]: {
            zIndex: token2.zIndexTableFixed + 1
          },
          [`table tr th${componentCls}-selection-column::after`]: {
            backgroundColor: "transparent !important"
          },
          [`${componentCls}-selection`]: {
            position: "relative",
            display: "inline-flex",
            flexDirection: "column"
          },
          [`${componentCls}-selection-extra`]: {
            position: "absolute",
            top: 0,
            zIndex: 1,
            cursor: "pointer",
            transition: `all ${token2.motionDurationSlow}`,
            marginInlineStart: "100%",
            paddingInlineStart: unit$1(calc(tablePaddingHorizontal).div(4).equal()),
            [iconCls]: {
              color: headerIconColor,
              fontSize: fontSizeIcon,
              verticalAlign: "baseline",
              "&:hover": {
                color: headerIconHoverColor
              }
            }
          },
          // ============================= Rows =============================
          [`${componentCls}-tbody`]: {
            [`${componentCls}-row`]: {
              [`&${componentCls}-row-selected`]: {
                [`> ${componentCls}-cell`]: {
                  background: tableSelectedRowBg,
                  "&-row-hover": {
                    background: tableSelectedRowHoverBg
                  }
                }
              },
              [`> ${componentCls}-cell-row-hover`]: {
                background: tableRowHoverBg
              }
            }
          }
        }
      };
    };
    const genSelectionStyle$1 = genSelectionStyle;
    const genSizeStyle = (token2) => {
      const {
        componentCls,
        tableExpandColumnWidth,
        calc
      } = token2;
      const getSizeStyle = (size, paddingVertical, paddingHorizontal, fontSize) => ({
        [`${componentCls}${componentCls}-${size}`]: {
          fontSize,
          [`
        ${componentCls}-title,
        ${componentCls}-footer,
        ${componentCls}-cell,
        ${componentCls}-thead > tr > th,
        ${componentCls}-tbody > tr > th,
        ${componentCls}-tbody > tr > td,
        tfoot > tr > th,
        tfoot > tr > td
      `]: {
            padding: `${unit$1(paddingVertical)} ${unit$1(paddingHorizontal)}`
          },
          [`${componentCls}-filter-trigger`]: {
            marginInlineEnd: unit$1(calc(paddingHorizontal).div(2).mul(-1).equal())
          },
          [`${componentCls}-expanded-row-fixed`]: {
            margin: `${unit$1(calc(paddingVertical).mul(-1).equal())} ${unit$1(calc(paddingHorizontal).mul(-1).equal())}`
          },
          [`${componentCls}-tbody`]: {
            // ========================= Nest Table ===========================
            [`${componentCls}-wrapper:only-child ${componentCls}`]: {
              marginBlock: unit$1(calc(paddingVertical).mul(-1).equal()),
              marginInline: `${unit$1(calc(tableExpandColumnWidth).sub(paddingHorizontal).equal())} ${unit$1(calc(paddingHorizontal).mul(-1).equal())}`
            }
          },
          // https://github.com/ant-design/ant-design/issues/35167
          [`${componentCls}-selection-extra`]: {
            paddingInlineStart: unit$1(calc(paddingHorizontal).div(4).equal())
          }
        }
      });
      return {
        [`${componentCls}-wrapper`]: Object.assign(Object.assign({}, getSizeStyle("middle", token2.tablePaddingVerticalMiddle, token2.tablePaddingHorizontalMiddle, token2.tableFontSizeMiddle)), getSizeStyle("small", token2.tablePaddingVerticalSmall, token2.tablePaddingHorizontalSmall, token2.tableFontSizeSmall))
      };
    };
    const genSizeStyle$1 = genSizeStyle;
    const genSorterStyle = (token2) => {
      const {
        componentCls,
        marginXXS,
        fontSizeIcon,
        headerIconColor,
        headerIconHoverColor
      } = token2;
      return {
        [`${componentCls}-wrapper`]: {
          [`${componentCls}-thead th${componentCls}-column-has-sorters`]: {
            outline: "none",
            cursor: "pointer",
            transition: `all ${token2.motionDurationSlow}`,
            "&:hover": {
              background: token2.tableHeaderSortHoverBg,
              "&::before": {
                backgroundColor: "transparent !important"
              }
            },
            "&:focus-visible": {
              color: token2.colorPrimary
            },
            // https://github.com/ant-design/ant-design/issues/30969
            [`
          &${componentCls}-cell-fix-left:hover,
          &${componentCls}-cell-fix-right:hover
        `]: {
              background: token2.tableFixedHeaderSortActiveBg
            }
          },
          [`${componentCls}-thead th${componentCls}-column-sort`]: {
            background: token2.tableHeaderSortBg,
            "&::before": {
              backgroundColor: "transparent !important"
            }
          },
          [`td${componentCls}-column-sort`]: {
            background: token2.tableBodySortBg
          },
          [`${componentCls}-column-title`]: {
            position: "relative",
            zIndex: 1,
            flex: 1
          },
          [`${componentCls}-column-sorters`]: {
            display: "flex",
            flex: "auto",
            alignItems: "center",
            justifyContent: "space-between",
            "&::after": {
              position: "absolute",
              inset: 0,
              width: "100%",
              height: "100%",
              content: '""'
            }
          },
          [`${componentCls}-column-sorter`]: {
            marginInlineStart: marginXXS,
            color: headerIconColor,
            fontSize: 0,
            transition: `color ${token2.motionDurationSlow}`,
            "&-inner": {
              display: "inline-flex",
              flexDirection: "column",
              alignItems: "center"
            },
            "&-up, &-down": {
              fontSize: fontSizeIcon,
              "&.active": {
                color: token2.colorPrimary
              }
            },
            [`${componentCls}-column-sorter-up + ${componentCls}-column-sorter-down`]: {
              marginTop: "-0.3em"
            }
          },
          [`${componentCls}-column-sorters:hover ${componentCls}-column-sorter`]: {
            color: headerIconHoverColor
          }
        }
      };
    };
    const genSorterStyle$1 = genSorterStyle;
    const genStickyStyle = (token2) => {
      const {
        componentCls,
        opacityLoading,
        tableScrollThumbBg,
        tableScrollThumbBgHover,
        tableScrollThumbSize,
        tableScrollBg,
        zIndexTableSticky,
        stickyScrollBarBorderRadius,
        lineWidth,
        lineType,
        tableBorderColor
      } = token2;
      const tableBorder = `${unit$1(lineWidth)} ${lineType} ${tableBorderColor}`;
      return {
        [`${componentCls}-wrapper`]: {
          [`${componentCls}-sticky`]: {
            "&-holder": {
              position: "sticky",
              zIndex: zIndexTableSticky,
              background: token2.colorBgContainer
            },
            "&-scroll": {
              position: "sticky",
              bottom: 0,
              height: `${unit$1(tableScrollThumbSize)} !important`,
              zIndex: zIndexTableSticky,
              display: "flex",
              alignItems: "center",
              background: tableScrollBg,
              borderTop: tableBorder,
              opacity: opacityLoading,
              "&:hover": {
                transformOrigin: "center bottom"
              },
              // fake scrollbar style of sticky
              "&-bar": {
                height: tableScrollThumbSize,
                backgroundColor: tableScrollThumbBg,
                borderRadius: stickyScrollBarBorderRadius,
                transition: `all ${token2.motionDurationSlow}, transform none`,
                position: "absolute",
                bottom: 0,
                "&:hover, &-active": {
                  backgroundColor: tableScrollThumbBgHover
                }
              }
            }
          }
        }
      };
    };
    const genStickyStyle$1 = genStickyStyle;
    const genSummaryStyle = (token2) => {
      const {
        componentCls,
        lineWidth,
        tableBorderColor,
        calc
      } = token2;
      const tableBorder = `${unit$1(lineWidth)} ${token2.lineType} ${tableBorderColor}`;
      return {
        [`${componentCls}-wrapper`]: {
          [`${componentCls}-summary`]: {
            position: "relative",
            zIndex: token2.zIndexTableFixed,
            background: token2.tableBg,
            "> tr": {
              "> th, > td": {
                borderBottom: tableBorder
              }
            }
          },
          [`div${componentCls}-summary`]: {
            boxShadow: `0 ${unit$1(calc(lineWidth).mul(-1).equal())} 0 ${tableBorderColor}`
          }
        }
      };
    };
    const genSummaryStyle$1 = genSummaryStyle;
    const genVirtualStyle = (token2) => {
      const {
        componentCls,
        motionDurationMid,
        lineWidth,
        lineType,
        tableBorderColor,
        calc
      } = token2;
      const tableBorder = `${unit$1(lineWidth)} ${lineType} ${tableBorderColor}`;
      const rowCellCls = `${componentCls}-expanded-row-cell`;
      return {
        [`${componentCls}-wrapper`]: {
          // ========================== Row ==========================
          [`${componentCls}-tbody-virtual`]: {
            [`${componentCls}-row`]: {
              display: "flex",
              boxSizing: "border-box",
              width: "100%"
            },
            [`${componentCls}-cell`]: {
              borderBottom: tableBorder,
              transition: `background ${motionDurationMid}`
            },
            [`${componentCls}-expanded-row`]: {
              [`${rowCellCls}${rowCellCls}-fixed`]: {
                position: "sticky",
                insetInlineStart: 0,
                overflow: "hidden",
                width: `calc(var(--virtual-width) - ${unit$1(lineWidth)})`,
                borderInlineEnd: "none"
              }
            }
          },
          // ======================== Border =========================
          [`${componentCls}-bordered`]: {
            [`${componentCls}-tbody-virtual`]: {
              "&:after": {
                content: '""',
                insetInline: 0,
                bottom: 0,
                borderBottom: tableBorder,
                position: "absolute"
              },
              [`${componentCls}-cell`]: {
                borderInlineEnd: tableBorder,
                [`&${componentCls}-cell-fix-right-first:before`]: {
                  content: '""',
                  position: "absolute",
                  insetBlock: 0,
                  insetInlineStart: calc(lineWidth).mul(-1).equal(),
                  borderInlineStart: tableBorder
                }
              }
            },
            // Empty placeholder
            [`&${componentCls}-virtual`]: {
              [`${componentCls}-placeholder ${componentCls}-cell`]: {
                borderInlineEnd: tableBorder,
                borderBottom: tableBorder
              }
            }
          }
        }
      };
    };
    const genVirtualStyle$1 = genVirtualStyle;
    const genTableStyle = (token2) => {
      const {
        componentCls,
        fontWeightStrong,
        tablePaddingVertical,
        tablePaddingHorizontal,
        tableExpandColumnWidth,
        lineWidth,
        lineType,
        tableBorderColor,
        tableFontSize,
        tableBg,
        tableRadius,
        tableHeaderTextColor,
        motionDurationMid,
        tableHeaderBg,
        tableHeaderCellSplitColor,
        tableFooterTextColor,
        tableFooterBg,
        calc
      } = token2;
      const tableBorder = `${unit$1(lineWidth)} ${lineType} ${tableBorderColor}`;
      return {
        [`${componentCls}-wrapper`]: Object.assign(Object.assign({
          clear: "both",
          maxWidth: "100%"
        }, clearFix()), {
          [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
            fontSize: tableFontSize,
            background: tableBg,
            borderRadius: `${unit$1(tableRadius)} ${unit$1(tableRadius)} 0 0`
          }),
          // https://github.com/ant-design/ant-design/issues/17611
          table: {
            width: "100%",
            textAlign: "start",
            borderRadius: `${unit$1(tableRadius)} ${unit$1(tableRadius)} 0 0`,
            borderCollapse: "separate",
            borderSpacing: 0
          },
          // ============================= Cell ==============================
          [`
          ${componentCls}-cell,
          ${componentCls}-thead > tr > th,
          ${componentCls}-tbody > tr > th,
          ${componentCls}-tbody > tr > td,
          tfoot > tr > th,
          tfoot > tr > td
        `]: {
            position: "relative",
            padding: `${unit$1(tablePaddingVertical)} ${unit$1(tablePaddingHorizontal)}`,
            overflowWrap: "break-word"
          },
          // ============================ Title =============================
          [`${componentCls}-title`]: {
            padding: `${unit$1(tablePaddingVertical)} ${unit$1(tablePaddingHorizontal)}`
          },
          // ============================ Header ============================
          [`${componentCls}-thead`]: {
            [`
          > tr > th,
          > tr > td
        `]: {
              position: "relative",
              color: tableHeaderTextColor,
              fontWeight: fontWeightStrong,
              textAlign: "start",
              background: tableHeaderBg,
              borderBottom: tableBorder,
              transition: `background ${motionDurationMid} ease`,
              "&[colspan]:not([colspan='1'])": {
                textAlign: "center"
              },
              [`&:not(:last-child):not(${componentCls}-selection-column):not(${componentCls}-row-expand-icon-cell):not([colspan])::before`]: {
                position: "absolute",
                top: "50%",
                insetInlineEnd: 0,
                width: 1,
                height: "1.6em",
                backgroundColor: tableHeaderCellSplitColor,
                transform: "translateY(-50%)",
                transition: `background-color ${motionDurationMid}`,
                content: '""'
              }
            },
            "> tr:not(:last-child) > th[colspan]": {
              borderBottom: 0
            }
          },
          // ============================ Body ============================
          [`${componentCls}-tbody`]: {
            "> tr": {
              [`> th, > td`]: {
                transition: `background ${motionDurationMid}, border-color ${motionDurationMid}`,
                borderBottom: tableBorder,
                // ========================= Nest Table ===========================
                [`
              > ${componentCls}-wrapper:only-child,
              > ${componentCls}-expanded-row-fixed > ${componentCls}-wrapper:only-child
            `]: {
                  [componentCls]: {
                    marginBlock: unit$1(calc(tablePaddingVertical).mul(-1).equal()),
                    marginInline: `${unit$1(calc(tableExpandColumnWidth).sub(tablePaddingHorizontal).equal())}
                ${unit$1(calc(tablePaddingHorizontal).mul(-1).equal())}`,
                    [`${componentCls}-tbody > tr:last-child > td`]: {
                      borderBottom: 0,
                      "&:first-child, &:last-child": {
                        borderRadius: 0
                      }
                    }
                  }
                }
              },
              "> th": {
                position: "relative",
                color: tableHeaderTextColor,
                fontWeight: fontWeightStrong,
                textAlign: "start",
                background: tableHeaderBg,
                borderBottom: tableBorder,
                transition: `background ${motionDurationMid} ease`
              }
            }
          },
          // ============================ Footer ============================
          [`${componentCls}-footer`]: {
            padding: `${unit$1(tablePaddingVertical)} ${unit$1(tablePaddingHorizontal)}`,
            color: tableFooterTextColor,
            background: tableFooterBg
          }
        })
      };
    };
    const prepareComponentToken$1 = (token2) => {
      const {
        colorFillAlter,
        colorBgContainer,
        colorTextHeading,
        colorFillSecondary,
        colorFillContent,
        controlItemBgActive,
        controlItemBgActiveHover,
        padding,
        paddingSM,
        paddingXS,
        colorBorderSecondary,
        borderRadiusLG,
        controlHeight,
        colorTextPlaceholder,
        fontSize,
        fontSizeSM,
        lineHeight,
        lineWidth,
        colorIcon,
        colorIconHover,
        opacityLoading,
        controlInteractiveSize
      } = token2;
      const colorFillSecondarySolid = new TinyColor(colorFillSecondary).onBackground(colorBgContainer).toHexShortString();
      const colorFillContentSolid = new TinyColor(colorFillContent).onBackground(colorBgContainer).toHexShortString();
      const colorFillAlterSolid = new TinyColor(colorFillAlter).onBackground(colorBgContainer).toHexShortString();
      const baseColorAction = new TinyColor(colorIcon);
      const baseColorActionHover = new TinyColor(colorIconHover);
      const expandIconHalfInner = controlInteractiveSize / 2 - lineWidth;
      const expandIconSize = expandIconHalfInner * 2 + lineWidth * 3;
      return {
        headerBg: colorFillAlterSolid,
        headerColor: colorTextHeading,
        headerSortActiveBg: colorFillSecondarySolid,
        headerSortHoverBg: colorFillContentSolid,
        bodySortBg: colorFillAlterSolid,
        rowHoverBg: colorFillAlterSolid,
        rowSelectedBg: controlItemBgActive,
        rowSelectedHoverBg: controlItemBgActiveHover,
        rowExpandedBg: colorFillAlter,
        cellPaddingBlock: padding,
        cellPaddingInline: padding,
        cellPaddingBlockMD: paddingSM,
        cellPaddingInlineMD: paddingXS,
        cellPaddingBlockSM: paddingXS,
        cellPaddingInlineSM: paddingXS,
        borderColor: colorBorderSecondary,
        headerBorderRadius: borderRadiusLG,
        footerBg: colorFillAlterSolid,
        footerColor: colorTextHeading,
        cellFontSize: fontSize,
        cellFontSizeMD: fontSize,
        cellFontSizeSM: fontSize,
        headerSplitColor: colorBorderSecondary,
        fixedHeaderSortActiveBg: colorFillSecondarySolid,
        headerFilterHoverBg: colorFillContent,
        filterDropdownMenuBg: colorBgContainer,
        filterDropdownBg: colorBgContainer,
        expandIconBg: colorBgContainer,
        selectionColumnWidth: controlHeight,
        stickyScrollBarBg: colorTextPlaceholder,
        stickyScrollBarBorderRadius: 100,
        expandIconMarginTop: (fontSize * lineHeight - lineWidth * 3) / 2 - Math.ceil((fontSizeSM * 1.4 - lineWidth * 3) / 2),
        headerIconColor: baseColorAction.clone().setAlpha(baseColorAction.getAlpha() * opacityLoading).toRgbString(),
        headerIconHoverColor: baseColorActionHover.clone().setAlpha(baseColorActionHover.getAlpha() * opacityLoading).toRgbString(),
        expandIconHalfInner,
        expandIconSize,
        expandIconScale: controlInteractiveSize / expandIconSize
      };
    };
    const useStyle$1 = genStyleHooks("Table", (token2) => {
      const {
        colorTextHeading,
        colorSplit,
        colorBgContainer,
        controlInteractiveSize: checkboxSize,
        headerBg,
        headerColor,
        headerSortActiveBg,
        headerSortHoverBg,
        bodySortBg,
        rowHoverBg,
        rowSelectedBg,
        rowSelectedHoverBg,
        rowExpandedBg,
        cellPaddingBlock,
        cellPaddingInline,
        cellPaddingBlockMD,
        cellPaddingInlineMD,
        cellPaddingBlockSM,
        cellPaddingInlineSM,
        borderColor,
        footerBg,
        footerColor,
        headerBorderRadius,
        cellFontSize,
        cellFontSizeMD,
        cellFontSizeSM,
        headerSplitColor,
        fixedHeaderSortActiveBg,
        headerFilterHoverBg,
        filterDropdownBg,
        expandIconBg,
        selectionColumnWidth,
        stickyScrollBarBg,
        calc
      } = token2;
      const zIndexTableFixed = 2;
      const tableToken = merge$1(token2, {
        tableFontSize: cellFontSize,
        tableBg: colorBgContainer,
        tableRadius: headerBorderRadius,
        tablePaddingVertical: cellPaddingBlock,
        tablePaddingHorizontal: cellPaddingInline,
        tablePaddingVerticalMiddle: cellPaddingBlockMD,
        tablePaddingHorizontalMiddle: cellPaddingInlineMD,
        tablePaddingVerticalSmall: cellPaddingBlockSM,
        tablePaddingHorizontalSmall: cellPaddingInlineSM,
        tableBorderColor: borderColor,
        tableHeaderTextColor: headerColor,
        tableHeaderBg: headerBg,
        tableFooterTextColor: footerColor,
        tableFooterBg: footerBg,
        tableHeaderCellSplitColor: headerSplitColor,
        tableHeaderSortBg: headerSortActiveBg,
        tableHeaderSortHoverBg: headerSortHoverBg,
        tableBodySortBg: bodySortBg,
        tableFixedHeaderSortActiveBg: fixedHeaderSortActiveBg,
        tableHeaderFilterActiveBg: headerFilterHoverBg,
        tableFilterDropdownBg: filterDropdownBg,
        tableRowHoverBg: rowHoverBg,
        tableSelectedRowBg: rowSelectedBg,
        tableSelectedRowHoverBg: rowSelectedHoverBg,
        zIndexTableFixed,
        zIndexTableSticky: zIndexTableFixed + 1,
        tableFontSizeMiddle: cellFontSizeMD,
        tableFontSizeSmall: cellFontSizeSM,
        tableSelectionColumnWidth: selectionColumnWidth,
        tableExpandIconBg: expandIconBg,
        tableExpandColumnWidth: calc(checkboxSize).add(calc(token2.padding).mul(2)).equal(),
        tableExpandedRowBg: rowExpandedBg,
        // Dropdown
        tableFilterDropdownWidth: 120,
        tableFilterDropdownHeight: 264,
        tableFilterDropdownSearchWidth: 140,
        // Virtual Scroll Bar
        tableScrollThumbSize: 8,
        // Mac scroll bar size
        tableScrollThumbBg: stickyScrollBarBg,
        tableScrollThumbBgHover: colorTextHeading,
        tableScrollBg: colorSplit
      });
      return [genTableStyle(tableToken), genPaginationStyle$1(tableToken), genSummaryStyle$1(tableToken), genSorterStyle$1(tableToken), genFilterStyle$1(tableToken), genBorderedStyle$1(tableToken), genRadiusStyle$1(tableToken), genExpandStyle$1(tableToken), genSummaryStyle$1(tableToken), genEmptyStyle$1(tableToken), genSelectionStyle$1(tableToken), genFixedStyle$1(tableToken), genStickyStyle$1(tableToken), genEllipsisStyle$1(tableToken), genSizeStyle$1(tableToken), genRtlStyle$2(tableToken), genVirtualStyle$1(tableToken)];
    }, prepareComponentToken$1, {
      unitless: {
        expandIconScale: true
      }
    });
    const EMPTY_LIST = [];
    const InternalTable = (props, ref) => {
      const {
        prefixCls: customizePrefixCls,
        className,
        rootClassName,
        style: style2,
        size: customizeSize,
        bordered,
        dropdownPrefixCls: customizeDropdownPrefixCls,
        dataSource,
        pagination,
        rowSelection,
        rowKey = "key",
        rowClassName,
        columns,
        children,
        childrenColumnName: legacyChildrenColumnName,
        onChange,
        getPopupContainer,
        loading,
        expandIcon,
        expandable,
        expandedRowRender,
        expandIconColumnIndex,
        indentSize,
        scroll,
        sortDirections,
        locale: locale2,
        showSorterTooltip = true,
        virtual
      } = props;
      devUseWarning();
      const baseColumns = reactExports.useMemo(() => columns || convertChildrenToColumns(children), [columns, children]);
      const needResponsive = reactExports.useMemo(() => baseColumns.some((col) => col.responsive), [baseColumns]);
      const screens = useBreakpoint(needResponsive);
      const mergedColumns = reactExports.useMemo(() => {
        const matched = new Set(Object.keys(screens).filter((m2) => screens[m2]));
        return baseColumns.filter((c2) => !c2.responsive || c2.responsive.some((r2) => matched.has(r2)));
      }, [baseColumns, screens]);
      const tableProps = omit(props, ["className", "style", "columns"]);
      const {
        locale: contextLocale = defaultLocale,
        direction,
        table,
        renderEmpty,
        getPrefixCls,
        getPopupContainer: getContextPopupContainer
      } = reactExports.useContext(ConfigContext);
      const mergedSize = useSize$1(customizeSize);
      const tableLocale = Object.assign(Object.assign({}, contextLocale.Table), locale2);
      const rawData = dataSource || EMPTY_LIST;
      const prefixCls = getPrefixCls("table", customizePrefixCls);
      const dropdownPrefixCls = getPrefixCls("dropdown", customizeDropdownPrefixCls);
      const [, token2] = useToken$1();
      const rootCls = useCSSVarCls$1(prefixCls);
      const [wrapCSSVar, hashId] = useStyle$1(prefixCls, rootCls);
      const mergedExpandable = Object.assign({
        childrenColumnName: legacyChildrenColumnName,
        expandIconColumnIndex
      }, expandable);
      const {
        childrenColumnName = "children"
      } = mergedExpandable;
      const expandType = reactExports.useMemo(() => {
        if (rawData.some((item) => item === null || item === void 0 ? void 0 : item[childrenColumnName])) {
          return "nest";
        }
        if (expandedRowRender || expandable && expandable.expandedRowRender) {
          return "row";
        }
        return null;
      }, [rawData]);
      const internalRefs = {
        body: reactExports.useRef()
      };
      const getContainerWidth = useContainerWidth(prefixCls);
      const rootRef = reactExports.useRef(null);
      const tblRef = reactExports.useRef(null);
      useProxyImperativeHandle(ref, () => Object.assign(Object.assign({}, tblRef.current), {
        nativeElement: rootRef.current
      }));
      const getRowKey = reactExports.useMemo(() => {
        if (typeof rowKey === "function") {
          return rowKey;
        }
        return (record) => record === null || record === void 0 ? void 0 : record[rowKey];
      }, [rowKey]);
      const [getRecordByKey] = useLazyKVMap(rawData, childrenColumnName, getRowKey);
      const changeEventInfo = {};
      const triggerOnChange = function(info, action) {
        let reset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        var _a, _b, _c;
        const changeInfo = Object.assign(Object.assign({}, changeEventInfo), info);
        if (reset) {
          (_a = changeEventInfo.resetPagination) === null || _a === void 0 ? void 0 : _a.call(changeEventInfo);
          if ((_b = changeInfo.pagination) === null || _b === void 0 ? void 0 : _b.current) {
            changeInfo.pagination.current = 1;
          }
          if (pagination && pagination.onChange) {
            pagination.onChange(1, (_c = changeInfo.pagination) === null || _c === void 0 ? void 0 : _c.pageSize);
          }
        }
        if (scroll && scroll.scrollToFirstRowOnChange !== false && internalRefs.body.current) {
          scrollTo$1(0, {
            getContainer: () => internalRefs.body.current
          });
        }
        onChange === null || onChange === void 0 ? void 0 : onChange(changeInfo.pagination, changeInfo.filters, changeInfo.sorter, {
          currentDataSource: getFilterData(getSortData(rawData, changeInfo.sorterStates, childrenColumnName), changeInfo.filterStates),
          action
        });
      };
      const onSorterChange = (sorter, sorterStates) => {
        triggerOnChange({
          sorter,
          sorterStates
        }, "sort", false);
      };
      const [transformSorterColumns, sortStates, sorterTitleProps, getSorters] = useFilterSorter({
        prefixCls,
        mergedColumns,
        onSorterChange,
        sortDirections: sortDirections || ["ascend", "descend"],
        tableLocale,
        showSorterTooltip
      });
      const sortedData = reactExports.useMemo(() => getSortData(rawData, sortStates, childrenColumnName), [rawData, sortStates]);
      changeEventInfo.sorter = getSorters();
      changeEventInfo.sorterStates = sortStates;
      const onFilterChange = (filters2, filterStates2) => {
        triggerOnChange({
          filters: filters2,
          filterStates: filterStates2
        }, "filter", true);
      };
      const [transformFilterColumns, filterStates, filters] = useFilter({
        prefixCls,
        locale: tableLocale,
        dropdownPrefixCls,
        mergedColumns,
        onFilterChange,
        getPopupContainer: getPopupContainer || getContextPopupContainer,
        rootClassName: classNames(rootClassName, rootCls)
      });
      const mergedData = getFilterData(sortedData, filterStates);
      changeEventInfo.filters = filters;
      changeEventInfo.filterStates = filterStates;
      const columnTitleProps = reactExports.useMemo(() => {
        const mergedFilters = {};
        Object.keys(filters).forEach((filterKey) => {
          if (filters[filterKey] !== null) {
            mergedFilters[filterKey] = filters[filterKey];
          }
        });
        return Object.assign(Object.assign({}, sorterTitleProps), {
          filters: mergedFilters
        });
      }, [sorterTitleProps, filters]);
      const [transformTitleColumns] = useTitleColumns(columnTitleProps);
      const onPaginationChange = (current, pageSize) => {
        triggerOnChange({
          pagination: Object.assign(Object.assign({}, changeEventInfo.pagination), {
            current,
            pageSize
          })
        }, "paginate");
      };
      const [mergedPagination, resetPagination] = usePagination(mergedData.length, onPaginationChange, pagination);
      changeEventInfo.pagination = pagination === false ? {} : getPaginationParam(mergedPagination, pagination);
      changeEventInfo.resetPagination = resetPagination;
      const pageData = reactExports.useMemo(() => {
        if (pagination === false || !mergedPagination.pageSize) {
          return mergedData;
        }
        const {
          current = 1,
          total,
          pageSize = DEFAULT_PAGE_SIZE
        } = mergedPagination;
        if (mergedData.length < total) {
          if (mergedData.length > pageSize) {
            return mergedData.slice((current - 1) * pageSize, current * pageSize);
          }
          return mergedData;
        }
        return mergedData.slice((current - 1) * pageSize, current * pageSize);
      }, [!!pagination, mergedData, mergedPagination && mergedPagination.current, mergedPagination && mergedPagination.pageSize, mergedPagination && mergedPagination.total]);
      const [transformSelectionColumns, selectedKeySet] = useSelection({
        prefixCls,
        data: mergedData,
        pageData,
        getRowKey,
        getRecordByKey,
        expandType,
        childrenColumnName,
        locale: tableLocale,
        getPopupContainer: getPopupContainer || getContextPopupContainer
      }, rowSelection);
      const internalRowClassName = (record, index2, indent) => {
        let mergedRowClassName;
        if (typeof rowClassName === "function") {
          mergedRowClassName = classNames(rowClassName(record, index2, indent));
        } else {
          mergedRowClassName = classNames(rowClassName);
        }
        return classNames({
          [`${prefixCls}-row-selected`]: selectedKeySet.has(getRowKey(record, index2))
        }, mergedRowClassName);
      };
      mergedExpandable.__PARENT_RENDER_ICON__ = mergedExpandable.expandIcon;
      mergedExpandable.expandIcon = mergedExpandable.expandIcon || expandIcon || renderExpandIcon(tableLocale);
      if (expandType === "nest" && mergedExpandable.expandIconColumnIndex === void 0) {
        mergedExpandable.expandIconColumnIndex = rowSelection ? 1 : 0;
      } else if (mergedExpandable.expandIconColumnIndex > 0 && rowSelection) {
        mergedExpandable.expandIconColumnIndex -= 1;
      }
      if (typeof mergedExpandable.indentSize !== "number") {
        mergedExpandable.indentSize = typeof indentSize === "number" ? indentSize : 15;
      }
      const transformColumns = reactExports.useCallback((innerColumns) => transformTitleColumns(transformSelectionColumns(transformFilterColumns(transformSorterColumns(innerColumns)))), [transformSorterColumns, transformFilterColumns, transformSelectionColumns]);
      let topPaginationNode;
      let bottomPaginationNode;
      if (pagination !== false && (mergedPagination === null || mergedPagination === void 0 ? void 0 : mergedPagination.total)) {
        let paginationSize;
        if (mergedPagination.size) {
          paginationSize = mergedPagination.size;
        } else {
          paginationSize = mergedSize === "small" || mergedSize === "middle" ? "small" : void 0;
        }
        const renderPagination = (position22) => /* @__PURE__ */ reactExports.createElement(Pagination$1, Object.assign({}, mergedPagination, {
          className: classNames(`${prefixCls}-pagination ${prefixCls}-pagination-${position22}`, mergedPagination.className),
          size: paginationSize
        }));
        const defaultPosition = direction === "rtl" ? "left" : "right";
        const {
          position: position2
        } = mergedPagination;
        if (position2 !== null && Array.isArray(position2)) {
          const topPos = position2.find((p2) => p2.includes("top"));
          const bottomPos = position2.find((p2) => p2.includes("bottom"));
          const isDisable = position2.every((p2) => `${p2}` === "none");
          if (!topPos && !bottomPos && !isDisable) {
            bottomPaginationNode = renderPagination(defaultPosition);
          }
          if (topPos) {
            topPaginationNode = renderPagination(topPos.toLowerCase().replace("top", ""));
          }
          if (bottomPos) {
            bottomPaginationNode = renderPagination(bottomPos.toLowerCase().replace("bottom", ""));
          }
        } else {
          bottomPaginationNode = renderPagination(defaultPosition);
        }
      }
      let spinProps;
      if (typeof loading === "boolean") {
        spinProps = {
          spinning: loading
        };
      } else if (typeof loading === "object") {
        spinProps = Object.assign({
          spinning: true
        }, loading);
      }
      const wrapperClassNames = classNames(rootCls, `${prefixCls}-wrapper`, table === null || table === void 0 ? void 0 : table.className, {
        [`${prefixCls}-wrapper-rtl`]: direction === "rtl"
      }, className, rootClassName, hashId);
      const mergedStyle = Object.assign(Object.assign({}, table === null || table === void 0 ? void 0 : table.style), style2);
      const emptyText = locale2 && locale2.emptyText || (renderEmpty === null || renderEmpty === void 0 ? void 0 : renderEmpty("Table")) || /* @__PURE__ */ reactExports.createElement(DefaultRenderEmpty$1, {
        componentName: "Table"
      });
      const TableComponent = virtual ? RcVirtualTable : RcTable;
      const virtualProps = {};
      const listItemHeight = reactExports.useMemo(() => {
        const {
          fontSize,
          lineHeight,
          padding,
          paddingXS,
          paddingSM
        } = token2;
        const fontHeight = Math.floor(fontSize * lineHeight);
        switch (mergedSize) {
          case "large":
            return padding * 2 + fontHeight;
          case "small":
            return paddingXS * 2 + fontHeight;
          default:
            return paddingSM * 2 + fontHeight;
        }
      }, [token2, mergedSize]);
      if (virtual) {
        virtualProps.listItemHeight = listItemHeight;
      }
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("div", {
        ref: rootRef,
        className: wrapperClassNames,
        style: mergedStyle
      }, /* @__PURE__ */ reactExports.createElement(Spin$1, Object.assign({
        spinning: false
      }, spinProps), topPaginationNode, /* @__PURE__ */ reactExports.createElement(TableComponent, Object.assign({}, virtualProps, tableProps, {
        ref: tblRef,
        columns: mergedColumns,
        direction,
        expandable: mergedExpandable,
        prefixCls,
        className: classNames({
          [`${prefixCls}-middle`]: mergedSize === "middle",
          [`${prefixCls}-small`]: mergedSize === "small",
          [`${prefixCls}-bordered`]: bordered,
          [`${prefixCls}-empty`]: rawData.length === 0
        }, rootCls, hashId),
        data: pageData,
        rowKey: getRowKey,
        rowClassName: internalRowClassName,
        emptyText,
        // Internal
        internalHooks: INTERNAL_HOOKS,
        internalRefs,
        transformColumns,
        getContainerWidth
      })), bottomPaginationNode)));
    };
    const InternalTable$1 = /* @__PURE__ */ reactExports.forwardRef(InternalTable);
    const Table = (props, ref) => {
      const renderTimesRef = reactExports.useRef(0);
      renderTimesRef.current += 1;
      return /* @__PURE__ */ reactExports.createElement(InternalTable$1, Object.assign({}, props, {
        ref,
        _renderTimes: renderTimesRef.current
      }));
    };
    const ForwardTable = /* @__PURE__ */ reactExports.forwardRef(Table);
    ForwardTable.SELECTION_COLUMN = SELECTION_COLUMN;
    ForwardTable.EXPAND_COLUMN = EXPAND_COLUMN;
    ForwardTable.SELECTION_ALL = SELECTION_ALL;
    ForwardTable.SELECTION_INVERT = SELECTION_INVERT;
    ForwardTable.SELECTION_NONE = SELECTION_NONE;
    ForwardTable.Column = Column;
    ForwardTable.ColumnGroup = ColumnGroup;
    ForwardTable.Summary = FooterComponents;
    const Table$1 = ForwardTable;
    var DeleteOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M360 184h-8c4.4 0 8-3.6 8-8v8h304v-8c0 4.4 3.6 8 8 8h-8v72h72v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80h72v-72zm504 72H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32zM731.3 840H292.7l-24.2-512h487l-24.2 512z" } }] }, "name": "delete", "theme": "outlined" };
    const DeleteOutlinedSvg = DeleteOutlined$2;
    var DeleteOutlined = function DeleteOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: DeleteOutlinedSvg
      }));
    };
    const DeleteOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(DeleteOutlined);
    function getError(option, xhr) {
      var msg = "cannot ".concat(option.method, " ").concat(option.action, " ").concat(xhr.status, "'");
      var err = new Error(msg);
      err.status = xhr.status;
      err.method = option.method;
      err.url = option.action;
      return err;
    }
    function getBody(xhr) {
      var text = xhr.responseText || xhr.response;
      if (!text) {
        return text;
      }
      try {
        return JSON.parse(text);
      } catch (e2) {
        return text;
      }
    }
    function upload(option) {
      var xhr = new XMLHttpRequest();
      if (option.onProgress && xhr.upload) {
        xhr.upload.onprogress = function progress(e2) {
          if (e2.total > 0) {
            e2.percent = e2.loaded / e2.total * 100;
          }
          option.onProgress(e2);
        };
      }
      var formData = new FormData();
      if (option.data) {
        Object.keys(option.data).forEach(function(key) {
          var value = option.data[key];
          if (Array.isArray(value)) {
            value.forEach(function(item) {
              formData.append("".concat(key, "[]"), item);
            });
            return;
          }
          formData.append(key, value);
        });
      }
      if (option.file instanceof Blob) {
        formData.append(option.filename, option.file, option.file.name);
      } else {
        formData.append(option.filename, option.file);
      }
      xhr.onerror = function error(e2) {
        option.onError(e2);
      };
      xhr.onload = function onload() {
        if (xhr.status < 200 || xhr.status >= 300) {
          return option.onError(getError(option, xhr), getBody(xhr));
        }
        return option.onSuccess(getBody(xhr), xhr);
      };
      xhr.open(option.method, option.action, true);
      if (option.withCredentials && "withCredentials" in xhr) {
        xhr.withCredentials = true;
      }
      var headers = option.headers || {};
      if (headers["X-Requested-With"] !== null) {
        xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
      }
      Object.keys(headers).forEach(function(h2) {
        if (headers[h2] !== null) {
          xhr.setRequestHeader(h2, headers[h2]);
        }
      });
      xhr.send(formData);
      return {
        abort: function abort() {
          xhr.abort();
        }
      };
    }
    var now$1 = +/* @__PURE__ */ new Date();
    var index = 0;
    function uid() {
      return "rc-upload-".concat(now$1, "-").concat(++index);
    }
    const attrAccept = function(file, acceptedFiles) {
      if (file && acceptedFiles) {
        var acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(",");
        var fileName = file.name || "";
        var mimeType = file.type || "";
        var baseMimeType = mimeType.replace(/\/.*$/, "");
        return acceptedFilesArray.some(function(type) {
          var validType = type.trim();
          if (/^\*(\/\*)?$/.test(type)) {
            return true;
          }
          if (validType.charAt(0) === ".") {
            var lowerFileName = fileName.toLowerCase();
            var lowerType = validType.toLowerCase();
            var affixList = [lowerType];
            if (lowerType === ".jpg" || lowerType === ".jpeg") {
              affixList = [".jpg", ".jpeg"];
            }
            return affixList.some(function(affix) {
              return lowerFileName.endsWith(affix);
            });
          }
          if (/\/\*$/.test(validType)) {
            return baseMimeType === validType.replace(/\/.*$/, "");
          }
          if (mimeType === validType) {
            return true;
          }
          if (/^\w+$/.test(validType)) {
            warningOnce(false, "Upload takes an invalidate 'accept' type '".concat(validType, "'.Skip for check."));
            return true;
          }
          return false;
        });
      }
      return true;
    };
    function loopFiles(item, callback) {
      var dirReader = item.createReader();
      var fileList = [];
      function sequence() {
        dirReader.readEntries(function(entries) {
          var entryList = Array.prototype.slice.apply(entries);
          fileList = fileList.concat(entryList);
          var isFinished = !entryList.length;
          if (isFinished) {
            callback(fileList);
          } else {
            sequence();
          }
        });
      }
      sequence();
    }
    var traverseFileTree = function traverseFileTree2(files, callback, isAccepted) {
      var _traverseFileTree = function _traverseFileTree2(item, path) {
        if (!item) {
          return;
        }
        item.path = path || "";
        if (item.isFile) {
          item.file(function(file) {
            if (isAccepted(file)) {
              if (item.fullPath && !file.webkitRelativePath) {
                Object.defineProperties(file, {
                  webkitRelativePath: {
                    writable: true
                  }
                });
                file.webkitRelativePath = item.fullPath.replace(/^\//, "");
                Object.defineProperties(file, {
                  webkitRelativePath: {
                    writable: false
                  }
                });
              }
              callback([file]);
            }
          });
        } else if (item.isDirectory) {
          loopFiles(item, function(entries) {
            entries.forEach(function(entryItem) {
              _traverseFileTree2(entryItem, "".concat(path).concat(item.name, "/"));
            });
          });
        }
      };
      files.forEach(function(file) {
        _traverseFileTree(file.webkitGetAsEntry());
      });
    };
    var _excluded = ["component", "prefixCls", "className", "disabled", "id", "style", "multiple", "accept", "capture", "children", "directory", "openFileDialogOnClick", "onMouseEnter", "onMouseLeave"];
    var AjaxUploader = /* @__PURE__ */ function(_Component) {
      _inherits(AjaxUploader2, _Component);
      var _super = _createSuper(AjaxUploader2);
      function AjaxUploader2() {
        var _this;
        _classCallCheck(this, AjaxUploader2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _this.state = {
          uid: uid()
        };
        _this.reqs = {};
        _this.fileInput = void 0;
        _this._isMounted = void 0;
        _this.onChange = function(e2) {
          var _this$props = _this.props, accept = _this$props.accept, directory = _this$props.directory;
          var files = e2.target.files;
          var acceptedFiles = _toConsumableArray(files).filter(function(file) {
            return !directory || attrAccept(file, accept);
          });
          _this.uploadFiles(acceptedFiles);
          _this.reset();
        };
        _this.onClick = function(e2) {
          var el2 = _this.fileInput;
          if (!el2) {
            return;
          }
          var _this$props2 = _this.props, children = _this$props2.children, onClick = _this$props2.onClick;
          if (children && children.type === "button") {
            var parent = el2.parentNode;
            parent.focus();
            parent.querySelector("button").blur();
          }
          el2.click();
          if (onClick) {
            onClick(e2);
          }
        };
        _this.onKeyDown = function(e2) {
          if (e2.key === "Enter") {
            _this.onClick(e2);
          }
        };
        _this.onFileDrop = function(e2) {
          var multiple = _this.props.multiple;
          e2.preventDefault();
          if (e2.type === "dragover") {
            return;
          }
          if (_this.props.directory) {
            traverseFileTree(Array.prototype.slice.call(e2.dataTransfer.items), _this.uploadFiles, function(_file) {
              return attrAccept(_file, _this.props.accept);
            });
          } else {
            var files = _toConsumableArray(e2.dataTransfer.files).filter(function(file) {
              return attrAccept(file, _this.props.accept);
            });
            if (multiple === false) {
              files = files.slice(0, 1);
            }
            _this.uploadFiles(files);
          }
        };
        _this.uploadFiles = function(files) {
          var originFiles = _toConsumableArray(files);
          var postFiles = originFiles.map(function(file) {
            file.uid = uid();
            return _this.processFile(file, originFiles);
          });
          Promise.all(postFiles).then(function(fileList) {
            var onBatchStart = _this.props.onBatchStart;
            onBatchStart === null || onBatchStart === void 0 ? void 0 : onBatchStart(fileList.map(function(_ref) {
              var origin = _ref.origin, parsedFile = _ref.parsedFile;
              return {
                file: origin,
                parsedFile
              };
            }));
            fileList.filter(function(file) {
              return file.parsedFile !== null;
            }).forEach(function(file) {
              _this.post(file);
            });
          });
        };
        _this.processFile = /* @__PURE__ */ function() {
          var _ref2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(file, fileList) {
            var beforeUpload, transformedFile, action, mergedAction, data, mergedData, parsedData, parsedFile, mergedParsedFile;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1)
                switch (_context.prev = _context.next) {
                  case 0:
                    beforeUpload = _this.props.beforeUpload;
                    transformedFile = file;
                    if (!beforeUpload) {
                      _context.next = 14;
                      break;
                    }
                    _context.prev = 3;
                    _context.next = 6;
                    return beforeUpload(file, fileList);
                  case 6:
                    transformedFile = _context.sent;
                    _context.next = 12;
                    break;
                  case 9:
                    _context.prev = 9;
                    _context.t0 = _context["catch"](3);
                    transformedFile = false;
                  case 12:
                    if (!(transformedFile === false)) {
                      _context.next = 14;
                      break;
                    }
                    return _context.abrupt("return", {
                      origin: file,
                      parsedFile: null,
                      action: null,
                      data: null
                    });
                  case 14:
                    action = _this.props.action;
                    if (!(typeof action === "function")) {
                      _context.next = 21;
                      break;
                    }
                    _context.next = 18;
                    return action(file);
                  case 18:
                    mergedAction = _context.sent;
                    _context.next = 22;
                    break;
                  case 21:
                    mergedAction = action;
                  case 22:
                    data = _this.props.data;
                    if (!(typeof data === "function")) {
                      _context.next = 29;
                      break;
                    }
                    _context.next = 26;
                    return data(file);
                  case 26:
                    mergedData = _context.sent;
                    _context.next = 30;
                    break;
                  case 29:
                    mergedData = data;
                  case 30:
                    parsedData = // string type is from legacy `transformFile`.
                    // Not sure if this will work since no related test case works with it
                    (_typeof(transformedFile) === "object" || typeof transformedFile === "string") && transformedFile ? transformedFile : file;
                    if (parsedData instanceof File) {
                      parsedFile = parsedData;
                    } else {
                      parsedFile = new File([parsedData], file.name, {
                        type: file.type
                      });
                    }
                    mergedParsedFile = parsedFile;
                    mergedParsedFile.uid = file.uid;
                    return _context.abrupt("return", {
                      origin: file,
                      data: mergedData,
                      parsedFile: mergedParsedFile,
                      action: mergedAction
                    });
                  case 35:
                  case "end":
                    return _context.stop();
                }
            }, _callee, null, [[3, 9]]);
          }));
          return function(_x, _x2) {
            return _ref2.apply(this, arguments);
          };
        }();
        _this.saveFileInput = function(node2) {
          _this.fileInput = node2;
        };
        return _this;
      }
      _createClass(AjaxUploader2, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          this._isMounted = true;
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this._isMounted = false;
          this.abort();
        }
      }, {
        key: "post",
        value: function post(_ref3) {
          var _this2 = this;
          var data = _ref3.data, origin = _ref3.origin, action = _ref3.action, parsedFile = _ref3.parsedFile;
          if (!this._isMounted) {
            return;
          }
          var _this$props3 = this.props, onStart = _this$props3.onStart, customRequest = _this$props3.customRequest, name = _this$props3.name, headers = _this$props3.headers, withCredentials = _this$props3.withCredentials, method = _this$props3.method;
          var uid2 = origin.uid;
          var request = customRequest || upload;
          var requestOption = {
            action,
            filename: name,
            data,
            file: parsedFile,
            headers,
            withCredentials,
            method: method || "post",
            onProgress: function onProgress(e2) {
              var onProgress2 = _this2.props.onProgress;
              onProgress2 === null || onProgress2 === void 0 ? void 0 : onProgress2(e2, parsedFile);
            },
            onSuccess: function onSuccess(ret, xhr) {
              var onSuccess2 = _this2.props.onSuccess;
              onSuccess2 === null || onSuccess2 === void 0 ? void 0 : onSuccess2(ret, parsedFile, xhr);
              delete _this2.reqs[uid2];
            },
            onError: function onError(err, ret) {
              var onError2 = _this2.props.onError;
              onError2 === null || onError2 === void 0 ? void 0 : onError2(err, ret, parsedFile);
              delete _this2.reqs[uid2];
            }
          };
          onStart(origin);
          this.reqs[uid2] = request(requestOption);
        }
      }, {
        key: "reset",
        value: function reset() {
          this.setState({
            uid: uid()
          });
        }
      }, {
        key: "abort",
        value: function abort(file) {
          var reqs = this.reqs;
          if (file) {
            var uid2 = file.uid ? file.uid : file;
            if (reqs[uid2] && reqs[uid2].abort) {
              reqs[uid2].abort();
            }
            delete reqs[uid2];
          } else {
            Object.keys(reqs).forEach(function(uid3) {
              if (reqs[uid3] && reqs[uid3].abort) {
                reqs[uid3].abort();
              }
              delete reqs[uid3];
            });
          }
        }
      }, {
        key: "render",
        value: function render2() {
          var _classNames;
          var _this$props4 = this.props, Tag = _this$props4.component, prefixCls = _this$props4.prefixCls, className = _this$props4.className, disabled = _this$props4.disabled, id2 = _this$props4.id, style2 = _this$props4.style, multiple = _this$props4.multiple, accept = _this$props4.accept, capture = _this$props4.capture, children = _this$props4.children, directory = _this$props4.directory, openFileDialogOnClick = _this$props4.openFileDialogOnClick, onMouseEnter = _this$props4.onMouseEnter, onMouseLeave = _this$props4.onMouseLeave, otherProps = _objectWithoutProperties(_this$props4, _excluded);
          var cls = classNames((_classNames = {}, _defineProperty(_classNames, prefixCls, true), _defineProperty(_classNames, "".concat(prefixCls, "-disabled"), disabled), _defineProperty(_classNames, className, className), _classNames));
          var dirProps = directory ? {
            directory: "directory",
            webkitdirectory: "webkitdirectory"
          } : {};
          var events = disabled ? {} : {
            onClick: openFileDialogOnClick ? this.onClick : function() {
            },
            onKeyDown: openFileDialogOnClick ? this.onKeyDown : function() {
            },
            onMouseEnter,
            onMouseLeave,
            onDrop: this.onFileDrop,
            onDragOver: this.onFileDrop,
            tabIndex: "0"
          };
          return /* @__PURE__ */ React.createElement(Tag, _extends$1({}, events, {
            className: cls,
            role: "button",
            style: style2
          }), /* @__PURE__ */ React.createElement("input", _extends$1({}, pickAttrs(otherProps, {
            aria: true,
            data: true
          }), {
            id: id2,
            disabled,
            type: "file",
            ref: this.saveFileInput,
            onClick: function onClick(e2) {
              return e2.stopPropagation();
            },
            key: this.state.uid,
            style: {
              display: "none"
            },
            accept
          }, dirProps, {
            multiple,
            onChange: this.onChange
          }, capture != null ? {
            capture
          } : {})), children);
        }
      }]);
      return AjaxUploader2;
    }(reactExports.Component);
    function empty() {
    }
    var Upload$3 = /* @__PURE__ */ function(_Component) {
      _inherits(Upload2, _Component);
      var _super = _createSuper(Upload2);
      function Upload2() {
        var _this;
        _classCallCheck(this, Upload2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _this.uploader = void 0;
        _this.saveUploader = function(node2) {
          _this.uploader = node2;
        };
        return _this;
      }
      _createClass(Upload2, [{
        key: "abort",
        value: function abort(file) {
          this.uploader.abort(file);
        }
      }, {
        key: "render",
        value: function render2() {
          return /* @__PURE__ */ React.createElement(AjaxUploader, _extends$1({}, this.props, {
            ref: this.saveUploader
          }));
        }
      }]);
      return Upload2;
    }(reactExports.Component);
    Upload$3.defaultProps = {
      component: "span",
      prefixCls: "rc-upload",
      data: {},
      headers: {},
      name: "file",
      multipart: false,
      onStart: empty,
      onError: empty,
      onSuccess: empty,
      multiple: false,
      beforeUpload: null,
      customRequest: null,
      withCredentials: false,
      openFileDialogOnClick: true
    };
    const genDraggerStyle = (token2) => {
      const {
        componentCls,
        iconCls
      } = token2;
      return {
        [`${componentCls}-wrapper`]: {
          [`${componentCls}-drag`]: {
            position: "relative",
            width: "100%",
            height: "100%",
            textAlign: "center",
            background: token2.colorFillAlter,
            border: `${unit$1(token2.lineWidth)} dashed ${token2.colorBorder}`,
            borderRadius: token2.borderRadiusLG,
            cursor: "pointer",
            transition: `border-color ${token2.motionDurationSlow}`,
            [componentCls]: {
              padding: `${unit$1(token2.padding)} 0`
            },
            [`${componentCls}-btn`]: {
              display: "table",
              width: "100%",
              height: "100%",
              outline: "none"
            },
            [`${componentCls}-drag-container`]: {
              display: "table-cell",
              verticalAlign: "middle"
            },
            [`
          &:not(${componentCls}-disabled):hover,
          &-hover:not(${componentCls}-disabled)
        `]: {
              borderColor: token2.colorPrimaryHover
            },
            [`p${componentCls}-drag-icon`]: {
              marginBottom: token2.margin,
              [iconCls]: {
                color: token2.colorPrimary,
                fontSize: token2.uploadThumbnailSize
              }
            },
            [`p${componentCls}-text`]: {
              margin: `0 0 ${unit$1(token2.marginXXS)}`,
              color: token2.colorTextHeading,
              fontSize: token2.fontSizeLG
            },
            [`p${componentCls}-hint`]: {
              color: token2.colorTextDescription,
              fontSize: token2.fontSize
            },
            // ===================== Disabled =====================
            [`&${componentCls}-disabled`]: {
              [`p${componentCls}-drag-icon ${iconCls},
            p${componentCls}-text,
            p${componentCls}-hint
          `]: {
                color: token2.colorTextDisabled
              }
            }
          }
        }
      };
    };
    const genDraggerStyle$1 = genDraggerStyle;
    const genListStyle = (token2) => {
      const {
        componentCls,
        antCls,
        iconCls,
        fontSize,
        lineHeight,
        calc
      } = token2;
      const itemCls = `${componentCls}-list-item`;
      const actionsCls = `${itemCls}-actions`;
      const actionCls = `${itemCls}-action`;
      const listItemHeightSM = token2.fontHeightSM;
      return {
        [`${componentCls}-wrapper`]: {
          [`${componentCls}-list`]: Object.assign(Object.assign({}, clearFix()), {
            lineHeight: token2.lineHeight,
            [itemCls]: {
              position: "relative",
              height: calc(token2.lineHeight).mul(fontSize).equal(),
              marginTop: token2.marginXS,
              fontSize,
              display: "flex",
              alignItems: "center",
              transition: `background-color ${token2.motionDurationSlow}`,
              "&:hover": {
                backgroundColor: token2.controlItemBgHover
              },
              [`${itemCls}-name`]: Object.assign(Object.assign({}, textEllipsis), {
                padding: `0 ${unit$1(token2.paddingXS)}`,
                lineHeight,
                flex: "auto",
                transition: `all ${token2.motionDurationSlow}`
              }),
              [actionsCls]: {
                [actionCls]: {
                  opacity: 0
                },
                [`${actionCls}${antCls}-btn-sm`]: {
                  height: listItemHeightSM,
                  border: 0,
                  lineHeight: 1,
                  // FIXME: should not override small button
                  "> span": {
                    transform: "scale(1)"
                  }
                },
                [`
              ${actionCls}:focus-visible,
              &.picture ${actionCls}
            `]: {
                  opacity: 1
                },
                [iconCls]: {
                  color: token2.actionsColor,
                  transition: `all ${token2.motionDurationSlow}`
                },
                [`&:hover ${iconCls}`]: {
                  color: token2.colorText
                }
              },
              [`${componentCls}-icon ${iconCls}`]: {
                color: token2.colorTextDescription,
                fontSize
              },
              [`${itemCls}-progress`]: {
                position: "absolute",
                bottom: token2.calc(token2.uploadProgressOffset).mul(-1).equal(),
                width: "100%",
                paddingInlineStart: calc(fontSize).add(token2.paddingXS).equal(),
                fontSize,
                lineHeight: 0,
                pointerEvents: "none",
                "> div": {
                  margin: 0
                }
              }
            },
            [`${itemCls}:hover ${actionCls}`]: {
              opacity: 1,
              color: token2.colorText
            },
            [`${itemCls}-error`]: {
              color: token2.colorError,
              [`${itemCls}-name, ${componentCls}-icon ${iconCls}`]: {
                color: token2.colorError
              },
              [actionsCls]: {
                [`${iconCls}, ${iconCls}:hover`]: {
                  color: token2.colorError
                },
                [actionCls]: {
                  opacity: 1
                }
              }
            },
            [`${componentCls}-list-item-container`]: {
              transition: `opacity ${token2.motionDurationSlow}, height ${token2.motionDurationSlow}`,
              // For smooth removing animation
              "&::before": {
                display: "table",
                width: 0,
                height: 0,
                content: '""'
              }
            }
          })
        }
      };
    };
    const genListStyle$1 = genListStyle;
    const uploadAnimateInlineIn = new Keyframe("uploadAnimateInlineIn", {
      from: {
        width: 0,
        height: 0,
        margin: 0,
        padding: 0,
        opacity: 0
      }
    });
    const uploadAnimateInlineOut = new Keyframe("uploadAnimateInlineOut", {
      to: {
        width: 0,
        height: 0,
        margin: 0,
        padding: 0,
        opacity: 0
      }
    });
    const genMotionStyle = (token2) => {
      const {
        componentCls
      } = token2;
      const inlineCls = `${componentCls}-animate-inline`;
      return [{
        [`${componentCls}-wrapper`]: {
          [`${inlineCls}-appear, ${inlineCls}-enter, ${inlineCls}-leave`]: {
            animationDuration: token2.motionDurationSlow,
            animationTimingFunction: token2.motionEaseInOutCirc,
            animationFillMode: "forwards"
          },
          [`${inlineCls}-appear, ${inlineCls}-enter`]: {
            animationName: uploadAnimateInlineIn
          },
          [`${inlineCls}-leave`]: {
            animationName: uploadAnimateInlineOut
          }
        }
      }, {
        [`${componentCls}-wrapper`]: initFadeMotion(token2)
      }, uploadAnimateInlineIn, uploadAnimateInlineOut];
    };
    const genMotionStyle$1 = genMotionStyle;
    const genPictureStyle = (token2) => {
      const {
        componentCls,
        iconCls,
        uploadThumbnailSize,
        uploadProgressOffset,
        calc
      } = token2;
      const listCls = `${componentCls}-list`;
      const itemCls = `${listCls}-item`;
      return {
        [`${componentCls}-wrapper`]: {
          // ${listCls} 增加优先级
          [`
        ${listCls}${listCls}-picture,
        ${listCls}${listCls}-picture-card,
        ${listCls}${listCls}-picture-circle
      `]: {
            [itemCls]: {
              position: "relative",
              height: calc(uploadThumbnailSize).add(calc(token2.lineWidth).mul(2)).add(calc(token2.paddingXS).mul(2)).equal(),
              padding: token2.paddingXS,
              border: `${unit$1(token2.lineWidth)} ${token2.lineType} ${token2.colorBorder}`,
              borderRadius: token2.borderRadiusLG,
              "&:hover": {
                background: "transparent"
              },
              [`${itemCls}-thumbnail`]: Object.assign(Object.assign({}, textEllipsis), {
                width: uploadThumbnailSize,
                height: uploadThumbnailSize,
                lineHeight: unit$1(calc(uploadThumbnailSize).add(token2.paddingSM).equal()),
                textAlign: "center",
                flex: "none",
                [iconCls]: {
                  fontSize: token2.fontSizeHeading2,
                  color: token2.colorPrimary
                },
                img: {
                  display: "block",
                  width: "100%",
                  height: "100%",
                  overflow: "hidden"
                }
              }),
              [`${itemCls}-progress`]: {
                bottom: uploadProgressOffset,
                width: `calc(100% - ${unit$1(calc(token2.paddingSM).mul(2).equal())})`,
                marginTop: 0,
                paddingInlineStart: calc(uploadThumbnailSize).add(token2.paddingXS).equal()
              }
            },
            [`${itemCls}-error`]: {
              borderColor: token2.colorError,
              // Adjust the color of the error icon : https://github.com/ant-design/ant-design/pull/24160
              [`${itemCls}-thumbnail ${iconCls}`]: {
                [`svg path[fill='${blue[0]}']`]: {
                  fill: token2.colorErrorBg
                },
                [`svg path[fill='${blue.primary}']`]: {
                  fill: token2.colorError
                }
              }
            },
            [`${itemCls}-uploading`]: {
              borderStyle: "dashed",
              [`${itemCls}-name`]: {
                marginBottom: uploadProgressOffset
              }
            }
          },
          [`${listCls}${listCls}-picture-circle ${itemCls}`]: {
            [`&, &::before, ${itemCls}-thumbnail`]: {
              borderRadius: "50%"
            }
          }
        }
      };
    };
    const genPictureCardStyle = (token2) => {
      const {
        componentCls,
        iconCls,
        fontSizeLG,
        colorTextLightSolid,
        calc
      } = token2;
      const listCls = `${componentCls}-list`;
      const itemCls = `${listCls}-item`;
      const uploadPictureCardSize = token2.uploadPicCardSize;
      return {
        [`
      ${componentCls}-wrapper${componentCls}-picture-card-wrapper,
      ${componentCls}-wrapper${componentCls}-picture-circle-wrapper
    `]: Object.assign(Object.assign({}, clearFix()), {
          display: "inline-block",
          width: "100%",
          [`${componentCls}${componentCls}-select`]: {
            width: uploadPictureCardSize,
            height: uploadPictureCardSize,
            marginInlineEnd: token2.marginXS,
            marginBottom: token2.marginXS,
            textAlign: "center",
            verticalAlign: "top",
            backgroundColor: token2.colorFillAlter,
            border: `${unit$1(token2.lineWidth)} dashed ${token2.colorBorder}`,
            borderRadius: token2.borderRadiusLG,
            cursor: "pointer",
            transition: `border-color ${token2.motionDurationSlow}`,
            [`> ${componentCls}`]: {
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              height: "100%",
              textAlign: "center"
            },
            [`&:not(${componentCls}-disabled):hover`]: {
              borderColor: token2.colorPrimary
            }
          },
          // list
          [`${listCls}${listCls}-picture-card, ${listCls}${listCls}-picture-circle`]: {
            [`${listCls}-item-container`]: {
              display: "inline-block",
              width: uploadPictureCardSize,
              height: uploadPictureCardSize,
              marginBlock: `0 ${unit$1(token2.marginXS)}`,
              marginInline: `0 ${unit$1(token2.marginXS)}`,
              verticalAlign: "top"
            },
            "&::after": {
              display: "none"
            },
            [itemCls]: {
              height: "100%",
              margin: 0,
              "&::before": {
                position: "absolute",
                zIndex: 1,
                width: `calc(100% - ${unit$1(calc(token2.paddingXS).mul(2).equal())})`,
                height: `calc(100% - ${unit$1(calc(token2.paddingXS).mul(2).equal())})`,
                backgroundColor: token2.colorBgMask,
                opacity: 0,
                transition: `all ${token2.motionDurationSlow}`,
                content: '" "'
              }
            },
            [`${itemCls}:hover`]: {
              [`&::before, ${itemCls}-actions`]: {
                opacity: 1
              }
            },
            [`${itemCls}-actions`]: {
              position: "absolute",
              insetInlineStart: 0,
              zIndex: 10,
              width: "100%",
              whiteSpace: "nowrap",
              textAlign: "center",
              opacity: 0,
              transition: `all ${token2.motionDurationSlow}`,
              [`${iconCls}-eye, ${iconCls}-download, ${iconCls}-delete`]: {
                zIndex: 10,
                width: fontSizeLG,
                margin: `0 ${unit$1(token2.marginXXS)}`,
                fontSize: fontSizeLG,
                cursor: "pointer",
                transition: `all ${token2.motionDurationSlow}`,
                svg: {
                  verticalAlign: "baseline"
                }
              }
            },
            [`${itemCls}-actions, ${itemCls}-actions:hover`]: {
              [`${iconCls}-eye, ${iconCls}-download, ${iconCls}-delete`]: {
                color: new TinyColor(colorTextLightSolid).setAlpha(0.65).toRgbString(),
                "&:hover": {
                  color: colorTextLightSolid
                }
              }
            },
            [`${itemCls}-thumbnail, ${itemCls}-thumbnail img`]: {
              position: "static",
              display: "block",
              width: "100%",
              height: "100%",
              objectFit: "contain"
            },
            [`${itemCls}-name`]: {
              display: "none",
              textAlign: "center"
            },
            [`${itemCls}-file + ${itemCls}-name`]: {
              position: "absolute",
              bottom: token2.margin,
              display: "block",
              width: `calc(100% - ${unit$1(calc(token2.paddingXS).mul(2).equal())})`
            },
            [`${itemCls}-uploading`]: {
              [`&${itemCls}`]: {
                backgroundColor: token2.colorFillAlter
              },
              [`&::before, ${iconCls}-eye, ${iconCls}-download, ${iconCls}-delete`]: {
                display: "none"
              }
            },
            [`${itemCls}-progress`]: {
              bottom: token2.marginXL,
              width: `calc(100% - ${unit$1(calc(token2.paddingXS).mul(2).equal())})`,
              paddingInlineStart: 0
            }
          }
        }),
        [`${componentCls}-wrapper${componentCls}-picture-circle-wrapper`]: {
          [`${componentCls}${componentCls}-select`]: {
            borderRadius: "50%"
          }
        }
      };
    };
    const genRtlStyle = (token2) => {
      const {
        componentCls
      } = token2;
      return {
        [`${componentCls}-rtl`]: {
          direction: "rtl"
        }
      };
    };
    const genRtlStyle$1 = genRtlStyle;
    const genBaseStyle = (token2) => {
      const {
        componentCls,
        colorTextDisabled
      } = token2;
      return {
        [`${componentCls}-wrapper`]: Object.assign(Object.assign({}, resetComponent(token2)), {
          [componentCls]: {
            outline: 0,
            "input[type='file']": {
              cursor: "pointer"
            }
          },
          [`${componentCls}-select`]: {
            display: "inline-block"
          },
          [`${componentCls}-disabled`]: {
            color: colorTextDisabled,
            cursor: "not-allowed"
          }
        })
      };
    };
    const prepareComponentToken = (token2) => ({
      actionsColor: token2.colorTextDescription
    });
    const useStyle = genStyleHooks("Upload", (token2) => {
      const {
        fontSizeHeading3,
        fontHeight,
        lineWidth,
        controlHeightLG,
        calc
      } = token2;
      const uploadToken = merge$1(token2, {
        uploadThumbnailSize: calc(fontSizeHeading3).mul(2).equal(),
        uploadProgressOffset: calc(calc(fontHeight).div(2)).add(lineWidth).equal(),
        uploadPicCardSize: calc(controlHeightLG).mul(2.55).equal()
      });
      return [genBaseStyle(uploadToken), genDraggerStyle$1(uploadToken), genPictureStyle(uploadToken), genPictureCardStyle(uploadToken), genListStyle$1(uploadToken), genMotionStyle$1(uploadToken), genRtlStyle$1(uploadToken), genCollapseMotion$1(uploadToken)];
    }, prepareComponentToken);
    var FileTwoTone$2 = { "icon": function render2(primaryColor, secondaryColor) {
      return { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M534 352V136H232v752h560V394H576a42 42 0 01-42-42z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM602 137.8L790.2 326H602V137.8zM792 888H232V136h302v216a42 42 0 0042 42h216v494z", "fill": primaryColor } }] };
    }, "name": "file", "theme": "twotone" };
    const FileTwoToneSvg = FileTwoTone$2;
    var FileTwoTone = function FileTwoTone2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: FileTwoToneSvg
      }));
    };
    const FileTwoTone$1 = /* @__PURE__ */ reactExports.forwardRef(FileTwoTone);
    var PaperClipOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M779.3 196.6c-94.2-94.2-247.6-94.2-341.7 0l-261 260.8c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l261-260.8c32.4-32.4 75.5-50.2 121.3-50.2s88.9 17.8 121.2 50.2c32.4 32.4 50.2 75.5 50.2 121.2 0 45.8-17.8 88.8-50.2 121.2l-266 265.9-43.1 43.1c-40.3 40.3-105.8 40.3-146.1 0-19.5-19.5-30.2-45.4-30.2-73s10.7-53.5 30.2-73l263.9-263.8c6.7-6.6 15.5-10.3 24.9-10.3h.1c9.4 0 18.1 3.7 24.7 10.3 6.7 6.7 10.3 15.5 10.3 24.9 0 9.3-3.7 18.1-10.3 24.7L372.4 653c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l215.6-215.6c19.9-19.9 30.8-46.3 30.8-74.4s-11-54.6-30.8-74.4c-41.1-41.1-107.9-41-149 0L463 364 224.8 602.1A172.22 172.22 0 00174 724.8c0 46.3 18.1 89.8 50.8 122.5 33.9 33.8 78.3 50.7 122.7 50.7 44.4 0 88.8-16.9 122.6-50.7l309.2-309C824.8 492.7 850 432 850 367.5c.1-64.6-25.1-125.3-70.7-170.9z" } }] }, "name": "paper-clip", "theme": "outlined" };
    const PaperClipOutlinedSvg = PaperClipOutlined$2;
    var PaperClipOutlined = function PaperClipOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: PaperClipOutlinedSvg
      }));
    };
    const PaperClipOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(PaperClipOutlined);
    var PictureTwoTone$2 = { "icon": function render2(primaryColor, secondaryColor) {
      return { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 632H136v-39.9l138.5-164.3 150.1 178L658.1 489 888 761.6V792zm0-129.8L664.2 396.8c-3.2-3.8-9-3.8-12.2 0L424.6 666.4l-144-170.7c-3.2-3.8-9-3.8-12.2 0L136 652.7V232h752v430.2z", "fill": primaryColor } }, { "tag": "path", "attrs": { "d": "M424.6 765.8l-150.1-178L136 752.1V792h752v-30.4L658.1 489z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M136 652.7l132.4-157c3.2-3.8 9-3.8 12.2 0l144 170.7L652 396.8c3.2-3.8 9-3.8 12.2 0L888 662.2V232H136v420.7zM304 280a88 88 0 110 176 88 88 0 010-176z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M276 368a28 28 0 1056 0 28 28 0 10-56 0z", "fill": secondaryColor } }, { "tag": "path", "attrs": { "d": "M304 456a88 88 0 100-176 88 88 0 000 176zm0-116c15.5 0 28 12.5 28 28s-12.5 28-28 28-28-12.5-28-28 12.5-28 28-28z", "fill": primaryColor } }] };
    }, "name": "picture", "theme": "twotone" };
    const PictureTwoToneSvg = PictureTwoTone$2;
    var PictureTwoTone = function PictureTwoTone2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: PictureTwoToneSvg
      }));
    };
    const PictureTwoTone$1 = /* @__PURE__ */ reactExports.forwardRef(PictureTwoTone);
    function file2Obj(file) {
      return Object.assign(Object.assign({}, file), {
        lastModified: file.lastModified,
        lastModifiedDate: file.lastModifiedDate,
        name: file.name,
        size: file.size,
        type: file.type,
        uid: file.uid,
        percent: 0,
        originFileObj: file
      });
    }
    function updateFileList(file, fileList) {
      const nextFileList = _toConsumableArray(fileList);
      const fileIndex = nextFileList.findIndex((_ref) => {
        let {
          uid: uid2
        } = _ref;
        return uid2 === file.uid;
      });
      if (fileIndex === -1) {
        nextFileList.push(file);
      } else {
        nextFileList[fileIndex] = file;
      }
      return nextFileList;
    }
    function getFileItem(file, fileList) {
      const matchKey = file.uid !== void 0 ? "uid" : "name";
      return fileList.filter((item) => item[matchKey] === file[matchKey])[0];
    }
    function removeFileItem(file, fileList) {
      const matchKey = file.uid !== void 0 ? "uid" : "name";
      const removed = fileList.filter((item) => item[matchKey] !== file[matchKey]);
      if (removed.length === fileList.length) {
        return null;
      }
      return removed;
    }
    const extname = function() {
      let url = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      const temp = url.split("/");
      const filename = temp[temp.length - 1];
      const filenameWithoutSuffix = filename.split(/#|\?/)[0];
      return (/\.[^./\\]*$/.exec(filenameWithoutSuffix) || [""])[0];
    };
    const isImageFileType = (type) => type.indexOf("image/") === 0;
    const isImageUrl = (file) => {
      if (file.type && !file.thumbUrl) {
        return isImageFileType(file.type);
      }
      const url = file.thumbUrl || file.url || "";
      const extension = extname(url);
      if (/^data:image\//.test(url) || /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico|heic|heif)$/i.test(extension)) {
        return true;
      }
      if (/^data:/.test(url)) {
        return false;
      }
      if (extension) {
        return false;
      }
      return true;
    };
    const MEASURE_SIZE = 200;
    function previewImage(file) {
      return new Promise((resolve) => {
        if (!file.type || !isImageFileType(file.type)) {
          resolve("");
          return;
        }
        const canvas = document.createElement("canvas");
        canvas.width = MEASURE_SIZE;
        canvas.height = MEASURE_SIZE;
        canvas.style.cssText = `position: fixed; left: 0; top: 0; width: ${MEASURE_SIZE}px; height: ${MEASURE_SIZE}px; z-index: 9999; display: none;`;
        document.body.appendChild(canvas);
        const ctx = canvas.getContext("2d");
        const img = new Image();
        img.onload = () => {
          const {
            width,
            height
          } = img;
          let drawWidth = MEASURE_SIZE;
          let drawHeight = MEASURE_SIZE;
          let offsetX = 0;
          let offsetY = 0;
          if (width > height) {
            drawHeight = height * (MEASURE_SIZE / width);
            offsetY = -(drawHeight - drawWidth) / 2;
          } else {
            drawWidth = width * (MEASURE_SIZE / height);
            offsetX = -(drawWidth - drawHeight) / 2;
          }
          ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
          const dataURL = canvas.toDataURL();
          document.body.removeChild(canvas);
          window.URL.revokeObjectURL(img.src);
          resolve(dataURL);
        };
        img.crossOrigin = "anonymous";
        if (file.type.startsWith("image/svg+xml")) {
          const reader = new FileReader();
          reader.onload = () => {
            if (reader.result)
              img.src = reader.result;
          };
          reader.readAsDataURL(file);
        } else if (file.type.startsWith("image/gif")) {
          const reader = new FileReader();
          reader.onload = () => {
            if (reader.result)
              resolve(reader.result);
          };
          reader.readAsDataURL(file);
        } else {
          img.src = window.URL.createObjectURL(file);
        }
      });
    }
    var DownloadOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M505.7 661a8 8 0 0012.6 0l112-141.7c4.1-5.2.4-12.9-6.3-12.9h-74.1V168c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v338.3H400c-6.7 0-10.4 7.7-6.3 12.9l112 141.8zM878 626h-60c-4.4 0-8 3.6-8 8v154H214V634c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v198c0 17.7 14.3 32 32 32h684c17.7 0 32-14.3 32-32V634c0-4.4-3.6-8-8-8z" } }] }, "name": "download", "theme": "outlined" };
    const DownloadOutlinedSvg = DownloadOutlined$2;
    var DownloadOutlined = function DownloadOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: DownloadOutlinedSvg
      }));
    };
    const DownloadOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(DownloadOutlined);
    const ListItem = /* @__PURE__ */ reactExports.forwardRef((_ref, ref) => {
      let {
        prefixCls,
        className,
        style: style2,
        locale: locale2,
        listType,
        file,
        items,
        progress: progressProps,
        iconRender,
        actionIconRender,
        itemRender,
        isImgUrl,
        showPreviewIcon,
        showRemoveIcon,
        showDownloadIcon,
        previewIcon: customPreviewIcon,
        removeIcon: customRemoveIcon,
        downloadIcon: customDownloadIcon,
        onPreview,
        onDownload,
        onClose
      } = _ref;
      var _a, _b;
      const {
        status
      } = file;
      const [mergedStatus, setMergedStatus] = reactExports.useState(status);
      reactExports.useEffect(() => {
        if (status !== "removed") {
          setMergedStatus(status);
        }
      }, [status]);
      const [showProgress, setShowProgress] = reactExports.useState(false);
      reactExports.useEffect(() => {
        const timer = setTimeout(() => {
          setShowProgress(true);
        }, 300);
        return () => {
          clearTimeout(timer);
        };
      }, []);
      const iconNode = iconRender(file);
      let icon = /* @__PURE__ */ reactExports.createElement("div", {
        className: `${prefixCls}-icon`
      }, iconNode);
      if (listType === "picture" || listType === "picture-card" || listType === "picture-circle") {
        if (mergedStatus === "uploading" || !file.thumbUrl && !file.url) {
          const uploadingClassName = classNames(`${prefixCls}-list-item-thumbnail`, {
            [`${prefixCls}-list-item-file`]: mergedStatus !== "uploading"
          });
          icon = /* @__PURE__ */ reactExports.createElement("div", {
            className: uploadingClassName
          }, iconNode);
        } else {
          const thumbnail = (isImgUrl === null || isImgUrl === void 0 ? void 0 : isImgUrl(file)) ? /* @__PURE__ */ reactExports.createElement("img", {
            src: file.thumbUrl || file.url,
            alt: file.name,
            className: `${prefixCls}-list-item-image`,
            crossOrigin: file.crossOrigin
          }) : iconNode;
          const aClassName = classNames(`${prefixCls}-list-item-thumbnail`, {
            [`${prefixCls}-list-item-file`]: isImgUrl && !isImgUrl(file)
          });
          icon = /* @__PURE__ */ reactExports.createElement("a", {
            className: aClassName,
            onClick: (e2) => onPreview(file, e2),
            href: file.url || file.thumbUrl,
            target: "_blank",
            rel: "noopener noreferrer"
          }, thumbnail);
        }
      }
      const listItemClassName = classNames(`${prefixCls}-list-item`, `${prefixCls}-list-item-${mergedStatus}`);
      const linkProps = typeof file.linkProps === "string" ? JSON.parse(file.linkProps) : file.linkProps;
      const removeIcon = showRemoveIcon ? actionIconRender((typeof customRemoveIcon === "function" ? customRemoveIcon(file) : customRemoveIcon) || /* @__PURE__ */ reactExports.createElement(DeleteOutlined$1, null), () => onClose(file), prefixCls, locale2.removeFile) : null;
      const downloadIcon = showDownloadIcon && mergedStatus === "done" ? actionIconRender((typeof customDownloadIcon === "function" ? customDownloadIcon(file) : customDownloadIcon) || /* @__PURE__ */ reactExports.createElement(DownloadOutlined$1, null), () => onDownload(file), prefixCls, locale2.downloadFile) : null;
      const downloadOrDelete = listType !== "picture-card" && listType !== "picture-circle" && /* @__PURE__ */ reactExports.createElement("span", {
        key: "download-delete",
        className: classNames(`${prefixCls}-list-item-actions`, {
          picture: listType === "picture"
        })
      }, downloadIcon, removeIcon);
      const listItemNameClass = classNames(`${prefixCls}-list-item-name`);
      const fileName = file.url ? [/* @__PURE__ */ reactExports.createElement("a", Object.assign({
        key: "view",
        target: "_blank",
        rel: "noopener noreferrer",
        className: listItemNameClass,
        title: file.name
      }, linkProps, {
        href: file.url,
        onClick: (e2) => onPreview(file, e2)
      }), file.name), downloadOrDelete] : [/* @__PURE__ */ reactExports.createElement("span", {
        key: "view",
        className: listItemNameClass,
        onClick: (e2) => onPreview(file, e2),
        title: file.name
      }, file.name), downloadOrDelete];
      const previewStyle = {
        pointerEvents: "none",
        opacity: 0.5
      };
      const previewIcon = showPreviewIcon ? /* @__PURE__ */ reactExports.createElement("a", {
        href: file.url || file.thumbUrl,
        target: "_blank",
        rel: "noopener noreferrer",
        style: file.url || file.thumbUrl ? void 0 : previewStyle,
        onClick: (e2) => onPreview(file, e2),
        title: locale2.previewFile
      }, typeof customPreviewIcon === "function" ? customPreviewIcon(file) : customPreviewIcon || /* @__PURE__ */ reactExports.createElement(EyeOutlined$1, null)) : null;
      const pictureCardActions = (listType === "picture-card" || listType === "picture-circle") && mergedStatus !== "uploading" && /* @__PURE__ */ reactExports.createElement("span", {
        className: `${prefixCls}-list-item-actions`
      }, previewIcon, mergedStatus === "done" && downloadIcon, removeIcon);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const rootPrefixCls = getPrefixCls();
      const dom = /* @__PURE__ */ reactExports.createElement("div", {
        className: listItemClassName
      }, icon, fileName, pictureCardActions, showProgress && /* @__PURE__ */ reactExports.createElement(CSSMotion, {
        motionName: `${rootPrefixCls}-fade`,
        visible: mergedStatus === "uploading",
        motionDeadline: 2e3
      }, (_ref2) => {
        let {
          className: motionClassName
        } = _ref2;
        const loadingProgress = "percent" in file ? /* @__PURE__ */ reactExports.createElement(Progress$1, Object.assign({}, progressProps, {
          type: "line",
          percent: file.percent,
          "aria-label": file["aria-label"],
          "aria-labelledby": file["aria-labelledby"]
        })) : null;
        return /* @__PURE__ */ reactExports.createElement("div", {
          className: classNames(`${prefixCls}-list-item-progress`, motionClassName)
        }, loadingProgress);
      }));
      const message = file.response && typeof file.response === "string" ? file.response : ((_a = file.error) === null || _a === void 0 ? void 0 : _a.statusText) || ((_b = file.error) === null || _b === void 0 ? void 0 : _b.message) || locale2.uploadError;
      const item = mergedStatus === "error" ? /* @__PURE__ */ reactExports.createElement(Tooltip$1, {
        title: message,
        getPopupContainer: (node2) => node2.parentNode
      }, dom) : dom;
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: classNames(`${prefixCls}-list-item-container`, className),
        style: style2,
        ref
      }, itemRender ? itemRender(item, file, items, {
        download: onDownload.bind(null, file),
        preview: onPreview.bind(null, file),
        remove: onClose.bind(null, file)
      }) : item);
    });
    const ListItem$1 = ListItem;
    const InternalUploadList = (props, ref) => {
      const {
        listType = "text",
        previewFile = previewImage,
        onPreview,
        onDownload,
        onRemove,
        locale: locale2,
        iconRender,
        isImageUrl: isImgUrl = isImageUrl,
        prefixCls: customizePrefixCls,
        items = [],
        showPreviewIcon = true,
        showRemoveIcon = true,
        showDownloadIcon = false,
        removeIcon,
        previewIcon,
        downloadIcon,
        progress = {
          size: [-1, 2],
          showInfo: false
        },
        appendAction,
        appendActionVisible = true,
        itemRender,
        disabled
      } = props;
      const forceUpdate = useForceUpdate();
      const [motionAppear, setMotionAppear] = reactExports.useState(false);
      reactExports.useEffect(() => {
        if (listType !== "picture" && listType !== "picture-card" && listType !== "picture-circle") {
          return;
        }
        (items || []).forEach((file) => {
          if (typeof document === "undefined" || typeof window === "undefined" || !window.FileReader || !window.File || !(file.originFileObj instanceof File || file.originFileObj instanceof Blob) || file.thumbUrl !== void 0) {
            return;
          }
          file.thumbUrl = "";
          if (previewFile) {
            previewFile(file.originFileObj).then((previewDataUrl) => {
              file.thumbUrl = previewDataUrl || "";
              forceUpdate();
            });
          }
        });
      }, [listType, items, previewFile]);
      reactExports.useEffect(() => {
        setMotionAppear(true);
      }, []);
      const onInternalPreview = (file, e2) => {
        if (!onPreview) {
          return;
        }
        e2 === null || e2 === void 0 ? void 0 : e2.preventDefault();
        return onPreview(file);
      };
      const onInternalDownload = (file) => {
        if (typeof onDownload === "function") {
          onDownload(file);
        } else if (file.url) {
          window.open(file.url);
        }
      };
      const onInternalClose = (file) => {
        onRemove === null || onRemove === void 0 ? void 0 : onRemove(file);
      };
      const internalIconRender = (file) => {
        if (iconRender) {
          return iconRender(file, listType);
        }
        const isLoading = file.status === "uploading";
        const fileIcon = isImgUrl && isImgUrl(file) ? /* @__PURE__ */ reactExports.createElement(PictureTwoTone$1, null) : /* @__PURE__ */ reactExports.createElement(FileTwoTone$1, null);
        let icon = isLoading ? /* @__PURE__ */ reactExports.createElement(LoadingOutlined$1, null) : /* @__PURE__ */ reactExports.createElement(PaperClipOutlined$1, null);
        if (listType === "picture") {
          icon = isLoading ? /* @__PURE__ */ reactExports.createElement(LoadingOutlined$1, null) : fileIcon;
        } else if (listType === "picture-card" || listType === "picture-circle") {
          icon = isLoading ? locale2.uploading : fileIcon;
        }
        return icon;
      };
      const actionIconRender = (customIcon, callback, prefixCls2, title) => {
        const btnProps = {
          type: "text",
          size: "small",
          title,
          onClick: (e2) => {
            callback();
            if (isValidElement(customIcon) && customIcon.props.onClick) {
              customIcon.props.onClick(e2);
            }
          },
          className: `${prefixCls2}-list-item-action`,
          disabled
        };
        if (isValidElement(customIcon)) {
          const btnIcon = cloneElement(customIcon, Object.assign(Object.assign({}, customIcon.props), {
            onClick: () => {
            }
          }));
          return /* @__PURE__ */ reactExports.createElement(Button$2, Object.assign({}, btnProps, {
            icon: btnIcon
          }));
        }
        return /* @__PURE__ */ reactExports.createElement(Button$2, Object.assign({}, btnProps), /* @__PURE__ */ reactExports.createElement("span", null, customIcon));
      };
      reactExports.useImperativeHandle(ref, () => ({
        handlePreview: onInternalPreview,
        handleDownload: onInternalDownload
      }));
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("upload", customizePrefixCls);
      const rootPrefixCls = getPrefixCls();
      const listClassNames = classNames(`${prefixCls}-list`, `${prefixCls}-list-${listType}`);
      const motionKeyList = _toConsumableArray(items.map((file) => ({
        key: file.uid,
        file
      })));
      const animationDirection = listType === "picture-card" || listType === "picture-circle" ? "animate-inline" : "animate";
      let motionConfig = {
        motionDeadline: 2e3,
        motionName: `${prefixCls}-${animationDirection}`,
        keys: motionKeyList,
        motionAppear
      };
      const listItemMotion = reactExports.useMemo(() => {
        const motion = Object.assign({}, initCollapseMotion(rootPrefixCls));
        delete motion.onAppearEnd;
        delete motion.onEnterEnd;
        delete motion.onLeaveEnd;
        return motion;
      }, [rootPrefixCls]);
      if (listType !== "picture-card" && listType !== "picture-circle") {
        motionConfig = Object.assign(Object.assign({}, listItemMotion), motionConfig);
      }
      return /* @__PURE__ */ reactExports.createElement("div", {
        className: listClassNames
      }, /* @__PURE__ */ reactExports.createElement(CSSMotionList, Object.assign({}, motionConfig, {
        component: false
      }), (_ref) => {
        let {
          key,
          file,
          className: motionClassName,
          style: motionStyle
        } = _ref;
        return /* @__PURE__ */ reactExports.createElement(ListItem$1, {
          key,
          locale: locale2,
          prefixCls,
          className: motionClassName,
          style: motionStyle,
          file,
          items,
          progress,
          listType,
          isImgUrl,
          showPreviewIcon,
          showRemoveIcon,
          showDownloadIcon,
          removeIcon,
          previewIcon,
          downloadIcon,
          iconRender: internalIconRender,
          actionIconRender,
          itemRender,
          onPreview: onInternalPreview,
          onDownload: onInternalDownload,
          onClose: onInternalClose
        });
      }), appendAction && /* @__PURE__ */ reactExports.createElement(CSSMotion, Object.assign({}, motionConfig, {
        visible: appendActionVisible,
        forceRender: true
      }), (_ref2) => {
        let {
          className: motionClassName,
          style: motionStyle
        } = _ref2;
        return cloneElement(appendAction, (oriProps) => ({
          className: classNames(oriProps.className, motionClassName),
          style: Object.assign(Object.assign(Object.assign({}, motionStyle), {
            // prevent the element has hover css pseudo-class that may cause animation to end prematurely.
            pointerEvents: motionClassName ? "none" : void 0
          }), oriProps.style)
        }));
      }));
    };
    const UploadList = /* @__PURE__ */ reactExports.forwardRef(InternalUploadList);
    const UploadList$1 = UploadList;
    var __awaiter = function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    const LIST_IGNORE = `__LIST_IGNORE_${Date.now()}__`;
    const InternalUpload = (props, ref) => {
      const {
        fileList,
        defaultFileList,
        onRemove,
        showUploadList = true,
        listType = "text",
        onPreview,
        onDownload,
        onChange,
        onDrop,
        previewFile,
        disabled: customDisabled,
        locale: propLocale,
        iconRender,
        isImageUrl: isImageUrl2,
        progress,
        prefixCls: customizePrefixCls,
        className,
        type = "select",
        children,
        style: style2,
        itemRender,
        maxCount,
        data = {},
        multiple = false,
        action = "",
        accept = "",
        supportServerRender = true,
        rootClassName
      } = props;
      const disabled = reactExports.useContext(DisabledContext$1);
      const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
      const [mergedFileList, setMergedFileList] = useMergedState(defaultFileList || [], {
        value: fileList,
        postState: (list) => list !== null && list !== void 0 ? list : []
      });
      const [dragState, setDragState] = reactExports.useState("drop");
      const upload2 = reactExports.useRef(null);
      reactExports.useMemo(() => {
        const timestamp = Date.now();
        (fileList || []).forEach((file, index2) => {
          if (!file.uid && !Object.isFrozen(file)) {
            file.uid = `__AUTO__${timestamp}_${index2}__`;
          }
        });
      }, [fileList]);
      const onInternalChange = (file, changedFileList, event) => {
        let cloneList = _toConsumableArray(changedFileList);
        let exceedMaxCount = false;
        if (maxCount === 1) {
          cloneList = cloneList.slice(-1);
        } else if (maxCount) {
          exceedMaxCount = cloneList.length > maxCount;
          cloneList = cloneList.slice(0, maxCount);
        }
        reactDomExports.flushSync(() => {
          setMergedFileList(cloneList);
        });
        const changeInfo = {
          file,
          fileList: cloneList
        };
        if (event) {
          changeInfo.event = event;
        }
        if (!exceedMaxCount || // We should ignore event if current file is exceed `maxCount`
        cloneList.some((f2) => f2.uid === file.uid)) {
          reactDomExports.flushSync(() => {
            onChange === null || onChange === void 0 ? void 0 : onChange(changeInfo);
          });
        }
      };
      const mergedBeforeUpload = (file, fileListArgs) => __awaiter(void 0, void 0, void 0, function* () {
        const {
          beforeUpload,
          transformFile
        } = props;
        let parsedFile = file;
        if (beforeUpload) {
          const result = yield beforeUpload(file, fileListArgs);
          if (result === false) {
            return false;
          }
          delete file[LIST_IGNORE];
          if (result === LIST_IGNORE) {
            Object.defineProperty(file, LIST_IGNORE, {
              value: true,
              configurable: true
            });
            return false;
          }
          if (typeof result === "object" && result) {
            parsedFile = result;
          }
        }
        if (transformFile) {
          parsedFile = yield transformFile(parsedFile);
        }
        return parsedFile;
      });
      const onBatchStart = (batchFileInfoList) => {
        const filteredFileInfoList = batchFileInfoList.filter((info) => !info.file[LIST_IGNORE]);
        if (!filteredFileInfoList.length) {
          return;
        }
        const objectFileList = filteredFileInfoList.map((info) => file2Obj(info.file));
        let newFileList = _toConsumableArray(mergedFileList);
        objectFileList.forEach((fileObj) => {
          newFileList = updateFileList(fileObj, newFileList);
        });
        objectFileList.forEach((fileObj, index2) => {
          let triggerFileObj = fileObj;
          if (!filteredFileInfoList[index2].parsedFile) {
            const {
              originFileObj
            } = fileObj;
            let clone2;
            try {
              clone2 = new File([originFileObj], originFileObj.name, {
                type: originFileObj.type
              });
            } catch (e2) {
              clone2 = new Blob([originFileObj], {
                type: originFileObj.type
              });
              clone2.name = originFileObj.name;
              clone2.lastModifiedDate = /* @__PURE__ */ new Date();
              clone2.lastModified = (/* @__PURE__ */ new Date()).getTime();
            }
            clone2.uid = fileObj.uid;
            triggerFileObj = clone2;
          } else {
            fileObj.status = "uploading";
          }
          onInternalChange(triggerFileObj, newFileList);
        });
      };
      const onSuccess = (response, file, xhr) => {
        try {
          if (typeof response === "string") {
            response = JSON.parse(response);
          }
        } catch (e2) {
        }
        if (!getFileItem(file, mergedFileList)) {
          return;
        }
        const targetItem = file2Obj(file);
        targetItem.status = "done";
        targetItem.percent = 100;
        targetItem.response = response;
        targetItem.xhr = xhr;
        const nextFileList = updateFileList(targetItem, mergedFileList);
        onInternalChange(targetItem, nextFileList);
      };
      const onProgress = (e2, file) => {
        if (!getFileItem(file, mergedFileList)) {
          return;
        }
        const targetItem = file2Obj(file);
        targetItem.status = "uploading";
        targetItem.percent = e2.percent;
        const nextFileList = updateFileList(targetItem, mergedFileList);
        onInternalChange(targetItem, nextFileList, e2);
      };
      const onError = (error, response, file) => {
        if (!getFileItem(file, mergedFileList)) {
          return;
        }
        const targetItem = file2Obj(file);
        targetItem.error = error;
        targetItem.response = response;
        targetItem.status = "error";
        const nextFileList = updateFileList(targetItem, mergedFileList);
        onInternalChange(targetItem, nextFileList);
      };
      const handleRemove = (file) => {
        let currentFile;
        Promise.resolve(typeof onRemove === "function" ? onRemove(file) : onRemove).then((ret) => {
          var _a;
          if (ret === false) {
            return;
          }
          const removedFileList = removeFileItem(file, mergedFileList);
          if (removedFileList) {
            currentFile = Object.assign(Object.assign({}, file), {
              status: "removed"
            });
            mergedFileList === null || mergedFileList === void 0 ? void 0 : mergedFileList.forEach((item) => {
              const matchKey = currentFile.uid !== void 0 ? "uid" : "name";
              if (item[matchKey] === currentFile[matchKey] && !Object.isFrozen(item)) {
                item.status = "removed";
              }
            });
            (_a = upload2.current) === null || _a === void 0 ? void 0 : _a.abort(currentFile);
            onInternalChange(currentFile, removedFileList);
          }
        });
      };
      const onFileDrop = (e2) => {
        setDragState(e2.type);
        if (e2.type === "drop") {
          onDrop === null || onDrop === void 0 ? void 0 : onDrop(e2);
        }
      };
      reactExports.useImperativeHandle(ref, () => ({
        onBatchStart,
        onSuccess,
        onProgress,
        onError,
        fileList: mergedFileList,
        upload: upload2.current
      }));
      const {
        getPrefixCls,
        direction,
        upload: ctxUpload
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls("upload", customizePrefixCls);
      const rcUploadProps = Object.assign(Object.assign({
        onBatchStart,
        onError,
        onProgress,
        onSuccess
      }, props), {
        data,
        multiple,
        action,
        accept,
        supportServerRender,
        prefixCls,
        disabled: mergedDisabled,
        beforeUpload: mergedBeforeUpload,
        onChange: void 0
      });
      delete rcUploadProps.className;
      delete rcUploadProps.style;
      if (!children || mergedDisabled) {
        delete rcUploadProps.id;
      }
      const wrapperCls = `${prefixCls}-wrapper`;
      const [wrapCSSVar, hashId] = useStyle(prefixCls, wrapperCls);
      const [contextLocale] = useLocale$1("Upload", defaultLocale.Upload);
      const {
        showRemoveIcon,
        showPreviewIcon,
        showDownloadIcon,
        removeIcon,
        previewIcon,
        downloadIcon
      } = typeof showUploadList === "boolean" ? {} : showUploadList;
      const realShowRemoveIcon = typeof showRemoveIcon === "undefined" ? !mergedDisabled : !!showRemoveIcon;
      const renderUploadList = (button, buttonVisible) => {
        if (!showUploadList) {
          return button;
        }
        return /* @__PURE__ */ reactExports.createElement(UploadList$1, {
          prefixCls,
          listType,
          items: mergedFileList,
          previewFile,
          onPreview,
          onDownload,
          onRemove: handleRemove,
          showRemoveIcon: realShowRemoveIcon,
          showPreviewIcon,
          showDownloadIcon,
          removeIcon,
          previewIcon,
          downloadIcon,
          iconRender,
          locale: Object.assign(Object.assign({}, contextLocale), propLocale),
          isImageUrl: isImageUrl2,
          progress,
          appendAction: button,
          appendActionVisible: buttonVisible,
          itemRender,
          disabled: mergedDisabled
        });
      };
      const mergedCls = classNames(wrapperCls, className, rootClassName, hashId, ctxUpload === null || ctxUpload === void 0 ? void 0 : ctxUpload.className, {
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-picture-card-wrapper`]: listType === "picture-card",
        [`${prefixCls}-picture-circle-wrapper`]: listType === "picture-circle"
      });
      const mergedStyle = Object.assign(Object.assign({}, ctxUpload === null || ctxUpload === void 0 ? void 0 : ctxUpload.style), style2);
      if (type === "drag") {
        const dragCls = classNames(hashId, prefixCls, `${prefixCls}-drag`, {
          [`${prefixCls}-drag-uploading`]: mergedFileList.some((file) => file.status === "uploading"),
          [`${prefixCls}-drag-hover`]: dragState === "dragover",
          [`${prefixCls}-disabled`]: mergedDisabled,
          [`${prefixCls}-rtl`]: direction === "rtl"
        });
        return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("span", {
          className: mergedCls
        }, /* @__PURE__ */ reactExports.createElement("div", {
          className: dragCls,
          style: mergedStyle,
          onDrop: onFileDrop,
          onDragOver: onFileDrop,
          onDragLeave: onFileDrop
        }, /* @__PURE__ */ reactExports.createElement(Upload$3, Object.assign({}, rcUploadProps, {
          ref: upload2,
          className: `${prefixCls}-btn`
        }), /* @__PURE__ */ reactExports.createElement("div", {
          className: `${prefixCls}-drag-container`
        }, children))), renderUploadList()));
      }
      const uploadButtonCls = classNames(prefixCls, `${prefixCls}-select`, {
        [`${prefixCls}-disabled`]: mergedDisabled
      });
      const renderUploadButton = (uploadButtonStyle) => /* @__PURE__ */ reactExports.createElement("div", {
        className: uploadButtonCls,
        style: uploadButtonStyle
      }, /* @__PURE__ */ reactExports.createElement(Upload$3, Object.assign({}, rcUploadProps, {
        ref: upload2
      })));
      const uploadButton = renderUploadButton(children ? void 0 : {
        display: "none"
      });
      if (listType === "picture-card" || listType === "picture-circle") {
        return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("span", {
          className: mergedCls
        }, renderUploadList(uploadButton, !!children)));
      }
      return wrapCSSVar(/* @__PURE__ */ reactExports.createElement("span", {
        className: mergedCls
      }, uploadButton, renderUploadList()));
    };
    const Upload$2 = /* @__PURE__ */ reactExports.forwardRef(InternalUpload);
    const InternalUpload$1 = Upload$2;
    var __rest = function(s, e2) {
      var t2 = {};
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s[p2];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
          if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
            t2[p2[i]] = s[p2[i]];
        }
      return t2;
    };
    const Dragger = /* @__PURE__ */ reactExports.forwardRef((_a, ref) => {
      var {
        style: style2,
        height
      } = _a, restProps = __rest(_a, ["style", "height"]);
      return /* @__PURE__ */ reactExports.createElement(InternalUpload$1, Object.assign({
        ref
      }, restProps, {
        type: "drag",
        style: Object.assign(Object.assign({}, style2), {
          height
        })
      }));
    });
    const Dragger$1 = Dragger;
    const Upload = InternalUpload$1;
    Upload.Dragger = Dragger$1;
    Upload.LIST_IGNORE = LIST_IGNORE;
    const Upload$1 = Upload;
    const TableCompoent = (props) => {
      const { columns, data, onRow } = props;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Table$1,
        {
          columns,
          dataSource: data.map((item, index2) => ({
            ...item,
            key: index2
          })),
          onRow,
          size: "large",
          className: " mx-10 w-full ",
          rowClassName: "cursor-pointer"
        }
      );
    };
    var LockOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M832 464h-68V240c0-70.7-57.3-128-128-128H388c-70.7 0-128 57.3-128 128v224h-68c-17.7 0-32 14.3-32 32v384c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V496c0-17.7-14.3-32-32-32zM332 240c0-30.9 25.1-56 56-56h248c30.9 0 56 25.1 56 56v224H332V240zm460 600H232V536h560v304zM484 701v53c0 4.4 3.6 8 8 8h40c4.4 0 8-3.6 8-8v-53a48.01 48.01 0 10-56 0z" } }] }, "name": "lock", "theme": "outlined" };
    const LockOutlinedSvg = LockOutlined$2;
    var LockOutlined = function LockOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: LockOutlinedSvg
      }));
    };
    const LockOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(LockOutlined);
    var UploadOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M400 317.7h73.9V656c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V317.7H624c6.7 0 10.4-7.7 6.3-12.9L518.3 163a8 8 0 00-12.6 0l-112 141.7c-4.1 5.3-.4 13 6.3 13zM878 626h-60c-4.4 0-8 3.6-8 8v154H214V634c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v198c0 17.7 14.3 32 32 32h684c17.7 0 32-14.3 32-32V634c0-4.4-3.6-8-8-8z" } }] }, "name": "upload", "theme": "outlined" };
    const UploadOutlinedSvg = UploadOutlined$2;
    var UploadOutlined = function UploadOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: UploadOutlinedSvg
      }));
    };
    const UploadOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(UploadOutlined);
    var UserOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M858.5 763.6a374 374 0 00-80.6-119.5 375.63 375.63 0 00-119.5-80.6c-.4-.2-.8-.3-1.2-.5C719.5 518 760 444.7 760 362c0-137-111-248-248-248S264 225 264 362c0 82.7 40.5 156 102.8 201.1-.4.2-.8.3-1.2.5-44.8 18.9-85 46-119.5 80.6a375.63 375.63 0 00-80.6 119.5A371.7 371.7 0 00136 901.8a8 8 0 008 8.2h60c4.4 0 7.9-3.5 8-7.8 2-77.2 33-149.5 87.8-204.3 56.7-56.7 132-87.9 212.2-87.9s155.5 31.2 212.2 87.9C779 752.7 810 825 812 902.2c.1 4.4 3.6 7.8 8 7.8h60a8 8 0 008-8.2c-1-47.8-10.9-94.3-29.5-138.2zM512 534c-45.9 0-89.1-17.9-121.6-50.4S340 407.9 340 362c0-45.9 17.9-89.1 50.4-121.6S466.1 190 512 190s89.1 17.9 121.6 50.4S684 316.1 684 362c0 45.9-17.9 89.1-50.4 121.6S557.9 534 512 534z" } }] }, "name": "user", "theme": "outlined" };
    const UserOutlinedSvg = UserOutlined$2;
    var UserOutlined = function UserOutlined2(props, ref) {
      return /* @__PURE__ */ reactExports.createElement(AntdIcon, _extends$1({}, props, {
        ref,
        icon: UserOutlinedSvg
      }));
    };
    const UserOutlined$1 = /* @__PURE__ */ reactExports.forwardRef(UserOutlined);
    var main = { exports: {} };
    (function(module2) {
      module2.exports = /******/
      function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId])
            return installedModules[moduleId].exports;
          var module22 = installedModules[moduleId] = {
            /******/
            exports: {},
            /******/
            id: moduleId,
            /******/
            loaded: false
            /******/
          };
          modules[moduleId].call(module22.exports, module22, module22.exports, __webpack_require__);
          module22.loaded = true;
          return module22.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.p = "";
        return __webpack_require__(0);
      }([
        /* 0 */
        /***/
        function(module22, exports2, __webpack_require__) {
          module22.exports = __webpack_require__(1);
        },
        /* 1 */
        /***/
        function(module22, exports2, __webpack_require__) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { "default": obj };
          }
          var _Highlighter = __webpack_require__(2);
          var _Highlighter2 = _interopRequireDefault2(_Highlighter);
          exports2["default"] = _Highlighter2["default"];
          module22.exports = exports2["default"];
        },
        /* 2 */
        /***/
        function(module22, exports2, __webpack_require__) {
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          var _extends2 = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          exports2["default"] = Highlighter2;
          function _interopRequireDefault2(obj) {
            return obj && obj.__esModule ? obj : { "default": obj };
          }
          function _objectWithoutProperties2(obj, keys2) {
            var target = {};
            for (var i in obj) {
              if (keys2.indexOf(i) >= 0)
                continue;
              if (!Object.prototype.hasOwnProperty.call(obj, i))
                continue;
              target[i] = obj[i];
            }
            return target;
          }
          var _highlightWordsCore = __webpack_require__(3);
          var _propTypes = __webpack_require__(4);
          var _propTypes2 = _interopRequireDefault2(_propTypes);
          var _react = __webpack_require__(14);
          var _memoizeOne = __webpack_require__(15);
          var _memoizeOne2 = _interopRequireDefault2(_memoizeOne);
          Highlighter2.propTypes = {
            activeClassName: _propTypes2["default"].string,
            activeIndex: _propTypes2["default"].number,
            activeStyle: _propTypes2["default"].object,
            autoEscape: _propTypes2["default"].bool,
            className: _propTypes2["default"].string,
            findChunks: _propTypes2["default"].func,
            highlightClassName: _propTypes2["default"].oneOfType([_propTypes2["default"].object, _propTypes2["default"].string]),
            highlightStyle: _propTypes2["default"].object,
            highlightTag: _propTypes2["default"].oneOfType([_propTypes2["default"].node, _propTypes2["default"].func, _propTypes2["default"].string]),
            sanitize: _propTypes2["default"].func,
            searchWords: _propTypes2["default"].arrayOf(_propTypes2["default"].oneOfType([_propTypes2["default"].string, _propTypes2["default"].instanceOf(RegExp)])).isRequired,
            textToHighlight: _propTypes2["default"].string.isRequired,
            unhighlightTag: _propTypes2["default"].oneOfType([_propTypes2["default"].node, _propTypes2["default"].func, _propTypes2["default"].string]),
            unhighlightClassName: _propTypes2["default"].string,
            unhighlightStyle: _propTypes2["default"].object
          };
          function Highlighter2(_ref) {
            var _ref$activeClassName = _ref.activeClassName;
            var activeClassName = _ref$activeClassName === void 0 ? "" : _ref$activeClassName;
            var _ref$activeIndex = _ref.activeIndex;
            var activeIndex = _ref$activeIndex === void 0 ? -1 : _ref$activeIndex;
            var activeStyle = _ref.activeStyle;
            var autoEscape = _ref.autoEscape;
            var _ref$caseSensitive = _ref.caseSensitive;
            var caseSensitive = _ref$caseSensitive === void 0 ? false : _ref$caseSensitive;
            var className = _ref.className;
            var findChunks = _ref.findChunks;
            var _ref$highlightClassName = _ref.highlightClassName;
            var highlightClassName = _ref$highlightClassName === void 0 ? "" : _ref$highlightClassName;
            var _ref$highlightStyle = _ref.highlightStyle;
            var highlightStyle = _ref$highlightStyle === void 0 ? {} : _ref$highlightStyle;
            var _ref$highlightTag = _ref.highlightTag;
            var highlightTag = _ref$highlightTag === void 0 ? "mark" : _ref$highlightTag;
            var sanitize = _ref.sanitize;
            var searchWords = _ref.searchWords;
            var textToHighlight = _ref.textToHighlight;
            var _ref$unhighlightTag = _ref.unhighlightTag;
            var unhighlightTag = _ref$unhighlightTag === void 0 ? "span" : _ref$unhighlightTag;
            var _ref$unhighlightClassName = _ref.unhighlightClassName;
            var unhighlightClassName = _ref$unhighlightClassName === void 0 ? "" : _ref$unhighlightClassName;
            var unhighlightStyle = _ref.unhighlightStyle;
            var rest = _objectWithoutProperties2(_ref, ["activeClassName", "activeIndex", "activeStyle", "autoEscape", "caseSensitive", "className", "findChunks", "highlightClassName", "highlightStyle", "highlightTag", "sanitize", "searchWords", "textToHighlight", "unhighlightTag", "unhighlightClassName", "unhighlightStyle"]);
            var chunks = (0, _highlightWordsCore.findAll)({
              autoEscape,
              caseSensitive,
              findChunks,
              sanitize,
              searchWords,
              textToHighlight
            });
            var HighlightTag = highlightTag;
            var highlightIndex = -1;
            var highlightClassNames = "";
            var highlightStyles = void 0;
            var lowercaseProps = function lowercaseProps2(object) {
              var mapped = {};
              for (var key in object) {
                mapped[key.toLowerCase()] = object[key];
              }
              return mapped;
            };
            var memoizedLowercaseProps = (0, _memoizeOne2["default"])(lowercaseProps);
            return (0, _react.createElement)("span", _extends2({
              className
            }, rest, {
              children: chunks.map(function(chunk, index2) {
                var text = textToHighlight.substr(chunk.start, chunk.end - chunk.start);
                if (chunk.highlight) {
                  highlightIndex++;
                  var highlightClass = void 0;
                  if (typeof highlightClassName === "object") {
                    if (!caseSensitive) {
                      highlightClassName = memoizedLowercaseProps(highlightClassName);
                      highlightClass = highlightClassName[text.toLowerCase()];
                    } else {
                      highlightClass = highlightClassName[text];
                    }
                  } else {
                    highlightClass = highlightClassName;
                  }
                  var isActive2 = highlightIndex === +activeIndex;
                  highlightClassNames = highlightClass + " " + (isActive2 ? activeClassName : "");
                  highlightStyles = isActive2 === true && activeStyle != null ? Object.assign({}, highlightStyle, activeStyle) : highlightStyle;
                  var props = {
                    children: text,
                    className: highlightClassNames,
                    key: index2,
                    style: highlightStyles
                  };
                  if (typeof HighlightTag !== "string") {
                    props.highlightIndex = highlightIndex;
                  }
                  return (0, _react.createElement)(HighlightTag, props);
                } else {
                  return (0, _react.createElement)(unhighlightTag, {
                    children: text,
                    className: unhighlightClassName,
                    key: index2,
                    style: unhighlightStyle
                  });
                }
              })
            }));
          }
          module22.exports = exports2["default"];
        },
        /* 3 */
        /***/
        function(module22, exports2) {
          module22.exports = /******/
          function(modules) {
            var installedModules = {};
            function __webpack_require__(moduleId) {
              if (installedModules[moduleId])
                return installedModules[moduleId].exports;
              var module3 = installedModules[moduleId] = {
                /******/
                exports: {},
                /******/
                id: moduleId,
                /******/
                loaded: false
                /******/
              };
              modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
              module3.loaded = true;
              return module3.exports;
            }
            __webpack_require__.m = modules;
            __webpack_require__.c = installedModules;
            __webpack_require__.p = "";
            return __webpack_require__(0);
          }([
            /* 0 */
            /***/
            function(module3, exports22, __webpack_require__) {
              module3.exports = __webpack_require__(1);
            },
            /* 1 */
            /***/
            function(module3, exports22, __webpack_require__) {
              Object.defineProperty(exports22, "__esModule", {
                value: true
              });
              var _utils = __webpack_require__(2);
              Object.defineProperty(exports22, "combineChunks", {
                enumerable: true,
                get: function get2() {
                  return _utils.combineChunks;
                }
              });
              Object.defineProperty(exports22, "fillInChunks", {
                enumerable: true,
                get: function get2() {
                  return _utils.fillInChunks;
                }
              });
              Object.defineProperty(exports22, "findAll", {
                enumerable: true,
                get: function get2() {
                  return _utils.findAll;
                }
              });
              Object.defineProperty(exports22, "findChunks", {
                enumerable: true,
                get: function get2() {
                  return _utils.findChunks;
                }
              });
            },
            /* 2 */
            /***/
            function(module3, exports22) {
              Object.defineProperty(exports22, "__esModule", {
                value: true
              });
              exports22.findAll = function findAll2(_ref) {
                var autoEscape = _ref.autoEscape, _ref$caseSensitive = _ref.caseSensitive, caseSensitive = _ref$caseSensitive === void 0 ? false : _ref$caseSensitive, _ref$findChunks = _ref.findChunks, findChunks = _ref$findChunks === void 0 ? defaultFindChunks : _ref$findChunks, sanitize = _ref.sanitize, searchWords = _ref.searchWords, textToHighlight = _ref.textToHighlight;
                return fillInChunks({
                  chunksToHighlight: combineChunks({
                    chunks: findChunks({
                      autoEscape,
                      caseSensitive,
                      sanitize,
                      searchWords,
                      textToHighlight
                    })
                  }),
                  totalLength: textToHighlight ? textToHighlight.length : 0
                });
              };
              var combineChunks = exports22.combineChunks = function combineChunks2(_ref2) {
                var chunks = _ref2.chunks;
                chunks = chunks.sort(function(first, second) {
                  return first.start - second.start;
                }).reduce(function(processedChunks, nextChunk) {
                  if (processedChunks.length === 0) {
                    return [nextChunk];
                  } else {
                    var prevChunk = processedChunks.pop();
                    if (nextChunk.start <= prevChunk.end) {
                      var endIndex = Math.max(prevChunk.end, nextChunk.end);
                      processedChunks.push({ start: prevChunk.start, end: endIndex });
                    } else {
                      processedChunks.push(prevChunk, nextChunk);
                    }
                    return processedChunks;
                  }
                }, []);
                return chunks;
              };
              var defaultFindChunks = function defaultFindChunks2(_ref3) {
                var autoEscape = _ref3.autoEscape, caseSensitive = _ref3.caseSensitive, _ref3$sanitize = _ref3.sanitize, sanitize = _ref3$sanitize === void 0 ? identity : _ref3$sanitize, searchWords = _ref3.searchWords, textToHighlight = _ref3.textToHighlight;
                textToHighlight = sanitize(textToHighlight);
                return searchWords.filter(function(searchWord) {
                  return searchWord;
                }).reduce(function(chunks, searchWord) {
                  searchWord = sanitize(searchWord);
                  if (autoEscape) {
                    searchWord = escapeRegExpFn(searchWord);
                  }
                  var regex = new RegExp(searchWord, caseSensitive ? "g" : "gi");
                  var match5 = void 0;
                  while (match5 = regex.exec(textToHighlight)) {
                    var start = match5.index;
                    var end = regex.lastIndex;
                    if (end > start) {
                      chunks.push({ start, end });
                    }
                    if (match5.index == regex.lastIndex) {
                      regex.lastIndex++;
                    }
                  }
                  return chunks;
                }, []);
              };
              exports22.findChunks = defaultFindChunks;
              var fillInChunks = exports22.fillInChunks = function fillInChunks2(_ref4) {
                var chunksToHighlight = _ref4.chunksToHighlight, totalLength = _ref4.totalLength;
                var allChunks = [];
                var append2 = function append22(start, end, highlight) {
                  if (end - start > 0) {
                    allChunks.push({
                      start,
                      end,
                      highlight
                    });
                  }
                };
                if (chunksToHighlight.length === 0) {
                  append2(0, totalLength, false);
                } else {
                  var lastIndex = 0;
                  chunksToHighlight.forEach(function(chunk) {
                    append2(lastIndex, chunk.start, false);
                    append2(chunk.start, chunk.end, true);
                    lastIndex = chunk.end;
                  });
                  append2(lastIndex, totalLength, false);
                }
                return allChunks;
              };
              function identity(value) {
                return value;
              }
              function escapeRegExpFn(str) {
                return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
              }
            }
            /******/
          ]);
        },
        /* 4 */
        /***/
        function(module22, exports2, __webpack_require__) {
          (function(process2) {
            if (process2.env.NODE_ENV !== "production") {
              var REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 60103;
              var isValidElement2 = function(object) {
                return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
              };
              var throwOnDirectAccess = true;
              module22.exports = __webpack_require__(6)(isValidElement2, throwOnDirectAccess);
            } else {
              module22.exports = __webpack_require__(13)();
            }
          }).call(exports2, __webpack_require__(5));
        },
        /* 5 */
        /***/
        function(module22, exports2) {
          var process2 = module22.exports = {};
          var cachedSetTimeout;
          var cachedClearTimeout;
          function defaultSetTimout() {
            throw new Error("setTimeout has not been defined");
          }
          function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined");
          }
          (function() {
            try {
              if (typeof setTimeout === "function") {
                cachedSetTimeout = setTimeout;
              } else {
                cachedSetTimeout = defaultSetTimout;
              }
            } catch (e2) {
              cachedSetTimeout = defaultSetTimout;
            }
            try {
              if (typeof clearTimeout === "function") {
                cachedClearTimeout = clearTimeout;
              } else {
                cachedClearTimeout = defaultClearTimeout;
              }
            } catch (e2) {
              cachedClearTimeout = defaultClearTimeout;
            }
          })();
          function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
              return setTimeout(fun, 0);
            }
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
              cachedSetTimeout = setTimeout;
              return setTimeout(fun, 0);
            }
            try {
              return cachedSetTimeout(fun, 0);
            } catch (e2) {
              try {
                return cachedSetTimeout.call(null, fun, 0);
              } catch (e22) {
                return cachedSetTimeout.call(this, fun, 0);
              }
            }
          }
          function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
              return clearTimeout(marker);
            }
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
              cachedClearTimeout = clearTimeout;
              return clearTimeout(marker);
            }
            try {
              return cachedClearTimeout(marker);
            } catch (e2) {
              try {
                return cachedClearTimeout.call(null, marker);
              } catch (e22) {
                return cachedClearTimeout.call(this, marker);
              }
            }
          }
          var queue = [];
          var draining = false;
          var currentQueue;
          var queueIndex = -1;
          function cleanUpNextTick() {
            if (!draining || !currentQueue) {
              return;
            }
            draining = false;
            if (currentQueue.length) {
              queue = currentQueue.concat(queue);
            } else {
              queueIndex = -1;
            }
            if (queue.length) {
              drainQueue();
            }
          }
          function drainQueue() {
            if (draining) {
              return;
            }
            var timeout = runTimeout(cleanUpNextTick);
            draining = true;
            var len = queue.length;
            while (len) {
              currentQueue = queue;
              queue = [];
              while (++queueIndex < len) {
                if (currentQueue) {
                  currentQueue[queueIndex].run();
                }
              }
              queueIndex = -1;
              len = queue.length;
            }
            currentQueue = null;
            draining = false;
            runClearTimeout(timeout);
          }
          process2.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
              for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
              }
            }
            queue.push(new Item2(fun, args));
            if (queue.length === 1 && !draining) {
              runTimeout(drainQueue);
            }
          };
          function Item2(fun, array) {
            this.fun = fun;
            this.array = array;
          }
          Item2.prototype.run = function() {
            this.fun.apply(null, this.array);
          };
          process2.title = "browser";
          process2.browser = true;
          process2.env = {};
          process2.argv = [];
          process2.version = "";
          process2.versions = {};
          function noop2() {
          }
          process2.on = noop2;
          process2.addListener = noop2;
          process2.once = noop2;
          process2.off = noop2;
          process2.removeListener = noop2;
          process2.removeAllListeners = noop2;
          process2.emit = noop2;
          process2.prependListener = noop2;
          process2.prependOnceListener = noop2;
          process2.listeners = function(name) {
            return [];
          };
          process2.binding = function(name) {
            throw new Error("process.binding is not supported");
          };
          process2.cwd = function() {
            return "/";
          };
          process2.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
          };
          process2.umask = function() {
            return 0;
          };
        },
        /* 6 */
        /***/
        function(module22, exports2, __webpack_require__) {
          (function(process2) {
            var emptyFunction = __webpack_require__(7);
            var invariant2 = __webpack_require__(8);
            var warning2 = __webpack_require__(9);
            var assign = __webpack_require__(10);
            var ReactPropTypesSecret = __webpack_require__(11);
            var checkPropTypes = __webpack_require__(12);
            module22.exports = function(isValidElement2, throwOnDirectAccess) {
              var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
              var FAUX_ITERATOR_SYMBOL = "@@iterator";
              function getIteratorFn(maybeIterable) {
                var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
                if (typeof iteratorFn === "function") {
                  return iteratorFn;
                }
              }
              var ANONYMOUS = "<<anonymous>>";
              var ReactPropTypes = {
                array: createPrimitiveTypeChecker("array"),
                bool: createPrimitiveTypeChecker("boolean"),
                func: createPrimitiveTypeChecker("function"),
                number: createPrimitiveTypeChecker("number"),
                object: createPrimitiveTypeChecker("object"),
                string: createPrimitiveTypeChecker("string"),
                symbol: createPrimitiveTypeChecker("symbol"),
                any: createAnyTypeChecker(),
                arrayOf: createArrayOfTypeChecker,
                element: createElementTypeChecker(),
                instanceOf: createInstanceTypeChecker,
                node: createNodeChecker(),
                objectOf: createObjectOfTypeChecker,
                oneOf: createEnumTypeChecker,
                oneOfType: createUnionTypeChecker,
                shape: createShapeTypeChecker,
                exact: createStrictShapeTypeChecker
              };
              function is(x2, y2) {
                if (x2 === y2) {
                  return x2 !== 0 || 1 / x2 === 1 / y2;
                } else {
                  return x2 !== x2 && y2 !== y2;
                }
              }
              function PropTypeError(message) {
                this.message = message;
                this.stack = "";
              }
              PropTypeError.prototype = Error.prototype;
              function createChainableTypeChecker(validate) {
                if (process2.env.NODE_ENV !== "production") {
                  var manualPropTypeCallCache = {};
                  var manualPropTypeWarningCount = 0;
                }
                function checkType(isRequired, props, propName, componentName, location2, propFullName, secret) {
                  componentName = componentName || ANONYMOUS;
                  propFullName = propFullName || propName;
                  if (secret !== ReactPropTypesSecret) {
                    if (throwOnDirectAccess) {
                      invariant2(
                        false,
                        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
                      );
                    } else if (process2.env.NODE_ENV !== "production" && typeof console !== "undefined") {
                      var cacheKey = componentName + ":" + propName;
                      if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
                      manualPropTypeWarningCount < 3) {
                        warning2(
                          false,
                          "You are manually calling a React.PropTypes validation function for the `%s` prop on `%s`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.",
                          propFullName,
                          componentName
                        );
                        manualPropTypeCallCache[cacheKey] = true;
                        manualPropTypeWarningCount++;
                      }
                    }
                  }
                  if (props[propName] == null) {
                    if (isRequired) {
                      if (props[propName] === null) {
                        return new PropTypeError("The " + location2 + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
                      }
                      return new PropTypeError("The " + location2 + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
                    }
                    return null;
                  } else {
                    return validate(props, propName, componentName, location2, propFullName);
                  }
                }
                var chainedCheckType = checkType.bind(null, false);
                chainedCheckType.isRequired = checkType.bind(null, true);
                return chainedCheckType;
              }
              function createPrimitiveTypeChecker(expectedType) {
                function validate(props, propName, componentName, location2, propFullName, secret) {
                  var propValue = props[propName];
                  var propType = getPropType(propValue);
                  if (propType !== expectedType) {
                    var preciseType = getPreciseType(propValue);
                    return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."));
                  }
                  return null;
                }
                return createChainableTypeChecker(validate);
              }
              function createAnyTypeChecker() {
                return createChainableTypeChecker(emptyFunction.thatReturnsNull);
              }
              function createArrayOfTypeChecker(typeChecker) {
                function validate(props, propName, componentName, location2, propFullName) {
                  if (typeof typeChecker !== "function") {
                    return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
                  }
                  var propValue = props[propName];
                  if (!Array.isArray(propValue)) {
                    var propType = getPropType(propValue);
                    return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
                  }
                  for (var i = 0; i < propValue.length; i++) {
                    var error = typeChecker(propValue, i, componentName, location2, propFullName + "[" + i + "]", ReactPropTypesSecret);
                    if (error instanceof Error) {
                      return error;
                    }
                  }
                  return null;
                }
                return createChainableTypeChecker(validate);
              }
              function createElementTypeChecker() {
                function validate(props, propName, componentName, location2, propFullName) {
                  var propValue = props[propName];
                  if (!isValidElement2(propValue)) {
                    var propType = getPropType(propValue);
                    return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
                  }
                  return null;
                }
                return createChainableTypeChecker(validate);
              }
              function createInstanceTypeChecker(expectedClass) {
                function validate(props, propName, componentName, location2, propFullName) {
                  if (!(props[propName] instanceof expectedClass)) {
                    var expectedClassName = expectedClass.name || ANONYMOUS;
                    var actualClassName = getClassName(props[propName]);
                    return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
                  }
                  return null;
                }
                return createChainableTypeChecker(validate);
              }
              function createEnumTypeChecker(expectedValues) {
                if (!Array.isArray(expectedValues)) {
                  process2.env.NODE_ENV !== "production" ? warning2(false, "Invalid argument supplied to oneOf, expected an instance of array.") : void 0;
                  return emptyFunction.thatReturnsNull;
                }
                function validate(props, propName, componentName, location2, propFullName) {
                  var propValue = props[propName];
                  for (var i = 0; i < expectedValues.length; i++) {
                    if (is(propValue, expectedValues[i])) {
                      return null;
                    }
                  }
                  var valuesString = JSON.stringify(expectedValues);
                  return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of value `" + propValue + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
                }
                return createChainableTypeChecker(validate);
              }
              function createObjectOfTypeChecker(typeChecker) {
                function validate(props, propName, componentName, location2, propFullName) {
                  if (typeof typeChecker !== "function") {
                    return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
                  }
                  var propValue = props[propName];
                  var propType = getPropType(propValue);
                  if (propType !== "object") {
                    return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
                  }
                  for (var key in propValue) {
                    if (propValue.hasOwnProperty(key)) {
                      var error = typeChecker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
                      if (error instanceof Error) {
                        return error;
                      }
                    }
                  }
                  return null;
                }
                return createChainableTypeChecker(validate);
              }
              function createUnionTypeChecker(arrayOfTypeCheckers) {
                if (!Array.isArray(arrayOfTypeCheckers)) {
                  process2.env.NODE_ENV !== "production" ? warning2(false, "Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
                  return emptyFunction.thatReturnsNull;
                }
                for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
                  var checker = arrayOfTypeCheckers[i];
                  if (typeof checker !== "function") {
                    warning2(
                      false,
                      "Invalid argument supplied to oneOfType. Expected an array of check functions, but received %s at index %s.",
                      getPostfixForTypeWarning(checker),
                      i
                    );
                    return emptyFunction.thatReturnsNull;
                  }
                }
                function validate(props, propName, componentName, location2, propFullName) {
                  for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
                    var checker2 = arrayOfTypeCheckers[i2];
                    if (checker2(props, propName, componentName, location2, propFullName, ReactPropTypesSecret) == null) {
                      return null;
                    }
                  }
                  return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` supplied to " + ("`" + componentName + "`."));
                }
                return createChainableTypeChecker(validate);
              }
              function createNodeChecker() {
                function validate(props, propName, componentName, location2, propFullName) {
                  if (!isNode(props[propName])) {
                    return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
                  }
                  return null;
                }
                return createChainableTypeChecker(validate);
              }
              function createShapeTypeChecker(shapeTypes) {
                function validate(props, propName, componentName, location2, propFullName) {
                  var propValue = props[propName];
                  var propType = getPropType(propValue);
                  if (propType !== "object") {
                    return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
                  }
                  for (var key in shapeTypes) {
                    var checker = shapeTypes[key];
                    if (!checker) {
                      continue;
                    }
                    var error = checker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
                    if (error) {
                      return error;
                    }
                  }
                  return null;
                }
                return createChainableTypeChecker(validate);
              }
              function createStrictShapeTypeChecker(shapeTypes) {
                function validate(props, propName, componentName, location2, propFullName) {
                  var propValue = props[propName];
                  var propType = getPropType(propValue);
                  if (propType !== "object") {
                    return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
                  }
                  var allKeys = assign({}, props[propName], shapeTypes);
                  for (var key in allKeys) {
                    var checker = shapeTypes[key];
                    if (!checker) {
                      return new PropTypeError(
                        "Invalid " + location2 + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
                      );
                    }
                    var error = checker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
                    if (error) {
                      return error;
                    }
                  }
                  return null;
                }
                return createChainableTypeChecker(validate);
              }
              function isNode(propValue) {
                switch (typeof propValue) {
                  case "number":
                  case "string":
                  case "undefined":
                    return true;
                  case "boolean":
                    return !propValue;
                  case "object":
                    if (Array.isArray(propValue)) {
                      return propValue.every(isNode);
                    }
                    if (propValue === null || isValidElement2(propValue)) {
                      return true;
                    }
                    var iteratorFn = getIteratorFn(propValue);
                    if (iteratorFn) {
                      var iterator = iteratorFn.call(propValue);
                      var step;
                      if (iteratorFn !== propValue.entries) {
                        while (!(step = iterator.next()).done) {
                          if (!isNode(step.value)) {
                            return false;
                          }
                        }
                      } else {
                        while (!(step = iterator.next()).done) {
                          var entry = step.value;
                          if (entry) {
                            if (!isNode(entry[1])) {
                              return false;
                            }
                          }
                        }
                      }
                    } else {
                      return false;
                    }
                    return true;
                  default:
                    return false;
                }
              }
              function isSymbol(propType, propValue) {
                if (propType === "symbol") {
                  return true;
                }
                if (propValue["@@toStringTag"] === "Symbol") {
                  return true;
                }
                if (typeof Symbol === "function" && propValue instanceof Symbol) {
                  return true;
                }
                return false;
              }
              function getPropType(propValue) {
                var propType = typeof propValue;
                if (Array.isArray(propValue)) {
                  return "array";
                }
                if (propValue instanceof RegExp) {
                  return "object";
                }
                if (isSymbol(propType, propValue)) {
                  return "symbol";
                }
                return propType;
              }
              function getPreciseType(propValue) {
                if (typeof propValue === "undefined" || propValue === null) {
                  return "" + propValue;
                }
                var propType = getPropType(propValue);
                if (propType === "object") {
                  if (propValue instanceof Date) {
                    return "date";
                  } else if (propValue instanceof RegExp) {
                    return "regexp";
                  }
                }
                return propType;
              }
              function getPostfixForTypeWarning(value) {
                var type = getPreciseType(value);
                switch (type) {
                  case "array":
                  case "object":
                    return "an " + type;
                  case "boolean":
                  case "date":
                  case "regexp":
                    return "a " + type;
                  default:
                    return type;
                }
              }
              function getClassName(propValue) {
                if (!propValue.constructor || !propValue.constructor.name) {
                  return ANONYMOUS;
                }
                return propValue.constructor.name;
              }
              ReactPropTypes.checkPropTypes = checkPropTypes;
              ReactPropTypes.PropTypes = ReactPropTypes;
              return ReactPropTypes;
            };
          }).call(exports2, __webpack_require__(5));
        },
        /* 7 */
        /***/
        function(module22, exports2) {
          function makeEmptyFunction(arg) {
            return function() {
              return arg;
            };
          }
          var emptyFunction = function emptyFunction2() {
          };
          emptyFunction.thatReturns = makeEmptyFunction;
          emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
          emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
          emptyFunction.thatReturnsNull = makeEmptyFunction(null);
          emptyFunction.thatReturnsThis = function() {
            return this;
          };
          emptyFunction.thatReturnsArgument = function(arg) {
            return arg;
          };
          module22.exports = emptyFunction;
        },
        /* 8 */
        /***/
        function(module22, exports2, __webpack_require__) {
          (function(process2) {
            var validateFormat = function validateFormat2(format2) {
            };
            if (process2.env.NODE_ENV !== "production") {
              validateFormat = function validateFormat2(format2) {
                if (format2 === void 0) {
                  throw new Error("invariant requires an error message argument");
                }
              };
            }
            function invariant2(condition, format2, a, b2, c2, d2, e2, f2) {
              validateFormat(format2);
              if (!condition) {
                var error;
                if (format2 === void 0) {
                  error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
                } else {
                  var args = [a, b2, c2, d2, e2, f2];
                  var argIndex = 0;
                  error = new Error(format2.replace(/%s/g, function() {
                    return args[argIndex++];
                  }));
                  error.name = "Invariant Violation";
                }
                error.framesToPop = 1;
                throw error;
              }
            }
            module22.exports = invariant2;
          }).call(exports2, __webpack_require__(5));
        },
        /* 9 */
        /***/
        function(module22, exports2, __webpack_require__) {
          (function(process2) {
            var emptyFunction = __webpack_require__(7);
            var warning2 = emptyFunction;
            if (process2.env.NODE_ENV !== "production") {
              var printWarning = function printWarning2(format2) {
                for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                var argIndex = 0;
                var message = "Warning: " + format2.replace(/%s/g, function() {
                  return args[argIndex++];
                });
                if (typeof console !== "undefined") {
                  console.error(message);
                }
                try {
                  throw new Error(message);
                } catch (x2) {
                }
              };
              warning2 = function warning22(condition, format2) {
                if (format2 === void 0) {
                  throw new Error("`warning(condition, format, ...args)` requires a warning message argument");
                }
                if (format2.indexOf("Failed Composite propType: ") === 0) {
                  return;
                }
                if (!condition) {
                  for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
                    args[_key2 - 2] = arguments[_key2];
                  }
                  printWarning.apply(void 0, [format2].concat(args));
                }
              };
            }
            module22.exports = warning2;
          }).call(exports2, __webpack_require__(5));
        },
        /* 10 */
        /***/
        function(module22, exports2) {
          var getOwnPropertySymbols = Object.getOwnPropertySymbols;
          var hasOwnProperty2 = Object.prototype.hasOwnProperty;
          var propIsEnumerable = Object.prototype.propertyIsEnumerable;
          function toObject2(val) {
            if (val === null || val === void 0) {
              throw new TypeError("Object.assign cannot be called with null or undefined");
            }
            return Object(val);
          }
          function shouldUseNative() {
            try {
              if (!Object.assign) {
                return false;
              }
              var test1 = new String("abc");
              test1[5] = "de";
              if (Object.getOwnPropertyNames(test1)[0] === "5") {
                return false;
              }
              var test2 = {};
              for (var i = 0; i < 10; i++) {
                test2["_" + String.fromCharCode(i)] = i;
              }
              var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
                return test2[n2];
              });
              if (order2.join("") !== "0123456789") {
                return false;
              }
              var test3 = {};
              "abcdefghijklmnopqrst".split("").forEach(function(letter) {
                test3[letter] = letter;
              });
              if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
                return false;
              }
              return true;
            } catch (err) {
              return false;
            }
          }
          module22.exports = shouldUseNative() ? Object.assign : function(target, source) {
            var from2;
            var to2 = toObject2(target);
            var symbols;
            for (var s = 1; s < arguments.length; s++) {
              from2 = Object(arguments[s]);
              for (var key in from2) {
                if (hasOwnProperty2.call(from2, key)) {
                  to2[key] = from2[key];
                }
              }
              if (getOwnPropertySymbols) {
                symbols = getOwnPropertySymbols(from2);
                for (var i = 0; i < symbols.length; i++) {
                  if (propIsEnumerable.call(from2, symbols[i])) {
                    to2[symbols[i]] = from2[symbols[i]];
                  }
                }
              }
            }
            return to2;
          };
        },
        /* 11 */
        /***/
        function(module22, exports2) {
          var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
          module22.exports = ReactPropTypesSecret;
        },
        /* 12 */
        /***/
        function(module22, exports2, __webpack_require__) {
          (function(process2) {
            if (process2.env.NODE_ENV !== "production") {
              var invariant2 = __webpack_require__(8);
              var warning2 = __webpack_require__(9);
              var ReactPropTypesSecret = __webpack_require__(11);
              var loggedTypeFailures = {};
            }
            function checkPropTypes(typeSpecs, values, location2, componentName, getStack) {
              if (process2.env.NODE_ENV !== "production") {
                for (var typeSpecName in typeSpecs) {
                  if (typeSpecs.hasOwnProperty(typeSpecName)) {
                    var error;
                    try {
                      invariant2(typeof typeSpecs[typeSpecName] === "function", "%s: %s type `%s` is invalid; it must be a function, usually from the `prop-types` package, but received `%s`.", componentName || "React class", location2, typeSpecName, typeof typeSpecs[typeSpecName]);
                      error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, ReactPropTypesSecret);
                    } catch (ex) {
                      error = ex;
                    }
                    warning2(!error || error instanceof Error, "%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error);
                    if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                      loggedTypeFailures[error.message] = true;
                      var stack = getStack ? getStack() : "";
                      warning2(false, "Failed %s type: %s%s", location2, error.message, stack != null ? stack : "");
                    }
                  }
                }
              }
            }
            module22.exports = checkPropTypes;
          }).call(exports2, __webpack_require__(5));
        },
        /* 13 */
        /***/
        function(module22, exports2, __webpack_require__) {
          var emptyFunction = __webpack_require__(7);
          var invariant2 = __webpack_require__(8);
          var ReactPropTypesSecret = __webpack_require__(11);
          module22.exports = function() {
            function shim(props, propName, componentName, location2, propFullName, secret) {
              if (secret === ReactPropTypesSecret) {
                return;
              }
              invariant2(
                false,
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
              );
            }
            shim.isRequired = shim;
            function getShim() {
              return shim;
            }
            var ReactPropTypes = {
              array: shim,
              bool: shim,
              func: shim,
              number: shim,
              object: shim,
              string: shim,
              symbol: shim,
              any: shim,
              arrayOf: getShim,
              element: shim,
              instanceOf: getShim,
              node: shim,
              objectOf: getShim,
              oneOf: getShim,
              oneOfType: getShim,
              shape: getShim,
              exact: getShim
            };
            ReactPropTypes.checkPropTypes = emptyFunction;
            ReactPropTypes.PropTypes = ReactPropTypes;
            return ReactPropTypes;
          };
        },
        /* 14 */
        /***/
        function(module22, exports2) {
          module22.exports = reactExports;
        },
        /* 15 */
        /***/
        function(module22, exports2) {
          var simpleIsEqual = function simpleIsEqual2(a, b2) {
            return a === b2;
          };
          function index2(resultFn) {
            var isEqual2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : simpleIsEqual;
            var lastThis = void 0;
            var lastArgs = [];
            var lastResult = void 0;
            var calledOnce = false;
            var isNewArgEqualToLast = function isNewArgEqualToLast2(newArg, index22) {
              return isEqual2(newArg, lastArgs[index22]);
            };
            var result = function result2() {
              for (var _len = arguments.length, newArgs = Array(_len), _key = 0; _key < _len; _key++) {
                newArgs[_key] = arguments[_key];
              }
              if (calledOnce && lastThis === this && newArgs.length === lastArgs.length && newArgs.every(isNewArgEqualToLast)) {
                return lastResult;
              }
              calledOnce = true;
              lastThis = this;
              lastArgs = newArgs;
              lastResult = resultFn.apply(this, newArgs);
              return lastResult;
            };
            return result;
          }
          module22.exports = index2;
        }
        /******/
      ]);
    })(main);
    var mainExports = main.exports;
    const Highlighter = /* @__PURE__ */ getDefaultExportFromCjs(mainExports);
    const getColumnSearchProps = (dataIndex) => {
      const [searchText, setSearchText] = reactExports.useState("");
      const [searchedColumn, setSearchedColumn] = reactExports.useState("");
      const searchInput = reactExports.useRef(null);
      const handleSearch = (selectedKeys, confirm2, dataIndex2) => {
        confirm2();
        setSearchText(selectedKeys[0]);
        setSearchedColumn(dataIndex2);
      };
      const handleReset = (clearFilters) => {
        clearFilters();
        setSearchText("");
      };
      const filterDropdown = ({
        setSelectedKeys,
        selectedKeys,
        confirm: confirm2,
        clearFilters,
        close
      }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: 8 }, onKeyDown: (e2) => e2.stopPropagation(), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input$1,
          {
            placeholder: `Search ${dataIndex}`,
            value: selectedKeys[0],
            onChange: (e2) => setSelectedKeys(e2.target.value ? [e2.target.value] : []),
            onPressEnter: () => handleSearch(selectedKeys, confirm2, dataIndex),
            style: { marginBottom: 8, display: "block" }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Space$1, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$2,
            {
              type: "primary",
              onClick: () => handleSearch(selectedKeys, confirm2, dataIndex),
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(SearchOutlined$1, {}),
              size: "small",
              className: "bg-blue-600 w-30",
              children: "搜尋"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$2,
            {
              onClick: () => clearFilters && handleReset(clearFilters),
              size: "small",
              style: { width: 90 },
              children: "重設"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$2,
            {
              type: "link",
              size: "small",
              onClick: () => {
                confirm2();
                setSearchText(selectedKeys[0]);
                setSearchedColumn(dataIndex);
              },
              children: "Filter"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$2,
            {
              type: "link",
              size: "small",
              onClick: () => {
                close();
              },
              children: "關閉"
            }
          )
        ] })
      ] });
      const filterIcon = (filtered) => /* @__PURE__ */ jsxRuntimeExports.jsx(SearchOutlined$1, { style: { color: filtered ? "#1677ff" : void 0 } });
      const onFilter = (value, record) => record[dataIndex].toString().toLowerCase().includes(value.toLowerCase());
      const onFilterDropdownOpenChange = (visible) => {
        if (visible) {
          setTimeout(() => searchInput.current?.select(), 100);
        }
      };
      const render2 = (text) => searchedColumn === dataIndex ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Highlighter,
        {
          highlightStyle: { backgroundColor: "#ffc069", padding: 0 },
          searchWords: [searchText],
          autoEscape: true,
          textToHighlight: text ? text.toString() : ""
        }
      ) : text;
      return {
        filterDropdown,
        filterIcon,
        onFilter,
        onFilterDropdownOpenChange,
        render: render2
      };
    };
    var util;
    (function(util2) {
      util2.assertEqual = (val) => val;
      function assertIs(_arg) {
      }
      util2.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      util2.assertNever = assertNever;
      util2.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util2.getValidEnumValues = (obj) => {
        const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
        const filtered = {};
        for (const k2 of validKeys) {
          filtered[k2] = obj[k2];
        }
        return util2.objectValues(filtered);
      };
      util2.objectValues = (obj) => {
        return util2.objectKeys(obj).map(function(e2) {
          return obj[e2];
        });
      };
      util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
        const keys2 = [];
        for (const key in object) {
          if (Object.prototype.hasOwnProperty.call(object, key)) {
            keys2.push(key);
          }
        }
        return keys2;
      };
      util2.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
      function joinValues(array, separator = " | ") {
        return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      util2.joinValues = joinValues;
      util2.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util || (util = {}));
    var objectUtil;
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil || (objectUtil = {}));
    const ZodParsedType = util.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    const getParsedType = (data) => {
      const t2 = typeof data;
      switch (t2) {
        case "undefined":
          return ZodParsedType.undefined;
        case "string":
          return ZodParsedType.string;
        case "number":
          return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
          return ZodParsedType.boolean;
        case "function":
          return ZodParsedType.function;
        case "bigint":
          return ZodParsedType.bigint;
        case "symbol":
          return ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return ZodParsedType.array;
          }
          if (data === null) {
            return ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return ZodParsedType.date;
          }
          return ZodParsedType.object;
        default:
          return ZodParsedType.unknown;
      }
    };
    const ZodIssueCode = util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    const quotelessJson = (obj) => {
      const json = JSON.stringify(obj, null, 2);
      return json.replace(/"([^"]+)":/g, "$1:");
    };
    class ZodError extends Error {
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      get errors() {
        return this.issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue) {
          return issue.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
          for (const issue of error.issues) {
            if (issue.code === "invalid_union") {
              issue.unionErrors.map(processError);
            } else if (issue.code === "invalid_return_type") {
              processError(issue.returnTypeError);
            } else if (issue.code === "invalid_arguments") {
              processError(issue.argumentsError);
            } else if (issue.path.length === 0) {
              fieldErrors._errors.push(mapper(issue));
            } else {
              let curr = fieldErrors;
              let i = 0;
              while (i < issue.path.length) {
                const el2 = issue.path[i];
                const terminal = i === issue.path.length - 1;
                if (!terminal) {
                  curr[el2] = curr[el2] || { _errors: [] };
                } else {
                  curr[el2] = curr[el2] || { _errors: [] };
                  curr[el2]._errors.push(mapper(issue));
                }
                curr = curr[el2];
                i++;
              }
            }
          }
        };
        processError(this);
        return fieldErrors;
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
            fieldErrors[sub.path[0]].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    }
    ZodError.create = (issues) => {
      const error = new ZodError(issues);
      return error;
    };
    const errorMap = (issue, _ctx) => {
      let message;
      switch (issue.code) {
        case ZodIssueCode.invalid_type:
          if (issue.received === ZodParsedType.undefined) {
            message = "Required";
          } else {
            message = `Expected ${issue.expected}, received ${issue.received}`;
          }
          break;
        case ZodIssueCode.invalid_literal:
          message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
          break;
        case ZodIssueCode.unrecognized_keys:
          message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
          break;
        case ZodIssueCode.invalid_union:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_union_discriminator:
          message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
          break;
        case ZodIssueCode.invalid_enum_value:
          message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodIssueCode.invalid_arguments:
          message = `Invalid function arguments`;
          break;
        case ZodIssueCode.invalid_return_type:
          message = `Invalid function return type`;
          break;
        case ZodIssueCode.invalid_date:
          message = `Invalid date`;
          break;
        case ZodIssueCode.invalid_string:
          if (typeof issue.validation === "object") {
            if ("includes" in issue.validation) {
              message = `Invalid input: must include "${issue.validation.includes}"`;
              if (typeof issue.validation.position === "number") {
                message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
              }
            } else if ("startsWith" in issue.validation) {
              message = `Invalid input: must start with "${issue.validation.startsWith}"`;
            } else if ("endsWith" in issue.validation) {
              message = `Invalid input: must end with "${issue.validation.endsWith}"`;
            } else {
              util.assertNever(issue.validation);
            }
          } else if (issue.validation !== "regex") {
            message = `Invalid ${issue.validation}`;
          } else {
            message = "Invalid";
          }
          break;
        case ZodIssueCode.too_small:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.too_big:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "bigint")
            message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.custom:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_intersection_types:
          message = `Intersection results could not be merged`;
          break;
        case ZodIssueCode.not_multiple_of:
          message = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodIssueCode.not_finite:
          message = "Number must be finite";
          break;
        default:
          message = _ctx.defaultError;
          util.assertNever(issue);
      }
      return { message };
    };
    let overrideErrorMap = errorMap;
    function setErrorMap(map2) {
      overrideErrorMap = map2;
    }
    function getErrorMap() {
      return overrideErrorMap;
    }
    const makeIssue = (params) => {
      const { data, path, errorMaps, issueData } = params;
      const fullPath = [...path, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      let errorMessage = "";
      const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
      for (const map2 of maps) {
        errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message || errorMessage
      };
    };
    const EMPTY_PATH = [];
    function addIssueToContext(ctx, issueData) {
      const issue = makeIssue({
        issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
          // then global default map
        ].filter((x2) => !!x2)
      });
      ctx.common.issues.push(issue);
    }
    class ParseStatus {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
          if (s.status === "aborted")
            return INVALID;
          if (s.status === "dirty")
            status.dirty();
          arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          syncPairs.push({
            key: await pair.key,
            value: await pair.value
          });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key, value } = pair;
          if (key.status === "aborted")
            return INVALID;
          if (value.status === "aborted")
            return INVALID;
          if (key.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
            finalObject[key.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    }
    const INVALID = Object.freeze({
      status: "aborted"
    });
    const DIRTY = (value) => ({ status: "dirty", value });
    const OK = (value) => ({ status: "valid", value });
    const isAborted = (x2) => x2.status === "aborted";
    const isDirty = (x2) => x2.status === "dirty";
    const isValid$3 = (x2) => x2.status === "valid";
    const isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
    var errorUtil;
    (function(errorUtil2) {
      errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
      errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
    })(errorUtil || (errorUtil = {}));
    class ParseInputLazyPath {
      constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (this._key instanceof Array) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    }
    const handleResult = (ctx, result) => {
      if (isValid$3(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error = new ZodError(ctx.common.issues);
            this._error = error;
            return this._error;
          }
        };
      }
    };
    function processCreateParams(params) {
      if (!params)
        return {};
      const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
      if (errorMap2 && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
      }
      if (errorMap2)
        return { errorMap: errorMap2, description };
      const customMap = (iss, ctx) => {
        if (iss.code !== "invalid_type")
          return { message: ctx.defaultError };
        if (typeof ctx.data === "undefined") {
          return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
        }
        return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
      };
      return { errorMap: customMap, description };
    }
    class ZodType {
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
      }
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return getParsedType(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params) {
        var _a;
        const ctx = {
          common: {
            issues: [],
            async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
      }
      async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            async: true
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
      }
      refine(check, message) {
        const getIssueProperties = (val) => {
          if (typeof message === "string" || typeof message === "undefined") {
            return { message };
          } else if (typeof message === "function") {
            return message(val);
          } else {
            return message;
          }
        };
        return this._refinement((val, ctx) => {
          const result = check(val);
          const setError = () => ctx.addIssue({
            code: ZodIssueCode.custom,
            ...getIssueProperties(val)
          });
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      optional() {
        return ZodOptional.create(this, this._def);
      }
      nullable() {
        return ZodNullable.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray.create(this, this._def);
      }
      promise() {
        return ZodPromise.create(this, this._def);
      }
      or(option) {
        return ZodUnion.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
      }
      transform(transform) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        });
      }
      catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline.create(this, target);
      }
      readonly() {
        return ZodReadonly.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    }
    const cuidRegex = /^c[^\s-]{8,}$/i;
    const cuid2Regex = /^[a-z][a-z0-9]*$/;
    const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
    const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    let emojiRegex;
    const ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
    const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
    const datetimeRegex = (args) => {
      if (args.precision) {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
        }
      } else if (args.precision === 0) {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
        }
      } else {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
        }
      }
    };
    function isValidIP(ip, version2) {
      if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
        return true;
      }
      if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
        return true;
      }
      return false;
    }
    class ZodString extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(
            ctx2,
            {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.string,
              received: ctx2.parsedType
            }
            //
          );
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.length < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.length > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "length") {
            const tooBig = input.data.length > check.value;
            const tooSmall = input.data.length < check.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              } else if (tooSmall) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              }
              status.dirty();
            }
          } else if (check.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "email",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "emoji") {
            if (!emojiRegex) {
              emojiRegex = new RegExp(_emojiRegex, "u");
            }
            if (!emojiRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "emoji",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "uuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid2") {
            if (!cuid2Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid2",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ulid") {
            if (!ulidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ulid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "url") {
            try {
              new URL(input.data);
            } catch (_a) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "url",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "regex") {
            check.regex.lastIndex = 0;
            const testResult = check.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "regex",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "trim") {
            input.data = input.data.trim();
          } else if (check.kind === "includes") {
            if (!input.data.includes(check.value, check.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { includes: check.value, position: check.position },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check.kind === "startsWith") {
            if (!input.data.startsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { startsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "endsWith") {
            if (!input.data.endsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { endsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "datetime") {
            const regex = datetimeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ip") {
            if (!isValidIP(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ip",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _regex(regex, validation, message) {
        return this.refinement((data) => regex.test(data), {
          validation,
          code: ZodIssueCode.invalid_string,
          ...errorUtil.errToObj(message)
        });
      }
      _addCheck(check) {
        return new ZodString({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
      }
      url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
      }
      emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
      }
      uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
      }
      cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
      }
      cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
      }
      ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
      }
      ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
      }
      datetime(options) {
        var _a;
        if (typeof options === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            message: options
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
          offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
          ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      regex(regex, message) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil.errToObj(message)
        });
      }
      includes(value, options) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options === null || options === void 0 ? void 0 : options.position,
          ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      startsWith(value, message) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      endsWith(value, message) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      min(minLength, message) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil.errToObj(message)
        });
      }
      max(maxLength, message) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil.errToObj(message)
        });
      }
      length(len, message) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil.errToObj(message)
        });
      }
      /**
       * @deprecated Use z.string().min(1) instead.
       * @see {@link ZodString.min}
       */
      nonempty(message) {
        return this.min(1, errorUtil.errToObj(message));
      }
      trim() {
        return new ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
      }
      toLowerCase() {
        return new ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
      }
      toUpperCase() {
        return new ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch2) => ch2.kind === "datetime");
      }
      get isEmail() {
        return !!this._def.checks.find((ch2) => ch2.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch2) => ch2.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch2) => ch2.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch2) => ch2.kind === "uuid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch2) => ch2.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch2) => ch2.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch2) => ch2.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch2) => ch2.kind === "ip");
      }
      get minLength() {
        let min2 = null;
        for (const ch2 of this._def.checks) {
          if (ch2.kind === "min") {
            if (min2 === null || ch2.value > min2)
              min2 = ch2.value;
          }
        }
        return min2;
      }
      get maxLength() {
        let max2 = null;
        for (const ch2 of this._def.checks) {
          if (ch2.kind === "max") {
            if (max2 === null || ch2.value < max2)
              max2 = ch2.value;
          }
        }
        return max2;
      }
    }
    ZodString.create = (params) => {
      var _a;
      return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params)
      });
    };
    function floatSafeRemainder(val, step) {
      const valDecCount = (val.toString().split(".")[1] || "").length;
      const stepDecCount = (step.toString().split(".")[1] || "").length;
      const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
      const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
      const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
      return valInt % stepInt / Math.pow(10, decCount);
    }
    class ZodNumber extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.number,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "int") {
            if (!util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (floatSafeRemainder(input.data, check.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_finite,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      int(message) {
        return this._addCheck({
          kind: "int",
          message: errorUtil.toString(message)
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      finite(message) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil.toString(message)
        });
      }
      safe(message) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil.toString(message)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min2 = null;
        for (const ch2 of this._def.checks) {
          if (ch2.kind === "min") {
            if (min2 === null || ch2.value > min2)
              min2 = ch2.value;
          }
        }
        return min2;
      }
      get maxValue() {
        let max2 = null;
        for (const ch2 of this._def.checks) {
          if (ch2.kind === "max") {
            if (max2 === null || ch2.value < max2)
              max2 = ch2.value;
          }
        }
        return max2;
      }
      get isInt() {
        return !!this._def.checks.find((ch2) => ch2.kind === "int" || ch2.kind === "multipleOf" && util.isInteger(ch2.value));
      }
      get isFinite() {
        let max2 = null, min2 = null;
        for (const ch2 of this._def.checks) {
          if (ch2.kind === "finite" || ch2.kind === "int" || ch2.kind === "multipleOf") {
            return true;
          } else if (ch2.kind === "min") {
            if (min2 === null || ch2.value > min2)
              min2 = ch2.value;
          } else if (ch2.kind === "max") {
            if (max2 === null || ch2.value < max2)
              max2 = ch2.value;
          }
        }
        return Number.isFinite(min2) && Number.isFinite(max2);
      }
    }
    ZodNumber.create = (params) => {
      return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    class ZodBigInt extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = BigInt(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.bigint,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                type: "bigint",
                minimum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                type: "bigint",
                maximum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (input.data % check.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min2 = null;
        for (const ch2 of this._def.checks) {
          if (ch2.kind === "min") {
            if (min2 === null || ch2.value > min2)
              min2 = ch2.value;
          }
        }
        return min2;
      }
      get maxValue() {
        let max2 = null;
        for (const ch2 of this._def.checks) {
          if (ch2.kind === "max") {
            if (max2 === null || ch2.value < max2)
              max2 = ch2.value;
          }
        }
        return max2;
      }
    }
    ZodBigInt.create = (params) => {
      var _a;
      return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params)
      });
    };
    class ZodBoolean extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    }
    ZodBoolean.create = (params) => {
      return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    class ZodDate extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.date,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        if (isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_date
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.getTime() < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                message: check.message,
                inclusive: true,
                exact: false,
                minimum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.getTime() > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                message: check.message,
                inclusive: true,
                exact: false,
                maximum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check) {
        return new ZodDate({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      min(minDate, message) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      max(maxDate, message) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      get minDate() {
        let min2 = null;
        for (const ch2 of this._def.checks) {
          if (ch2.kind === "min") {
            if (min2 === null || ch2.value > min2)
              min2 = ch2.value;
          }
        }
        return min2 != null ? new Date(min2) : null;
      }
      get maxDate() {
        let max2 = null;
        for (const ch2 of this._def.checks) {
          if (ch2.kind === "max") {
            if (max2 === null || ch2.value < max2)
              max2 = ch2.value;
          }
        }
        return max2 != null ? new Date(max2) : null;
      }
    }
    ZodDate.create = (params) => {
      return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params)
      });
    };
    class ZodSymbol extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    }
    ZodSymbol.create = (params) => {
      return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params)
      });
    };
    class ZodUndefined extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    }
    ZodUndefined.create = (params) => {
      return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params)
      });
    };
    class ZodNull extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.null,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    }
    ZodNull.create = (params) => {
      return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params)
      });
    };
    class ZodAny extends ZodType {
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    }
    ZodAny.create = (params) => {
      return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params)
      });
    };
    class ZodUnknown extends ZodType {
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    }
    ZodUnknown.create = (params) => {
      return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params)
      });
    };
    class ZodNever extends ZodType {
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.never,
          received: ctx.parsedType
        });
        return INVALID;
      }
    }
    ZodNever.create = (params) => {
      return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params)
      });
    };
    class ZodVoid extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.void,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    }
    ZodVoid.create = (params) => {
      return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params)
      });
    };
    class ZodArray extends ZodType {
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            addIssueToContext(ctx, {
              code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i) => {
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
          })).then((result2) => {
            return ParseStatus.mergeArray(status, result2);
          });
        }
        const result = [...ctx.data].map((item, i) => {
          return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message) {
        return new ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil.toString(message) }
        });
      }
      max(maxLength, message) {
        return new ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil.toString(message) }
        });
      }
      length(len, message) {
        return new ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil.toString(message) }
        });
      }
      nonempty(message) {
        return this.min(1, message);
      }
    }
    ZodArray.create = (schema, params) => {
      return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params)
      });
    };
    function deepPartialify(schema) {
      if (schema instanceof ZodObject) {
        const newShape = {};
        for (const key in schema.shape) {
          const fieldSchema = schema.shape[key];
          newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
          ...schema._def,
          shape: () => newShape
        });
      } else if (schema instanceof ZodArray) {
        return new ZodArray({
          ...schema._def,
          type: deepPartialify(schema.element)
        });
      } else if (schema instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema.unwrap()));
      } else if (schema instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema.unwrap()));
      } else if (schema instanceof ZodTuple) {
        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
      } else {
        return schema;
      }
    }
    class ZodObject extends ZodType {
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys2 = util.objectKeys(shape);
        return this._cached = { shape, keys: keys2 };
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
          for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
              extraKeys.push(key);
            }
          }
        }
        const pairs = [];
        for (const key of shapeKeys) {
          const keyValidator = shape[key];
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key },
                value: { status: "valid", value: ctx.data[key] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip")
            ;
          else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key of extraKeys) {
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: catchall._parse(
                new ParseInputLazyPath(ctx, value, ctx.path, key)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key = await pair.key;
              syncPairs.push({
                key,
                value: await pair.value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message) {
        errorUtil.errToObj;
        return new ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message !== void 0 ? {
            errorMap: (issue, ctx) => {
              var _a, _b, _c, _d;
              const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}
        });
      }
      strip() {
        return new ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      // const AugmentFactory =
      //   <Def extends ZodObjectDef>(def: Def) =>
      //   <Augmentation extends ZodRawShape>(
      //     augmentation: Augmentation
      //   ): ZodObject<
      //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
      //     Def["unknownKeys"],
      //     Def["catchall"]
      //   > => {
      //     return new ZodObject({
      //       ...def,
      //       shape: () => ({
      //         ...def.shape(),
      //         ...augmentation,
      //       }),
      //     }) as any;
      //   };
      extend(augmentation) {
        return new ZodObject({
          ...this._def,
          shape: () => ({
            ...this._def.shape(),
            ...augmentation
          })
        });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: () => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
      }
      // merge<
      //   Incoming extends AnyZodObject,
      //   Augmentation extends Incoming["shape"],
      //   NewOutput extends {
      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
      //       ? Augmentation[k]["_output"]
      //       : k extends keyof Output
      //       ? Output[k]
      //       : never;
      //   },
      //   NewInput extends {
      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
      //       ? Augmentation[k]["_input"]
      //       : k extends keyof Input
      //       ? Input[k]
      //       : never;
      //   }
      // >(
      //   merging: Incoming
      // ): ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"],
      //   NewOutput,
      //   NewInput
      // > {
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      setKey(key, schema) {
        return this.augment({ [key]: schema });
      }
      // merge<Incoming extends AnyZodObject>(
      //   merging: Incoming
      // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
      // ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"]
      // > {
      //   // const mergedShape = objectUtil.mergeShapes(
      //   //   this._def.shape(),
      //   //   merging._def.shape()
      //   // );
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      catchall(index2) {
        return new ZodObject({
          ...this._def,
          catchall: index2
        });
      }
      pick(mask) {
        const shape = {};
        util.objectKeys(mask).forEach((key) => {
          if (mask[key] && this.shape[key]) {
            shape[key] = this.shape[key];
          }
        });
        return new ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      omit(mask) {
        const shape = {};
        util.objectKeys(this.shape).forEach((key) => {
          if (!mask[key]) {
            shape[key] = this.shape[key];
          }
        });
        return new ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      /**
       * @deprecated
       */
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key) => {
          const fieldSchema = this.shape[key];
          if (mask && !mask[key]) {
            newShape[key] = fieldSchema;
          } else {
            newShape[key] = fieldSchema.optional();
          }
        });
        return new ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      required(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key) => {
          if (mask && !mask[key]) {
            newShape[key] = this.shape[key];
          } else {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
              newField = newField._def.innerType;
            }
            newShape[key] = newField;
          }
        });
        return new ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      keyof() {
        return createZodEnum(util.objectKeys(this.shape));
      }
    }
    ZodObject.create = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.strictCreate = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.lazycreate = (shape, params) => {
      return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    class ZodUnion extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return Promise.all(options.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError(issues2));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    }
    ZodUnion.create = (types2, params) => {
      return new ZodUnion({
        options: types2,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params)
      });
    };
    const getDiscriminator = (type) => {
      if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
      } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
      } else if (type instanceof ZodLiteral) {
        return [type.value];
      } else if (type instanceof ZodEnum) {
        return type.options;
      } else if (type instanceof ZodNativeEnum) {
        return Object.keys(type.enum);
      } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
      } else if (type instanceof ZodUndefined) {
        return [void 0];
      } else if (type instanceof ZodNull) {
        return [null];
      } else {
        return null;
      }
    };
    class ZodDiscriminatedUnion extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      /**
       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
       * have a different value for each object in the union.
       * @param discriminator the name of the discriminator property
       * @param types an array of object schemas
       * @param params
       */
      static create(discriminator, options, params) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options) {
          const discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
          discriminator,
          options,
          optionsMap,
          ...processCreateParams(params)
        });
      }
    }
    function mergeValues(a, b2) {
      const aType = getParsedType(a);
      const bType = getParsedType(b2);
      if (a === b2) {
        return { valid: true, data: a };
      } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
        const bKeys = util.objectKeys(b2);
        const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b2 };
        for (const key of sharedKeys) {
          const sharedValue = mergeValues(a[key], b2[key]);
          if (!sharedValue.valid) {
            return { valid: false };
          }
          newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
      } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
        if (a.length !== b2.length) {
          return { valid: false };
        }
        const newArray = [];
        for (let index2 = 0; index2 < a.length; index2++) {
          const itemA = a[index2];
          const itemB = b2[index2];
          const sharedValue = mergeValues(itemA, itemB);
          if (!sharedValue.valid) {
            return { valid: false };
          }
          newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
      } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b2) {
        return { valid: true, data: a };
      } else {
        return { valid: false };
      }
    }
    class ZodIntersection extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
          if (isAborted(parsedLeft) || isAborted(parsedRight)) {
            return INVALID;
          }
          const merged = mergeValues(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_intersection_types
            });
            return INVALID;
          }
          if (isDirty(parsedLeft) || isDirty(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    }
    ZodIntersection.create = (left, right, params) => {
      return new ZodIntersection({
        left,
        right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params)
      });
    };
    class ZodTuple extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema = this._def.items[itemIndex] || this._def.rest;
          if (!schema)
            return null;
          return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x2) => !!x2);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return ParseStatus.mergeArray(status, results);
          });
        } else {
          return ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new ZodTuple({
          ...this._def,
          rest
        });
      }
    }
    ZodTuple.create = (schemas, params) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
      });
    };
    class ZodRecord extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
          });
        }
        if (ctx.common.async) {
          return ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType) {
          return new ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
          });
        }
        return new ZodRecord({
          keyType: ZodString.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(second)
        });
      }
    }
    class ZodMap extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.map,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key = pair.key;
            const value = pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    }
    ZodMap.create = (keyType, valueType, params) => {
      return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params)
      });
    };
    class ZodSet extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.set,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return INVALID;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message) {
        return new ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil.toString(message) }
        });
      }
      max(maxSize, message) {
        return new ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil.toString(message) }
        });
      }
      size(size, message) {
        return this.min(size, message).max(size, message);
      }
      nonempty(message) {
        return this.min(1, message);
      }
    }
    ZodSet.create = (valueType, params) => {
      return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params)
      });
    };
    class ZodFunction extends ZodType {
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.function,
            received: ctx.parsedType
          });
          return INVALID;
        }
        function makeArgsIssue(args, error) {
          return makeIssue({
            data: args,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              getErrorMap(),
              errorMap
            ].filter((x2) => !!x2),
            issueData: {
              code: ZodIssueCode.invalid_arguments,
              argumentsError: error
            }
          });
        }
        function makeReturnsIssue(returns, error) {
          return makeIssue({
            data: returns,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              getErrorMap(),
              errorMap
            ].filter((x2) => !!x2),
            issueData: {
              code: ZodIssueCode.invalid_return_type,
              returnTypeError: error
            }
          });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
          const me2 = this;
          return OK(async function(...args) {
            const error = new ZodError([]);
            const parsedArgs = await me2._def.args.parseAsync(args, params).catch((e2) => {
              error.addIssue(makeArgsIssue(args, e2));
              throw error;
            });
            const result = await Reflect.apply(fn, this, parsedArgs);
            const parsedReturns = await me2._def.returns._def.type.parseAsync(result, params).catch((e2) => {
              error.addIssue(makeReturnsIssue(result, e2));
              throw error;
            });
            return parsedReturns;
          });
        } else {
          const me2 = this;
          return OK(function(...args) {
            const parsedArgs = me2._def.args.safeParse(args, params);
            if (!parsedArgs.success) {
              throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = Reflect.apply(fn, this, parsedArgs.data);
            const parsedReturns = me2._def.returns.safeParse(result, params);
            if (!parsedReturns.success) {
              throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new ZodFunction({
          ...this._def,
          args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
      }
      returns(returnType) {
        return new ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params) {
        return new ZodFunction({
          args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
          returns: returns || ZodUnknown.create(),
          typeName: ZodFirstPartyTypeKind.ZodFunction,
          ...processCreateParams(params)
        });
      }
    }
    class ZodLazy extends ZodType {
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    }
    ZodLazy.create = (getter, params) => {
      return new ZodLazy({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params)
      });
    };
    class ZodLiteral extends ZodType {
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    }
    ZodLiteral.create = (value, params) => {
      return new ZodLiteral({
        value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params)
      });
    };
    function createZodEnum(values, params) {
      return new ZodEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params)
      });
    }
    class ZodEnum extends ZodType {
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (this._def.values.indexOf(input.data) === -1) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values) {
        return ZodEnum.create(values);
      }
      exclude(values) {
        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
      }
    }
    ZodEnum.create = createZodEnum;
    class ZodNativeEnum extends ZodType {
      _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (nativeEnumValues.indexOf(input.data) === -1) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get enum() {
        return this._def.values;
      }
    }
    ZodNativeEnum.create = (values, params) => {
      return new ZodNativeEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params)
      });
    };
    class ZodPromise extends ZodType {
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.promise,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    }
    ZodPromise.create = (schema, params) => {
      return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params)
      });
    };
    class ZodEffects extends ZodType {
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
          addIssue: (arg) => {
            addIssueToContext(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          },
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
          const processed = effect.transform(ctx.data, checkCtx);
          if (ctx.common.issues.length) {
            return {
              status: "dirty",
              value: ctx.data
            };
          }
          if (ctx.common.async) {
            return Promise.resolve(processed).then((processed2) => {
              return this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
            });
          } else {
            return this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
          }
        }
        if (effect.type === "refinement") {
          const executeRefinement = (acc) => {
            const result = effect.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          };
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect.type === "transform") {
          if (ctx.common.async === false) {
            const base = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!isValid$3(base))
              return base;
            const result = effect.transform(base.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
              if (!isValid$3(base))
                return base;
              return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
            });
          }
        }
        util.assertNever(effect);
      }
    }
    ZodEffects.create = (schema, effect, params) => {
      return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
      return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params)
      });
    };
    class ZodOptional extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
          return OK(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    }
    ZodOptional.create = (type, params) => {
      return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params)
      });
    };
    class ZodNullable extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
          return OK(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    }
    ZodNullable.create = (type, params) => {
      return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params)
      });
    };
    class ZodDefault extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    }
    ZodDefault.create = (type, params) => {
      return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params)
      });
    };
    class ZodCatch extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if (isAsync(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    }
    ZodCatch.create = (type, params) => {
      return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params)
      });
    };
    class ZodNaN extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.nan,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
    }
    ZodNaN.create = (params) => {
      return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params)
      });
    };
    const BRAND = Symbol("zod_brand");
    class ZodBranded extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    }
    class ZodPipeline extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return DIRTY(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          };
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a, b2) {
        return new ZodPipeline({
          in: a,
          out: b2,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    }
    class ZodReadonly extends ZodType {
      _parse(input) {
        const result = this._def.innerType._parse(input);
        if (isValid$3(result)) {
          result.value = Object.freeze(result.value);
        }
        return result;
      }
    }
    ZodReadonly.create = (type, params) => {
      return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params)
      });
    };
    const custom = (check, params = {}, fatal) => {
      if (check)
        return ZodAny.create().superRefine((data, ctx) => {
          var _a, _b;
          if (!check(data)) {
            const p2 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
            const _fatal = (_b = (_a = p2.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
            const p22 = typeof p2 === "string" ? { message: p2 } : p2;
            ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
          }
        });
      return ZodAny.create();
    };
    const late = {
      object: ZodObject.lazycreate
    };
    var ZodFirstPartyTypeKind;
    (function(ZodFirstPartyTypeKind2) {
      ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
      ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
    const instanceOfType = (cls, params = {
      message: `Input not instance of ${cls.name}`
    }) => custom((data) => data instanceof cls, params);
    const stringType = ZodString.create;
    const numberType = ZodNumber.create;
    const nanType = ZodNaN.create;
    const bigIntType = ZodBigInt.create;
    const booleanType = ZodBoolean.create;
    const dateType = ZodDate.create;
    const symbolType = ZodSymbol.create;
    const undefinedType = ZodUndefined.create;
    const nullType = ZodNull.create;
    const anyType = ZodAny.create;
    const unknownType = ZodUnknown.create;
    const neverType = ZodNever.create;
    const voidType = ZodVoid.create;
    const arrayType = ZodArray.create;
    const objectType = ZodObject.create;
    const strictObjectType = ZodObject.strictCreate;
    const unionType = ZodUnion.create;
    const discriminatedUnionType = ZodDiscriminatedUnion.create;
    const intersectionType = ZodIntersection.create;
    const tupleType = ZodTuple.create;
    const recordType = ZodRecord.create;
    const mapType = ZodMap.create;
    const setType = ZodSet.create;
    const functionType = ZodFunction.create;
    const lazyType = ZodLazy.create;
    const literalType = ZodLiteral.create;
    const enumType = ZodEnum.create;
    const nativeEnumType = ZodNativeEnum.create;
    const promiseType = ZodPromise.create;
    const effectsType = ZodEffects.create;
    const optionalType = ZodOptional.create;
    const nullableType = ZodNullable.create;
    const preprocessType = ZodEffects.createWithPreprocess;
    const pipelineType = ZodPipeline.create;
    const ostring = () => stringType().optional();
    const onumber = () => numberType().optional();
    const oboolean = () => booleanType().optional();
    const coerce = {
      string: (arg) => ZodString.create({ ...arg, coerce: true }),
      number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
      boolean: (arg) => ZodBoolean.create({
        ...arg,
        coerce: true
      }),
      bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
      date: (arg) => ZodDate.create({ ...arg, coerce: true })
    };
    const NEVER = INVALID;
    var z = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      defaultErrorMap: errorMap,
      setErrorMap,
      getErrorMap,
      makeIssue,
      EMPTY_PATH,
      addIssueToContext,
      ParseStatus,
      INVALID,
      DIRTY,
      OK,
      isAborted,
      isDirty,
      isValid: isValid$3,
      isAsync,
      get util() {
        return util;
      },
      get objectUtil() {
        return objectUtil;
      },
      ZodParsedType,
      getParsedType,
      ZodType,
      ZodString,
      ZodNumber,
      ZodBigInt,
      ZodBoolean,
      ZodDate,
      ZodSymbol,
      ZodUndefined,
      ZodNull,
      ZodAny,
      ZodUnknown,
      ZodNever,
      ZodVoid,
      ZodArray,
      ZodObject,
      ZodUnion,
      ZodDiscriminatedUnion,
      ZodIntersection,
      ZodTuple,
      ZodRecord,
      ZodMap,
      ZodSet,
      ZodFunction,
      ZodLazy,
      ZodLiteral,
      ZodEnum,
      ZodNativeEnum,
      ZodPromise,
      ZodEffects,
      ZodTransformer: ZodEffects,
      ZodOptional,
      ZodNullable,
      ZodDefault,
      ZodCatch,
      ZodNaN,
      BRAND,
      ZodBranded,
      ZodPipeline,
      ZodReadonly,
      custom,
      Schema: ZodType,
      ZodSchema: ZodType,
      late,
      get ZodFirstPartyTypeKind() {
        return ZodFirstPartyTypeKind;
      },
      coerce,
      any: anyType,
      array: arrayType,
      bigint: bigIntType,
      boolean: booleanType,
      date: dateType,
      discriminatedUnion: discriminatedUnionType,
      effect: effectsType,
      "enum": enumType,
      "function": functionType,
      "instanceof": instanceOfType,
      intersection: intersectionType,
      lazy: lazyType,
      literal: literalType,
      map: mapType,
      nan: nanType,
      nativeEnum: nativeEnumType,
      never: neverType,
      "null": nullType,
      nullable: nullableType,
      number: numberType,
      object: objectType,
      oboolean,
      onumber,
      optional: optionalType,
      ostring,
      pipeline: pipelineType,
      preprocess: preprocessType,
      promise: promiseType,
      record: recordType,
      set: setType,
      strictObject: strictObjectType,
      string: stringType,
      symbol: symbolType,
      transformer: effectsType,
      tuple: tupleType,
      "undefined": undefinedType,
      union: unionType,
      unknown: unknownType,
      "void": voidType,
      NEVER,
      ZodIssueCode,
      quotelessJson,
      ZodError
    });
    const APIBaseURL = "http://localhost:5173";
    const getFetch = (url, token2) => {
      return fetch(`${APIBaseURL}/api${url}`, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token2}`,
          "ngrok-skip-browser-warning": "true"
        }
      });
    };
    const mutableFetch = (url, method, token2, body) => {
      return fetch(`${APIBaseURL}/api${url}`, {
        method,
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token2}`,
          "ngrok-skip-browser-warning": "true"
        },
        body: JSON.stringify(body)
      });
    };
    function basicZodSchema(zodSchema) {
      return objectType({
        message: stringType(),
        data: zodSchema
      });
    }
    function useToken() {
      return localStorage.getItem("token");
    }
    function useGetCollectionList() {
      const token2 = useToken();
      const [datasa, setData] = reactExports.useState();
      const [isLoading, setIsLoading] = reactExports.useState(true);
      const [isError, setIsError] = reactExports.useState(false);
      reactExports.useEffect(() => {
        (async () => {
          try {
            const res = await getFetch("/collection", token2);
            const newData = await res.json();
            const validSchema = basicZodSchema(
              objectType({
                collection_name: stringType(),
                tenement_address: stringType(),
                collection_type: stringType(),
                price: stringType(),
                collection_id: numberType()
              }).array()
            );
            const validData = validSchema.parse(newData);
            setData(validData.data);
          } catch (error) {
            console.error(error);
            setIsError(true);
          } finally {
            setIsLoading(false);
          }
        })();
      }, []);
      return {
        isLoading,
        isError,
        datasa
      };
    }
    function usePostCollectionAdd() {
      const token2 = useToken();
      const [isLoading, setIsLoading] = reactExports.useState(false);
      const [isError, setIsError] = reactExports.useState(false);
      const handleSaveColumn = async (formDatas) => {
        setIsLoading(true);
        try {
          const { tenement_address, collection_id, ...sendData } = formDatas;
          const res = await mutableFetch("/collection", "POST", token2, {
            ...sendData,
            tenement_no: tenement_address.toString()
          });
          if (!res.ok) {
            alert("操作失敗");
            throw new Error(res.statusText);
          }
          const data = await res.json();
          const validSchema = basicZodSchema(
            objectType({
              collection_id: numberType()
            })
          );
          const validData = validSchema.parse(data);
          return validData;
        } catch (error) {
          console.error(error);
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      const handleSaveNotice = async (notices) => {
        setIsLoading(true);
        try {
          const res = await mutableFetch(
            "/collection/notices",
            "POST",
            token2,
            notices
          );
          if (!res.ok) {
            alert("操作失敗");
            throw new Error(res.statusText);
          }
        } catch (error) {
          console.error(error);
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      return {
        isLoading,
        isError,
        handleSaveColumn,
        handleSaveNotice
      };
    }
    const useGetCollectionEdit = () => {
      const token2 = useToken();
      const [isLoading, setIsLoading] = reactExports.useState(true);
      const [isError, setIsError] = reactExports.useState(false);
      const [dataEdit, setData] = reactExports.useState();
      const getCollectionEdit = async (id2) => {
        try {
          const res = await getFetch(`/collection/${id2}`, token2);
          const data = await res.json();
          const validSchema = basicZodSchema(
            objectType({
              tenement_address: stringType(),
              collection_name: stringType(),
              collection_type: stringType(),
              price: stringType(),
              payment: stringType(),
              collection_remark: stringType(),
              collection_date: stringType(),
              remittance_bank: stringType(),
              remittance_account: stringType(),
              cus_remittance_bank: stringType(),
              cus_remittance_account: stringType(),
              collection_complete: stringType(),
              notices: objectType({
                id: numberType(),
                visitDate: stringType(),
                record: stringType(),
                remindDate: stringType(),
                remind: stringType()
              }).array()
            })
          );
          const validData = validSchema.parse(data);
          setData({
            ...validData.data,
            collection_id: id2
          });
        } catch (error) {
          console.error(error);
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      return {
        isLoading,
        isError,
        getCollectionEdit,
        dataEdit
      };
    };
    function usePostCollectionEdit() {
      const token2 = useToken();
      const [isLoading, setIsLoading] = reactExports.useState(false);
      const [isError, setIsError] = reactExports.useState(false);
      const handleSaveColumn = async (formDatas) => {
        setIsLoading(true);
        try {
          const res = await mutableFetch(
            `/collection/${formDatas.collection_id}`,
            "PUT",
            token2,
            {
              tenement_no: formDatas.tenement_address.toString(),
              collection_name: formDatas.collection_name,
              collection_type: formDatas.collection_type,
              price: formDatas.price,
              payment: formDatas.payment,
              collection_remark: formDatas.collection_remark,
              collection_date: formDatas.collection_date,
              remittance_bank: formDatas.remittance_bank,
              remittance_account: formDatas.remittance_account,
              cus_remittance_bank: formDatas.cus_remittance_bank,
              cus_remittance_account: formDatas.cus_remittance_account,
              collection_complete: formDatas.collection_complete
            }
          );
          if (!res.ok) {
            alert("操作失敗");
            throw new Error(res.statusText);
          }
        } catch (error) {
          console.error(error);
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      const handleSaveNotice = async (notices) => {
        setIsLoading(true);
        try {
          const res = await mutableFetch(
            "/collection/notices",
            "POST",
            token2,
            notices
          );
          if (!res.ok) {
            alert("操作失敗");
            throw new Error(res.statusText);
          }
        } catch (error) {
          console.error(error);
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      const handleDeleteNoticeFetch = async (id2) => {
        setIsLoading(true);
        try {
          const res = await mutableFetch(
            `/notices/${id2}/collection`,
            "DELETE",
            token2,
            {}
          );
          if (!res.ok) {
            alert("操作失敗");
            throw new Error(res.statusText);
          }
        } catch (error) {
          console.error(error);
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      const handleDeleteCollectionFetch = async (id2) => {
        setIsLoading(true);
        try {
          const res = await mutableFetch(`/collection/${id2}`, "DELETE", token2, {});
          if (!res.ok) {
            alert("操作失敗");
            throw new Error(res.statusText);
          }
        } catch (error) {
          console.error(error);
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      return {
        isLoading,
        isError,
        handleSaveColumn,
        handleSaveNotice,
        handleDeleteNoticeFetch,
        handleDeleteCollectionFetch
      };
    }
    function useGetUserList() {
      const token2 = useToken();
      const [dataUser, setDataUser] = reactExports.useState();
      const [isLoading, setIsLoading] = reactExports.useState(true);
      const [isError, setIsError] = reactExports.useState(false);
      const getUserList = async () => {
        try {
          const res = await getFetch("/user/list", token2);
          const newData = await res.json();
          const validSchema = basicZodSchema(
            objectType({
              user_id: numberType(),
              user_name: stringType(),
              user_email: stringType(),
              status: booleanType()
            }).array()
          );
          const validData = validSchema.parse(newData);
          const organizedData = validData.data.map((item) => ({
            ...item,
            status: item.status ? "是" : "否",
            user_id: item.user_id.toString()
          }));
          setDataUser(organizedData);
        } catch (error) {
          console.error(error);
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      reactExports.useEffect(() => {
        getUserList();
      }, []);
      return {
        isLoading,
        isError,
        dataUser
      };
    }
    function usePostUserAdd() {
      const token2 = useToken();
      const [isLoading, setIsLoading] = reactExports.useState(false);
      const [isError, setIsError] = reactExports.useState(false);
      const handleSaveUser = async (formDatas) => {
        setIsLoading(true);
        try {
          const res = await mutableFetch("/user", "POST", token2, {
            ...formDatas,
            status: formDatas.status === "是",
            isadmin: formDatas.isadmin === "是",
            isDelete: false
          });
          if (!res.ok) {
            alert("操作失敗");
            throw new Error(res.statusText);
          }
        } catch (error) {
          console.error(error);
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      return {
        isLoading,
        isError,
        handleSaveUser
      };
    }
    function usePostUserEdit() {
      const token2 = useToken();
      const [isLoading, setIsLoading] = reactExports.useState(false);
      const [isError, setIsError] = reactExports.useState(false);
      const handleSaveUser = async (formDatas) => {
        setIsLoading(true);
        try {
          const newFormData = {
            user_name: formDatas.user_name,
            user_email: formDatas.user_email,
            status: formDatas.status === "是",
            isadmin: formDatas.isadmin === "是",
            user_password: formDatas.user_password
          };
          const res = await mutableFetch(
            `/user/${formDatas.user_id}`,
            "PUT",
            token2,
            newFormData
          );
          if (!res.ok) {
            alert("操作失敗");
            throw new Error(res.statusText);
          }
        } catch (error) {
          console.error(error);
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      const handleDeleteUserFetch = async (user_id) => {
        setIsLoading(true);
        try {
          const res = await mutableFetch(`/user/${user_id}`, "DELETE", token2, {});
          if (!res.ok) {
            alert("操作失敗");
            throw new Error(res.statusText);
          }
        } catch (error) {
          console.error(error);
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      return {
        isLoading,
        isError,
        handleSaveUser,
        handleDeleteUserFetch
      };
    }
    function useGetUserEdit() {
      const token2 = useToken();
      const [isLoading, setIsLoading] = reactExports.useState(true);
      const [isError, setIsError] = reactExports.useState(false);
      const [dataEdit, setData] = reactExports.useState();
      const getUserEdit = async (user_id) => {
        try {
          const res = await getFetch(`/user/${user_id}`, token2);
          const data = await res.json();
          const validSchema = basicZodSchema(
            objectType({
              user_name: stringType(),
              user_email: stringType(),
              status: booleanType(),
              user_id: numberType(),
              isadmin: booleanType()
            })
          );
          const validData = validSchema.parse(data);
          setData({
            ...validData.data,
            status: validData.data.status ? "是" : "否",
            isadmin: validData.data.isadmin ? "是" : "否",
            user_id: user_id.toString(),
            user_password: ""
          });
        } catch (error) {
          console.error(error);
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      return {
        isLoading,
        isError,
        getUserEdit,
        dataEdit
      };
    }
    function usePostCalender() {
      const token2 = useToken();
      const [isLoading, setIsLoading] = reactExports.useState(false);
      const [isError, setIsError] = reactExports.useState(false);
      const [dataCalender, setDataCalender] = reactExports.useState([]);
      const handleGetCalender = async (formDatas) => {
        setIsLoading(true);
        try {
          const res = await getFetch(
            `/calendar/${formDatas.year}/${formDatas.month}`,
            token2
          );
          const data = await res.json();
          const validSchema = basicZodSchema(
            objectType({
              day: numberType(),
              events: objectType({
                content: stringType(),
                id: stringType(),
                class: stringType()
              }).array()
            }).array()
          );
          const validData = validSchema.parse(data);
          setDataCalender(validData.data);
        } catch (error) {
          console.error(error);
          alert("取得資料失敗");
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      return {
        isLoading,
        isError,
        handleGetCalender,
        dataCalender
      };
    }
    function usePostCalenderCollection() {
      const token2 = useToken();
      const [isLoading, setIsLoading] = reactExports.useState(false);
      const [isError, setIsError] = reactExports.useState(false);
      const [dataCalender, setDataCalender] = reactExports.useState([]);
      const handleGetCalender = async (formDatas) => {
        setIsLoading(true);
        try {
          const res = await getFetch(
            `/calendar/collection/${formDatas.year}/${formDatas.month}`,
            token2
          );
          const data = await res.json();
          const validSchema = basicZodSchema(
            objectType({
              day: numberType(),
              events: objectType({
                content: stringType(),
                id: stringType(),
                class: stringType()
              }).array()
            }).array()
          );
          const validData = validSchema.parse(data);
          setDataCalender(validData.data);
        } catch (error) {
          console.error(error);
          alert("取得資料失敗");
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      return {
        isLoading,
        isError,
        handleGetCalender,
        dataCalender
      };
    }
    function useDeleteNotice() {
      const token2 = useToken();
      const [isLoading, setIsLoading] = reactExports.useState(false);
      const [isError, setIsError] = reactExports.useState(false);
      const handleDeleteNoticeApi = async (id2, type) => {
        setIsLoading(true);
        try {
          const deleteType = type === "collection" ? "collection" : "tenement";
          const res = await mutableFetch(
            `/notices/${id2}/${deleteType}`,
            "DELETE",
            token2,
            {}
          );
          if (!res.ok) {
            alert("操作失敗");
            throw new Error(res.statusText);
          }
        } catch (error) {
          console.error(error);
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      return {
        isLoading,
        isError,
        handleDeleteNoticeApi
      };
    }
    function useGetTenementList() {
      const token2 = useToken();
      const [isLoading, setIsLoading] = reactExports.useState(true);
      const [isError, setIsError] = reactExports.useState(false);
      const [dataTenement, setDataTenement] = reactExports.useState([]);
      const handleGetTenement = async (query) => {
        setIsLoading(true);
        const querys = Object.fromEntries(
          Object.entries(query).filter(([_, v2]) => v2 !== void 0 && v2 !== "")
        );
        const queryString = Object.keys(querys).map((key) => `${key}=${querys[key]}`).join("&");
        try {
          const res = await getFetch(`/tenement?${queryString}`, token2);
          const data = await res.json();
          const validSchema = basicZodSchema(
            objectType({
              tenement_id: numberType(),
              tenement_address: stringType(),
              tenement_face: stringType(),
              tenement_status: stringType(),
              tenement_type: stringType(),
              tenement_product_type: stringType(),
              management_fee_bottom: numberType(),
              management_floor_bottom: numberType()
            }).array()
          );
          const validData = validSchema.parse(data);
          setDataTenement(validData.data);
        } catch (error) {
          console.error(error);
          alert("取得資料失敗");
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      return {
        isLoading,
        isError,
        dataTenement,
        handleGetTenement
      };
    }
    function useGetTenementListSell() {
      const token2 = useToken();
      const [isLoading, setIsLoading] = reactExports.useState(true);
      const [isError, setIsError] = reactExports.useState(false);
      const [dataTenement, setDataTenement] = reactExports.useState([]);
      const handleGetTenement = async (query) => {
        setIsLoading(true);
        const filterData = Object.fromEntries(
          Object.entries(query).filter(([_, v2]) => v2 !== void 0 && v2 !== "")
        );
        const queryString = Object.keys(filterData).map((key) => `${key}=${filterData[key]}`).join("&");
        try {
          const res = await getFetch(`/tenement/sell?${queryString}`, token2);
          const data = await res.json();
          const validSchema = basicZodSchema(
            objectType({
              tenement_id: numberType(),
              tenement_address: stringType(),
              tenement_face: stringType(),
              tenement_status: stringType(),
              tenement_type: stringType(),
              tenement_product_type: stringType(),
              management_fee_bottom: numberType(),
              selling_price: numberType(),
              Total_rating: numberType(),
              inside_rating: numberType(),
              public_building: numberType(),
              tenement_floor: numberType()
            }).array()
          );
          const validData = validSchema.parse(data);
          setDataTenement(validData.data);
        } catch (error) {
          console.error(error);
          alert("取得資料失敗");
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      return {
        isLoading,
        isError,
        dataTenement,
        handleGetTenement
      };
    }
    function useGetTenementListRent() {
      const token2 = useToken();
      const [isLoading, setIsLoading] = reactExports.useState(true);
      const [isError, setIsError] = reactExports.useState(false);
      const [dataTenement, setDataTenement] = reactExports.useState([]);
      const handleGetTenement = async (query) => {
        setIsLoading(true);
        const querys = Object.fromEntries(
          Object.entries(query).filter(([_, v2]) => v2 !== void 0 && v2 !== "")
        );
        const queryString = Object.keys(querys).map((key) => `${key}=${querys[key]}`).join("&");
        try {
          const res = await getFetch(`/tenement/rent?${queryString}`, token2);
          const data = await res.json();
          const validSchema = basicZodSchema(
            objectType({
              tenement_id: numberType(),
              tenement_address: stringType(),
              tenement_face: stringType(),
              tenement_status: stringType(),
              tenement_type: stringType(),
              tenement_product_type: stringType(),
              management_fee_bottom: numberType(),
              management_floor_bottom: numberType(),
              rent: numberType(),
              Total_rating: numberType(),
              inside_rating: numberType(),
              public_building: numberType(),
              tenement_floor: numberType()
            }).array()
          );
          const validData = validSchema.parse(data);
          setDataTenement(validData.data);
        } catch (error) {
          console.error(error);
          alert("取得資料失敗");
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      return {
        isLoading,
        isError,
        dataTenement,
        handleGetTenement
      };
    }
    function useLogin() {
      const [isLoading, setIsLoading] = reactExports.useState(false);
      const [isLogin, setIsLogin] = reactExports.useState(false);
      const handleLogin = async (formDatas) => {
        setIsLoading(true);
        const res = await mutableFetch("/user/login", "POST", "", formDatas);
        const data = await res.json();
        const validSchema = basicZodSchema(
          objectType({
            token: stringType()
          })
        );
        const validData = validSchema.parse(data);
        localStorage.setItem("token", validData.data.token);
        setIsLogin(true);
      };
      return {
        isLoading,
        handleLogin,
        isLogin
      };
    }
    function useGetSellEdit() {
      const token2 = useToken();
      const [isLoading, setIsLoading] = reactExports.useState(true);
      const [isError, setIsError] = reactExports.useState(false);
      const [dataEdit, setData] = reactExports.useState();
      const getSellEdit = async (id2) => {
        try {
          const res = await getFetch(`/tenement/edit/sell/${id2}`, token2);
          const data = await res.json();
          const validSchema = basicZodSchema(
            objectType({
              tenement_id: numberType(),
              tenement_address: stringType(),
              tenement_product_type: stringType(),
              tenement_type: stringType(),
              tenement_status: stringType(),
              tenement_face: stringType(),
              tenement_images: stringType().array(),
              total_rating: numberType(),
              main_building: numberType(),
              affiliated_building: numberType(),
              public_building: numberType(),
              unregistered_area: numberType(),
              management_magnification: numberType(),
              management_fee: numberType(),
              selling_price: numberType(),
              tenement_floor: numberType(),
              tenement_host_name: stringType(),
              tenement_host_telphone: stringType(),
              tenement_host_phone: stringType(),
              tenement_host_line: stringType(),
              tenement_host_remittance_bank: stringType(),
              tenement_host_remittance_account: stringType(),
              tenement_host_address: stringType(),
              tenement_host_birthday: stringType(),
              tenement_host_hobby: stringType(),
              tenement_host_remark: stringType(),
              buyer_order_date: stringType(),
              buyer_handout_date: stringType(),
              buyer_name: stringType(),
              buyer_id_images: stringType().array(),
              buyer_phone: stringType(),
              buyer_jobtitle: stringType(),
              buyer_remark: stringType()
            })
          );
          const validData = validSchema.parse(data);
          const newData = {
            ...validData.data,
            total_rating: validData.data.total_rating.toString(),
            main_building: validData.data.main_building.toString(),
            affiliated_building: validData.data.affiliated_building.toString(),
            public_building: validData.data.public_building.toString(),
            unregistered_area: validData.data.unregistered_area.toString(),
            management_magnification: validData.data.management_magnification.toString(),
            management_fee: validData.data.management_fee.toString(),
            selling_price: validData.data.selling_price.toString(),
            tenement_floor: validData.data.tenement_floor.toString()
          };
          setData(newData);
          return newData;
        } catch (error) {
          console.error(error);
          alert("取得資料失敗");
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      return {
        isLoading,
        isError,
        getSellEdit,
        dataEdit
      };
    }
    function usePostSellEdit() {
      const token2 = useToken();
      const [isLoading, setIsLoading] = reactExports.useState(false);
      const [isError, setIsError] = reactExports.useState(false);
      const handleSaveColumn = async (formDatas) => {
        setIsLoading(true);
        try {
          const res = await mutableFetch(
            `/tenement/edit/sell/${formDatas.tenement_id}`,
            "POST",
            token2,
            formDatas
          );
          if (!res.ok) {
            alert("操作失敗");
            throw new Error(res.statusText);
          }
        } catch (error) {
          console.error(error);
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      return {
        isLoading,
        isError,
        handleSaveColumn
      };
    }
    function useGetDevelopEdit() {
      const token2 = useToken();
      const [isLoading, setIsLoading] = reactExports.useState(true);
      const [isError, setIsError] = reactExports.useState(false);
      const [dataEdit, setData] = reactExports.useState();
      const getDevelopEdit = async (id2) => {
        try {
          const res = await getFetch(`/tenement/edit/develop/${id2}`, token2);
          const data = await res.json();
          const validSchema = basicZodSchema(
            objectType({
              tenement_id: numberType(),
              tenement_address: stringType(),
              tenement_product_type: stringType(),
              tenement_type: stringType(),
              tenement_face: stringType(),
              tenement_images: stringType().array(),
              total_rating: numberType(),
              main_building: numberType(),
              affiliated_building: numberType(),
              public_building: numberType(),
              unregistered_area: numberType(),
              management_magnification: numberType(),
              management_fee: numberType(),
              selling_price: numberType(),
              rent_price: numberType(),
              deposit_price: numberType(),
              tenement_floor: numberType(),
              tenement_host_name: stringType(),
              tenement_host_telphone: stringType(),
              tenement_host_phone: stringType(),
              tenement_host_line: stringType(),
              tenement_host_remittance_bank: stringType(),
              tenement_host_remittance_account: stringType(),
              tenement_host_address: stringType(),
              tenement_host_birthday: stringType(),
              tenement_host_hobby: stringType(),
              tenement_host_remark: stringType()
            })
          );
          const validData = validSchema.parse(data);
          const newData = {
            ...validData.data,
            total_rating: validData.data.total_rating.toString(),
            main_building: validData.data.main_building.toString(),
            affiliated_building: validData.data.affiliated_building.toString(),
            public_building: validData.data.public_building.toString(),
            unregistered_area: validData.data.unregistered_area.toString(),
            management_magnification: validData.data.management_magnification.toString(),
            management_fee: validData.data.management_fee.toString(),
            selling_price: validData.data.selling_price.toString(),
            rent_price: validData.data.rent_price.toString(),
            tenement_floor: validData.data.tenement_floor.toString(),
            deposit_price: validData.data.deposit_price.toString()
          };
          setData(newData);
          return newData;
        } catch (error) {
          console.error(error);
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      return {
        isLoading,
        isError,
        getDevelopEdit,
        dataEdit
      };
    }
    function usePostDevelopEdit() {
      const token2 = useToken();
      const [isLoading, setIsLoading] = reactExports.useState(false);
      const [isError, setIsError] = reactExports.useState(false);
      const handleSaveColumn = async (formDatas) => {
        setIsLoading(true);
        try {
          const res = await mutableFetch(
            `/tenement/edit/develop/${formDatas.tenement_id}`,
            "POST",
            token2,
            formDatas
          );
          if (!res.ok) {
            alert("操作失敗");
            throw new Error(res.statusText);
          }
        } catch (error) {
          console.error(error);
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      return {
        isLoading,
        isError,
        handleSaveColumn
      };
    }
    function useGetRentEdit() {
      const token2 = useToken();
      const [isLoading, setIsLoading] = reactExports.useState(true);
      const [isError, setIsError] = reactExports.useState(false);
      const [dataEdit, setData] = reactExports.useState();
      const getRentEdit = async (id2) => {
        try {
          const res = await getFetch(`/tenement/edit/rent/${id2}`, token2);
          const data = await res.json();
          const validSchema = basicZodSchema(
            objectType({
              tenement_id: numberType(),
              tenement_address: stringType(),
              tenement_product_type: stringType(),
              tenement_type: stringType(),
              tenement_face: stringType(),
              tenement_images: stringType().array(),
              tenement_status: stringType(),
              total_rating: numberType(),
              main_building: numberType(),
              affiliated_building: numberType(),
              public_building: numberType(),
              unregistered_area: numberType(),
              management_magnification: numberType(),
              management_fee: numberType(),
              rent_price: numberType(),
              deposit_price: numberType(),
              tenement_floor: numberType(),
              tenement_host_name: stringType(),
              tenement_host_telphone: stringType(),
              tenement_host_phone: stringType(),
              tenement_host_line: stringType(),
              tenement_host_remittance_bank: stringType(),
              tenement_host_remittance_account: stringType(),
              tenement_host_address: stringType(),
              tenement_host_birthday: stringType(),
              tenement_host_hobby: stringType(),
              tenement_host_remark: stringType(),
              renter_start_date: stringType(),
              renter_end_date: stringType(),
              renter_name: stringType(),
              renter_id_images: stringType().array(),
              renter_phone: stringType(),
              renter_jobtitle: stringType(),
              renter_guarantor_name: stringType(),
              renter_guarantor_phone: stringType(),
              renter_remark: stringType()
            })
          );
          const validData = validSchema.parse(data);
          const newData = {
            ...validData.data,
            total_rating: validData.data.total_rating.toString(),
            main_building: validData.data.main_building.toString(),
            affiliated_building: validData.data.affiliated_building.toString(),
            public_building: validData.data.public_building.toString(),
            unregistered_area: validData.data.unregistered_area.toString(),
            management_magnification: validData.data.management_magnification.toString(),
            management_fee: validData.data.management_fee.toString(),
            rent_price: validData.data.rent_price.toString(),
            deposit_price: validData.data.deposit_price.toString(),
            tenement_floor: validData.data.tenement_floor.toString()
          };
          setData(newData);
          return newData;
        } catch (error) {
          console.error(error);
          alert("取得資料失敗");
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      return {
        isLoading,
        isError,
        getRentEdit,
        dataEdit
      };
    }
    function usePostRentEdit() {
      const token2 = useToken();
      const [isLoading, setIsLoading] = reactExports.useState(false);
      const [isError, setIsError] = reactExports.useState(false);
      const handleSaveColumn = async (formDatas) => {
        setIsLoading(true);
        try {
          const res = await mutableFetch(
            `/tenement/edit/rent/${formDatas.tenement_id}`,
            "POST",
            token2,
            formDatas
          );
          if (!res.ok) {
            alert("操作失敗");
            throw new Error(res.statusText);
          }
        } catch (error) {
          console.error(error);
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      return {
        isLoading,
        isError,
        handleSaveColumn
      };
    }
    function useGetMarketEdit() {
      const token2 = useToken();
      const [isLoading, setIsLoading] = reactExports.useState(true);
      const [isError, setIsError] = reactExports.useState(false);
      const [dataEdit, setData] = reactExports.useState();
      const getMarketEdit = async (id2) => {
        try {
          const res = await getFetch(`/tenement/edit/market/${id2}`, token2);
          const data = await res.json();
          const validSchema = basicZodSchema(
            objectType({
              tenement_address: stringType(),
              tenement_product_type: stringType(),
              tenement_type: stringType(),
              tenement_face: stringType(),
              tenement_images: stringType().array(),
              tenement_host_name: stringType(),
              tenement_host_telphone: stringType(),
              tenement_host_phone: stringType(),
              tenement_host_line: stringType(),
              tenement_host_remittance_bank: stringType(),
              tenement_host_remittance_account: stringType(),
              tenement_host_address: stringType(),
              tenement_host_birthday: stringType(),
              tenement_host_hobby: stringType(),
              tenement_host_remark: stringType(),
              tenement_area_max: numberType(),
              tenement_area_min: numberType(),
              burget_rent_max: numberType(),
              burget_rent_min: numberType(),
              hopefloor_max: numberType(),
              hopefloor_min: numberType(),
              market_state: stringType()
            })
          );
          const validData = validSchema.parse(data);
          const newData = {
            ...validData.data,
            tenement_area_max: validData.data.tenement_area_max.toString(),
            tenement_area_min: validData.data.tenement_area_min.toString(),
            burget_rent_max: validData.data.burget_rent_max.toString(),
            burget_rent_min: validData.data.burget_rent_min.toString(),
            hopefloor_max: validData.data.hopefloor_max.toString(),
            hopefloor_min: validData.data.hopefloor_min.toString()
          };
          setData(newData);
          return newData;
        } catch (error) {
          console.error(error);
          alert("取得資料失敗");
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      return {
        isLoading,
        isError,
        getMarketEdit,
        dataEdit
      };
    }
    function usePostMarketEdit() {
      const token2 = useToken();
      const [isLoading, setIsLoading] = reactExports.useState(false);
      const [isError, setIsError] = reactExports.useState(false);
      const handleSaveColumn = async (formDatas) => {
        setIsLoading(true);
        try {
          const res = await mutableFetch(
            `/tenement/edit/market/${formDatas.tenement_id}`,
            "POST",
            token2,
            formDatas
          );
          if (!res.ok) {
            alert("操作失敗");
            throw new Error(res.statusText);
          }
        } catch (error) {
          console.error(error);
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      return {
        isLoading,
        isError,
        handleSaveColumn
      };
    }
    function useGetNotice() {
      const token2 = useToken();
      const [isLoading, setIsLoading] = reactExports.useState(true);
      const [isError, setIsError] = reactExports.useState(false);
      const [dataNotice, setData] = reactExports.useState([]);
      const getNotice = async (id2, type) => {
        try {
          const res = await getFetch(`/notices/${type}/${id2}`, token2);
          const data = await res.json();
          const validSchema = basicZodSchema(
            objectType({
              id: numberType(),
              visitDate: stringType(),
              record: stringType(),
              remindDate: stringType(),
              remind: stringType()
            }).array()
          );
          const validData = validSchema.parse(data);
          setData(validData.data);
        } catch (error) {
          console.error(error);
          alert("取得資料失敗");
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      return {
        isLoading,
        isError,
        getNotice,
        dataNotice
      };
    }
    async function handlePostAddNotice(type, notices) {
      const organzedNotices = notices.map(({ collection_id, ...rest }) => {
        if (type === "collection") {
          return {
            ...rest,
            collection_id: Number(collection_id)
          };
        } else {
          return {
            ...rest,
            tenement_id: Number(collection_id)
          };
        }
      });
      const token2 = localStorage.getItem("token");
      console.log(organzedNotices);
      try {
        const res = await mutableFetch(
          `/notices/${type}`,
          "POST",
          token2,
          organzedNotices
        );
        const data = await res.json();
        const validSchema = basicZodSchema(
          objectType({
            id: numberType(),
            visitDate: stringType(),
            record: stringType(),
            remindDate: stringType(),
            remind: stringType()
          }).array()
        );
        const validData = validSchema.parse(data);
        return validData.data;
      } catch (error) {
        console.error(error);
      }
    }
    function usePutNotice() {
      const token2 = useToken();
      const [isDone, setIsDone] = reactExports.useState(false);
      const [isLoading, setIsLoading] = reactExports.useState(false);
      const [isError, setIsError] = reactExports.useState(false);
      const handlePutNotice = async (type, notices) => {
        setIsLoading(true);
        setIsDone(false);
        console.log(notices);
        try {
          const body = notices.map((notice) => ({
            id: notice.id,
            visitDate: notice.visitDate,
            record: notice.record,
            remindDate: notice.remindDate,
            remind: notice.remind,
            isNew: notice.isNew
          }));
          const res = await mutableFetch(`/notices/${type}`, "PUT", token2, body);
          if (!res.ok) {
            alert("操作失敗");
            throw new Error(res.statusText);
          }
          setIsDone(true);
          console.log(res);
        } catch (error) {
          console.error(error);
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      return {
        isLoading,
        isError,
        isDone,
        handlePutNotice
      };
    }
    function usePostAddTenement() {
      const token2 = useToken();
      const [isDone, setIsDone] = reactExports.useState(false);
      const [isLoading, setIsLoading] = reactExports.useState(false);
      const [isError, setIsError] = reactExports.useState(false);
      const handlePostAddTenement = async (type, tenement) => {
        setIsLoading(true);
        setIsDone(false);
        try {
          const res = await mutableFetch(
            `/tenement/add/${type}`,
            "POST",
            token2,
            tenement
          );
          const data = await res.json();
          const validSchema = basicZodSchema(
            objectType({
              tenement_id: numberType()
            })
          );
          const validData = validSchema.parse(data);
          setIsDone(true);
          return validData.data.tenement_id;
        } catch (error) {
          console.error(error);
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      return {
        isLoading,
        isError,
        isDone,
        handlePostAddTenement
      };
    }
    function useDeleteTenement() {
      const token2 = useToken();
      const [isDone, setIsDone] = reactExports.useState(false);
      const [isLoading, setIsLoading] = reactExports.useState(false);
      const [isError, setIsError] = reactExports.useState(false);
      const handleDeleteTenement = async (tenement_id, tenement_type) => {
        setIsLoading(true);
        setIsDone(false);
        try {
          const res = await mutableFetch(
            `/tenement/delete/${tenement_type}/${tenement_id}`,
            "DELETE",
            token2,
            {}
          );
          if (!res.ok) {
            alert("操作失敗");
            throw new Error(res.statusText);
          }
          setIsDone(true);
          console.log(res);
        } catch (error) {
          console.error(error);
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      return {
        isLoading,
        isError,
        isDone,
        handleDeleteTenement
      };
    }
    function useGetUserRole(token2) {
      const [isAdmin, setIsAdmin] = reactExports.useState(false);
      const getUserRole = async () => {
        if (!token2)
          return;
        const res = await getFetch(`/user/auth`, token2);
        const data = await res.json();
        const validSchema = basicZodSchema(
          objectType({
            isadmin: booleanType()
          })
        );
        const validData = validSchema.parse(data);
        setIsAdmin(validData.data.isadmin);
      };
      return {
        isAdmin,
        getUserRole
      };
    }
    async function deleteFile(fileName) {
      const token2 = localStorage.getItem("token");
      const res = await fetch(`${APIBaseURL}/api/files/delete/${fileName}`, {
        headers: {
          Authorization: `Bearer ${token2}`,
          "ngrok-skip-browser-warning": "true"
        },
        method: "DELETE"
      });
      if (!res.ok) {
        alert("操作失敗");
        throw new Error(res.statusText);
      }
    }
    function useGetRollbackTenementList() {
      const token2 = useToken();
      const [isLoading, setIsLoading] = reactExports.useState(true);
      const [isError, setIsError] = reactExports.useState(false);
      const [dataTenement, setDataTenement] = reactExports.useState([]);
      const handleGetTenement = async (query) => {
        setIsLoading(true);
        const querys = Object.fromEntries(
          Object.entries(query).filter(([_, v2]) => v2 !== void 0 && v2 !== "")
        );
        const queryString = Object.keys(querys).map((key) => `${key}=${querys[key]}`).join("&");
        try {
          const res = await getFetch(`/tenement/rollback?${queryString}`, token2);
          const data = await res.json();
          const validSchema = basicZodSchema(
            objectType({
              tenement_id: numberType(),
              tenement_address: stringType(),
              tenement_face: stringType(),
              tenement_status: stringType(),
              tenement_type: stringType(),
              tenement_product_type: stringType(),
              management_fee_bottom: numberType(),
              management_floor_bottom: numberType()
            }).array()
          );
          const validData = validSchema.parse(data);
          setDataTenement(validData.data);
        } catch (error) {
          console.error(error);
          alert("取得資料失敗");
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      return {
        isLoading,
        isError,
        dataTenement,
        handleGetTenement
      };
    }
    function useGetRollbackCollectionList() {
      const token2 = useToken();
      const [datasa, setData] = reactExports.useState();
      const [isLoading, setIsLoading] = reactExports.useState(true);
      const [isError, setIsError] = reactExports.useState(false);
      reactExports.useEffect(() => {
        (async () => {
          try {
            const res = await getFetch("/collection/rollback", token2);
            const newData = await res.json();
            const validSchema = basicZodSchema(
              objectType({
                collection_name: stringType(),
                tenement_address: stringType(),
                collection_type: stringType(),
                price: stringType(),
                collection_id: numberType()
              }).array()
            );
            const validData = validSchema.parse(newData);
            setData(validData.data);
          } catch (error) {
            console.error(error);
            setIsError(true);
          } finally {
            setIsLoading(false);
          }
        })();
      }, []);
      return {
        isLoading,
        isError,
        datasa
      };
    }
    function useGetRollbackUserList() {
      const token2 = useToken();
      const [dataUser, setDataUser] = reactExports.useState();
      const [isLoading, setIsLoading] = reactExports.useState(true);
      const [isError, setIsError] = reactExports.useState(false);
      const getUserList = async () => {
        try {
          const res = await getFetch("/user/rollback/list", token2);
          const newData = await res.json();
          const validSchema = basicZodSchema(
            objectType({
              user_id: numberType(),
              user_name: stringType(),
              user_email: stringType(),
              status: booleanType()
            }).array()
          );
          const validData = validSchema.parse(newData);
          const organizedData = validData.data.map((item) => ({
            ...item,
            status: item.status ? "是" : "否",
            user_id: item.user_id.toString()
          }));
          setDataUser(organizedData);
        } catch (error) {
          console.error(error);
          setIsError(true);
        } finally {
          setIsLoading(false);
        }
      };
      reactExports.useEffect(() => {
        getUserList();
      }, []);
      return {
        isLoading,
        isError,
        dataUser
      };
    }
    const deleteCollectionFetchFn = async (id2) => {
      const token2 = localStorage.getItem("token");
      try {
        const res = await mutableFetch(
          `/collection/rollback/${id2}`,
          "DELETE",
          token2,
          {}
        );
        if (!res.ok) {
          alert("操作失敗");
          throw new Error(res.statusText);
        }
      } catch (error) {
        console.error(error);
      }
    };
    const hardDeleteTenement = async (tenement_id, tenement_type) => {
      const token2 = localStorage.getItem("token");
      const res = await mutableFetch(
        `/tenement/delete/rollback/${tenement_type}/${tenement_id}`,
        "DELETE",
        token2,
        {}
      );
      if (!res.ok) {
        alert("操作失敗");
        throw new Error(res.statusText);
      }
    };
    const useCollectionList$1 = () => {
      const [data, setData] = reactExports.useState([
        {
          collection_name: "代收1",
          collection_type: "代收",
          tenement_address: "1",
          price: "1000",
          collection_id: 1
        },
        {
          collection_name: "代付1",
          tenement_address: "2",
          collection_type: "代付",
          price: "2000",
          collection_id: 2
        },
        {
          collection_name: "代收2",
          tenement_address: "3",
          collection_type: "代收",
          price: "3000",
          collection_id: 3
        },
        {
          collection_name: "代付2",
          tenement_address: "4",
          collection_type: "代付",
          price: "4000",
          collection_id: 4
        }
      ]);
      const columns = [
        {
          title: "編號",
          dataIndex: "collection_id"
        },
        {
          title: "房屋編號",
          dataIndex: "tenement_address",
          key: "tenement_address",
          width: "30%",
          ...getColumnSearchProps("tenement_address")
        },
        {
          title: "費用名稱",
          dataIndex: "collection_name",
          filters: [
            {
              text: "水電空調費",
              value: "水電空調費"
            },
            {
              text: "管理費",
              value: "管理費"
            },
            {
              text: "其他費用",
              value: "其他費用"
            },
            {
              text: "第四台",
              value: "第四台"
            }
          ],
          onFilter: (value, record) => record.collection_name.includes(value)
        },
        {
          title: "費用類型",
          dataIndex: "collection_type",
          filters: [
            {
              text: "代收",
              value: "代收"
            },
            {
              text: "代付",
              value: "代付"
            }
          ],
          onFilter: (value, record) => record.collection_type.includes(value)
        },
        {
          title: "費用金額",
          dataIndex: "price",
          sorter: (a, b2) => parseInt(a.price) - parseInt(b2.price)
        }
      ];
      const { isLoading, isError, datasa } = useGetCollectionList();
      reactExports.useEffect(() => {
        if (datasa) {
          const newdataCollection = datasa.map((collection) => {
            return {
              collection_id: collection.collection_id,
              tenement_address: collection.tenement_address,
              collection_name: collection.collection_name,
              collection_type: collection.collection_type,
              price: collection.price,
              key: collection.collection_id
            };
          });
          setData(newdataCollection);
        }
      }, [datasa]);
      const navigate = useNavigate();
      const onRow = (record) => {
        return {
          onClick: () => {
            navigate(`/Collection/${record.collection_id}`);
          }
        };
      };
      return {
        data,
        columns,
        onRow,
        isLoading,
        isError
      };
    };
    const CollectionList$1 = () => {
      const { data, columns, onRow, isError, isLoading } = useCollectionList$1();
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center w-4/5 m-10 ", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inline-flex items-center mb-10 justify-evenly w-96", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-4xl ", children: "代收付管理列表" }) }),
        isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "loading..." }) : isError ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "error..." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(TableCompoent, { data, columns, onRow })
      ] });
    };
    dayjs.extend(customParseFormat);
    function Notice({
      keya,
      handleNoticeChange,
      notice,
      handleDeleteNotice
    }) {
      const { TextArea: TextArea2 } = Input$1;
      const dateFormat = "YYYY-MM-DD";
      const visitDate = dayjs(notice.visitDate, dateFormat);
      const remindDate = dayjs(notice.remindDate, dateFormat);
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col w-full ml-5", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-wrap w-full h-full gap-2 ", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex items-center whitespace-nowrap", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "洽談日期：" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            DatePicker$1,
            {
              onChange: (_, dateString) => handleNoticeChange(keya, "visitDate", dateString),
              defaultValue: visitDate
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex items-center whitespace-nowrap", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "紀錄事項：" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextArea2,
            {
              placeholder: "請輸入內容",
              rows: 1,
              className: "w-48",
              onChange: (e2) => handleNoticeChange(keya, "record", e2.target.value),
              value: notice.record
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex items-center whitespace-nowrap", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "提醒日期：" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            DatePicker$1,
            {
              onChange: (_, dateString) => handleNoticeChange(keya, "remindDate", dateString),
              defaultValue: remindDate
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex items-center whitespace-nowrap", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "提醒事項：" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            TextArea2,
            {
              placeholder: "請輸入內容",
              rows: 1,
              className: "w-48",
              onChange: (e2) => handleNoticeChange(keya, "remind", e2.target.value),
              value: notice.remind
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inline-flex items-center whitespace-nowrap", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { danger: true, onClick: () => handleDeleteNotice(keya), children: "刪除" }) })
      ] }) });
    }
    function InputWithErrorMessage({
      value,
      onChange,
      // isError,
      // errorMessage,
      required = false
    }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative my-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { placeholder: "請輸入內容", value, onChange, required }) }) });
    }
    dayjs.extend(customParseFormat);
    function CollectionMange$1(props) {
      const { TextArea: TextArea2 } = Input$1;
      const navigate = useNavigate();
      const handleback = () => {
        navigate("/collections");
      };
      const {
        formData,
        notices,
        handleChange,
        handleNoticeChange,
        handleSave,
        handleReset,
        handleAddNotice,
        handleDeleteNotice,
        handleDeleteCollection,
        isLoading,
        isError
      } = props;
      const dateFormat = "YYYY-MM-DD";
      const collection_date = dayjs(formData.collection_date, dateFormat);
      if (!formData.remittance_bank) {
        formData.remittance_bank = "";
        formData.remittance_account = "";
        formData.cus_remittance_bank = "";
        formData.cus_remittance_account = "";
      }
      const getParams = () => {
        const parama = window.location.href.split("/")[4];
        if (parama === "Add") {
          return false;
        }
        return true;
      };
      const query = new URLSearchParams(window.location.search);
      const isRollback = query.get("rollback") || false;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "form",
        {
          className: "flex flex-col w-full h-full ",
          onSubmit: (e2) => {
            e2.preventDefault();
            handleSave();
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col h-full px-10 py-20 mx-10 mt-12 mb-10 ml-12 bg-white shadow-2xl w-8/9 rounded-xl", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "flex w-12 h-20", onClick: handleback, children: "< 返回" }),
            isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "loading..." }) : isError ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "error..." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inline-flex flex-col mb-3 ml-5", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-4xl font-bold whitespace-normal", children: [
                isRollback && "復原",
                formData.collection_type,
                "管理"
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "ml-5 border-b-2 border-gray-300 " }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row justify-between ", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col flex-wrap w-2/3 h-full gap-5 pl-10 overflow-visible", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "地址:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: formData.tenement_address,
                        onChange: (e2) => handleChange("tenement_address", e2.target.value),
                        isError: formData.tenement_address.length <= 2,
                        errorMessage: "至少兩個字",
                        required: true
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 ", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 text-right ", children: "是否完成:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Select$1,
                      {
                        defaultValue: "否",
                        style: { width: 120 },
                        options: [{ value: "是" }, { value: "否" }],
                        onChange: (value) => handleChange("collection_complete", value),
                        value: formData.collection_complete
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 ", children: "契約日期:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DatePicker$1,
                      {
                        onChange: (_, dateString) => handleChange("collection_date", dateString),
                        format: "YYYY-MM-DD",
                        defaultValue: collection_date,
                        className: "w-48 col-span-3"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 ", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 text-right ", children: "費用類型:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Select$1,
                      {
                        defaultValue: "代收",
                        style: { width: 120 },
                        options: [{ value: "代收" }, { value: "代付" }],
                        onChange: (value) => handleChange("collection_type", value),
                        value: formData.collection_type
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 ", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 text-right ", children: "費用名稱:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Select$1,
                      {
                        defaultValue: "管理費",
                        style: { width: 120 },
                        options: [
                          { value: "水電空調費" },
                          { value: "第四台" },
                          { value: "管理費" },
                          { value: "租金" },
                          { value: "其他" }
                        ],
                        onChange: (value) => handleChange("collection_name", value),
                        value: formData.collection_name
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "費用金額:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: formData.price,
                        onChange: (e2) => handleChange("price", e2.target.value),
                        isError: formData.price.length <= 2,
                        errorMessage: "至少兩個字",
                        required: true
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 ", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 text-right ", children: "繳納方式:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Select$1,
                      {
                        value: formData.payment,
                        style: { width: 120 },
                        options: [{ value: "現金" }, { value: "匯款" }],
                        onChange: (value) => handleChange("payment", value)
                      }
                    )
                  ] }),
                  formData.payment === "匯款" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "大眾匯款銀行:" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        InputWithErrorMessage,
                        {
                          value: formData.remittance_bank,
                          onChange: (e2) => handleChange("remittance_bank", e2.target.value),
                          isError: formData.remittance_bank.length <= 2,
                          errorMessage: "請輸入內容"
                        }
                      )
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "大眾匯款帳號:" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        InputWithErrorMessage,
                        {
                          value: formData.remittance_account,
                          onChange: (e2) => handleChange("remittance_account", e2.target.value),
                          isError: formData.remittance_account.length <= 2,
                          errorMessage: "請輸入內容"
                        }
                      )
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: formData.collection_type === "代收" ? "客戶匯款銀行:" : "機構匯款銀行:" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        InputWithErrorMessage,
                        {
                          value: formData.cus_remittance_bank,
                          onChange: (e2) => handleChange("cus_remittance_bank", e2.target.value),
                          isError: formData.cus_remittance_bank.length <= 2,
                          errorMessage: "請輸入內容"
                        }
                      )
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5", children: formData.collection_type === "代收" ? "客戶匯款帳號:" : "機構匯款帳號:" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        InputWithErrorMessage,
                        {
                          value: formData.cus_remittance_account,
                          onChange: (e2) => handleChange("cus_remittance_account", e2.target.value),
                          isError: formData.cus_remittance_account.length <= 2,
                          errorMessage: "請輸入內容"
                        }
                      )
                    ] })
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex flex-col w-1/3 mt-5 ", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 whitespace-nowrap ", children: "備註:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    TextArea2,
                    {
                      placeholder: "請輸入內容",
                      rows: 15,
                      className: "h-full w-96",
                      value: formData.collection_remark,
                      onChange: (e2) => handleChange("collection_remark", e2.target.value)
                    }
                  )
                ] })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col p-5", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex flex-row gap-5 mb-5 ", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-4xl font-bold whitespace-normal", children: "提醒設定" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button$2,
                  {
                    type: "primary",
                    className: "mt-1 bg-blue-600",
                    onClick: handleAddNotice,
                    children: "新增提醒"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-3 ml-5 border-b-2 border-gray-300" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-5", children: notices.map((notice, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                Notice,
                {
                  keya: index2,
                  notice,
                  handleNoticeChange,
                  handleDeleteNotice
                },
                index2
              )) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-end gap-5 m-10 ", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { className: "bg-blue-600 ", type: "primary", htmlType: "submit", children: isRollback ? "復原" : "儲存" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { type: "default", onClick: () => handleReset(), children: "回復預設" }),
              getParams() && /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button$2,
                {
                  type: "primary",
                  danger: true,
                  onClick: () => handleDeleteCollection(),
                  children: isRollback ? "永久刪除" : "刪除"
                }
              )
            ] })
          ] })
        }
      );
    }
    //! moment.js
    //! version : 2.30.1
    //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
    //! license : MIT
    //! momentjs.com
    var hookCallback;
    function hooks() {
      return hookCallback.apply(null, arguments);
    }
    function setHookCallback(callback) {
      hookCallback = callback;
    }
    function isArray$1(input) {
      return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
    }
    function isObject$1(input) {
      return input != null && Object.prototype.toString.call(input) === "[object Object]";
    }
    function hasOwnProp(a, b2) {
      return Object.prototype.hasOwnProperty.call(a, b2);
    }
    function isObjectEmpty(obj) {
      if (Object.getOwnPropertyNames) {
        return Object.getOwnPropertyNames(obj).length === 0;
      } else {
        var k2;
        for (k2 in obj) {
          if (hasOwnProp(obj, k2)) {
            return false;
          }
        }
        return true;
      }
    }
    function isUndefined$1(input) {
      return input === void 0;
    }
    function isNumber$1(input) {
      return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
    }
    function isDate$1(input) {
      return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
    }
    function map(arr, fn) {
      var res = [], i, arrLen = arr.length;
      for (i = 0; i < arrLen; ++i) {
        res.push(fn(arr[i], i));
      }
      return res;
    }
    function extend$1(a, b2) {
      for (var i in b2) {
        if (hasOwnProp(b2, i)) {
          a[i] = b2[i];
        }
      }
      if (hasOwnProp(b2, "toString")) {
        a.toString = b2.toString;
      }
      if (hasOwnProp(b2, "valueOf")) {
        a.valueOf = b2.valueOf;
      }
      return a;
    }
    function createUTC(input, format2, locale2, strict) {
      return createLocalOrUTC(input, format2, locale2, strict, true).utc();
    }
    function defaultParsingFlags() {
      return {
        empty: false,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: false,
        invalidEra: null,
        invalidMonth: null,
        invalidFormat: false,
        userInvalidated: false,
        iso: false,
        parsedDateParts: [],
        era: null,
        meridiem: null,
        rfc2822: false,
        weekdayMismatch: false
      };
    }
    function getParsingFlags(m2) {
      if (m2._pf == null) {
        m2._pf = defaultParsingFlags();
      }
      return m2._pf;
    }
    var some;
    if (Array.prototype.some) {
      some = Array.prototype.some;
    } else {
      some = function(fun) {
        var t2 = Object(this), len = t2.length >>> 0, i;
        for (i = 0; i < len; i++) {
          if (i in t2 && fun.call(this, t2[i], i, t2)) {
            return true;
          }
        }
        return false;
      };
    }
    function isValid(m2) {
      var flags = null, parsedParts = false, isNowValid = m2._d && !isNaN(m2._d.getTime());
      if (isNowValid) {
        flags = getParsingFlags(m2);
        parsedParts = some.call(flags.parsedDateParts, function(i) {
          return i != null;
        });
        isNowValid = flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
        if (m2._strict) {
          isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
        }
      }
      if (Object.isFrozen == null || !Object.isFrozen(m2)) {
        m2._isValid = isNowValid;
      } else {
        return isNowValid;
      }
      return m2._isValid;
    }
    function createInvalid(flags) {
      var m2 = createUTC(NaN);
      if (flags != null) {
        extend$1(getParsingFlags(m2), flags);
      } else {
        getParsingFlags(m2).userInvalidated = true;
      }
      return m2;
    }
    var momentProperties = hooks.momentProperties = [], updateInProgress = false;
    function copyConfig(to2, from2) {
      var i, prop, val, momentPropertiesLen = momentProperties.length;
      if (!isUndefined$1(from2._isAMomentObject)) {
        to2._isAMomentObject = from2._isAMomentObject;
      }
      if (!isUndefined$1(from2._i)) {
        to2._i = from2._i;
      }
      if (!isUndefined$1(from2._f)) {
        to2._f = from2._f;
      }
      if (!isUndefined$1(from2._l)) {
        to2._l = from2._l;
      }
      if (!isUndefined$1(from2._strict)) {
        to2._strict = from2._strict;
      }
      if (!isUndefined$1(from2._tzm)) {
        to2._tzm = from2._tzm;
      }
      if (!isUndefined$1(from2._isUTC)) {
        to2._isUTC = from2._isUTC;
      }
      if (!isUndefined$1(from2._offset)) {
        to2._offset = from2._offset;
      }
      if (!isUndefined$1(from2._pf)) {
        to2._pf = getParsingFlags(from2);
      }
      if (!isUndefined$1(from2._locale)) {
        to2._locale = from2._locale;
      }
      if (momentPropertiesLen > 0) {
        for (i = 0; i < momentPropertiesLen; i++) {
          prop = momentProperties[i];
          val = from2[prop];
          if (!isUndefined$1(val)) {
            to2[prop] = val;
          }
        }
      }
      return to2;
    }
    function Moment(config) {
      copyConfig(this, config);
      this._d = new Date(config._d != null ? config._d.getTime() : NaN);
      if (!this.isValid()) {
        this._d = /* @__PURE__ */ new Date(NaN);
      }
      if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
      }
    }
    function isMoment(obj) {
      return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
    }
    function warn(msg) {
      if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
        console.warn("Deprecation warning: " + msg);
      }
    }
    function deprecate(msg, fn) {
      var firstTime = true;
      return extend$1(function() {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
          var args = [], arg, i, key, argLen = arguments.length;
          for (i = 0; i < argLen; i++) {
            arg = "";
            if (typeof arguments[i] === "object") {
              arg += "\n[" + i + "] ";
              for (key in arguments[0]) {
                if (hasOwnProp(arguments[0], key)) {
                  arg += key + ": " + arguments[0][key] + ", ";
                }
              }
              arg = arg.slice(0, -2);
            } else {
              arg = arguments[i];
            }
            args.push(arg);
          }
          warn(
            msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
          );
          firstTime = false;
        }
        return fn.apply(this, arguments);
      }, fn);
    }
    var deprecations = {};
    function deprecateSimple(name, msg) {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
      }
      if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
      }
    }
    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;
    function isFunction$1(input) {
      return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
    }
    function set(config) {
      var prop, i;
      for (i in config) {
        if (hasOwnProp(config, i)) {
          prop = config[i];
          if (isFunction$1(prop)) {
            this[i] = prop;
          } else {
            this["_" + i] = prop;
          }
        }
      }
      this._config = config;
      this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
      );
    }
    function mergeConfigs(parentConfig, childConfig) {
      var res = extend$1({}, parentConfig), prop;
      for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
          if (isObject$1(parentConfig[prop]) && isObject$1(childConfig[prop])) {
            res[prop] = {};
            extend$1(res[prop], parentConfig[prop]);
            extend$1(res[prop], childConfig[prop]);
          } else if (childConfig[prop] != null) {
            res[prop] = childConfig[prop];
          } else {
            delete res[prop];
          }
        }
      }
      for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject$1(parentConfig[prop])) {
          res[prop] = extend$1({}, res[prop]);
        }
      }
      return res;
    }
    function Locale(config) {
      if (config != null) {
        this.set(config);
      }
    }
    var keys;
    if (Object.keys) {
      keys = Object.keys;
    } else {
      keys = function(obj) {
        var i, res = [];
        for (i in obj) {
          if (hasOwnProp(obj, i)) {
            res.push(i);
          }
        }
        return res;
      };
    }
    var defaultCalendar = {
      sameDay: "[Today at] LT",
      nextDay: "[Tomorrow at] LT",
      nextWeek: "dddd [at] LT",
      lastDay: "[Yesterday at] LT",
      lastWeek: "[Last] dddd [at] LT",
      sameElse: "L"
    };
    function calendar(key, mom, now2) {
      var output = this._calendar[key] || this._calendar["sameElse"];
      return isFunction$1(output) ? output.call(mom, now2) : output;
    }
    function zeroFill(number, targetLength, forceSign) {
      var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
      return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }
    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
    function addFormatToken(token2, padded, ordinal2, callback) {
      var func = callback;
      if (typeof callback === "string") {
        func = function() {
          return this[callback]();
        };
      }
      if (token2) {
        formatTokenFunctions[token2] = func;
      }
      if (padded) {
        formatTokenFunctions[padded[0]] = function() {
          return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
      }
      if (ordinal2) {
        formatTokenFunctions[ordinal2] = function() {
          return this.localeData().ordinal(
            func.apply(this, arguments),
            token2
          );
        };
      }
    }
    function removeFormattingTokens(input) {
      if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, "");
      }
      return input.replace(/\\/g, "");
    }
    function makeFormatFunction(format2) {
      var array = format2.match(formattingTokens), i, length2;
      for (i = 0, length2 = array.length; i < length2; i++) {
        if (formatTokenFunctions[array[i]]) {
          array[i] = formatTokenFunctions[array[i]];
        } else {
          array[i] = removeFormattingTokens(array[i]);
        }
      }
      return function(mom) {
        var output = "", i2;
        for (i2 = 0; i2 < length2; i2++) {
          output += isFunction$1(array[i2]) ? array[i2].call(mom, format2) : array[i2];
        }
        return output;
      };
    }
    function formatMoment(m2, format2) {
      if (!m2.isValid()) {
        return m2.localeData().invalidDate();
      }
      format2 = expandFormat(format2, m2.localeData());
      formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
      return formatFunctions[format2](m2);
    }
    function expandFormat(format2, locale2) {
      var i = 5;
      function replaceLongDateFormatTokens(input) {
        return locale2.longDateFormat(input) || input;
      }
      localFormattingTokens.lastIndex = 0;
      while (i >= 0 && localFormattingTokens.test(format2)) {
        format2 = format2.replace(
          localFormattingTokens,
          replaceLongDateFormatTokens
        );
        localFormattingTokens.lastIndex = 0;
        i -= 1;
      }
      return format2;
    }
    var defaultLongDateFormat = {
      LTS: "h:mm:ss A",
      LT: "h:mm A",
      L: "MM/DD/YYYY",
      LL: "MMMM D, YYYY",
      LLL: "MMMM D, YYYY h:mm A",
      LLLL: "dddd, MMMM D, YYYY h:mm A"
    };
    function longDateFormat(key) {
      var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
      if (format2 || !formatUpper) {
        return format2;
      }
      this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
        if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
          return tok.slice(1);
        }
        return tok;
      }).join("");
      return this._longDateFormat[key];
    }
    var defaultInvalidDate = "Invalid date";
    function invalidDate() {
      return this._invalidDate;
    }
    var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
    function ordinal(number) {
      return this._ordinal.replace("%d", number);
    }
    var defaultRelativeTime = {
      future: "in %s",
      past: "%s ago",
      s: "a few seconds",
      ss: "%d seconds",
      m: "a minute",
      mm: "%d minutes",
      h: "an hour",
      hh: "%d hours",
      d: "a day",
      dd: "%d days",
      w: "a week",
      ww: "%d weeks",
      M: "a month",
      MM: "%d months",
      y: "a year",
      yy: "%d years"
    };
    function relativeTime(number, withoutSuffix, string2, isFuture) {
      var output = this._relativeTime[string2];
      return isFunction$1(output) ? output(number, withoutSuffix, string2, isFuture) : output.replace(/%d/i, number);
    }
    function pastFuture(diff2, output) {
      var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
      return isFunction$1(format2) ? format2(output) : format2.replace(/%s/i, output);
    }
    var aliases = {
      D: "date",
      dates: "date",
      date: "date",
      d: "day",
      days: "day",
      day: "day",
      e: "weekday",
      weekdays: "weekday",
      weekday: "weekday",
      E: "isoWeekday",
      isoweekdays: "isoWeekday",
      isoweekday: "isoWeekday",
      DDD: "dayOfYear",
      dayofyears: "dayOfYear",
      dayofyear: "dayOfYear",
      h: "hour",
      hours: "hour",
      hour: "hour",
      ms: "millisecond",
      milliseconds: "millisecond",
      millisecond: "millisecond",
      m: "minute",
      minutes: "minute",
      minute: "minute",
      M: "month",
      months: "month",
      month: "month",
      Q: "quarter",
      quarters: "quarter",
      quarter: "quarter",
      s: "second",
      seconds: "second",
      second: "second",
      gg: "weekYear",
      weekyears: "weekYear",
      weekyear: "weekYear",
      GG: "isoWeekYear",
      isoweekyears: "isoWeekYear",
      isoweekyear: "isoWeekYear",
      w: "week",
      weeks: "week",
      week: "week",
      W: "isoWeek",
      isoweeks: "isoWeek",
      isoweek: "isoWeek",
      y: "year",
      years: "year",
      year: "year"
    };
    function normalizeUnits(units) {
      return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
    }
    function normalizeObjectUnits(inputObject) {
      var normalizedInput = {}, normalizedProp, prop;
      for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
          normalizedProp = normalizeUnits(prop);
          if (normalizedProp) {
            normalizedInput[normalizedProp] = inputObject[prop];
          }
        }
      }
      return normalizedInput;
    }
    var priorities = {
      date: 9,
      day: 11,
      weekday: 11,
      isoWeekday: 11,
      dayOfYear: 4,
      hour: 13,
      millisecond: 16,
      minute: 14,
      month: 8,
      quarter: 7,
      second: 15,
      weekYear: 1,
      isoWeekYear: 1,
      week: 5,
      isoWeek: 5,
      year: 1
    };
    function getPrioritizedUnits(unitsObj) {
      var units = [], u2;
      for (u2 in unitsObj) {
        if (hasOwnProp(unitsObj, u2)) {
          units.push({ unit: u2, priority: priorities[u2] });
        }
      }
      units.sort(function(a, b2) {
        return a.priority - b2.priority;
      });
      return units;
    }
    var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, match1to2NoLeadingZero = /^[1-9]\d?/, match1to2HasZero = /^([1-9]\d|\d)/, regexes;
    regexes = {};
    function addRegexToken(token2, regex, strictRegex) {
      regexes[token2] = isFunction$1(regex) ? regex : function(isStrict, localeData2) {
        return isStrict && strictRegex ? strictRegex : regex;
      };
    }
    function getParseRegexForToken(token2, config) {
      if (!hasOwnProp(regexes, token2)) {
        return new RegExp(unescapeFormat(token2));
      }
      return regexes[token2](config._strict, config._locale);
    }
    function unescapeFormat(s) {
      return regexEscape(
        s.replace("\\", "").replace(
          /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
          function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
          }
        )
      );
    }
    function regexEscape(s) {
      return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    function absFloor(number) {
      if (number < 0) {
        return Math.ceil(number) || 0;
      } else {
        return Math.floor(number);
      }
    }
    function toInt(argumentForCoercion) {
      var coercedNumber = +argumentForCoercion, value = 0;
      if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
      }
      return value;
    }
    var tokens = {};
    function addParseToken(token2, callback) {
      var i, func = callback, tokenLen;
      if (typeof token2 === "string") {
        token2 = [token2];
      }
      if (isNumber$1(callback)) {
        func = function(input, array) {
          array[callback] = toInt(input);
        };
      }
      tokenLen = token2.length;
      for (i = 0; i < tokenLen; i++) {
        tokens[token2[i]] = func;
      }
    }
    function addWeekParseToken(token2, callback) {
      addParseToken(token2, function(input, array, config, token3) {
        config._w = config._w || {};
        callback(input, config._w, config, token3);
      });
    }
    function addTimeToArrayFromToken(token2, input, config) {
      if (input != null && hasOwnProp(tokens, token2)) {
        tokens[token2](input, config._a, config, token2);
      }
    }
    function isLeapYear(year) {
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
    var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
    addFormatToken("Y", 0, 0, function() {
      var y2 = this.year();
      return y2 <= 9999 ? zeroFill(y2, 4) : "+" + y2;
    });
    addFormatToken(0, ["YY", 2], 0, function() {
      return this.year() % 100;
    });
    addFormatToken(0, ["YYYY", 4], 0, "year");
    addFormatToken(0, ["YYYYY", 5], 0, "year");
    addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
    addRegexToken("Y", matchSigned);
    addRegexToken("YY", match1to2, match2);
    addRegexToken("YYYY", match1to4, match4);
    addRegexToken("YYYYY", match1to6, match6);
    addRegexToken("YYYYYY", match1to6, match6);
    addParseToken(["YYYYY", "YYYYYY"], YEAR);
    addParseToken("YYYY", function(input, array) {
      array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken("YY", function(input, array) {
      array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken("Y", function(input, array) {
      array[YEAR] = parseInt(input, 10);
    });
    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }
    hooks.parseTwoDigitYear = function(input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    };
    var getSetYear = makeGetSet("FullYear", true);
    function getIsLeapYear() {
      return isLeapYear(this.year());
    }
    function makeGetSet(unit2, keepTime) {
      return function(value) {
        if (value != null) {
          set$1(this, unit2, value);
          hooks.updateOffset(this, keepTime);
          return this;
        } else {
          return get(this, unit2);
        }
      };
    }
    function get(mom, unit2) {
      if (!mom.isValid()) {
        return NaN;
      }
      var d2 = mom._d, isUTC = mom._isUTC;
      switch (unit2) {
        case "Milliseconds":
          return isUTC ? d2.getUTCMilliseconds() : d2.getMilliseconds();
        case "Seconds":
          return isUTC ? d2.getUTCSeconds() : d2.getSeconds();
        case "Minutes":
          return isUTC ? d2.getUTCMinutes() : d2.getMinutes();
        case "Hours":
          return isUTC ? d2.getUTCHours() : d2.getHours();
        case "Date":
          return isUTC ? d2.getUTCDate() : d2.getDate();
        case "Day":
          return isUTC ? d2.getUTCDay() : d2.getDay();
        case "Month":
          return isUTC ? d2.getUTCMonth() : d2.getMonth();
        case "FullYear":
          return isUTC ? d2.getUTCFullYear() : d2.getFullYear();
        default:
          return NaN;
      }
    }
    function set$1(mom, unit2, value) {
      var d2, isUTC, year, month, date;
      if (!mom.isValid() || isNaN(value)) {
        return;
      }
      d2 = mom._d;
      isUTC = mom._isUTC;
      switch (unit2) {
        case "Milliseconds":
          return void (isUTC ? d2.setUTCMilliseconds(value) : d2.setMilliseconds(value));
        case "Seconds":
          return void (isUTC ? d2.setUTCSeconds(value) : d2.setSeconds(value));
        case "Minutes":
          return void (isUTC ? d2.setUTCMinutes(value) : d2.setMinutes(value));
        case "Hours":
          return void (isUTC ? d2.setUTCHours(value) : d2.setHours(value));
        case "Date":
          return void (isUTC ? d2.setUTCDate(value) : d2.setDate(value));
        case "FullYear":
          break;
        default:
          return;
      }
      year = value;
      month = mom.month();
      date = mom.date();
      date = date === 29 && month === 1 && !isLeapYear(year) ? 28 : date;
      void (isUTC ? d2.setUTCFullYear(year, month, date) : d2.setFullYear(year, month, date));
    }
    function stringGet(units) {
      units = normalizeUnits(units);
      if (isFunction$1(this[units])) {
        return this[units]();
      }
      return this;
    }
    function stringSet(units, value) {
      if (typeof units === "object") {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
        for (i = 0; i < prioritizedLen; i++) {
          this[prioritized[i].unit](units[prioritized[i].unit]);
        }
      } else {
        units = normalizeUnits(units);
        if (isFunction$1(this[units])) {
          return this[units](value);
        }
      }
      return this;
    }
    function mod(n2, x2) {
      return (n2 % x2 + x2) % x2;
    }
    var indexOf;
    if (Array.prototype.indexOf) {
      indexOf = Array.prototype.indexOf;
    } else {
      indexOf = function(o2) {
        var i;
        for (i = 0; i < this.length; ++i) {
          if (this[i] === o2) {
            return i;
          }
        }
        return -1;
      };
    }
    function daysInMonth(year, month) {
      if (isNaN(year) || isNaN(month)) {
        return NaN;
      }
      var modMonth = mod(month, 12);
      year += (month - modMonth) / 12;
      return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
    }
    addFormatToken("M", ["MM", 2], "Mo", function() {
      return this.month() + 1;
    });
    addFormatToken("MMM", 0, 0, function(format2) {
      return this.localeData().monthsShort(this, format2);
    });
    addFormatToken("MMMM", 0, 0, function(format2) {
      return this.localeData().months(this, format2);
    });
    addRegexToken("M", match1to2, match1to2NoLeadingZero);
    addRegexToken("MM", match1to2, match2);
    addRegexToken("MMM", function(isStrict, locale2) {
      return locale2.monthsShortRegex(isStrict);
    });
    addRegexToken("MMMM", function(isStrict, locale2) {
      return locale2.monthsRegex(isStrict);
    });
    addParseToken(["M", "MM"], function(input, array) {
      array[MONTH] = toInt(input) - 1;
    });
    addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
      var month = config._locale.monthsParse(input, token2, config._strict);
      if (month != null) {
        array[MONTH] = month;
      } else {
        getParsingFlags(config).invalidMonth = input;
      }
    });
    var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
      "_"
    ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
    function localeMonths(m2, format2) {
      if (!m2) {
        return isArray$1(this._months) ? this._months : this._months["standalone"];
      }
      return isArray$1(this._months) ? this._months[m2.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m2.month()];
    }
    function localeMonthsShort(m2, format2) {
      if (!m2) {
        return isArray$1(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
      }
      return isArray$1(this._monthsShort) ? this._monthsShort[m2.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m2.month()];
    }
    function handleStrictParse(monthName, format2, strict) {
      var i, ii2, mom, llc = monthName.toLocaleLowerCase();
      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
          mom = createUTC([2e3, i]);
          this._shortMonthsParse[i] = this.monthsShort(
            mom,
            ""
          ).toLocaleLowerCase();
          this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
        }
      }
      if (strict) {
        if (format2 === "MMM") {
          ii2 = indexOf.call(this._shortMonthsParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else {
          ii2 = indexOf.call(this._longMonthsParse, llc);
          return ii2 !== -1 ? ii2 : null;
        }
      } else {
        if (format2 === "MMM") {
          ii2 = indexOf.call(this._shortMonthsParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._longMonthsParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else {
          ii2 = indexOf.call(this._longMonthsParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._shortMonthsParse, llc);
          return ii2 !== -1 ? ii2 : null;
        }
      }
    }
    function localeMonthsParse(monthName, format2, strict) {
      var i, mom, regex;
      if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format2, strict);
      }
      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
      }
      for (i = 0; i < 12; i++) {
        mom = createUTC([2e3, i]);
        if (strict && !this._longMonthsParse[i]) {
          this._longMonthsParse[i] = new RegExp(
            "^" + this.months(mom, "").replace(".", "") + "$",
            "i"
          );
          this._shortMonthsParse[i] = new RegExp(
            "^" + this.monthsShort(mom, "").replace(".", "") + "$",
            "i"
          );
        }
        if (!strict && !this._monthsParse[i]) {
          regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
          this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
        }
        if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
          return i;
        } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
          return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
          return i;
        }
      }
    }
    function setMonth(mom, value) {
      if (!mom.isValid()) {
        return mom;
      }
      if (typeof value === "string") {
        if (/^\d+$/.test(value)) {
          value = toInt(value);
        } else {
          value = mom.localeData().monthsParse(value);
          if (!isNumber$1(value)) {
            return mom;
          }
        }
      }
      var month = value, date = mom.date();
      date = date < 29 ? date : Math.min(date, daysInMonth(mom.year(), month));
      void (mom._isUTC ? mom._d.setUTCMonth(month, date) : mom._d.setMonth(month, date));
      return mom;
    }
    function getSetMonth(value) {
      if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
      } else {
        return get(this, "Month");
      }
    }
    function getDaysInMonth() {
      return daysInMonth(this.year(), this.month());
    }
    function monthsShortRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, "_monthsRegex")) {
          computeMonthsParse.call(this);
        }
        if (isStrict) {
          return this._monthsShortStrictRegex;
        } else {
          return this._monthsShortRegex;
        }
      } else {
        if (!hasOwnProp(this, "_monthsShortRegex")) {
          this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
      }
    }
    function monthsRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, "_monthsRegex")) {
          computeMonthsParse.call(this);
        }
        if (isStrict) {
          return this._monthsStrictRegex;
        } else {
          return this._monthsRegex;
        }
      } else {
        if (!hasOwnProp(this, "_monthsRegex")) {
          this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
      }
    }
    function computeMonthsParse() {
      function cmpLenRev(a, b2) {
        return b2.length - a.length;
      }
      var shortPieces = [], longPieces = [], mixedPieces = [], i, mom, shortP, longP;
      for (i = 0; i < 12; i++) {
        mom = createUTC([2e3, i]);
        shortP = regexEscape(this.monthsShort(mom, ""));
        longP = regexEscape(this.months(mom, ""));
        shortPieces.push(shortP);
        longPieces.push(longP);
        mixedPieces.push(longP);
        mixedPieces.push(shortP);
      }
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._monthsShortRegex = this._monthsRegex;
      this._monthsStrictRegex = new RegExp(
        "^(" + longPieces.join("|") + ")",
        "i"
      );
      this._monthsShortStrictRegex = new RegExp(
        "^(" + shortPieces.join("|") + ")",
        "i"
      );
    }
    function createDate(y2, m2, d2, h2, M2, s, ms) {
      var date;
      if (y2 < 100 && y2 >= 0) {
        date = new Date(y2 + 400, m2, d2, h2, M2, s, ms);
        if (isFinite(date.getFullYear())) {
          date.setFullYear(y2);
        }
      } else {
        date = new Date(y2, m2, d2, h2, M2, s, ms);
      }
      return date;
    }
    function createUTCDate(y2) {
      var date, args;
      if (y2 < 100 && y2 >= 0) {
        args = Array.prototype.slice.call(arguments);
        args[0] = y2 + 400;
        date = new Date(Date.UTC.apply(null, args));
        if (isFinite(date.getUTCFullYear())) {
          date.setUTCFullYear(y2);
        }
      } else {
        date = new Date(Date.UTC.apply(null, arguments));
      }
      return date;
    }
    function firstWeekOffset(year, dow, doy) {
      var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
      return -fwdlw + fwd - 1;
    }
    function dayOfYearFromWeeks(year, week, weekday2, dow, doy) {
      var localWeekday = (7 + weekday2 - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
      if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
      } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
      } else {
        resYear = year;
        resDayOfYear = dayOfYear;
      }
      return {
        year: resYear,
        dayOfYear: resDayOfYear
      };
    }
    function weekOfYear(mom, dow, doy) {
      var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
      if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
      } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
      } else {
        resYear = mom.year();
        resWeek = week;
      }
      return {
        week: resWeek,
        year: resYear
      };
    }
    function weeksInYear(year, dow, doy) {
      var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
      return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }
    addFormatToken("w", ["ww", 2], "wo", "week");
    addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
    addRegexToken("w", match1to2, match1to2NoLeadingZero);
    addRegexToken("ww", match1to2, match2);
    addRegexToken("W", match1to2, match1to2NoLeadingZero);
    addRegexToken("WW", match1to2, match2);
    addWeekParseToken(
      ["w", "ww", "W", "WW"],
      function(input, week, config, token2) {
        week[token2.substr(0, 1)] = toInt(input);
      }
    );
    function localeWeek(mom) {
      return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    var defaultLocaleWeek = {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6
      // The week that contains Jan 6th is the first week of the year.
    };
    function localeFirstDayOfWeek() {
      return this._week.dow;
    }
    function localeFirstDayOfYear() {
      return this._week.doy;
    }
    function getSetWeek(input) {
      var week = this.localeData().week(this);
      return input == null ? week : this.add((input - week) * 7, "d");
    }
    function getSetISOWeek(input) {
      var week = weekOfYear(this, 1, 4).week;
      return input == null ? week : this.add((input - week) * 7, "d");
    }
    addFormatToken("d", 0, "do", "day");
    addFormatToken("dd", 0, 0, function(format2) {
      return this.localeData().weekdaysMin(this, format2);
    });
    addFormatToken("ddd", 0, 0, function(format2) {
      return this.localeData().weekdaysShort(this, format2);
    });
    addFormatToken("dddd", 0, 0, function(format2) {
      return this.localeData().weekdays(this, format2);
    });
    addFormatToken("e", 0, 0, "weekday");
    addFormatToken("E", 0, 0, "isoWeekday");
    addRegexToken("d", match1to2);
    addRegexToken("e", match1to2);
    addRegexToken("E", match1to2);
    addRegexToken("dd", function(isStrict, locale2) {
      return locale2.weekdaysMinRegex(isStrict);
    });
    addRegexToken("ddd", function(isStrict, locale2) {
      return locale2.weekdaysShortRegex(isStrict);
    });
    addRegexToken("dddd", function(isStrict, locale2) {
      return locale2.weekdaysRegex(isStrict);
    });
    addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
      var weekday2 = config._locale.weekdaysParse(input, token2, config._strict);
      if (weekday2 != null) {
        week.d = weekday2;
      } else {
        getParsingFlags(config).invalidWeekday = input;
      }
    });
    addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
      week[token2] = toInt(input);
    });
    function parseWeekday(input, locale2) {
      if (typeof input !== "string") {
        return input;
      }
      if (!isNaN(input)) {
        return parseInt(input, 10);
      }
      input = locale2.weekdaysParse(input);
      if (typeof input === "number") {
        return input;
      }
      return null;
    }
    function parseIsoWeekday(input, locale2) {
      if (typeof input === "string") {
        return locale2.weekdaysParse(input) % 7 || 7;
      }
      return isNaN(input) ? null : input;
    }
    function shiftWeekdays(ws, n2) {
      return ws.slice(n2, 7).concat(ws.slice(0, n2));
    }
    var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
    function localeWeekdays(m2, format2) {
      var weekdays = isArray$1(this._weekdays) ? this._weekdays : this._weekdays[m2 && m2 !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
      return m2 === true ? shiftWeekdays(weekdays, this._week.dow) : m2 ? weekdays[m2.day()] : weekdays;
    }
    function localeWeekdaysShort(m2) {
      return m2 === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m2 ? this._weekdaysShort[m2.day()] : this._weekdaysShort;
    }
    function localeWeekdaysMin(m2) {
      return m2 === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m2 ? this._weekdaysMin[m2.day()] : this._weekdaysMin;
    }
    function handleStrictParse$1(weekdayName, format2, strict) {
      var i, ii2, mom, llc = weekdayName.toLocaleLowerCase();
      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];
        for (i = 0; i < 7; ++i) {
          mom = createUTC([2e3, 1]).day(i);
          this._minWeekdaysParse[i] = this.weekdaysMin(
            mom,
            ""
          ).toLocaleLowerCase();
          this._shortWeekdaysParse[i] = this.weekdaysShort(
            mom,
            ""
          ).toLocaleLowerCase();
          this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
        }
      }
      if (strict) {
        if (format2 === "dddd") {
          ii2 = indexOf.call(this._weekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else if (format2 === "ddd") {
          ii2 = indexOf.call(this._shortWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else {
          ii2 = indexOf.call(this._minWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        }
      } else {
        if (format2 === "dddd") {
          ii2 = indexOf.call(this._weekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._shortWeekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._minWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else if (format2 === "ddd") {
          ii2 = indexOf.call(this._shortWeekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._weekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._minWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else {
          ii2 = indexOf.call(this._minWeekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._weekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._shortWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        }
      }
    }
    function localeWeekdaysParse(weekdayName, format2, strict) {
      var i, mom, regex;
      if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format2, strict);
      }
      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
      }
      for (i = 0; i < 7; i++) {
        mom = createUTC([2e3, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
          this._fullWeekdaysParse[i] = new RegExp(
            "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
          this._shortWeekdaysParse[i] = new RegExp(
            "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
          this._minWeekdaysParse[i] = new RegExp(
            "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
        }
        if (!this._weekdaysParse[i]) {
          regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
          this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
        }
        if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
          return i;
        }
      }
    }
    function getSetDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      var day = get(this, "Day");
      if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, "d");
      } else {
        return day;
      }
    }
    function getSetLocaleDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      var weekday2 = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return input == null ? weekday2 : this.add(input - weekday2, "d");
    }
    function getSetISODayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      if (input != null) {
        var weekday2 = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday2 : weekday2 - 7);
      } else {
        return this.day() || 7;
      }
    }
    function weekdaysRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysStrictRegex;
        } else {
          return this._weekdaysRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
      }
    }
    function weekdaysShortRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysShortStrictRegex;
        } else {
          return this._weekdaysShortRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysShortRegex")) {
          this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
      }
    }
    function weekdaysMinRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysMinStrictRegex;
        } else {
          return this._weekdaysMinRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysMinRegex")) {
          this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
      }
    }
    function computeWeekdaysParse() {
      function cmpLenRev(a, b2) {
        return b2.length - a.length;
      }
      var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
      for (i = 0; i < 7; i++) {
        mom = createUTC([2e3, 1]).day(i);
        minp = regexEscape(this.weekdaysMin(mom, ""));
        shortp = regexEscape(this.weekdaysShort(mom, ""));
        longp = regexEscape(this.weekdays(mom, ""));
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
      }
      minPieces.sort(cmpLenRev);
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._weekdaysShortRegex = this._weekdaysRegex;
      this._weekdaysMinRegex = this._weekdaysRegex;
      this._weekdaysStrictRegex = new RegExp(
        "^(" + longPieces.join("|") + ")",
        "i"
      );
      this._weekdaysShortStrictRegex = new RegExp(
        "^(" + shortPieces.join("|") + ")",
        "i"
      );
      this._weekdaysMinStrictRegex = new RegExp(
        "^(" + minPieces.join("|") + ")",
        "i"
      );
    }
    function hFormat() {
      return this.hours() % 12 || 12;
    }
    function kFormat() {
      return this.hours() || 24;
    }
    addFormatToken("H", ["HH", 2], 0, "hour");
    addFormatToken("h", ["hh", 2], 0, hFormat);
    addFormatToken("k", ["kk", 2], 0, kFormat);
    addFormatToken("hmm", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken("hmmss", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken("Hmm", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken("Hmmss", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    function meridiem(token2, lowercase) {
      addFormatToken(token2, 0, 0, function() {
        return this.localeData().meridiem(
          this.hours(),
          this.minutes(),
          lowercase
        );
      });
    }
    meridiem("a", true);
    meridiem("A", false);
    function matchMeridiem(isStrict, locale2) {
      return locale2._meridiemParse;
    }
    addRegexToken("a", matchMeridiem);
    addRegexToken("A", matchMeridiem);
    addRegexToken("H", match1to2, match1to2HasZero);
    addRegexToken("h", match1to2, match1to2NoLeadingZero);
    addRegexToken("k", match1to2, match1to2NoLeadingZero);
    addRegexToken("HH", match1to2, match2);
    addRegexToken("hh", match1to2, match2);
    addRegexToken("kk", match1to2, match2);
    addRegexToken("hmm", match3to4);
    addRegexToken("hmmss", match5to6);
    addRegexToken("Hmm", match3to4);
    addRegexToken("Hmmss", match5to6);
    addParseToken(["H", "HH"], HOUR);
    addParseToken(["k", "kk"], function(input, array, config) {
      var kInput = toInt(input);
      array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(["a", "A"], function(input, array, config) {
      config._isPm = config._locale.isPM(input);
      config._meridiem = input;
    });
    addParseToken(["h", "hh"], function(input, array, config) {
      array[HOUR] = toInt(input);
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("hmm", function(input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("hmmss", function(input, array, config) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("Hmm", function(input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken("Hmmss", function(input, array, config) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
    });
    function localeIsPM(input) {
      return (input + "").toLowerCase().charAt(0) === "p";
    }
    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
    function localeMeridiem(hours2, minutes2, isLower) {
      if (hours2 > 11) {
        return isLower ? "pm" : "PM";
      } else {
        return isLower ? "am" : "AM";
      }
    }
    var baseConfig = {
      calendar: defaultCalendar,
      longDateFormat: defaultLongDateFormat,
      invalidDate: defaultInvalidDate,
      ordinal: defaultOrdinal,
      dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
      relativeTime: defaultRelativeTime,
      months: defaultLocaleMonths,
      monthsShort: defaultLocaleMonthsShort,
      week: defaultLocaleWeek,
      weekdays: defaultLocaleWeekdays,
      weekdaysMin: defaultLocaleWeekdaysMin,
      weekdaysShort: defaultLocaleWeekdaysShort,
      meridiemParse: defaultLocaleMeridiemParse
    };
    var locales = {}, localeFamilies = {}, globalLocale;
    function commonPrefix(arr1, arr2) {
      var i, minl = Math.min(arr1.length, arr2.length);
      for (i = 0; i < minl; i += 1) {
        if (arr1[i] !== arr2[i]) {
          return i;
        }
      }
      return minl;
    }
    function normalizeLocale(key) {
      return key ? key.toLowerCase().replace("_", "-") : key;
    }
    function chooseLocale(names2) {
      var i = 0, j, next2, locale2, split;
      while (i < names2.length) {
        split = normalizeLocale(names2[i]).split("-");
        j = split.length;
        next2 = normalizeLocale(names2[i + 1]);
        next2 = next2 ? next2.split("-") : null;
        while (j > 0) {
          locale2 = loadLocale(split.slice(0, j).join("-"));
          if (locale2) {
            return locale2;
          }
          if (next2 && next2.length >= j && commonPrefix(split, next2) >= j - 1) {
            break;
          }
          j--;
        }
        i++;
      }
      return globalLocale;
    }
    function isLocaleNameSane(name) {
      return !!(name && name.match("^[^/\\\\]*$"));
    }
    function loadLocale(name) {
      var oldLocale = null, aliasedRequire;
      if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
        try {
          oldLocale = globalLocale._abbr;
          aliasedRequire = require;
          aliasedRequire("./locale/" + name);
          getSetGlobalLocale(oldLocale);
        } catch (e2) {
          locales[name] = null;
        }
      }
      return locales[name];
    }
    function getSetGlobalLocale(key, values) {
      var data;
      if (key) {
        if (isUndefined$1(values)) {
          data = getLocale(key);
        } else {
          data = defineLocale(key, values);
        }
        if (data) {
          globalLocale = data;
        } else {
          if (typeof console !== "undefined" && console.warn) {
            console.warn(
              "Locale " + key + " not found. Did you forget to load it?"
            );
          }
        }
      }
      return globalLocale._abbr;
    }
    function defineLocale(name, config) {
      if (config !== null) {
        var locale2, parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
          deprecateSimple(
            "defineLocaleOverride",
            "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
          );
          parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
          if (locales[config.parentLocale] != null) {
            parentConfig = locales[config.parentLocale]._config;
          } else {
            locale2 = loadLocale(config.parentLocale);
            if (locale2 != null) {
              parentConfig = locale2._config;
            } else {
              if (!localeFamilies[config.parentLocale]) {
                localeFamilies[config.parentLocale] = [];
              }
              localeFamilies[config.parentLocale].push({
                name,
                config
              });
              return null;
            }
          }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));
        if (localeFamilies[name]) {
          localeFamilies[name].forEach(function(x2) {
            defineLocale(x2.name, x2.config);
          });
        }
        getSetGlobalLocale(name);
        return locales[name];
      } else {
        delete locales[name];
        return null;
      }
    }
    function updateLocale(name, config) {
      if (config != null) {
        var locale2, tmpLocale, parentConfig = baseConfig;
        if (locales[name] != null && locales[name].parentLocale != null) {
          locales[name].set(mergeConfigs(locales[name]._config, config));
        } else {
          tmpLocale = loadLocale(name);
          if (tmpLocale != null) {
            parentConfig = tmpLocale._config;
          }
          config = mergeConfigs(parentConfig, config);
          if (tmpLocale == null) {
            config.abbr = name;
          }
          locale2 = new Locale(config);
          locale2.parentLocale = locales[name];
          locales[name] = locale2;
        }
        getSetGlobalLocale(name);
      } else {
        if (locales[name] != null) {
          if (locales[name].parentLocale != null) {
            locales[name] = locales[name].parentLocale;
            if (name === getSetGlobalLocale()) {
              getSetGlobalLocale(name);
            }
          } else if (locales[name] != null) {
            delete locales[name];
          }
        }
      }
      return locales[name];
    }
    function getLocale(key) {
      var locale2;
      if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
      }
      if (!key) {
        return globalLocale;
      }
      if (!isArray$1(key)) {
        locale2 = loadLocale(key);
        if (locale2) {
          return locale2;
        }
        key = [key];
      }
      return chooseLocale(key);
    }
    function listLocales() {
      return keys(locales);
    }
    function checkOverflow(m2) {
      var overflow, a = m2._a;
      if (a && getParsingFlags(m2).overflow === -2) {
        overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
        if (getParsingFlags(m2)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
          overflow = DATE;
        }
        if (getParsingFlags(m2)._overflowWeeks && overflow === -1) {
          overflow = WEEK;
        }
        if (getParsingFlags(m2)._overflowWeekday && overflow === -1) {
          overflow = WEEKDAY;
        }
        getParsingFlags(m2).overflow = overflow;
      }
      return m2;
    }
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
      ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
      ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
      ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
      ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
      ["YYYY-DDD", /\d{4}-\d{3}/],
      ["YYYY-MM", /\d{4}-\d\d/, false],
      ["YYYYYYMMDD", /[+-]\d{10}/],
      ["YYYYMMDD", /\d{8}/],
      ["GGGG[W]WWE", /\d{4}W\d{3}/],
      ["GGGG[W]WW", /\d{4}W\d{2}/, false],
      ["YYYYDDD", /\d{7}/],
      ["YYYYMM", /\d{6}/, false],
      ["YYYY", /\d{4}/, false]
    ], isoTimes = [
      ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
      ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
      ["HH:mm:ss", /\d\d:\d\d:\d\d/],
      ["HH:mm", /\d\d:\d\d/],
      ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
      ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
      ["HHmmss", /\d\d\d\d\d\d/],
      ["HHmm", /\d\d\d\d/],
      ["HH", /\d\d/]
    ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
      UT: 0,
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    function configFromISO(config) {
      var i, l2, string2 = config._i, match5 = extendedIsoRegex.exec(string2) || basicIsoRegex.exec(string2), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
      if (match5) {
        getParsingFlags(config).iso = true;
        for (i = 0, l2 = isoDatesLen; i < l2; i++) {
          if (isoDates[i][1].exec(match5[1])) {
            dateFormat = isoDates[i][0];
            allowTime = isoDates[i][2] !== false;
            break;
          }
        }
        if (dateFormat == null) {
          config._isValid = false;
          return;
        }
        if (match5[3]) {
          for (i = 0, l2 = isoTimesLen; i < l2; i++) {
            if (isoTimes[i][1].exec(match5[3])) {
              timeFormat = (match5[2] || " ") + isoTimes[i][0];
              break;
            }
          }
          if (timeFormat == null) {
            config._isValid = false;
            return;
          }
        }
        if (!allowTime && timeFormat != null) {
          config._isValid = false;
          return;
        }
        if (match5[4]) {
          if (tzRegex.exec(match5[4])) {
            tzFormat = "Z";
          } else {
            config._isValid = false;
            return;
          }
        }
        config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
        configFromStringAndFormat(config);
      } else {
        config._isValid = false;
      }
    }
    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      var result = [
        untruncateYear(yearStr),
        defaultLocaleMonthsShort.indexOf(monthStr),
        parseInt(dayStr, 10),
        parseInt(hourStr, 10),
        parseInt(minuteStr, 10)
      ];
      if (secondStr) {
        result.push(parseInt(secondStr, 10));
      }
      return result;
    }
    function untruncateYear(yearStr) {
      var year = parseInt(yearStr, 10);
      if (year <= 49) {
        return 2e3 + year;
      } else if (year <= 999) {
        return 1900 + year;
      }
      return year;
    }
    function preprocessRFC2822(s) {
      return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    }
    function checkWeekday(weekdayStr, parsedInput, config) {
      if (weekdayStr) {
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
          parsedInput[0],
          parsedInput[1],
          parsedInput[2]
        ).getDay();
        if (weekdayProvided !== weekdayActual) {
          getParsingFlags(config).weekdayMismatch = true;
          config._isValid = false;
          return false;
        }
      }
      return true;
    }
    function calculateOffset(obsOffset, militaryOffset, numOffset) {
      if (obsOffset) {
        return obsOffsets[obsOffset];
      } else if (militaryOffset) {
        return 0;
      } else {
        var hm = parseInt(numOffset, 10), m2 = hm % 100, h2 = (hm - m2) / 100;
        return h2 * 60 + m2;
      }
    }
    function configFromRFC2822(config) {
      var match5 = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
      if (match5) {
        parsedArray = extractFromRFC2822Strings(
          match5[4],
          match5[3],
          match5[2],
          match5[5],
          match5[6],
          match5[7]
        );
        if (!checkWeekday(match5[1], parsedArray, config)) {
          return;
        }
        config._a = parsedArray;
        config._tzm = calculateOffset(match5[8], match5[9], match5[10]);
        config._d = createUTCDate.apply(null, config._a);
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        getParsingFlags(config).rfc2822 = true;
      } else {
        config._isValid = false;
      }
    }
    function configFromString(config) {
      var matched = aspNetJsonRegex.exec(config._i);
      if (matched !== null) {
        config._d = /* @__PURE__ */ new Date(+matched[1]);
        return;
      }
      configFromISO(config);
      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      }
      configFromRFC2822(config);
      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      }
      if (config._strict) {
        config._isValid = false;
      } else {
        hooks.createFromInputFallback(config);
      }
    }
    hooks.createFromInputFallback = deprecate(
      "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
      function(config) {
        config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
      }
    );
    function defaults$2(a, b2, c2) {
      if (a != null) {
        return a;
      }
      if (b2 != null) {
        return b2;
      }
      return c2;
    }
    function currentDateArray(config) {
      var nowValue = new Date(hooks.now());
      if (config._useUTC) {
        return [
          nowValue.getUTCFullYear(),
          nowValue.getUTCMonth(),
          nowValue.getUTCDate()
        ];
      }
      return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }
    function configFromArray(config) {
      var i, date, input = [], currentDate, expectedWeekday, yearToUse;
      if (config._d) {
        return;
      }
      currentDate = currentDateArray(config);
      if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
      }
      if (config._dayOfYear != null) {
        yearToUse = defaults$2(config._a[YEAR], currentDate[YEAR]);
        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
          getParsingFlags(config)._overflowDayOfYear = true;
        }
        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
      }
      for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
      }
      for (; i < 7; i++) {
        config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
      }
      if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
      }
      config._d = (config._useUTC ? createUTCDate : createDate).apply(
        null,
        input
      );
      expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
      if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      }
      if (config._nextDay) {
        config._a[HOUR] = 24;
      }
      if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
        getParsingFlags(config).weekdayMismatch = true;
      }
    }
    function dayOfYearFromWeekInfo(config) {
      var w2, weekYear2, week, weekday2, dow, doy, temp, weekdayOverflow, curWeek;
      w2 = config._w;
      if (w2.GG != null || w2.W != null || w2.E != null) {
        dow = 1;
        doy = 4;
        weekYear2 = defaults$2(
          w2.GG,
          config._a[YEAR],
          weekOfYear(createLocal(), 1, 4).year
        );
        week = defaults$2(w2.W, 1);
        weekday2 = defaults$2(w2.E, 1);
        if (weekday2 < 1 || weekday2 > 7) {
          weekdayOverflow = true;
        }
      } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;
        curWeek = weekOfYear(createLocal(), dow, doy);
        weekYear2 = defaults$2(w2.gg, config._a[YEAR], curWeek.year);
        week = defaults$2(w2.w, curWeek.week);
        if (w2.d != null) {
          weekday2 = w2.d;
          if (weekday2 < 0 || weekday2 > 6) {
            weekdayOverflow = true;
          }
        } else if (w2.e != null) {
          weekday2 = w2.e + dow;
          if (w2.e < 0 || w2.e > 6) {
            weekdayOverflow = true;
          }
        } else {
          weekday2 = dow;
        }
      }
      if (week < 1 || week > weeksInYear(weekYear2, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
      } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
      } else {
        temp = dayOfYearFromWeeks(weekYear2, week, weekday2, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
      }
    }
    hooks.ISO_8601 = function() {
    };
    hooks.RFC_2822 = function() {
    };
    function configFromStringAndFormat(config) {
      if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
      }
      if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
      }
      config._a = [];
      getParsingFlags(config).empty = true;
      var string2 = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string2.length, totalParsedInputLength = 0, era, tokenLen;
      tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
      tokenLen = tokens2.length;
      for (i = 0; i < tokenLen; i++) {
        token2 = tokens2[i];
        parsedInput = (string2.match(getParseRegexForToken(token2, config)) || [])[0];
        if (parsedInput) {
          skipped = string2.substr(0, string2.indexOf(parsedInput));
          if (skipped.length > 0) {
            getParsingFlags(config).unusedInput.push(skipped);
          }
          string2 = string2.slice(
            string2.indexOf(parsedInput) + parsedInput.length
          );
          totalParsedInputLength += parsedInput.length;
        }
        if (formatTokenFunctions[token2]) {
          if (parsedInput) {
            getParsingFlags(config).empty = false;
          } else {
            getParsingFlags(config).unusedTokens.push(token2);
          }
          addTimeToArrayFromToken(token2, parsedInput, config);
        } else if (config._strict && !parsedInput) {
          getParsingFlags(config).unusedTokens.push(token2);
        }
      }
      getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
      if (string2.length > 0) {
        getParsingFlags(config).unusedInput.push(string2);
      }
      if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = void 0;
      }
      getParsingFlags(config).parsedDateParts = config._a.slice(0);
      getParsingFlags(config).meridiem = config._meridiem;
      config._a[HOUR] = meridiemFixWrap(
        config._locale,
        config._a[HOUR],
        config._meridiem
      );
      era = getParsingFlags(config).era;
      if (era !== null) {
        config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
      }
      configFromArray(config);
      checkOverflow(config);
    }
    function meridiemFixWrap(locale2, hour, meridiem2) {
      var isPm;
      if (meridiem2 == null) {
        return hour;
      }
      if (locale2.meridiemHour != null) {
        return locale2.meridiemHour(hour, meridiem2);
      } else if (locale2.isPM != null) {
        isPm = locale2.isPM(meridiem2);
        if (isPm && hour < 12) {
          hour += 12;
        }
        if (!isPm && hour === 12) {
          hour = 0;
        }
        return hour;
      } else {
        return hour;
      }
    }
    function configFromStringAndArray(config) {
      var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
      if (configfLen === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = /* @__PURE__ */ new Date(NaN);
        return;
      }
      for (i = 0; i < configfLen; i++) {
        currentScore = 0;
        validFormatFound = false;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
          tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);
        if (isValid(tempConfig)) {
          validFormatFound = true;
        }
        currentScore += getParsingFlags(tempConfig).charsLeftOver;
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
        getParsingFlags(tempConfig).score = currentScore;
        if (!bestFormatIsValid) {
          if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
            if (validFormatFound) {
              bestFormatIsValid = true;
            }
          }
        } else {
          if (currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
          }
        }
      }
      extend$1(config, bestMoment || tempConfig);
    }
    function configFromObject(config) {
      if (config._d) {
        return;
      }
      var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
      config._a = map(
        [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
        function(obj) {
          return obj && parseInt(obj, 10);
        }
      );
      configFromArray(config);
    }
    function createFromConfig(config) {
      var res = new Moment(checkOverflow(prepareConfig(config)));
      if (res._nextDay) {
        res.add(1, "d");
        res._nextDay = void 0;
      }
      return res;
    }
    function prepareConfig(config) {
      var input = config._i, format2 = config._f;
      config._locale = config._locale || getLocale(config._l);
      if (input === null || format2 === void 0 && input === "") {
        return createInvalid({ nullInput: true });
      }
      if (typeof input === "string") {
        config._i = input = config._locale.preparse(input);
      }
      if (isMoment(input)) {
        return new Moment(checkOverflow(input));
      } else if (isDate$1(input)) {
        config._d = input;
      } else if (isArray$1(format2)) {
        configFromStringAndArray(config);
      } else if (format2) {
        configFromStringAndFormat(config);
      } else {
        configFromInput(config);
      }
      if (!isValid(config)) {
        config._d = null;
      }
      return config;
    }
    function configFromInput(config) {
      var input = config._i;
      if (isUndefined$1(input)) {
        config._d = new Date(hooks.now());
      } else if (isDate$1(input)) {
        config._d = new Date(input.valueOf());
      } else if (typeof input === "string") {
        configFromString(config);
      } else if (isArray$1(input)) {
        config._a = map(input.slice(0), function(obj) {
          return parseInt(obj, 10);
        });
        configFromArray(config);
      } else if (isObject$1(input)) {
        configFromObject(config);
      } else if (isNumber$1(input)) {
        config._d = new Date(input);
      } else {
        hooks.createFromInputFallback(config);
      }
    }
    function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
      var c2 = {};
      if (format2 === true || format2 === false) {
        strict = format2;
        format2 = void 0;
      }
      if (locale2 === true || locale2 === false) {
        strict = locale2;
        locale2 = void 0;
      }
      if (isObject$1(input) && isObjectEmpty(input) || isArray$1(input) && input.length === 0) {
        input = void 0;
      }
      c2._isAMomentObject = true;
      c2._useUTC = c2._isUTC = isUTC;
      c2._l = locale2;
      c2._i = input;
      c2._f = format2;
      c2._strict = strict;
      return createFromConfig(c2);
    }
    function createLocal(input, format2, locale2, strict) {
      return createLocalOrUTC(input, format2, locale2, strict, false);
    }
    var prototypeMin = deprecate(
      "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other < this ? this : other;
        } else {
          return createInvalid();
        }
      }
    ), prototypeMax = deprecate(
      "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other > this ? this : other;
        } else {
          return createInvalid();
        }
      }
    );
    function pickBy(fn, moments) {
      var res, i;
      if (moments.length === 1 && isArray$1(moments[0])) {
        moments = moments[0];
      }
      if (!moments.length) {
        return createLocal();
      }
      res = moments[0];
      for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
          res = moments[i];
        }
      }
      return res;
    }
    function min() {
      var args = [].slice.call(arguments, 0);
      return pickBy("isBefore", args);
    }
    function max() {
      var args = [].slice.call(arguments, 0);
      return pickBy("isAfter", args);
    }
    var now = function() {
      return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
    };
    var ordering = [
      "year",
      "quarter",
      "month",
      "week",
      "day",
      "hour",
      "minute",
      "second",
      "millisecond"
    ];
    function isDurationValid(m2) {
      var key, unitHasDecimal = false, i, orderLen = ordering.length;
      for (key in m2) {
        if (hasOwnProp(m2, key) && !(indexOf.call(ordering, key) !== -1 && (m2[key] == null || !isNaN(m2[key])))) {
          return false;
        }
      }
      for (i = 0; i < orderLen; ++i) {
        if (m2[ordering[i]]) {
          if (unitHasDecimal) {
            return false;
          }
          if (parseFloat(m2[ordering[i]]) !== toInt(m2[ordering[i]])) {
            unitHasDecimal = true;
          }
        }
      }
      return true;
    }
    function isValid$1() {
      return this._isValid;
    }
    function createInvalid$1() {
      return createDuration(NaN);
    }
    function Duration(duration) {
      var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
      this._isValid = isDurationValid(normalizedInput);
      this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
      minutes2 * 6e4 + // 1000 * 60
      hours2 * 1e3 * 60 * 60;
      this._days = +days2 + weeks2 * 7;
      this._months = +months2 + quarters * 3 + years2 * 12;
      this._data = {};
      this._locale = getLocale();
      this._bubble();
    }
    function isDuration(obj) {
      return obj instanceof Duration;
    }
    function absRound(number) {
      if (number < 0) {
        return Math.round(-1 * number) * -1;
      } else {
        return Math.round(number);
      }
    }
    function compareArrays(array1, array22, dontConvert) {
      var len = Math.min(array1.length, array22.length), lengthDiff = Math.abs(array1.length - array22.length), diffs = 0, i;
      for (i = 0; i < len; i++) {
        if (dontConvert && array1[i] !== array22[i] || !dontConvert && toInt(array1[i]) !== toInt(array22[i])) {
          diffs++;
        }
      }
      return diffs + lengthDiff;
    }
    function offset(token2, separator) {
      addFormatToken(token2, 0, 0, function() {
        var offset2 = this.utcOffset(), sign2 = "+";
        if (offset2 < 0) {
          offset2 = -offset2;
          sign2 = "-";
        }
        return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
      });
    }
    offset("Z", ":");
    offset("ZZ", "");
    addRegexToken("Z", matchShortOffset);
    addRegexToken("ZZ", matchShortOffset);
    addParseToken(["Z", "ZZ"], function(input, array, config) {
      config._useUTC = true;
      config._tzm = offsetFromString(matchShortOffset, input);
    });
    var chunkOffset = /([\+\-]|\d\d)/gi;
    function offsetFromString(matcher, string2) {
      var matches = (string2 || "").match(matcher), chunk, parts, minutes2;
      if (matches === null) {
        return null;
      }
      chunk = matches[matches.length - 1] || [];
      parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
      minutes2 = +(parts[1] * 60) + toInt(parts[2]);
      return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
    }
    function cloneWithOffset(input, model) {
      var res, diff2;
      if (model._isUTC) {
        res = model.clone();
        diff2 = (isMoment(input) || isDate$1(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        res._d.setTime(res._d.valueOf() + diff2);
        hooks.updateOffset(res, false);
        return res;
      } else {
        return createLocal(input).local();
      }
    }
    function getDateOffset(m2) {
      return -Math.round(m2._d.getTimezoneOffset());
    }
    hooks.updateOffset = function() {
    };
    function getSetOffset(input, keepLocalTime, keepMinutes) {
      var offset2 = this._offset || 0, localAdjust;
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      if (input != null) {
        if (typeof input === "string") {
          input = offsetFromString(matchShortOffset, input);
          if (input === null) {
            return this;
          }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
          input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
          localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
          this.add(localAdjust, "m");
        }
        if (offset2 !== input) {
          if (!keepLocalTime || this._changeInProgress) {
            addSubtract(
              this,
              createDuration(input - offset2, "m"),
              1,
              false
            );
          } else if (!this._changeInProgress) {
            this._changeInProgress = true;
            hooks.updateOffset(this, true);
            this._changeInProgress = null;
          }
        }
        return this;
      } else {
        return this._isUTC ? offset2 : getDateOffset(this);
      }
    }
    function getSetZone(input, keepLocalTime) {
      if (input != null) {
        if (typeof input !== "string") {
          input = -input;
        }
        this.utcOffset(input, keepLocalTime);
        return this;
      } else {
        return -this.utcOffset();
      }
    }
    function setOffsetToUTC(keepLocalTime) {
      return this.utcOffset(0, keepLocalTime);
    }
    function setOffsetToLocal(keepLocalTime) {
      if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;
        if (keepLocalTime) {
          this.subtract(getDateOffset(this), "m");
        }
      }
      return this;
    }
    function setOffsetToParsedOffset() {
      if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
      } else if (typeof this._i === "string") {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
          this.utcOffset(tZone);
        } else {
          this.utcOffset(0, true);
        }
      }
      return this;
    }
    function hasAlignedHourOffset(input) {
      if (!this.isValid()) {
        return false;
      }
      input = input ? createLocal(input).utcOffset() : 0;
      return (this.utcOffset() - input) % 60 === 0;
    }
    function isDaylightSavingTime() {
      return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }
    function isDaylightSavingTimeShifted() {
      if (!isUndefined$1(this._isDSTShifted)) {
        return this._isDSTShifted;
      }
      var c2 = {}, other;
      copyConfig(c2, this);
      c2 = prepareConfig(c2);
      if (c2._a) {
        other = c2._isUTC ? createUTC(c2._a) : createLocal(c2._a);
        this._isDSTShifted = this.isValid() && compareArrays(c2._a, other.toArray()) > 0;
      } else {
        this._isDSTShifted = false;
      }
      return this._isDSTShifted;
    }
    function isLocal() {
      return this.isValid() ? !this._isUTC : false;
    }
    function isUtcOffset() {
      return this.isValid() ? this._isUTC : false;
    }
    function isUtc() {
      return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    function createDuration(input, key) {
      var duration = input, match5 = null, sign2, ret, diffRes;
      if (isDuration(input)) {
        duration = {
          ms: input._milliseconds,
          d: input._days,
          M: input._months
        };
      } else if (isNumber$1(input) || !isNaN(+input)) {
        duration = {};
        if (key) {
          duration[key] = +input;
        } else {
          duration.milliseconds = +input;
        }
      } else if (match5 = aspNetRegex.exec(input)) {
        sign2 = match5[1] === "-" ? -1 : 1;
        duration = {
          y: 0,
          d: toInt(match5[DATE]) * sign2,
          h: toInt(match5[HOUR]) * sign2,
          m: toInt(match5[MINUTE]) * sign2,
          s: toInt(match5[SECOND]) * sign2,
          ms: toInt(absRound(match5[MILLISECOND] * 1e3)) * sign2
          // the millisecond decimal point is included in the match
        };
      } else if (match5 = isoRegex.exec(input)) {
        sign2 = match5[1] === "-" ? -1 : 1;
        duration = {
          y: parseIso(match5[2], sign2),
          M: parseIso(match5[3], sign2),
          w: parseIso(match5[4], sign2),
          d: parseIso(match5[5], sign2),
          h: parseIso(match5[6], sign2),
          m: parseIso(match5[7], sign2),
          s: parseIso(match5[8], sign2)
        };
      } else if (duration == null) {
        duration = {};
      } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
        diffRes = momentsDifference(
          createLocal(duration.from),
          createLocal(duration.to)
        );
        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
      }
      ret = new Duration(duration);
      if (isDuration(input) && hasOwnProp(input, "_locale")) {
        ret._locale = input._locale;
      }
      if (isDuration(input) && hasOwnProp(input, "_isValid")) {
        ret._isValid = input._isValid;
      }
      return ret;
    }
    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;
    function parseIso(inp, sign2) {
      var res = inp && parseFloat(inp.replace(",", "."));
      return (isNaN(res) ? 0 : res) * sign2;
    }
    function positiveMomentsDifference(base, other) {
      var res = {};
      res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
      if (base.clone().add(res.months, "M").isAfter(other)) {
        --res.months;
      }
      res.milliseconds = +other - +base.clone().add(res.months, "M");
      return res;
    }
    function momentsDifference(base, other) {
      var res;
      if (!(base.isValid() && other.isValid())) {
        return { milliseconds: 0, months: 0 };
      }
      other = cloneWithOffset(other, base);
      if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
      } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
      }
      return res;
    }
    function createAdder(direction, name) {
      return function(val, period) {
        var dur, tmp;
        if (period !== null && !isNaN(+period)) {
          deprecateSimple(
            name,
            "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
          );
          tmp = val;
          val = period;
          period = tmp;
        }
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
      };
    }
    function addSubtract(mom, duration, isAdding, updateOffset) {
      var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
      if (!mom.isValid()) {
        return;
      }
      updateOffset = updateOffset == null ? true : updateOffset;
      if (months2) {
        setMonth(mom, get(mom, "Month") + months2 * isAdding);
      }
      if (days2) {
        set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
      }
      if (milliseconds2) {
        mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
      }
      if (updateOffset) {
        hooks.updateOffset(mom, days2 || months2);
      }
    }
    var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
    function isString$1(input) {
      return typeof input === "string" || input instanceof String;
    }
    function isMomentInput(input) {
      return isMoment(input) || isDate$1(input) || isString$1(input) || isNumber$1(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
    }
    function isMomentInputObject(input) {
      var objectTest = isObject$1(input) && !isObjectEmpty(input), propertyTest = false, properties = [
        "years",
        "year",
        "y",
        "months",
        "month",
        "M",
        "days",
        "day",
        "d",
        "dates",
        "date",
        "D",
        "hours",
        "hour",
        "h",
        "minutes",
        "minute",
        "m",
        "seconds",
        "second",
        "s",
        "milliseconds",
        "millisecond",
        "ms"
      ], i, property, propertyLen = properties.length;
      for (i = 0; i < propertyLen; i += 1) {
        property = properties[i];
        propertyTest = propertyTest || hasOwnProp(input, property);
      }
      return objectTest && propertyTest;
    }
    function isNumberOrStringArray(input) {
      var arrayTest = isArray$1(input), dataTypeTest = false;
      if (arrayTest) {
        dataTypeTest = input.filter(function(item) {
          return !isNumber$1(item) && isString$1(input);
        }).length === 0;
      }
      return arrayTest && dataTypeTest;
    }
    function isCalendarSpec(input) {
      var objectTest = isObject$1(input) && !isObjectEmpty(input), propertyTest = false, properties = [
        "sameDay",
        "nextDay",
        "lastDay",
        "nextWeek",
        "lastWeek",
        "sameElse"
      ], i, property;
      for (i = 0; i < properties.length; i += 1) {
        property = properties[i];
        propertyTest = propertyTest || hasOwnProp(input, property);
      }
      return objectTest && propertyTest;
    }
    function getCalendarFormat(myMoment, now2) {
      var diff2 = myMoment.diff(now2, "days", true);
      return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
    }
    function calendar$1(time, formats) {
      if (arguments.length === 1) {
        if (!arguments[0]) {
          time = void 0;
          formats = void 0;
        } else if (isMomentInput(arguments[0])) {
          time = arguments[0];
          formats = void 0;
        } else if (isCalendarSpec(arguments[0])) {
          formats = arguments[0];
          time = void 0;
        }
      }
      var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction$1(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
      return this.format(
        output || this.localeData().calendar(format2, this, createLocal(now2))
      );
    }
    function clone() {
      return new Moment(this);
    }
    function isAfter(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() > localInput.valueOf();
      } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
      }
    }
    function isBefore(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() < localInput.valueOf();
      } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
      }
    }
    function isBetween(from2, to2, units, inclusivity) {
      var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
      if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
        return false;
      }
      inclusivity = inclusivity || "()";
      return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }
    function isSame(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input), inputMs;
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() === localInput.valueOf();
      } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
      }
    }
    function isSameOrAfter(input, units) {
      return this.isSame(input, units) || this.isAfter(input, units);
    }
    function isSameOrBefore(input, units) {
      return this.isSame(input, units) || this.isBefore(input, units);
    }
    function diff(input, units, asFloat) {
      var that, zoneDelta, output;
      if (!this.isValid()) {
        return NaN;
      }
      that = cloneWithOffset(input, this);
      if (!that.isValid()) {
        return NaN;
      }
      zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
      units = normalizeUnits(units);
      switch (units) {
        case "year":
          output = monthDiff(this, that) / 12;
          break;
        case "month":
          output = monthDiff(this, that);
          break;
        case "quarter":
          output = monthDiff(this, that) / 3;
          break;
        case "second":
          output = (this - that) / 1e3;
          break;
        case "minute":
          output = (this - that) / 6e4;
          break;
        case "hour":
          output = (this - that) / 36e5;
          break;
        case "day":
          output = (this - that - zoneDelta) / 864e5;
          break;
        case "week":
          output = (this - that - zoneDelta) / 6048e5;
          break;
        default:
          output = this - that;
      }
      return asFloat ? output : absFloor(output);
    }
    function monthDiff(a, b2) {
      if (a.date() < b2.date()) {
        return -monthDiff(b2, a);
      }
      var wholeMonthDiff = (b2.year() - a.year()) * 12 + (b2.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
      if (b2 - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
        adjust = (b2 - anchor) / (anchor - anchor2);
      } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
        adjust = (b2 - anchor) / (anchor2 - anchor);
      }
      return -(wholeMonthDiff + adjust) || 0;
    }
    hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
    hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    function toString$1() {
      return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
    }
    function toISOString(keepOffset) {
      if (!this.isValid()) {
        return null;
      }
      var utc = keepOffset !== true, m2 = utc ? this.clone().utc() : this;
      if (m2.year() < 0 || m2.year() > 9999) {
        return formatMoment(
          m2,
          utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      if (isFunction$1(Date.prototype.toISOString)) {
        if (utc) {
          return this.toDate().toISOString();
        } else {
          return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m2, "Z"));
        }
      }
      return formatMoment(
        m2,
        utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
      );
    }
    function inspect() {
      if (!this.isValid()) {
        return "moment.invalid(/* " + this._i + " */)";
      }
      var func = "moment", zone = "", prefix, year, datetime, suffix;
      if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
        zone = "Z";
      }
      prefix = "[" + func + '("]';
      year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
      datetime = "-MM-DD[T]HH:mm:ss.SSS";
      suffix = zone + '[")]';
      return this.format(prefix + year + datetime + suffix);
    }
    function format(inputString) {
      if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
      }
      var output = formatMoment(this, inputString);
      return this.localeData().postformat(output);
    }
    function from(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }
    function fromNow(withoutSuffix) {
      return this.from(createLocal(), withoutSuffix);
    }
    function to(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }
    function toNow(withoutSuffix) {
      return this.to(createLocal(), withoutSuffix);
    }
    function locale$4(key) {
      var newLocaleData;
      if (key === void 0) {
        return this._locale._abbr;
      } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
          this._locale = newLocaleData;
        }
        return this;
      }
    }
    var lang = deprecate(
      "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
      function(key) {
        if (key === void 0) {
          return this.localeData();
        } else {
          return this.locale(key);
        }
      }
    );
    function localeData() {
      return this._locale;
    }
    var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
    function mod$1(dividend, divisor) {
      return (dividend % divisor + divisor) % divisor;
    }
    function localStartOfDate(y2, m2, d2) {
      if (y2 < 100 && y2 >= 0) {
        return new Date(y2 + 400, m2, d2) - MS_PER_400_YEARS;
      } else {
        return new Date(y2, m2, d2).valueOf();
      }
    }
    function utcStartOfDate(y2, m2, d2) {
      if (y2 < 100 && y2 >= 0) {
        return Date.UTC(y2 + 400, m2, d2) - MS_PER_400_YEARS;
      } else {
        return Date.UTC(y2, m2, d2);
      }
    }
    function startOf(units) {
      var time, startOfDate;
      units = normalizeUnits(units);
      if (units === void 0 || units === "millisecond" || !this.isValid()) {
        return this;
      }
      startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
      switch (units) {
        case "year":
          time = startOfDate(this.year(), 0, 1);
          break;
        case "quarter":
          time = startOfDate(
            this.year(),
            this.month() - this.month() % 3,
            1
          );
          break;
        case "month":
          time = startOfDate(this.year(), this.month(), 1);
          break;
        case "week":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - this.weekday()
          );
          break;
        case "isoWeek":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - (this.isoWeekday() - 1)
          );
          break;
        case "day":
        case "date":
          time = startOfDate(this.year(), this.month(), this.date());
          break;
        case "hour":
          time = this._d.valueOf();
          time -= mod$1(
            time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
            MS_PER_HOUR
          );
          break;
        case "minute":
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_MINUTE);
          break;
        case "second":
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_SECOND);
          break;
      }
      this._d.setTime(time);
      hooks.updateOffset(this, true);
      return this;
    }
    function endOf(units) {
      var time, startOfDate;
      units = normalizeUnits(units);
      if (units === void 0 || units === "millisecond" || !this.isValid()) {
        return this;
      }
      startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
      switch (units) {
        case "year":
          time = startOfDate(this.year() + 1, 0, 1) - 1;
          break;
        case "quarter":
          time = startOfDate(
            this.year(),
            this.month() - this.month() % 3 + 3,
            1
          ) - 1;
          break;
        case "month":
          time = startOfDate(this.year(), this.month() + 1, 1) - 1;
          break;
        case "week":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - this.weekday() + 7
          ) - 1;
          break;
        case "isoWeek":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - (this.isoWeekday() - 1) + 7
          ) - 1;
          break;
        case "day":
        case "date":
          time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
          break;
        case "hour":
          time = this._d.valueOf();
          time += MS_PER_HOUR - mod$1(
            time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
            MS_PER_HOUR
          ) - 1;
          break;
        case "minute":
          time = this._d.valueOf();
          time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
          break;
        case "second":
          time = this._d.valueOf();
          time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
          break;
      }
      this._d.setTime(time);
      hooks.updateOffset(this, true);
      return this;
    }
    function valueOf() {
      return this._d.valueOf() - (this._offset || 0) * 6e4;
    }
    function unix() {
      return Math.floor(this.valueOf() / 1e3);
    }
    function toDate() {
      return new Date(this.valueOf());
    }
    function toArray$1() {
      var m2 = this;
      return [
        m2.year(),
        m2.month(),
        m2.date(),
        m2.hour(),
        m2.minute(),
        m2.second(),
        m2.millisecond()
      ];
    }
    function toObject() {
      var m2 = this;
      return {
        years: m2.year(),
        months: m2.month(),
        date: m2.date(),
        hours: m2.hours(),
        minutes: m2.minutes(),
        seconds: m2.seconds(),
        milliseconds: m2.milliseconds()
      };
    }
    function toJSON() {
      return this.isValid() ? this.toISOString() : null;
    }
    function isValid$2() {
      return isValid(this);
    }
    function parsingFlags() {
      return extend$1({}, getParsingFlags(this));
    }
    function invalidAt() {
      return getParsingFlags(this).overflow;
    }
    function creationData() {
      return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
      };
    }
    addFormatToken("N", 0, 0, "eraAbbr");
    addFormatToken("NN", 0, 0, "eraAbbr");
    addFormatToken("NNN", 0, 0, "eraAbbr");
    addFormatToken("NNNN", 0, 0, "eraName");
    addFormatToken("NNNNN", 0, 0, "eraNarrow");
    addFormatToken("y", ["y", 1], "yo", "eraYear");
    addFormatToken("y", ["yy", 2], 0, "eraYear");
    addFormatToken("y", ["yyy", 3], 0, "eraYear");
    addFormatToken("y", ["yyyy", 4], 0, "eraYear");
    addRegexToken("N", matchEraAbbr);
    addRegexToken("NN", matchEraAbbr);
    addRegexToken("NNN", matchEraAbbr);
    addRegexToken("NNNN", matchEraName);
    addRegexToken("NNNNN", matchEraNarrow);
    addParseToken(
      ["N", "NN", "NNN", "NNNN", "NNNNN"],
      function(input, array, config, token2) {
        var era = config._locale.erasParse(input, token2, config._strict);
        if (era) {
          getParsingFlags(config).era = era;
        } else {
          getParsingFlags(config).invalidEra = input;
        }
      }
    );
    addRegexToken("y", matchUnsigned);
    addRegexToken("yy", matchUnsigned);
    addRegexToken("yyy", matchUnsigned);
    addRegexToken("yyyy", matchUnsigned);
    addRegexToken("yo", matchEraYearOrdinal);
    addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
    addParseToken(["yo"], function(input, array, config, token2) {
      var match5;
      if (config._locale._eraYearOrdinalRegex) {
        match5 = input.match(config._locale._eraYearOrdinalRegex);
      }
      if (config._locale.eraYearOrdinalParse) {
        array[YEAR] = config._locale.eraYearOrdinalParse(input, match5);
      } else {
        array[YEAR] = parseInt(input, 10);
      }
    });
    function localeEras(m2, format2) {
      var i, l2, date, eras = this._eras || getLocale("en")._eras;
      for (i = 0, l2 = eras.length; i < l2; ++i) {
        switch (typeof eras[i].since) {
          case "string":
            date = hooks(eras[i].since).startOf("day");
            eras[i].since = date.valueOf();
            break;
        }
        switch (typeof eras[i].until) {
          case "undefined":
            eras[i].until = Infinity;
            break;
          case "string":
            date = hooks(eras[i].until).startOf("day").valueOf();
            eras[i].until = date.valueOf();
            break;
        }
      }
      return eras;
    }
    function localeErasParse(eraName, format2, strict) {
      var i, l2, eras = this.eras(), name, abbr, narrow;
      eraName = eraName.toUpperCase();
      for (i = 0, l2 = eras.length; i < l2; ++i) {
        name = eras[i].name.toUpperCase();
        abbr = eras[i].abbr.toUpperCase();
        narrow = eras[i].narrow.toUpperCase();
        if (strict) {
          switch (format2) {
            case "N":
            case "NN":
            case "NNN":
              if (abbr === eraName) {
                return eras[i];
              }
              break;
            case "NNNN":
              if (name === eraName) {
                return eras[i];
              }
              break;
            case "NNNNN":
              if (narrow === eraName) {
                return eras[i];
              }
              break;
          }
        } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
          return eras[i];
        }
      }
    }
    function localeErasConvertYear(era, year) {
      var dir = era.since <= era.until ? 1 : -1;
      if (year === void 0) {
        return hooks(era.since).year();
      } else {
        return hooks(era.since).year() + (year - era.offset) * dir;
      }
    }
    function getEraName() {
      var i, l2, val, eras = this.localeData().eras();
      for (i = 0, l2 = eras.length; i < l2; ++i) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until) {
          return eras[i].name;
        }
        if (eras[i].until <= val && val <= eras[i].since) {
          return eras[i].name;
        }
      }
      return "";
    }
    function getEraNarrow() {
      var i, l2, val, eras = this.localeData().eras();
      for (i = 0, l2 = eras.length; i < l2; ++i) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until) {
          return eras[i].narrow;
        }
        if (eras[i].until <= val && val <= eras[i].since) {
          return eras[i].narrow;
        }
      }
      return "";
    }
    function getEraAbbr() {
      var i, l2, val, eras = this.localeData().eras();
      for (i = 0, l2 = eras.length; i < l2; ++i) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until) {
          return eras[i].abbr;
        }
        if (eras[i].until <= val && val <= eras[i].since) {
          return eras[i].abbr;
        }
      }
      return "";
    }
    function getEraYear() {
      var i, l2, dir, val, eras = this.localeData().eras();
      for (i = 0, l2 = eras.length; i < l2; ++i) {
        dir = eras[i].since <= eras[i].until ? 1 : -1;
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
          return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
        }
      }
      return this.year();
    }
    function erasNameRegex(isStrict) {
      if (!hasOwnProp(this, "_erasNameRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasNameRegex : this._erasRegex;
    }
    function erasAbbrRegex(isStrict) {
      if (!hasOwnProp(this, "_erasAbbrRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasAbbrRegex : this._erasRegex;
    }
    function erasNarrowRegex(isStrict) {
      if (!hasOwnProp(this, "_erasNarrowRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasNarrowRegex : this._erasRegex;
    }
    function matchEraAbbr(isStrict, locale2) {
      return locale2.erasAbbrRegex(isStrict);
    }
    function matchEraName(isStrict, locale2) {
      return locale2.erasNameRegex(isStrict);
    }
    function matchEraNarrow(isStrict, locale2) {
      return locale2.erasNarrowRegex(isStrict);
    }
    function matchEraYearOrdinal(isStrict, locale2) {
      return locale2._eraYearOrdinalRegex || matchUnsigned;
    }
    function computeErasParse() {
      var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l2, erasName, erasAbbr, erasNarrow, eras = this.eras();
      for (i = 0, l2 = eras.length; i < l2; ++i) {
        erasName = regexEscape(eras[i].name);
        erasAbbr = regexEscape(eras[i].abbr);
        erasNarrow = regexEscape(eras[i].narrow);
        namePieces.push(erasName);
        abbrPieces.push(erasAbbr);
        narrowPieces.push(erasNarrow);
        mixedPieces.push(erasName);
        mixedPieces.push(erasAbbr);
        mixedPieces.push(erasNarrow);
      }
      this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
      this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
      this._erasNarrowRegex = new RegExp(
        "^(" + narrowPieces.join("|") + ")",
        "i"
      );
    }
    addFormatToken(0, ["gg", 2], 0, function() {
      return this.weekYear() % 100;
    });
    addFormatToken(0, ["GG", 2], 0, function() {
      return this.isoWeekYear() % 100;
    });
    function addWeekYearFormatToken(token2, getter) {
      addFormatToken(0, [token2, token2.length], 0, getter);
    }
    addWeekYearFormatToken("gggg", "weekYear");
    addWeekYearFormatToken("ggggg", "weekYear");
    addWeekYearFormatToken("GGGG", "isoWeekYear");
    addWeekYearFormatToken("GGGGG", "isoWeekYear");
    addRegexToken("G", matchSigned);
    addRegexToken("g", matchSigned);
    addRegexToken("GG", match1to2, match2);
    addRegexToken("gg", match1to2, match2);
    addRegexToken("GGGG", match1to4, match4);
    addRegexToken("gggg", match1to4, match4);
    addRegexToken("GGGGG", match1to6, match6);
    addRegexToken("ggggg", match1to6, match6);
    addWeekParseToken(
      ["gggg", "ggggg", "GGGG", "GGGGG"],
      function(input, week, config, token2) {
        week[token2.substr(0, 2)] = toInt(input);
      }
    );
    addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
      week[token2] = hooks.parseTwoDigitYear(input);
    });
    function getSetWeekYear(input) {
      return getSetWeekYearHelper.call(
        this,
        input,
        this.week(),
        this.weekday() + this.localeData()._week.dow,
        this.localeData()._week.dow,
        this.localeData()._week.doy
      );
    }
    function getSetISOWeekYear(input) {
      return getSetWeekYearHelper.call(
        this,
        input,
        this.isoWeek(),
        this.isoWeekday(),
        1,
        4
      );
    }
    function getISOWeeksInYear() {
      return weeksInYear(this.year(), 1, 4);
    }
    function getISOWeeksInISOWeekYear() {
      return weeksInYear(this.isoWeekYear(), 1, 4);
    }
    function getWeeksInYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    function getWeeksInWeekYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }
    function getSetWeekYearHelper(input, week, weekday2, dow, doy) {
      var weeksTarget;
      if (input == null) {
        return weekOfYear(this, dow, doy).year;
      } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
          week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday2, dow, doy);
      }
    }
    function setWeekAll(weekYear2, week, weekday2, dow, doy) {
      var dayOfYearData = dayOfYearFromWeeks(weekYear2, week, weekday2, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
      this.year(date.getUTCFullYear());
      this.month(date.getUTCMonth());
      this.date(date.getUTCDate());
      return this;
    }
    addFormatToken("Q", 0, "Qo", "quarter");
    addRegexToken("Q", match1);
    addParseToken("Q", function(input, array) {
      array[MONTH] = (toInt(input) - 1) * 3;
    });
    function getSetQuarter(input) {
      return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }
    addFormatToken("D", ["DD", 2], "Do", "date");
    addRegexToken("D", match1to2, match1to2NoLeadingZero);
    addRegexToken("DD", match1to2, match2);
    addRegexToken("Do", function(isStrict, locale2) {
      return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
    });
    addParseToken(["D", "DD"], DATE);
    addParseToken("Do", function(input, array) {
      array[DATE] = toInt(input.match(match1to2)[0]);
    });
    var getSetDayOfMonth = makeGetSet("Date", true);
    addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
    addRegexToken("DDD", match1to3);
    addRegexToken("DDDD", match3);
    addParseToken(["DDD", "DDDD"], function(input, array, config) {
      config._dayOfYear = toInt(input);
    });
    function getSetDayOfYear(input) {
      var dayOfYear = Math.round(
        (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
      ) + 1;
      return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
    }
    addFormatToken("m", ["mm", 2], 0, "minute");
    addRegexToken("m", match1to2, match1to2HasZero);
    addRegexToken("mm", match1to2, match2);
    addParseToken(["m", "mm"], MINUTE);
    var getSetMinute = makeGetSet("Minutes", false);
    addFormatToken("s", ["ss", 2], 0, "second");
    addRegexToken("s", match1to2, match1to2HasZero);
    addRegexToken("ss", match1to2, match2);
    addParseToken(["s", "ss"], SECOND);
    var getSetSecond = makeGetSet("Seconds", false);
    addFormatToken("S", 0, 0, function() {
      return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ["SS", 2], 0, function() {
      return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ["SSS", 3], 0, "millisecond");
    addFormatToken(0, ["SSSS", 4], 0, function() {
      return this.millisecond() * 10;
    });
    addFormatToken(0, ["SSSSS", 5], 0, function() {
      return this.millisecond() * 100;
    });
    addFormatToken(0, ["SSSSSS", 6], 0, function() {
      return this.millisecond() * 1e3;
    });
    addFormatToken(0, ["SSSSSSS", 7], 0, function() {
      return this.millisecond() * 1e4;
    });
    addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
      return this.millisecond() * 1e5;
    });
    addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
      return this.millisecond() * 1e6;
    });
    addRegexToken("S", match1to3, match1);
    addRegexToken("SS", match1to3, match2);
    addRegexToken("SSS", match1to3, match3);
    var token, getSetMillisecond;
    for (token = "SSSS"; token.length <= 9; token += "S") {
      addRegexToken(token, matchUnsigned);
    }
    function parseMs(input, array) {
      array[MILLISECOND] = toInt(("0." + input) * 1e3);
    }
    for (token = "S"; token.length <= 9; token += "S") {
      addParseToken(token, parseMs);
    }
    getSetMillisecond = makeGetSet("Milliseconds", false);
    addFormatToken("z", 0, 0, "zoneAbbr");
    addFormatToken("zz", 0, 0, "zoneName");
    function getZoneAbbr() {
      return this._isUTC ? "UTC" : "";
    }
    function getZoneName() {
      return this._isUTC ? "Coordinated Universal Time" : "";
    }
    var proto = Moment.prototype;
    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale$4;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray$1;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    if (typeof Symbol !== "undefined" && Symbol.for != null) {
      proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return "Moment<" + this.format() + ">";
      };
    }
    proto.toJSON = toJSON;
    proto.toString = toString$1;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate(
      "dates accessor is deprecated. Use date instead.",
      getSetDayOfMonth
    );
    proto.months = deprecate(
      "months accessor is deprecated. Use month instead",
      getSetMonth
    );
    proto.years = deprecate(
      "years accessor is deprecated. Use year instead",
      getSetYear
    );
    proto.zone = deprecate(
      "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
      getSetZone
    );
    proto.isDSTShifted = deprecate(
      "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
      isDaylightSavingTimeShifted
    );
    function createUnix(input) {
      return createLocal(input * 1e3);
    }
    function createInZone() {
      return createLocal.apply(null, arguments).parseZone();
    }
    function preParsePostFormat(string2) {
      return string2;
    }
    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;
    function get$1(format2, index2, field, setter) {
      var locale2 = getLocale(), utc = createUTC().set(setter, index2);
      return locale2[field](utc, format2);
    }
    function listMonthsImpl(format2, index2, field) {
      if (isNumber$1(format2)) {
        index2 = format2;
        format2 = void 0;
      }
      format2 = format2 || "";
      if (index2 != null) {
        return get$1(format2, index2, field, "month");
      }
      var i, out = [];
      for (i = 0; i < 12; i++) {
        out[i] = get$1(format2, i, field, "month");
      }
      return out;
    }
    function listWeekdaysImpl(localeSorted, format2, index2, field) {
      if (typeof localeSorted === "boolean") {
        if (isNumber$1(format2)) {
          index2 = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
      } else {
        format2 = localeSorted;
        index2 = format2;
        localeSorted = false;
        if (isNumber$1(format2)) {
          index2 = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
      }
      var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
      if (index2 != null) {
        return get$1(format2, (index2 + shift) % 7, field, "day");
      }
      for (i = 0; i < 7; i++) {
        out[i] = get$1(format2, (i + shift) % 7, field, "day");
      }
      return out;
    }
    function listMonths(format2, index2) {
      return listMonthsImpl(format2, index2, "months");
    }
    function listMonthsShort(format2, index2) {
      return listMonthsImpl(format2, index2, "monthsShort");
    }
    function listWeekdays(localeSorted, format2, index2) {
      return listWeekdaysImpl(localeSorted, format2, index2, "weekdays");
    }
    function listWeekdaysShort(localeSorted, format2, index2) {
      return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysShort");
    }
    function listWeekdaysMin(localeSorted, format2, index2) {
      return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysMin");
    }
    getSetGlobalLocale("en", {
      eras: [
        {
          since: "0001-01-01",
          until: Infinity,
          offset: 1,
          name: "Anno Domini",
          narrow: "AD",
          abbr: "AD"
        },
        {
          since: "0000-12-31",
          until: -Infinity,
          offset: 1,
          name: "Before Christ",
          narrow: "BC",
          abbr: "BC"
        }
      ],
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function(number) {
        var b2 = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b2 === 1 ? "st" : b2 === 2 ? "nd" : b2 === 3 ? "rd" : "th";
        return number + output;
      }
    });
    hooks.lang = deprecate(
      "moment.lang is deprecated. Use moment.locale instead.",
      getSetGlobalLocale
    );
    hooks.langData = deprecate(
      "moment.langData is deprecated. Use moment.localeData instead.",
      getLocale
    );
    var mathAbs = Math.abs;
    function abs() {
      var data = this._data;
      this._milliseconds = mathAbs(this._milliseconds);
      this._days = mathAbs(this._days);
      this._months = mathAbs(this._months);
      data.milliseconds = mathAbs(data.milliseconds);
      data.seconds = mathAbs(data.seconds);
      data.minutes = mathAbs(data.minutes);
      data.hours = mathAbs(data.hours);
      data.months = mathAbs(data.months);
      data.years = mathAbs(data.years);
      return this;
    }
    function addSubtract$1(duration, input, value, direction) {
      var other = createDuration(input, value);
      duration._milliseconds += direction * other._milliseconds;
      duration._days += direction * other._days;
      duration._months += direction * other._months;
      return duration._bubble();
    }
    function add$1(input, value) {
      return addSubtract$1(this, input, value, 1);
    }
    function subtract$1(input, value) {
      return addSubtract$1(this, input, value, -1);
    }
    function absCeil(number) {
      if (number < 0) {
        return Math.floor(number);
      } else {
        return Math.ceil(number);
      }
    }
    function bubble() {
      var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
      if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
        milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
        days2 = 0;
        months2 = 0;
      }
      data.milliseconds = milliseconds2 % 1e3;
      seconds2 = absFloor(milliseconds2 / 1e3);
      data.seconds = seconds2 % 60;
      minutes2 = absFloor(seconds2 / 60);
      data.minutes = minutes2 % 60;
      hours2 = absFloor(minutes2 / 60);
      data.hours = hours2 % 24;
      days2 += absFloor(hours2 / 24);
      monthsFromDays = absFloor(daysToMonths(days2));
      months2 += monthsFromDays;
      days2 -= absCeil(monthsToDays(monthsFromDays));
      years2 = absFloor(months2 / 12);
      months2 %= 12;
      data.days = days2;
      data.months = months2;
      data.years = years2;
      return this;
    }
    function daysToMonths(days2) {
      return days2 * 4800 / 146097;
    }
    function monthsToDays(months2) {
      return months2 * 146097 / 4800;
    }
    function as(units) {
      if (!this.isValid()) {
        return NaN;
      }
      var days2, months2, milliseconds2 = this._milliseconds;
      units = normalizeUnits(units);
      if (units === "month" || units === "quarter" || units === "year") {
        days2 = this._days + milliseconds2 / 864e5;
        months2 = this._months + daysToMonths(days2);
        switch (units) {
          case "month":
            return months2;
          case "quarter":
            return months2 / 3;
          case "year":
            return months2 / 12;
        }
      } else {
        days2 = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
          case "week":
            return days2 / 7 + milliseconds2 / 6048e5;
          case "day":
            return days2 + milliseconds2 / 864e5;
          case "hour":
            return days2 * 24 + milliseconds2 / 36e5;
          case "minute":
            return days2 * 1440 + milliseconds2 / 6e4;
          case "second":
            return days2 * 86400 + milliseconds2 / 1e3;
          case "millisecond":
            return Math.floor(days2 * 864e5) + milliseconds2;
          default:
            throw new Error("Unknown unit " + units);
        }
      }
    }
    function makeAs(alias) {
      return function() {
        return this.as(alias);
      };
    }
    var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y"), valueOf$1 = asMilliseconds;
    function clone$1() {
      return createDuration(this);
    }
    function get$2(units) {
      units = normalizeUnits(units);
      return this.isValid() ? this[units + "s"]() : NaN;
    }
    function makeGetter(name) {
      return function() {
        return this.isValid() ? this._data[name] : NaN;
      };
    }
    var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
    function weeks() {
      return absFloor(this.days() / 7);
    }
    var round = Math.round, thresholds = {
      ss: 44,
      // a few seconds to seconds
      s: 45,
      // seconds to minute
      m: 45,
      // minutes to hour
      h: 22,
      // hours to day
      d: 26,
      // days to month/week
      w: null,
      // weeks to month
      M: 11
      // months to year
    };
    function substituteTimeAgo(string2, number, withoutSuffix, isFuture, locale2) {
      return locale2.relativeTime(number || 1, !!withoutSuffix, string2, isFuture);
    }
    function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
      var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
      if (thresholds2.w != null) {
        a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
      }
      a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
      a[2] = withoutSuffix;
      a[3] = +posNegDuration > 0;
      a[4] = locale2;
      return substituteTimeAgo.apply(null, a);
    }
    function getSetRelativeTimeRounding(roundingFunction) {
      if (roundingFunction === void 0) {
        return round;
      }
      if (typeof roundingFunction === "function") {
        round = roundingFunction;
        return true;
      }
      return false;
    }
    function getSetRelativeTimeThreshold(threshold, limit) {
      if (thresholds[threshold] === void 0) {
        return false;
      }
      if (limit === void 0) {
        return thresholds[threshold];
      }
      thresholds[threshold] = limit;
      if (threshold === "s") {
        thresholds.ss = limit - 1;
      }
      return true;
    }
    function humanize(argWithSuffix, argThresholds) {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      var withSuffix = false, th2 = thresholds, locale2, output;
      if (typeof argWithSuffix === "object") {
        argThresholds = argWithSuffix;
        argWithSuffix = false;
      }
      if (typeof argWithSuffix === "boolean") {
        withSuffix = argWithSuffix;
      }
      if (typeof argThresholds === "object") {
        th2 = Object.assign({}, thresholds, argThresholds);
        if (argThresholds.s != null && argThresholds.ss == null) {
          th2.ss = argThresholds.s - 1;
        }
      }
      locale2 = this.localeData();
      output = relativeTime$1(this, !withSuffix, th2, locale2);
      if (withSuffix) {
        output = locale2.pastFuture(+this, output);
      }
      return locale2.postformat(output);
    }
    var abs$1 = Math.abs;
    function sign(x2) {
      return (x2 > 0) - (x2 < 0) || +x2;
    }
    function toISOString$1() {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
      if (!total) {
        return "P0D";
      }
      minutes2 = absFloor(seconds2 / 60);
      hours2 = absFloor(minutes2 / 60);
      seconds2 %= 60;
      minutes2 %= 60;
      years2 = absFloor(months2 / 12);
      months2 %= 12;
      s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
      totalSign = total < 0 ? "-" : "";
      ymSign = sign(this._months) !== sign(total) ? "-" : "";
      daysSign = sign(this._days) !== sign(total) ? "-" : "";
      hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
      return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
    }
    var proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale$4;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate(
      "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
      toISOString$1
    );
    proto$2.lang = lang;
    addFormatToken("X", 0, 0, "unix");
    addFormatToken("x", 0, 0, "valueOf");
    addRegexToken("x", matchSigned);
    addRegexToken("X", matchTimestamp);
    addParseToken("X", function(input, array, config) {
      config._d = new Date(parseFloat(input) * 1e3);
    });
    addParseToken("x", function(input, array, config) {
      config._d = new Date(toInt(input));
    });
    //! moment.js
    hooks.version = "2.30.1";
    setHookCallback(createLocal);
    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate$1;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;
    hooks.HTML5_FMT = {
      DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
      // <input type="datetime-local" />
      DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
      // <input type="datetime-local" step="1" />
      DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
      // <input type="datetime-local" step="0.001" />
      DATE: "YYYY-MM-DD",
      // <input type="date" />
      TIME: "HH:mm",
      // <input type="time" />
      TIME_SECONDS: "HH:mm:ss",
      // <input type="time" step="1" />
      TIME_MS: "HH:mm:ss.SSS",
      // <input type="time" step="0.001" />
      WEEK: "GGGG-[W]WW",
      // <input type="week" />
      MONTH: "YYYY-MM"
      // <input type="month" />
    };
    const useCollectionAdd$1 = () => {
      const { handleSaveColumn } = usePostCollectionAdd();
      const nowdatestring = hooks().format("YYYY-MM-DD");
      const [notices, setNotices] = reactExports.useState([]);
      const [formData, setFormData] = reactExports.useState({
        tenement_address: "",
        collection_id: "",
        collection_name: "水電空調費",
        collection_type: "代收",
        price: "",
        payment: "現金",
        collection_remark: "",
        remittance_bank: "",
        remittance_account: "",
        cus_remittance_account: "",
        cus_remittance_bank: "",
        collection_date: nowdatestring,
        collection_complete: "是"
      });
      const handleChange = (key, value) => {
        setFormData((prevFormData) => ({
          ...prevFormData,
          [key]: value
        }));
      };
      const handleNoticeChange = (index2, key, value) => {
        setNotices((prevNotices) => {
          const newNotices = [...prevNotices];
          newNotices[index2] = {
            ...newNotices[index2],
            [key]: value
          };
          return newNotices;
        });
      };
      const handleDeleteNotice = (index2) => {
        setNotices((prevNotices) => {
          const newNotices = [...prevNotices];
          newNotices.splice(index2, 1);
          return newNotices;
        });
      };
      const handleSave = async () => {
        const schemaform = z.object({
          tenement_address: z.string().min(2, "地址至少兩個字"),
          collection_name: z.string(),
          collection_id: z.string(),
          collection_type: z.string(),
          price: z.string().nonempty("金額不得為空"),
          payment: z.string(),
          collection_remark: z.string(),
          remittance_bank: z.string(),
          remittance_account: z.string(),
          cus_remittance_account: z.string(),
          cus_remittance_bank: z.string(),
          collection_date: z.string(),
          collection_complete: z.string()
        });
        const parseResult = schemaform.safeParse(formData);
        if (!parseResult.success) {
          const errorMessages = parseResult.error.errors.map((error) => {
            return error.message;
          });
          alert(errorMessages.join("\n"));
          return;
        }
        const columnData = await handleSaveColumn(parseResult.data);
        if (!columnData) {
          alert("儲存失敗");
          return;
        }
        const noticeData = notices.map((notice) => {
          return {
            visitDate: notice.visitDate,
            record: notice.record,
            remindDate: notice.remindDate,
            remind: notice.remind,
            collection_id: columnData.data.collection_id
          };
        });
        await handlePostAddNotice("collection", noticeData);
        alert("儲存成功");
      };
      const handleReset = () => {
        setFormData({
          tenement_address: "",
          collection_id: "",
          collection_name: "水電空調費",
          collection_type: "代收",
          price: "",
          payment: "現金",
          collection_remark: "",
          remittance_bank: "",
          remittance_account: "",
          cus_remittance_account: "",
          cus_remittance_bank: "",
          collection_date: nowdatestring,
          collection_complete: "是"
        });
        setNotices([]);
      };
      const handleAddNotice = () => {
        setNotices((prevNotices) => [
          ...prevNotices,
          {
            id: Math.random().toString(),
            visitDate: nowdatestring,
            record: "",
            remindDate: nowdatestring,
            remind: "",
            isNew: true
          }
        ]);
      };
      return {
        formData,
        notices,
        handleChange,
        handleNoticeChange,
        handleSave,
        handleReset,
        handleAddNotice,
        handleDeleteNotice
      };
    };
    const Collection$1 = () => {
      const {
        formData,
        notices,
        handleChange,
        handleNoticeChange,
        handleSave,
        handleReset,
        handleAddNotice,
        handleDeleteNotice
      } = useCollectionAdd$1();
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        CollectionMange$1,
        {
          formData,
          notices,
          handleChange,
          handleNoticeChange,
          handleSave,
          handleReset,
          handleAddNotice,
          handleDeleteNotice
        }
      );
    };
    const useCollectionEdit$1 = () => {
      const { getCollectionEdit, isError, isLoading, dataEdit } = useGetCollectionEdit();
      const {
        handleSaveColumn,
        handleDeleteCollectionFetch
      } = usePostCollectionEdit();
      const { handlePutNotice } = usePutNotice();
      const { handleDeleteNoticeApi } = useDeleteNotice();
      const getparamid = useParams().id;
      const query = new URLSearchParams(window.location.search);
      const isRollback = query.get("rollback") || false;
      const nowdatestring = hooks().format("YYYY-MM-DD");
      const { id: id2 } = useParams();
      const [notices, setNotices] = reactExports.useState([]);
      const [formData, setFormData] = reactExports.useState({
        tenement_address: "",
        collection_id: "",
        collection_name: "",
        collection_type: "",
        price: "",
        payment: "",
        collection_remark: "",
        collection_date: nowdatestring,
        remittance_bank: "",
        remittance_account: "",
        cus_remittance_account: "",
        cus_remittance_bank: "",
        collection_complete: ""
      });
      const handleChange = (key, value) => {
        setFormData((prevFormData) => ({
          ...prevFormData,
          [key]: value
        }));
      };
      const handleNoticeChange = (index2, key, value) => {
        setNotices((prevNotices) => {
          const newNotices = [...prevNotices];
          newNotices[index2] = {
            ...newNotices[index2],
            [key]: value
          };
          return newNotices;
        });
      };
      const handleDeleteNotice = (index2) => {
        handleDeleteNoticeApi(notices[index2].id, "collection");
        setNotices((prevNotices) => {
          const newNotices = [...prevNotices];
          newNotices.splice(index2, 1);
          return newNotices;
        });
        if (notices[index2].isNew)
          return;
      };
      const handleDeleteCollection = () => {
        confirm("確定要刪除嗎？");
        !isRollback && handleDeleteCollectionFetch(id2 || "");
        isRollback && deleteCollectionFetchFn(id2 || "");
        alert("刪除成功");
      };
      const handleSave = async () => {
        if (!id2)
          return;
        const schemaform = z.object({
          tenement_address: z.string().min(2, "地址至少兩個字"),
          collection_name: z.string(),
          collection_type: z.string(),
          price: z.string().nonempty("金額不得為空"),
          payment: z.string(),
          collection_remark: z.string(),
          collection_date: z.string(),
          remittance_bank: z.string(),
          remittance_account: z.string(),
          cus_remittance_account: z.string(),
          cus_remittance_bank: z.string(),
          collection_complete: z.string()
        });
        const parseResult = schemaform.safeParse(formData);
        if (!parseResult.success) {
          const errorMessages = parseResult.error.errors.map((error) => {
            return error.message;
          });
          alert(errorMessages.join("\n"));
          return;
        }
        const newformdata = {
          ...parseResult.data,
          collection_id: id2
        };
        await handleSaveColumn(newformdata);
        if (notices.length > 0) {
          await handlePutNotice("collection", notices);
        }
        alert("儲存成功");
      };
      const handleReset = () => {
        setFormData({
          tenement_address: "",
          collection_id: "",
          collection_name: "水費",
          collection_type: "代收",
          price: "",
          payment: "現金",
          collection_remark: "",
          collection_date: nowdatestring,
          remittance_bank: "",
          remittance_account: "",
          cus_remittance_account: "",
          cus_remittance_bank: "",
          collection_complete: ""
        });
        setNotices([]);
      };
      const handleAddNotice = async () => {
        const newNotice = {
          visitDate: nowdatestring,
          record: "",
          remindDate: nowdatestring,
          remind: "",
          collection_id: Number(getparamid)
        };
        const newNoticeData = await handlePostAddNotice("collection", [newNotice]);
        if (newNoticeData === void 0)
          return;
        setNotices((prevNotices) => {
          return [...prevNotices, ...newNoticeData];
        });
      };
      const getapi = async () => {
        if (!id2)
          return;
        await getCollectionEdit(id2);
      };
      reactExports.useEffect(() => {
        getapi();
      }, []);
      reactExports.useEffect(() => {
        if (!dataEdit || dataEdit.notices === void 0)
          return;
        setFormData({
          tenement_address: dataEdit.tenement_address,
          collection_id: dataEdit.collection_id,
          collection_name: dataEdit.collection_name,
          collection_type: dataEdit.collection_type,
          price: dataEdit.price,
          payment: dataEdit.payment,
          collection_remark: dataEdit.collection_remark,
          remittance_bank: dataEdit.remittance_bank,
          remittance_account: dataEdit.remittance_account,
          collection_date: dataEdit.collection_date,
          cus_remittance_account: dataEdit.cus_remittance_account,
          cus_remittance_bank: dataEdit.cus_remittance_bank,
          collection_complete: dataEdit.collection_complete
        });
        setNotices(dataEdit.notices);
      }, [dataEdit]);
      return {
        formData,
        notices,
        handleChange,
        handleNoticeChange,
        handleSave,
        handleReset,
        handleAddNotice,
        handleDeleteNotice,
        handleDeleteCollection,
        isLoading,
        isError
      };
    };
    const Collection = () => {
      const {
        formData,
        notices,
        handleChange,
        handleNoticeChange,
        handleSave,
        handleReset,
        handleAddNotice,
        handleDeleteNotice,
        handleDeleteCollection,
        isLoading,
        isError
      } = useCollectionEdit$1();
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        CollectionMange$1,
        {
          formData,
          notices,
          handleChange,
          handleNoticeChange,
          handleSave,
          handleReset,
          handleAddNotice,
          handleDeleteNotice,
          handleDeleteCollection,
          isLoading,
          isError
        }
      );
    };
    function CollectionMange(props) {
      const navigate = useNavigate();
      const query = new URLSearchParams(window.location.search);
      const isRollback = query.get("rollback") || false;
      const isAdd = window.location.pathname === "/user";
      const handleback = () => {
        navigate(isRollback ? "/rollback/users" : "/users");
      };
      const {
        formData,
        handleChange,
        handleSave,
        handleReset,
        isLoading,
        isError,
        handleDeleteUser
      } = props;
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col w-full h-full ", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col w-4/5 h-full p-10 mt-12 bg-white shadow-2xl mx-36 rounded-xl ", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "flex w-12 h-20", onClick: handleback, children: "< 返回" }),
        isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 ", children: "loading..." }) : isError ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 ", children: "error..." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inline-flex flex-col ml-5", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-4xl whitespace-normal", children: [
            isRollback && "復原",
            "使用者管理"
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col flex-wrap w-2/3 h-full gap-10 p-10 overflow-visible ", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-2 pt-5", children: "使用者名稱:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                InputWithErrorMessage,
                {
                  value: formData.user_name,
                  onChange: (e2) => handleChange("user_name", e2.target.value),
                  isError: formData.user_name.length <= 2,
                  errorMessage: "至少兩個字"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right ", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-2 pt-5", children: "使用者信箱:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                InputWithErrorMessage,
                {
                  value: formData.user_email,
                  onChange: (e2) => handleChange("user_email", e2.target.value),
                  isError: !formData.user_email.includes("@"),
                  errorMessage: "email格式錯誤"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right ", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-2 pt-5 whitespace-nowrap", children: "使用者密碼:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                InputWithErrorMessage,
                {
                  value: formData.user_password,
                  onChange: (e2) => handleChange("user_password", e2.target.value),
                  isError: false,
                  errorMessage: "至少六個字"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-2 ", children: "是否啟用:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Select$1,
                {
                  defaultValue: "是",
                  className: "col-span-1",
                  options: [{ value: "是" }, { value: "否" }],
                  onChange: (value) => handleChange("status", value),
                  value: formData.status
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-2 ", children: "管理員權限:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Select$1,
                {
                  defaultValue: "是",
                  className: "col-span-1",
                  options: [{ value: "是" }, { value: "否" }],
                  onChange: (value) => handleChange("isadmin", value),
                  value: formData.isadmin
                }
              )
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-end gap-5 m-10 ", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { className: "bg-blue-600 ", type: "primary", onClick: handleSave, children: isRollback ? "復原" : "儲存" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { type: "default", onClick: () => handleReset(), children: "回復預設" }),
          isAdd ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { danger: true, onClick: () => handleDeleteUser(), children: isRollback ? "永久刪除" : "刪除" })
        ] })
      ] }) });
    }
    const useCollectionAdd = () => {
      const { isLoading, isError, handleSaveUser } = usePostUserAdd();
      const [formData, setFormData] = reactExports.useState({
        user_name: "",
        user_email: "",
        status: "是",
        user_password: "",
        isadmin: "否"
      });
      const handleChange = (key, value) => {
        setFormData((prevFormData) => ({
          ...prevFormData,
          [key]: value
        }));
      };
      const handleSave = async () => {
        const schema = z.object({
          user_name: z.string().min(2, "請輸入至少兩個以上的名字"),
          user_email: z.string().email("不符合Email格式"),
          status: z.string(),
          user_password: z.string().min(6, "請輸入至少六個以上的密碼"),
          isadmin: z.string()
        });
        const parseResult = schema.safeParse(formData);
        if (!parseResult.success) {
          const errorMessages = parseResult.error.errors.map((error) => {
            return error.message;
          });
          alert(errorMessages.join("\n"));
          return;
        }
        await handleSaveUser(parseResult.data);
        alert("儲存成功");
      };
      const handleReset = () => {
        setFormData({
          user_name: "",
          user_email: "",
          status: "是",
          user_password: "",
          isadmin: "否"
        });
      };
      return {
        formData,
        handleChange,
        handleSave,
        handleReset,
        isLoading,
        isError
      };
    };
    const UserAdd = () => {
      const { formData, handleChange, handleSave, handleReset } = useCollectionAdd();
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        CollectionMange,
        {
          formData,
          handleChange,
          handleSave,
          handleReset
        }
      );
    };
    const useCollectionEdit = () => {
      const { isLoading, isError, handleSaveUser, handleDeleteUserFetch } = usePostUserEdit();
      const { getUserEdit, dataEdit } = useGetUserEdit();
      const { user_id } = useParams();
      const query = new URLSearchParams(location.search);
      const isRollback = query.get("rollback") || false;
      const [formData, setFormData] = reactExports.useState({
        user_name: "",
        user_email: "",
        status: "是",
        user_password: "",
        isadmin: "否"
      });
      const handleChange = (key, value) => {
        setFormData((prevFormData) => ({
          ...prevFormData,
          [key]: value
        }));
      };
      const handleSave = async () => {
        if (!user_id)
          return;
        const newformdata = {
          ...formData,
          user_id
        };
        const schema = z.object({
          user_name: z.string().min(2, "請輸入至少兩個以上的名字"),
          user_email: z.string().email("不符合Email格式"),
          status: z.string(),
          user_password: z.string(),
          isadmin: z.string(),
          user_id: z.string()
        });
        const parseResult = schema.safeParse(newformdata);
        if (!parseResult.success) {
          const errorMessages = parseResult.error.errors.map((error) => {
            return error.message;
          });
          alert(errorMessages.join("\n"));
          return;
        }
        await handleSaveUser(parseResult.data);
        alert("儲存成功");
      };
      const handleDeleteUser = () => {
        confirm("確定要刪除嗎？");
        !isRollback && handleDeleteUserFetch(user_id || "");
        isRollback && handleHardDeleteUser(user_id || "");
      };
      const handleReset = () => {
        setFormData({
          user_name: "",
          user_email: "",
          status: "是",
          user_password: "",
          isadmin: "否"
        });
      };
      const getapi = async () => {
        if (!user_id)
          return;
        await getUserEdit(user_id);
      };
      reactExports.useEffect(() => {
        getapi();
      }, []);
      reactExports.useEffect(() => {
        if (!dataEdit)
          return;
        setFormData({
          user_name: dataEdit.user_name,
          user_email: dataEdit.user_email,
          status: dataEdit.status,
          user_password: dataEdit.user_password,
          isadmin: dataEdit.isadmin
        });
      }, [dataEdit]);
      return {
        formData,
        handleChange,
        handleSave,
        handleReset,
        isLoading,
        isError,
        handleDeleteUser
      };
    };
    const UserEdit = () => {
      const {
        formData,
        handleChange,
        handleSave,
        handleReset,
        handleDeleteUser,
        isLoading,
        isError
      } = useCollectionEdit();
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        CollectionMange,
        {
          formData,
          handleChange,
          handleSave,
          handleReset,
          isLoading,
          isError,
          handleDeleteUser
        }
      );
    };
    const useCollectionList = () => {
      const [data, setData] = reactExports.useState([
        {
          user_id: "1",
          user_name: "翁先生",
          user_email: "user@gmail.com",
          status: "是"
        },
        {
          user_id: "2",
          user_name: "李先生",
          user_email: "user2@gmail.com",
          status: "是"
        },
        {
          user_id: "3",
          user_name: "張先生",
          user_email: "user3@gmail.com",
          status: "是"
        },
        {
          user_id: "4",
          user_name: "陳先生",
          user_email: "user4@gmail.com",
          status: "否"
        }
      ]);
      const columns = [
        {
          title: "編號",
          dataIndex: "user_id"
        },
        {
          title: "使用者名稱",
          dataIndex: "user_name"
        },
        {
          title: "使用者信箱",
          dataIndex: "user_email"
        },
        {
          title: "是否啟用",
          dataIndex: "status",
          filters: [
            {
              text: "是",
              value: "是"
            },
            {
              text: "否",
              value: "否"
            }
          ],
          onFilter: (value, record) => record.status.indexOf(value) === 0
        }
      ];
      const { isLoading, isError, dataUser } = useGetUserList();
      reactExports.useEffect(() => {
        if (dataUser) {
          const newdatauser = dataUser.map((user) => {
            return {
              user_id: user.user_id,
              user_name: user.user_name,
              user_email: user.user_email,
              status: user.status,
              key: user.user_id
            };
          });
          setData(newdatauser);
        }
      }, [dataUser]);
      const navigate = useNavigate();
      const onRow = (record) => {
        return {
          onClick: () => {
            navigate(`/User/${record.user_id}`);
          }
        };
      };
      return {
        data,
        columns,
        onRow,
        isLoading,
        isError
      };
    };
    const CollectionList = () => {
      const { data, columns, onRow, isError, isLoading } = useCollectionList();
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center w-4/5 m-10 ", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inline-flex items-center mb-10 justify-evenly w-96", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-4xl ", children: "使用者列表" }) }),
        isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "loading..." }) : isError ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "error..." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(TableCompoent, { data, columns, onRow })
      ] });
    };
    const AuthContext = reactExports.createContext(void 0);
    const AuthProvider = ({ children }) => {
      const [isLogin, setIsLogin] = reactExports.useState(false);
      const token2 = useToken();
      const userRoleHook = useGetUserRole(token2);
      const naviate = useNavigate();
      const location2 = useLocation();
      reactExports.useEffect(() => {
        if (token2) {
          setIsLogin(true);
          userRoleHook.getUserRole().catch((err) => {
            alert("登入逾時，請重新登入");
            console.error(err);
            localStorage.removeItem("token");
            naviate("/login");
          });
        }
      }, [token2, location2.pathname]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(AuthContext.Provider, { value: { isLogin, isAdmin: userRoleHook.isAdmin }, children });
    };
    const useAuth = () => {
      const authContextValue = reactExports.useContext(AuthContext);
      if (!authContextValue) {
        throw new Error("useAuth 必須在 AuthProvider 內使用");
      }
      return authContextValue;
    };
    function getItem(label, key, icon, children, type) {
      return {
        key,
        icon,
        children,
        label,
        type
      };
    }
    const isAdminMenuItems = [
      getItem("登出", "login", void 0, void 0),
      getItem("代收付管理", "collectionmange", void 0, [
        getItem("代收付管理列表", "collections"),
        getItem("代收付管理新增", "Collection/Add")
      ]),
      getItem("房屋管理", "tenementmange", void 0, [
        getItem("出租列表", "Tenements/Rent"),
        getItem("出售列表", "Tenements/Sell"),
        getItem("房屋管理列表", "Tenements"),
        getItem("房屋管理新增", "Tenement/Add")
      ]),
      getItem("提醒月曆", "calendarmange", void 0, [
        getItem("提醒事項列表", "Calenderlist"),
        getItem("代收付提醒列表", "Calenderlist_collection")
      ]),
      getItem("使用者管理", "usermange", void 0, [
        getItem("使用者管理列表", "users"),
        getItem("使用者管理新增", "user")
      ]),
      getItem("復原管理", "rollback", void 0, [
        getItem("房屋復原管理", "rollback/tenements"),
        getItem("代收付復原管理", "rollback/collections"),
        getItem("使用者復原管理", "rollback/users")
      ])
    ];
    const isNotAdminMenuItems = [...isAdminMenuItems.slice(0, 4)];
    const Menus = () => {
      const navigate = useNavigate();
      const { isAdmin } = useAuth();
      const [menuItems, setMenuItems] = reactExports.useState([]);
      reactExports.useEffect(() => {
        setMenuItems(isAdmin ? isAdminMenuItems : isNotAdminMenuItems);
      }, [isAdmin]);
      const onClick = (e2) => {
        if (e2.key && e2.key.toString() !== "") {
          navigate("/" + e2.key.toString());
        }
        if (e2.key === "login") {
          localStorage.removeItem("token");
          navigate("/login");
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Menu$1,
        {
          onClick,
          style: { width: 256 },
          defaultSelectedKeys: ["1"],
          defaultOpenKeys: ["sub1"],
          mode: "inline",
          items: menuItems,
          className: "sticky top-0 h-screen max-h-screen pt-10 overflow-y-auto bg-blue-100"
        }
      );
    };
    function Layout() {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex w-full h-full min-h-screen bg-gray-100 ", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Menus, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Outlet, {})
      ] });
    }
    function CalenderTable(props) {
      const { handleGetCalender, dataCalender } = props;
      const [yearClick, setYearClick] = reactExports.useState(0);
      const [monthClick, setMonthClick] = reactExports.useState(0);
      const handleGetCalenderData = (date) => {
        const year = date.year();
        const month = date.month() + 1;
        setYearClick(year);
        setMonthClick(month);
        handleGetCalender({ year, month });
      };
      const getEventType = (classType) => {
        switch (classType) {
          case "collection":
            return "green";
          case "rent":
            return "red";
          case "sell":
            return "gray";
          case "develop":
            return "blue";
          case "market":
            return "gold";
          case "pay":
            return "red";
          case "prepay":
            return "blue";
        }
      };
      const transformEvent = (event, year, month) => {
        const eventDataWithDate = {
          ...event,
          year,
          month,
          events: event.events.map((event2) => ({
            ...event2,
            type: getEventType(event2.class)
          }))
        };
        console.log(eventDataWithDate);
        return eventDataWithDate;
      };
      const getTransformedEvent = (year, month) => {
        const transformedData = dataCalender.map(
          (event) => transformEvent(event, year, month)
        );
        return transformedData;
      };
      const getListData = (value) => {
        const year = value.year();
        const month = value.month() + 1;
        const day = value.date();
        const transformedData = getTransformedEvent(yearClick, monthClick);
        const matchingDay = transformedData.find(
          (event) => event.year === year && event.month === month && event.day === day
        );
        return matchingDay ? matchingDay.events.map((event) => ({
          type: event.type,
          content: event.content,
          id: event.id,
          class: event.class
        })) : [];
      };
      const switchparam = (param, id2) => {
        console.log(param, id2);
        switch (param) {
          case "market":
            return `/Tenement/${id2}/market?tenement_type=行銷追蹤`;
          case "rent":
            return `/Tenement/${id2}/rent?tenement_type=出租`;
          case "sell":
            return `/Tenement/${id2}/sell?tenement_type=出售`;
          case "develop":
            return `/Tenement/${id2}/develop?tenement_type=開發追蹤`;
          case "collection":
            return `/Collection/${id2}`;
          case "pay":
            return `/Collection/${id2}`;
          case "prepay":
            return `/Collection/${id2}`;
          default:
            return `/Calenderlist`;
        }
      };
      const dateCellRender = (value) => {
        const listData = getListData(value);
        const navigate = useNavigate();
        return /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "events", children: listData.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          "li",
          {
            onClick: () => {
              navigate(switchparam(item.class, item.id));
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Badge$1,
              {
                color: item.type,
                text: item.content
              }
            )
          },
          index2
        )) });
      };
      const cellRender = (current, info) => {
        if (info.type === "date")
          return dateCellRender(current);
        return info.originNode;
      };
      reactExports.useEffect(() => {
        handleGetCalenderData(dayjs());
      }, []);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Calendar$1,
        {
          cellRender,
          onPanelChange: (date) => handleGetCalenderData(date)
        }
      ) });
    }
    const CalenderList$1 = () => {
      const { isLoading, isError, handleGetCalender, dataCalender } = usePostCalender();
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center w-4/5 m-10 ", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inline-flex items-center mb-10 justify-evenly w-96", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inline-flex items-center justify-evenly w-96", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-4xl ", children: "提醒事項列表" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex p-4 site-calendar-custom-header gap-x-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "w-4 h-4 bg-green-400 rounded-full" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs", children: "代收付事項" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "w-4 h-4 bg-red-500 rounded-full" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs", children: "租房事項" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "w-4 h-4 bg-gray-400 rounded-full" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs", children: "售房事項" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "w-4 h-4 bg-blue-400 rounded-full" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs", children: "開發追蹤事項" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "w-4 h-4 bg-orange-400 rounded-full" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs", children: "行銷追蹤事項" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          CalenderTable,
          {
            isLoading,
            isError,
            handleGetCalender,
            dataCalender
          }
        )
      ] });
    };
    function bind(fn, thisArg) {
      return function wrap() {
        return fn.apply(thisArg, arguments);
      };
    }
    const { toString } = Object.prototype;
    const { getPrototypeOf } = Object;
    const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
      const str = toString.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    const kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    const typeOfTest = (type) => (thing) => typeof thing === type;
    const { isArray } = Array;
    const isUndefined = typeOfTest("undefined");
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    const isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    const isString = typeOfTest("string");
    const isFunction = typeOfTest("function");
    const isNumber = typeOfTest("number");
    const isObject = (thing) => thing !== null && typeof thing === "object";
    const isBoolean = (thing) => thing === true || thing === false;
    const isPlainObject = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
    };
    const isDate = kindOfTest("Date");
    const isFile = kindOfTest("File");
    const isBlob = kindOfTest("Blob");
    const isFileList = kindOfTest("FileList");
    const isStream = (val) => isObject(val) && isFunction(val.pipe);
    const isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
    };
    const isURLSearchParams = kindOfTest("URLSearchParams");
    const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach(obj, fn, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i;
      let l2;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (i = 0, l2 = obj.length; i < l2; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys2.length;
        let key;
        for (i = 0; i < len; i++) {
          key = keys2[i];
          fn.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey(obj, key) {
      key = key.toLowerCase();
      const keys2 = Object.keys(obj);
      let i = keys2.length;
      let _key;
      while (i-- > 0) {
        _key = keys2[i];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    const _global = (() => {
      if (typeof globalThis !== "undefined")
        return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    const isContextDefined = (context) => !isUndefined(context) && context !== _global;
    function merge() {
      const { caseless } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue = (val, key) => {
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
          result[targetKey] = merge(result[targetKey], val);
        } else if (isPlainObject(val)) {
          result[targetKey] = merge({}, val);
        } else if (isArray(val)) {
          result[targetKey] = val.slice();
        } else {
          result[targetKey] = val;
        }
      };
      for (let i = 0, l2 = arguments.length; i < l2; i++) {
        arguments[i] && forEach(arguments[i], assignValue);
      }
      return result;
    }
    const extend = (a, b2, thisArg, { allOwnKeys } = {}) => {
      forEach(b2, (val, key) => {
        if (thisArg && isFunction(val)) {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      }, { allOwnKeys });
      return a;
    };
    const stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    const inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
      let props;
      let i;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null)
        return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    const endsWith = (str, searchString, position2) => {
      str = String(str);
      if (position2 === void 0 || position2 > str.length) {
        position2 = str.length;
      }
      position2 -= searchString.length;
      const lastIndex = str.indexOf(searchString, position2);
      return lastIndex !== -1 && lastIndex === position2;
    };
    const toArray = (thing) => {
      if (!thing)
        return null;
      if (isArray(thing))
        return thing;
      let i = thing.length;
      if (!isNumber(i))
        return null;
      const arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    };
    const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    const forEachEntry = (obj, fn) => {
      const generator = obj && obj[Symbol.iterator];
      const iterator = generator.call(obj);
      let result;
      while ((result = iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };
    const matchAll = (regExp, str) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    const isHTMLForm = kindOfTest("HTMLFormElement");
    const toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer(m2, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
    const isRegExp = kindOfTest("RegExp");
    const reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors2, (descriptor, name) => {
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) {
          reducedDescriptors[name] = ret || descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    const freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
          return false;
        }
        const value = obj[name];
        if (!isFunction(value))
          return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name + "'");
          };
        }
      });
    };
    const toObjectSet = (arrayOrString, delimiter2) => {
      const obj = {};
      const define = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter2));
      return obj;
    };
    const noop = () => {
    };
    const toFiniteNumber = (value, defaultValue) => {
      value = +value;
      return Number.isFinite(value) ? value : defaultValue;
    };
    const ALPHA = "abcdefghijklmnopqrstuvwxyz";
    const DIGIT = "0123456789";
    const ALPHABET = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    };
    const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
      let str = "";
      const { length: length2 } = alphabet;
      while (size--) {
        str += alphabet[Math.random() * length2 | 0];
      }
      return str;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
    }
    const toJSONObject = (obj) => {
      const stack = new Array(10);
      const visit = (source, i) => {
        if (isObject(source)) {
          if (stack.indexOf(source) >= 0) {
            return;
          }
          if (!("toJSON" in source)) {
            stack[i] = source;
            const target = isArray(source) ? [] : {};
            forEach(source, (value, key) => {
              const reducedValue = visit(value, i + 1);
              !isUndefined(reducedValue) && (target[key] = reducedValue);
            });
            stack[i] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit(obj, 0);
    };
    const isAsyncFn = kindOfTest("AsyncFunction");
    const isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
    const utils$1 = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isBoolean,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isRegExp,
      isFunction,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty,
      hasOwnProp: hasOwnProperty,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      ALPHABET,
      generateString,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable
    };
    function AxiosError(message, code, config, request, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request && (this.request = request);
      response && (this.response = response);
    }
    utils$1.inherits(AxiosError, Error, {
      toJSON: function toJSON2() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils$1.toJSONObject(this.config),
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    const prototype$1 = AxiosError.prototype;
    const descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code) => {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError.from = (error, code, config, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils$1.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      AxiosError.call(axiosError, error.message, code, config, request, response);
      axiosError.cause = error;
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    const httpAdapter = null;
    function isVisitable(thing) {
      return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
    }
    function removeBrackets(key) {
      return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path, key, dots) {
      if (!path)
        return key;
      return path.concat(key).map(function each(token2, i) {
        token2 = removeBrackets(token2);
        return !dots && i ? "[" + token2 + "]" : token2;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils$1.isArray(arr) && !arr.some(isVisitable);
    }
    const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData(obj, formData, options) {
      if (!utils$1.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new FormData();
      options = utils$1.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils$1.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
      if (!utils$1.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils$1.isDate(value)) {
          return value.toISOString();
        }
        if (!useBlob && utils$1.isBlob(value)) {
          throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        }
        if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
          if (utils$1.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
            key = removeBrackets(key);
            arr.forEach(function each(el2, index2) {
              !(utils$1.isUndefined(el2) || el2 === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
                convertValue(el2)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
      }
      const stack = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path) {
        if (utils$1.isUndefined(value))
          return;
        if (stack.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack.push(value);
        utils$1.forEach(value, function each(el2, key) {
          const result = !(utils$1.isUndefined(el2) || el2 === null) && visitor.call(
            formData,
            el2,
            utils$1.isString(key) ? key.trim() : key,
            path,
            exposedHelpers
          );
          if (result === true) {
            build(el2, path ? path.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils$1.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match5) {
        return charMap[match5];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    const prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append2(name, value) {
      this._pairs.push([name, value]);
    };
    prototype.toString = function toString2(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;
      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    function buildURL(url, params, options) {
      if (!params) {
        return url;
      }
      const _encode = options && options.encode || encode;
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    }
    class InterceptorManager {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
       */
      eject(id2) {
        if (this.handlers[id2]) {
          this.handlers[id2] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils$1.forEach(this.handlers, function forEachHandler(h2) {
          if (h2 !== null) {
            fn(h2);
          }
        });
      }
    }
    const InterceptorManager$1 = InterceptorManager;
    const transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
    const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
    const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
    const platform$1 = {
      isBrowser: true,
      classes: {
        URLSearchParams: URLSearchParams$1,
        FormData: FormData$1,
        Blob: Blob$1
      },
      protocols: ["http", "https", "file", "blob", "url", "data"]
    };
    const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
    const hasStandardBrowserEnv = ((product) => {
      return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
    })(typeof navigator !== "undefined" && navigator.product);
    const hasStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      hasBrowserEnv,
      hasStandardBrowserEnv,
      hasStandardBrowserWebWorkerEnv
    }, Symbol.toStringTag, { value: "Module" }));
    const platform = {
      ...utils,
      ...platform$1
    };
    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path, helpers) {
          if (platform.isNode && utils$1.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        }
      }, options));
    }
    function parsePropPath(name) {
      return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match5) => {
        return match5[0] === "[]" ? "" : match5[1] || match5[0];
      });
    }
    function arrayToObject(arr) {
      const obj = {};
      const keys2 = Object.keys(arr);
      let i;
      const len = keys2.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys2[i];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path, value, target, index2) {
        let name = path[index2++];
        if (name === "__proto__")
          return true;
        const isNumericKey = Number.isFinite(+name);
        const isLast = index2 >= path.length;
        name = !name && utils$1.isArray(target) ? target.length : name;
        if (isLast) {
          if (utils$1.hasOwnProp(target, name)) {
            target[name] = [target[name], value];
          } else {
            target[name] = value;
          }
          return !isNumericKey;
        }
        if (!target[name] || !utils$1.isObject(target[name])) {
          target[name] = [];
        }
        const result = buildPath(path, value, target[name], index2);
        if (result && utils$1.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
      }
      if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
        const obj = {};
        utils$1.forEachEntry(formData, (name, value) => {
          buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils$1.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils$1.trim(rawValue);
        } catch (e2) {
          if (e2.name !== "SyntaxError") {
            throw e2;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    const defaults = {
      transitional: transitionalDefaults,
      adapter: ["xhr", "http"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils$1.isObject(data);
        if (isObjectPayload && utils$1.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils$1.isFormData(data);
        if (isFormData2) {
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data)) {
          return data;
        }
        if (utils$1.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$1.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data);
          } catch (e2) {
            if (strictJSONParsing) {
              if (e2.name === "SyntaxError") {
                throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e2;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*",
          "Content-Type": void 0
        }
      }
    };
    utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
      defaults.headers[method] = {};
    });
    const defaults$1 = defaults;
    const ignoreDuplicateOf = utils$1.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    const parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line2) {
        i = line2.indexOf(":");
        key = line2.substring(0, i).trim().toLowerCase();
        val = line2.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    const $internals = Symbol("internals");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str) {
      const tokens2 = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match5;
      while (match5 = tokensRE.exec(str)) {
        tokens2[match5[1]] = match5[2];
      }
      return tokens2;
    }
    const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
    function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
      if (utils$1.isFunction(filter)) {
        return filter.call(this, value, header);
      }
      if (isHeaderNameFilter) {
        value = header;
      }
      if (!utils$1.isString(value))
        return;
      if (utils$1.isString(filter)) {
        return value.indexOf(filter) !== -1;
      }
      if (utils$1.isRegExp(filter)) {
        return filter.test(value);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char2, str) => {
        return char2.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils$1.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    class AxiosHeaders {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils$1.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils$1.isFunction(parser)) {
              return parser.call(this, value, key);
            }
            if (utils$1.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
      delete(header, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils$1.findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils$1.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys2 = Object.keys(this);
        let i = keys2.length;
        let deleted = false;
        while (i--) {
          const key = keys2[i];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format2) {
        const self2 = this;
        const headers = {};
        utils$1.forEach(this, (value, header) => {
          const key = utils$1.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format2 ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils$1.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target) => computed.set(target));
        return computed;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    }
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
      let mapped = key[0].toUpperCase() + key.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      };
    });
    utils$1.freezeMethods(AxiosHeaders);
    const AxiosHeaders$1 = AxiosHeaders;
    function transformData(fns, response) {
      const config = this || defaults$1;
      const context = response || config;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;
      utils$1.forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel(value) {
      return !!(value && value.__CANCEL__);
    }
    function CanceledError(message, config, request) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
      this.name = "CanceledError";
    }
    utils$1.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    function settle(resolve, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    const cookies = platform.hasStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      {
        write(name, value, expires, path, domain, secure) {
          const cookie = [name + "=" + encodeURIComponent(value)];
          utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
          utils$1.isString(path) && cookie.push("path=" + path);
          utils$1.isString(domain) && cookie.push("domain=" + domain);
          secure === true && cookie.push("secure");
          document.cookie = cookie.join("; ");
        },
        read(name) {
          const match5 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match5 ? decodeURIComponent(match5[3]) : null;
        },
        remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      }
    ) : (
      // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {
        },
        read() {
          return null;
        },
        remove() {
        }
      }
    );
    function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    const isURLSameOrigin = platform.hasStandardBrowserEnv ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        const msie = /(msie|trident)/i.test(navigator.userAgent);
        const urlParsingNode = document.createElement("a");
        let originURL;
        function resolveURL(url) {
          let href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin2(requestURL) {
          const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      /* @__PURE__ */ function nonStandardBrowserEnv() {
        return function isURLSameOrigin2() {
          return true;
        };
      }()
    );
    function parseProtocol(url) {
      const match5 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match5 && match5[1] || "";
    }
    function speedometer(samplesCount, min2) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min2 = min2 !== void 0 ? min2 : 1e3;
      return function push(chunkLength) {
        const now2 = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now2;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now2;
        let i = tail;
        let bytesCount = 0;
        while (i !== head) {
          bytesCount += bytes[i++];
          i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now2 - firstSampleTS < min2) {
          return;
        }
        const passed = startedAt && now2 - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function progressEventReducer(listener, isDownloadStream) {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return (e2) => {
        const loaded = e2.loaded;
        const total = e2.lengthComputable ? e2.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e2
        };
        data[isDownloadStream ? "download" : "upload"] = true;
        listener(data);
      };
    }
    const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    const xhrAdapter = isXHRAdapterSupported && function(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        let requestData = config.data;
        const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
        let { responseType, withXSRFToken } = config;
        let onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        let contentType;
        if (utils$1.isFormData(requestData)) {
          if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
            requestHeaders.setContentType(false);
          } else if ((contentType = requestHeaders.getContentType()) !== false) {
            const [type, ...tokens2] = contentType ? contentType.split(";").map((token2) => token2.trim()).filter(Boolean) : [];
            requestHeaders.setContentType([type || "multipart/form-data", ...tokens2].join("; "));
          }
        }
        let request = new XMLHttpRequest();
        if (config.auth) {
          const username = config.auth.username || "";
          const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
        }
        const fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request
          ));
          request = null;
        };
        if (platform.hasStandardBrowserEnv) {
          withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
          if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(fullPath)) {
            const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
            if (xsrfValue) {
              requestHeaders.set(config.xsrfHeaderName, xsrfValue);
            }
          }
        }
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils$1.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
        }
        if (config.cancelToken || config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(fullPath);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData || null);
      });
    };
    const knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter
    };
    utils$1.forEach(knownAdapters, (fn, value) => {
      if (fn) {
        try {
          Object.defineProperty(fn, "name", { value });
        } catch (e2) {
        }
        Object.defineProperty(fn, "adapterName", { value });
      }
    });
    const renderReason = (reason) => `- ${reason}`;
    const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
    const adapters = {
      getAdapter: (adapters2) => {
        adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
        const { length: length2 } = adapters2;
        let nameOrAdapter;
        let adapter;
        const rejectedReasons = {};
        for (let i = 0; i < length2; i++) {
          nameOrAdapter = adapters2[i];
          let id2;
          adapter = nameOrAdapter;
          if (!isResolvedHandle(nameOrAdapter)) {
            adapter = knownAdapters[(id2 = String(nameOrAdapter)).toLowerCase()];
            if (adapter === void 0) {
              throw new AxiosError(`Unknown adapter '${id2}'`);
            }
          }
          if (adapter) {
            break;
          }
          rejectedReasons[id2 || "#" + i] = adapter;
        }
        if (!adapter) {
          const reasons = Object.entries(rejectedReasons).map(
            ([id2, state]) => `adapter ${id2} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
          );
          let s = length2 ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
          throw new AxiosError(
            `There is no suitable adapter to dispatch the request ` + s,
            "ERR_NOT_SUPPORT"
          );
        }
        return adapter;
      },
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError(null, config);
      }
    }
    function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = AxiosHeaders$1.from(config.headers);
      config.data = transformData.call(
        config,
        config.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config.method) !== -1) {
        config.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          config.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              config.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
    function mergeConfig(config1, config2) {
      config2 = config2 || {};
      const config = {};
      function getMergedValue(target, source, caseless) {
        if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
          return utils$1.merge.call({ caseless }, target, source);
        } else if (utils$1.isPlainObject(source)) {
          return utils$1.merge({}, source);
        } else if (utils$1.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a, b2, caseless) {
        if (!utils$1.isUndefined(b2)) {
          return getMergedValue(a, b2, caseless);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a, caseless);
        }
      }
      function valueFromConfig2(a, b2) {
        if (!utils$1.isUndefined(b2)) {
          return getMergedValue(void 0, b2);
        }
      }
      function defaultToConfig2(a, b2) {
        if (!utils$1.isUndefined(b2)) {
          return getMergedValue(void 0, b2);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a);
        }
      }
      function mergeDirectKeys(a, b2, prop) {
        if (prop in config2) {
          return getMergedValue(a, b2);
        } else if (prop in config1) {
          return getMergedValue(void 0, a);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b2) => mergeDeepProperties(headersToObject(a), headersToObject(b2), true)
      };
      utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
        const merge2 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge2(config1[prop], config2[prop], prop);
        utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    }
    const VERSION = "1.6.7";
    const validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    const deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version2, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version2 && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version2 + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      const keys2 = Object.keys(options);
      let i = keys2.length;
      while (i-- > 0) {
        const opt = keys2[i];
        const validator2 = schema[opt];
        if (validator2) {
          const value = options[opt];
          const result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    const validator = {
      assertOptions,
      validators: validators$1
    };
    const validators = validator.validators;
    class Axios {
      constructor(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager$1(),
          response: new InterceptorManager$1()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      async request(configOrUrl, config) {
        try {
          return await this._request(configOrUrl, config);
        } catch (err) {
          if (err instanceof Error) {
            let dummy;
            Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
            const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
            if (!err.stack) {
              err.stack = stack;
            } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
              err.stack += "\n" + stack;
            }
          }
          throw err;
        }
      }
      _request(configOrUrl, config) {
        if (typeof configOrUrl === "string") {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        config = mergeConfig(this.defaults, config);
        const { transitional, paramsSerializer, headers } = config;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils$1.isFunction(paramsSerializer)) {
            config.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders = headers && utils$1.merge(
          headers.common,
          headers[config.method]
        );
        headers && utils$1.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift.apply(chain, requestInterceptorChain);
          chain.push.apply(chain, responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config);
          while (i < len) {
            promise = promise.then(chain[i++], chain[i++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        i = 0;
        while (i < len) {
          const onFulfilled = requestInterceptorChain[i++];
          const onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while (i < len) {
          promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }
        return promise;
      }
      getUri(config) {
        config = mergeConfig(this.defaults, config);
        const fullPath = buildFullPath(config.baseURL, config.url);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      }
    }
    utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    const Axios$1 = Axios;
    class CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        const token2 = this;
        this.promise.then((cancel) => {
          if (!token2._listeners)
            return;
          let i = token2._listeners.length;
          while (i-- > 0) {
            token2._listeners[i](cancel);
          }
          token2._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve) => {
            token2.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token2.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message, config, request) {
          if (token2.reason) {
            return;
          }
          token2.reason = new CanceledError(message, config, request);
          resolvePromise(token2.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index2 = this._listeners.indexOf(listener);
        if (index2 !== -1) {
          this._listeners.splice(index2, 1);
        }
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token2 = new CancelToken(function executor(c2) {
          cancel = c2;
        });
        return {
          token: token2,
          cancel
        };
      }
    }
    const CancelToken$1 = CancelToken;
    function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    }
    function isAxiosError(payload) {
      return utils$1.isObject(payload) && payload.isAxiosError === true;
    }
    const HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511
    };
    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });
    const HttpStatusCode$1 = HttpStatusCode;
    function createInstance(defaultConfig2) {
      const context = new Axios$1(defaultConfig2);
      const instance = bind(Axios$1.prototype.request, context);
      utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
      utils$1.extend(instance, context, null, { allOwnKeys: true });
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig2, instanceConfig));
      };
      return instance;
    }
    const axios = createInstance(defaults$1);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData;
    axios.AxiosError = AxiosError;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters.getAdapter;
    axios.HttpStatusCode = HttpStatusCode$1;
    axios.default = axios;
    const axios$1 = axios;
    function checkIsImageExist(url) {
      const http = new XMLHttpRequest();
      http.open("HEAD", url, false);
      http.send();
      return http.status !== 404;
    }
    const App$1 = (props) => {
      const url = `${"http://localhost:5174"}/api/files/upload`;
      const [progress, setProgress] = reactExports.useState(0);
      const organizedFileList = props.fileList.reduce((acc, cur) => {
        const isThisImageExist = checkIsImageExist(cur);
        if (!isThisImageExist) {
          props.setFileList(props.fileList.filter((url2) => url2 !== cur));
          return acc;
        }
        return [
          ...acc,
          {
            uid: cur,
            name: "",
            status: "done",
            url: cur
          }
        ];
      }, []);
      const beforeUpload = (file) => {
        const isJpgOrPng = file.type === "image/jpeg" || file.type === "image/png";
        if (!isJpgOrPng) {
          alert("您只能上傳 JPG/PNG 檔案");
        }
        const isLt2M = file.size / 1024 / 1024 < 2;
        if (!isLt2M) {
          alert("圖片必須小於 2MB!");
        }
        return isJpgOrPng && isLt2M;
      };
      const uploadImage = async (options) => {
        const { onSuccess, onError, file, onProgress } = options;
        const fmData = new FormData();
        const config = {
          headers: {
            "content-type": "multipart/form-data",
            Authorization: `Bearer ${localStorage.getItem("token")}`
          },
          onUploadProgress: (event) => {
            const percent = Math.floor(event.loaded / event.total * 100);
            setProgress(percent);
            if (percent === 100) {
              setTimeout(() => setProgress(0), 1e3);
            }
            onProgress({ percent: event.loaded / event.total * 100 });
          }
        };
        fmData.append("file", file);
        try {
          const res = await axios$1.post(url, fmData, config);
          props.setFileList([...props.fileList, res.data.url]);
          onSuccess(res.data);
        } catch (err) {
          console.log("Eroor: ", err);
          onError({ err });
        }
      };
      const onRemove = async (file) => {
        try {
          const fileName = file.url?.split("/")[4];
          console.log(fileName);
          await deleteFile(fileName);
          const fileList = props.fileList.filter((url2) => url2 !== file.url);
          props.setFileList(fileList);
        } catch (error) {
          console.error(error);
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Upload$1,
          {
            listType: "picture",
            fileList: organizedFileList,
            onRemove,
            customRequest: uploadImage,
            className: "upload-list-inline",
            beforeUpload,
            accept: ".jpg,.png",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button$2,
              {
                type: "primary",
                className: "bg-blue-600 ",
                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UploadOutlined$1, {}),
                children: "新增照片"
              }
            )
          }
        ),
        progress > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Progress$1, { percent: progress }) : null
      ] });
    };
    dayjs.extend(customParseFormat);
    function RenterInfo(props) {
      const { renterData, handleRenterChange } = props;
      const dateFormat = "YYYY-MM-DD";
      const renter_start_date = dayjs(renterData.renter_start_date, dateFormat);
      const renter_end_date = dayjs(renterData.renter_end_date, dateFormat);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col w-full px-5 mt-10", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inline-flex col-span-2 mb-5 ml-10", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-4xl font-bold", children: "租客資訊" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-3 ml-5 border-b-2 border-gray-300" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row w-full ", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col w-1/3 gap-10 mr-3 ", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-1 text-right ", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 ", children: "起租日期:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                DatePicker$1,
                {
                  className: "col-span-2",
                  defaultValue: renter_start_date,
                  onChange: (_, dateString) => handleRenterChange("renter_start_date", dateString)
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-1 text-right ", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 ", children: "退租日期:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                DatePicker$1,
                {
                  className: "col-span-2",
                  defaultValue: renter_end_date,
                  onChange: (_, dateString) => handleRenterChange("renter_end_date", dateString)
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-1 text-right ", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 ", children: "租客姓名:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input$1,
                {
                  className: "col-span-2",
                  value: renterData.renter_name,
                  onChange: (e2) => handleRenterChange("renter_name", e2.target.value)
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-1 text-right ", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 ", children: "電話:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input$1,
                {
                  className: "col-span-2",
                  value: renterData.renter_phone,
                  onChange: (e2) => handleRenterChange("renter_phone", e2.target.value)
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-1 text-right ", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 ", children: "工作職稱:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input$1,
                {
                  className: "col-span-2",
                  value: renterData.renter_jobtitle,
                  onChange: (e2) => handleRenterChange("renter_jobtitle", e2.target.value)
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-1 text-right ", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 ", children: "保證人姓名:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input$1,
                {
                  className: "col-span-2",
                  value: renterData.renter_guarantor_name,
                  onChange: (e2) => handleRenterChange("renter_guarantor_name", e2.target.value)
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-1 text-right ", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 ", children: "保證人電話:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input$1,
                {
                  className: "col-span-2",
                  value: renterData.renter_guarantor_phone,
                  onChange: (e2) => handleRenterChange("renter_guarantor_phone", e2.target.value)
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col w-1/3 ", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-3 gap-1 ", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-2 ", children: "身分證件翻拍存檔:" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              App$1,
              {
                fileList: renterData.renter_id_images,
                setFileList: (fileList) => handleRenterChange("renter_id_images", fileList)
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col w-1/3 ml-5", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-5 gap-1 ", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-5 ", children: "備註:" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "textarea",
              {
                className: "w-full h-40 border border-gray-300",
                value: renterData.renter_remark,
                onChange: (e2) => handleRenterChange("renter_remark", e2.target.value)
              }
            )
          ] })
        ] })
      ] });
    }
    dayjs.extend(customParseFormat);
    function SellerInfo(props) {
      const { sellerData, handleChangeSeller } = props;
      const dateFormat = "YYYY-MM-DD";
      const buyer_order_date = dayjs(sellerData.buyer_order_date, dateFormat);
      const buyer_handout_date = dayjs(sellerData.buyer_handout_date, dateFormat);
      return (
        // 買客資訊
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col w-full px-5 mt-10", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inline-flex mb-10 ml-16 gird ", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-4xl font-bold", children: "買客資訊" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-3 ml-5 border-b-2 border-gray-300" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row w-full ", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col w-1/2 gap-10 pr-10 ", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-1 text-right ", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 ", children: "下定日期:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DatePicker$1,
                  {
                    className: "col-span-2",
                    value: buyer_order_date,
                    onChange: (_, dateString) => handleChangeSeller("buyer_order_date", dateString)
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-1 text-right ", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 ", children: "交房日期:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DatePicker$1,
                  {
                    className: "col-span-2",
                    value: buyer_handout_date,
                    onChange: (_, dateString) => handleChangeSeller("buyer_handout_date", dateString)
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-1 text-right ", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 ", children: "買客姓名:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input$1,
                  {
                    className: "col-span-2",
                    value: sellerData.buyer_name,
                    onChange: (e2) => handleChangeSeller("buyer_name", e2.target.value)
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-1 text-right ", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 ", children: "電話:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input$1,
                  {
                    className: "col-span-2",
                    value: sellerData.buyer_phone,
                    onChange: (e2) => handleChangeSeller("buyer_phone", e2.target.value)
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-1 text-right ", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 ", children: "工作職稱:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input$1,
                  {
                    className: "col-span-2",
                    value: sellerData.buyer_jobtitle,
                    onChange: (e2) => handleChangeSeller("buyer_jobtitle", e2.target.value)
                  }
                )
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col w-1/2 ", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-3 gap-1 ", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-2 ", children: "身分證件翻拍存檔:" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                App$1,
                {
                  fileList: sellerData.buyer_id_images,
                  setFileList: (newFilelist) => {
                    handleChangeSeller("buyer_id_images", newFilelist);
                  }
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col w-1/3 ml-5", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-5 gap-1 ", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-5 ", children: "備註:" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input$1.TextArea,
                {
                  className: "h-40",
                  value: sellerData.buyer_remark,
                  onChange: (e2) => handleChangeSeller("buyer_remark", e2.target.value)
                }
              )
            ] })
          ] })
        ] })
      );
    }
    const SwitchTenementType = reactExports.memo(
      (props) => {
        const {
          tenement_type,
          sellerData,
          handleChangeSeller,
          renterData,
          handleRenterChange
        } = props;
        switch (tenement_type) {
          case "出租":
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              RenterInfo,
              {
                renterData,
                handleRenterChange
              }
            );
          case "出售":
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              SellerInfo,
              {
                sellerData,
                handleChangeSeller
              }
            );
          case "開發追蹤":
            return "";
          case "行銷追蹤":
            return "";
          default:
            return "";
        }
      }
    );
    function TenementInfo(props) {
      const nowdatestring = hooks().format("YYYY-MM-DD");
      const navigate = useNavigate();
      const handleback = () => {
        navigate("/tenements");
      };
      const [searchParams] = useSearchParams();
      const handlePutDataWithQuery = (searchParams2) => {
        const tenementType = searchParams2.get("tenement_type") || "出租";
        setTenement_type(tenementType);
        return {
          tenement_id: searchParams2.get("tenement_id") || "",
          tenement_address: searchParams2.get("tenement_address") || "",
          tenement_product_type: searchParams2.get("tenement_product_type") || "套房",
          tenement_type: tenementType,
          tenement_face: searchParams2.get("tenement_face") || "",
          tenement_images: JSON.parse(searchParams2.get("tenement_images")) || [],
          tenement_status: searchParams2.get("tenement_status") || "未成交",
          total_rating: searchParams2.get("total_rating") || "",
          main_building: searchParams2.get("main_building") || "",
          affiliated_building: searchParams2.get("affiliated_building") || "",
          public_building: searchParams2.get("public_building") || "",
          unregistered_area: searchParams2.get("unregistered_area") || "",
          management_magnification: searchParams2.get("management_magnification") || "",
          management_fee: searchParams2.get("management_fee") || "",
          rent_price: searchParams2.get("rent_price") || "",
          deposit_price: searchParams2.get("deposit_price") || "",
          tenement_floor: searchParams2.get("tenement_floor") || "",
          tenement_host_name: searchParams2.get("tenement_host_name") || "",
          tenement_host_telphone: searchParams2.get("tenement_host_telphone") || "",
          tenement_host_phone: searchParams2.get("tenement_host_phone") || "",
          tenement_host_line: searchParams2.get("tenement_host_line") || "",
          tenement_host_remittance_bank: searchParams2.get("tenement_host_remittance_bank") || "",
          tenement_host_remittance_account: searchParams2.get("tenement_host_remittance_account") || "",
          tenement_host_address: searchParams2.get("tenement_host_address") || "",
          tenement_host_birthday: searchParams2.get("tenement_host_birthday") || "",
          tenement_host_hobby: searchParams2.get("tenement_host_hobby") || "",
          tenement_host_remark: searchParams2.get("tenement_host_remark") || "",
          tenement_area_max: searchParams2.get("tenement_area_max") || "",
          tenement_area_min: searchParams2.get("tenement_area_min") || "",
          burget_rent_max: searchParams2.get("burget_rent_max") || "",
          burget_rent_min: searchParams2.get("burget_rent_min") || "",
          hopefloor_max: searchParams2.get("hopefloor_max") || "",
          hopefloor_min: searchParams2.get("hopefloor_min") || "",
          market_state: searchParams2.get("market_state") || "",
          selling_price: searchParams2.get("selling_price") || ""
        };
      };
      const [formData, setFormData] = reactExports.useState({
        tenement_address: "",
        tenement_product_type: "套房",
        tenement_type: "出租",
        tenement_face: "海景",
        tenement_images: [],
        tenement_status: "已成交",
        total_rating: "0.0",
        main_building: "0.0",
        affiliated_building: "0.0",
        public_building: "0.0",
        unregistered_area: "0.0",
        management_magnification: "1.5",
        management_fee: "0",
        rent_price: "0",
        deposit_price: "0",
        tenement_floor: "0",
        tenement_host_name: "0",
        tenement_host_telphone: "0",
        tenement_host_phone: "0",
        tenement_host_line: "0",
        tenement_host_remittance_bank: "0",
        tenement_host_remittance_account: "9876543210",
        tenement_host_address: "123 Main St, City, Country",
        tenement_host_birthday: "1980-01-01",
        tenement_host_hobby: "Reading",
        tenement_host_remark: "No remarks",
        tenement_area_max: "10",
        tenement_area_min: "5",
        burget_rent_max: "20000",
        burget_rent_min: "10000",
        hopefloor_max: "5",
        hopefloor_min: "2",
        market_state: "租房",
        selling_price: "1000"
      });
      const [renterData, setRenterData] = reactExports.useState({
        renter_start_date: nowdatestring,
        renter_end_date: nowdatestring,
        renter_name: "Jane Doe",
        renter_phone: "0987654321",
        renter_jobtitle: "Software Engineer",
        renter_guarantor_name: "John Smith",
        renter_guarantor_phone: "1234567890",
        renter_remark: "No remarks",
        renter_id_images: []
      });
      const [sellerData, setSellerData] = reactExports.useState({
        buyer_order_date: nowdatestring,
        buyer_handout_date: nowdatestring,
        buyer_name: "Jane Doe",
        buyer_id_images: [],
        buyer_phone: "0987654321",
        buyer_jobtitle: "Software Engineer",
        buyer_remark: "No remarks"
      });
      const handleChangeSeller = (key, value) => {
        setSellerData((prev2) => ({ ...prev2, [key]: value }));
      };
      const handleRenterChange = (key, value) => {
        setRenterData((prev2) => ({ ...prev2, [key]: value }));
      };
      reactExports.useEffect(() => {
        const newFormData = handlePutDataWithQuery(searchParams);
        setFormData(newFormData);
      }, [searchParams]);
      const { isLoading, isError } = props;
      const [notices, setNotices] = reactExports.useState([]);
      const handleNoticeChange = (index2, key, value) => {
        setNotices(
          (prev2) => prev2.map(
            (notice, i) => i === index2 ? { ...notice, [key]: value } : notice
          )
        );
      };
      const handleDeleteNotice = (index2) => {
        setNotices((prev2) => prev2.filter((_, i) => i !== index2));
      };
      const handleAddNotice = () => {
        setNotices((prev2) => [
          ...prev2,
          {
            id: Math.random(),
            visitDate: nowdatestring,
            record: "",
            remindDate: nowdatestring,
            remind: "",
            isNew: true
          }
        ]);
      };
      const { handlePostAddTenement } = usePostAddTenement();
      const handleSave = async () => {
        const rentData = {
          tenement_address: formData.tenement_address,
          tenement_product_type: formData.tenement_product_type,
          tenement_type: formData.tenement_type,
          tenement_face: formData.tenement_face,
          tenement_images: formData.tenement_images,
          tenement_status: formData.tenement_status,
          total_rating: formData.total_rating,
          main_building: formData.main_building,
          affiliated_building: formData.affiliated_building,
          public_building: formData.public_building,
          unregistered_area: formData.unregistered_area,
          management_magnification: formData.management_magnification,
          management_fee: formData.management_fee,
          rent_price: formData.rent_price,
          deposit_price: formData.deposit_price,
          tenement_floor: formData.tenement_floor,
          tenement_host_name: formData.tenement_host_name,
          tenement_host_telphone: formData.tenement_host_telphone,
          tenement_host_phone: formData.tenement_host_phone,
          tenement_host_line: formData.tenement_host_line,
          tenement_host_remittance_bank: formData.tenement_host_remittance_bank,
          tenement_host_remittance_account: formData.tenement_host_remittance_account,
          tenement_host_address: formData.tenement_host_address,
          tenement_host_birthday: formData.tenement_host_birthday,
          tenement_host_hobby: formData.tenement_host_hobby,
          tenement_host_remark: formData.tenement_host_remark,
          ...renterData
        };
        const sellData = {
          tenement_address: formData.tenement_address,
          tenement_product_type: formData.tenement_product_type,
          tenement_type: formData.tenement_type,
          tenement_face: formData.tenement_face,
          tenement_images: formData.tenement_images,
          tenement_status: formData.tenement_status,
          total_rating: formData.total_rating,
          main_building: formData.main_building,
          affiliated_building: formData.affiliated_building,
          public_building: formData.public_building,
          unregistered_area: formData.unregistered_area,
          management_magnification: formData.management_magnification,
          management_fee: formData.management_fee,
          selling_price: formData.selling_price,
          tenement_floor: formData.tenement_floor,
          tenement_host_name: formData.tenement_host_name,
          tenement_host_telphone: formData.tenement_host_telphone,
          tenement_host_phone: formData.tenement_host_phone,
          tenement_host_line: formData.tenement_host_line,
          tenement_host_remittance_bank: formData.tenement_host_remittance_bank,
          tenement_host_remittance_account: formData.tenement_host_remittance_account,
          tenement_host_address: formData.tenement_host_address,
          tenement_host_birthday: formData.tenement_host_birthday,
          tenement_host_hobby: formData.tenement_host_hobby,
          tenement_host_remark: formData.tenement_host_remark,
          ...sellerData
        };
        const developerData = {
          tenement_address: formData.tenement_address,
          tenement_product_type: formData.tenement_product_type,
          tenement_type: formData.tenement_type,
          tenement_face: formData.tenement_face,
          tenement_images: formData.tenement_images,
          total_rating: formData.total_rating,
          main_building: formData.main_building,
          affiliated_building: formData.affiliated_building,
          public_building: formData.public_building,
          unregistered_area: formData.unregistered_area,
          management_magnification: formData.management_magnification,
          management_fee: formData.management_fee,
          selling_price: formData.selling_price,
          rent_price: formData.rent_price,
          deposit_price: formData.deposit_price,
          tenement_floor: formData.tenement_floor,
          tenement_host_name: formData.tenement_host_name,
          tenement_host_telphone: formData.tenement_host_telphone,
          tenement_host_phone: formData.tenement_host_phone,
          tenement_host_line: formData.tenement_host_line,
          tenement_host_remittance_bank: formData.tenement_host_remittance_bank,
          tenement_host_remittance_account: formData.tenement_host_remittance_account,
          tenement_host_address: formData.tenement_host_address,
          tenement_host_birthday: formData.tenement_host_birthday,
          tenement_host_hobby: formData.tenement_host_hobby,
          tenement_host_remark: formData.tenement_host_remark
        };
        const marketData = {
          tenement_address: formData.tenement_address,
          tenement_product_type: formData.tenement_product_type,
          tenement_type: formData.tenement_type,
          tenement_face: formData.tenement_face,
          tenement_images: formData.tenement_images,
          tenement_host_name: formData.tenement_host_name,
          tenement_host_telphone: formData.tenement_host_telphone,
          tenement_host_phone: formData.tenement_host_phone,
          tenement_host_line: formData.tenement_host_line,
          tenement_host_remittance_bank: formData.tenement_host_remittance_bank,
          tenement_host_remittance_account: formData.tenement_host_remittance_account,
          tenement_host_address: formData.tenement_host_address,
          tenement_host_birthday: formData.tenement_host_birthday,
          tenement_host_hobby: formData.tenement_host_hobby,
          tenement_host_remark: formData.tenement_host_remark,
          tenement_area_max: formData.tenement_area_max,
          tenement_area_min: formData.tenement_area_min,
          burget_rent_max: formData.burget_rent_max,
          burget_rent_min: formData.burget_rent_min,
          hopefloor_max: formData.hopefloor_max,
          hopefloor_min: formData.hopefloor_min,
          market_state: formData.market_state
        };
        function getNoticeWithTenementId(notices2, tenementId) {
          return notices2.map((notice) => ({
            visitDate: notice.visitDate,
            record: notice.record,
            remindDate: notice.remindDate,
            remind: notice.remind,
            collection_id: tenementId
          }));
        }
        async function startCreateTenement(tenement_type2, tenementData) {
          const tenementId = await handlePostAddTenement(
            tenement_type2,
            tenementData
          );
          if (tenementId) {
            const newNotices = getNoticeWithTenementId(notices, tenementId);
            handlePostAddNotice(tenement_type2, newNotices);
          }
        }
        async function handleCreateTenmentInfo(tenement_type2) {
          const queryData = handlePutDataWithQuery(searchParams);
          switch (tenement_type2) {
            case "出租": {
              const newRentData = queryData.tenement_id === "" ? rentData : { ...rentData, tenement_id: queryData.tenement_id };
              await startCreateTenement("rent", newRentData);
              break;
            }
            case "出售": {
              const newSellData = queryData.tenement_id === "" ? sellData : { ...sellData, tenement_id: queryData.tenement_id };
              await startCreateTenement("sell", newSellData);
              break;
            }
            case "開發追蹤": {
              const newDevelopData = queryData.tenement_id === "" ? developerData : { ...developerData, tenement_id: queryData.tenement_id };
              await startCreateTenement("develop", newDevelopData);
              break;
            }
            case "行銷追蹤": {
              const newMarketData = queryData.tenement_id === "" ? marketData : { ...marketData, tenement_id: queryData.tenement_id };
              await startCreateTenement("market", newMarketData);
              break;
            }
          }
        }
        await handleCreateTenmentInfo(tenement_type);
        alert("儲存成功");
      };
      const handleReset = () => {
        setFormData({
          tenement_address: "1234",
          tenement_product_type: "套房",
          tenement_type: "出租",
          tenement_face: "海景",
          tenement_images: [],
          tenement_status: "已成交",
          total_rating: "4",
          main_building: "3",
          affiliated_building: "2",
          public_building: "1",
          unregistered_area: "2",
          management_magnification: "1.5",
          management_fee: "3000",
          rent_price: "20000",
          deposit_price: "40000",
          tenement_floor: "7",
          tenement_host_name: "John Doe",
          tenement_host_telphone: "1234567890",
          tenement_host_phone: "0987654321",
          tenement_host_line: "john_doe",
          tenement_host_remittance_bank: "Bank of America",
          tenement_host_remittance_account: "9876543210",
          tenement_host_address: "123 Main St, City, Country",
          tenement_host_birthday: "1980-01-01",
          tenement_host_hobby: "Reading",
          tenement_host_remark: "No remarks",
          tenement_area_max: "10",
          tenement_area_min: "5",
          burget_rent_max: "20000",
          burget_rent_min: "10000",
          hopefloor_max: "5",
          hopefloor_min: "2",
          market_state: "租房",
          selling_price: "1000"
        });
        setNotices([
          {
            id: 1,
            visitDate: nowdatestring,
            record: "看房子",
            remindDate: nowdatestring,
            remind: "提醒"
          },
          {
            id: 2,
            visitDate: nowdatestring,
            record: "繳水電",
            remindDate: nowdatestring,
            remind: "繳房租"
          }
        ]);
      };
      const [tenement_type, setTenement_type] = reactExports.useState("出租");
      const handletypeChange = (e2) => {
        setFormData((prev2) => ({ ...prev2, tenement_type: e2.target.value }));
        setTenement_type(e2.target.value);
      };
      const handleChange = (key, value) => {
        setFormData((prev2) => ({ ...prev2, [key]: value }));
      };
      const swtitchExtraInfo = (tenement_type2) => {
        switch (tenement_type2) {
          case "出租":
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "租金:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  InputWithErrorMessage,
                  {
                    value: formData.rent_price,
                    onChange: (e2) => handleChange("rent_price", e2.target.value),
                    isError: formData.rent_price.length <= 2,
                    errorMessage: "至少兩個字",
                    required: true
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "押金:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  InputWithErrorMessage,
                  {
                    value: formData.deposit_price,
                    onChange: (e2) => handleChange("deposit_price", e2.target.value),
                    isError: formData.deposit_price.length <= 2,
                    errorMessage: "至少兩個字"
                  }
                )
              ] })
            ] });
          case "出售":
            return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 ", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 text-right ", children: "售價(萬):" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                InputWithErrorMessage,
                {
                  value: formData.selling_price,
                  onChange: (e2) => handleChange("selling_price", e2.target.value),
                  isError: formData.selling_price.length <= 2,
                  errorMessage: "至少兩個字",
                  required: true
                }
              )
            ] }) });
          case "開發追蹤":
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col ", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 ", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 text-right", children: "售價(萬):" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  InputWithErrorMessage,
                  {
                    value: formData.selling_price,
                    onChange: (e2) => handleChange("selling_price", e2.target.value),
                    isError: formData.selling_price.length <= 2,
                    errorMessage: "至少兩個字",
                    required: true
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 ", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 text-right ", children: "租金:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  InputWithErrorMessage,
                  {
                    value: formData.rent_price,
                    onChange: (e2) => handleChange("rent_price", e2.target.value),
                    isError: formData.rent_price.length <= 2,
                    errorMessage: "至少兩個字"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 ", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 text-right ", children: "押金:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  InputWithErrorMessage,
                  {
                    value: formData.deposit_price,
                    onChange: (e2) => handleChange("deposit_price", e2.target.value),
                    isError: formData.deposit_price.length <= 2,
                    errorMessage: "至少兩個字"
                  }
                )
              ] })
            ] });
          case "行銷追蹤":
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 mb-5 ", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 text-right", children: "預期坪數:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-grid items-center grid-flow-col ", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Input$1,
                    {
                      value: formData.tenement_area_min,
                      onChange: (e2) => handleChange("tenement_area_min", e2.target.value),
                      className: "h-8 col-span-1 mt-3",
                      placeholder: "最小值"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "pt-3 pl-1 ", children: "~" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input$1,
                  {
                    value: formData.tenement_area_max,
                    onChange: (e2) => handleChange("tenement_area_max", e2.target.value),
                    className: "col-span-1 mt-3",
                    placeholder: "最大值"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-10 gap-1 text-right", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-2 pt-1 whitespace-nowrap ", children: "要租要買:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Select$1,
                  {
                    defaultValue: "租房",
                    className: "w-20 col-span-1 ",
                    value: formData.market_state,
                    onChange: (value) => handleChange("market_state", value),
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Select$1.Option, { value: "租房", children: "租房" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Select$1.Option, { value: "買房", children: "買房" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Select$1.Option, { value: "要租要買", children: "要租要買" })
                    ]
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "col-span-1 pt-5 ", children: [
                  " ",
                  formData.market_state === "租房" ? "租金預算" : "售價預算(萬)",
                  ":"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-grid items-center grid-flow-col ", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Input$1,
                    {
                      value: formData.burget_rent_min,
                      onChange: (e2) => handleChange("burget_rent_min", e2.target.value),
                      className: "h-8 col-span-1 mt-3",
                      placeholder: "最小值",
                      required: true
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "pt-3 pl-1 ", children: "~" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input$1,
                  {
                    value: formData.burget_rent_max,
                    onChange: (e2) => handleChange("burget_rent_max", e2.target.value),
                    className: "col-span-1 mt-3",
                    placeholder: "最大值",
                    required: true
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "希望的樓層:" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-grid items-center grid-flow-col ", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Input$1,
                    {
                      value: formData.hopefloor_min,
                      onChange: (e2) => handleChange("hopefloor_min", e2.target.value),
                      className: "h-8 col-span-1 mt-3",
                      placeholder: "最小值",
                      required: true
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "pt-3 pl-1 ", children: "~" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input$1,
                  {
                    value: formData.hopefloor_max,
                    onChange: (e2) => handleChange("hopefloor_max", e2.target.value),
                    className: "col-span-1 mt-3",
                    placeholder: "最大值",
                    required: true
                  }
                )
              ] })
            ] });
          default:
            return "";
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "form",
        {
          className: "flex flex-col items-center w-full h-full ",
          onSubmit: (e2) => {
            e2.preventDefault();
            handleSave();
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col w-full h-full max-w-screen-xl pb-12 mt-12 mb-10 bg-white shadow-2xl rounded-xl", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "flex w-12 h-20 mt-10 ml-5", onClick: handleback, children: "< 返回" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inline-flex flex-col mb-5 ml-8", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-4xl font-bold whitespace-normal", children: [
              tenement_type,
              "資料"
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-3 ml-5 border-b-2 border-gray-300" }),
            isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "loading..." }) : isError ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "error..." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row ", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col flex-wrap w-1/2 h-full gap-3 overflow-visible pl-7 ", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 whitespace-nowrap ", children: "地址:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: formData.tenement_address,
                      onChange: (e2) => handleChange("tenement_address", e2.target.value),
                      isError: formData.tenement_address.length <= 2,
                      errorMessage: "至少兩個字",
                      required: formData.tenement_type !== "行銷追蹤"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 ", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 text-right", children: "產品類別:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Radio$1.Group,
                    {
                      className: "col-span-4",
                      value: formData.tenement_product_type,
                      onChange: (e2) => handleChange("tenement_product_type", e2.target.value),
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "套房", children: "套房" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "店面", children: "店面" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "辦公室", children: "辦公室" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "其他", children: "其他" })
                      ]
                    }
                  )
                ] }),
                tenement_type === "開發追蹤" || tenement_type === "行銷追蹤" ? " " : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 ", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-right whitespace-nowrap", children: "物件狀態:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Radio$1.Group,
                    {
                      className: "col-span-4",
                      onChange: (e2) => handleChange("tenement_status", e2.target.value),
                      value: formData.tenement_status,
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "未成交", children: "未成交" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "已成交", children: "已成交" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "已成交下架", children: "已成交下架" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "過戶完成下架", children: "過戶完成下架" })
                      ]
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 ", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-right whitespace-nowrap", children: "物件型態:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Radio$1.Group,
                    {
                      onChange: handletypeChange,
                      value: tenement_type,
                      className: "col-span-4 ",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "出租", children: "出租" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "出售", children: "出售" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "開發追蹤", children: "開發追蹤" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "行銷追蹤", children: "行銷追蹤" })
                      ]
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 ", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 text-right whitespace-nowrap ", children: "面向:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Radio$1.Group,
                    {
                      className: "col-span-4",
                      onChange: (e2) => handleChange("tenement_face", e2.target.value),
                      value: formData.tenement_face,
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "海景", children: "海景" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "中庭", children: "中庭" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "三多路", children: "三多路" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "自強路", children: "自強路" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "市景風洞", children: "市景風洞" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "海景風洞", children: "海景風洞" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "其他", children: "其他" })
                      ]
                    }
                  )
                ] }),
                tenement_type === "行銷追蹤" ? " " : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "權狀坪數:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: formData.total_rating,
                      onChange: (e2) => handleChange("total_rating", e2.target.value),
                      isError: formData.total_rating.length <= 2,
                      errorMessage: "請輸入到小數點後二位",
                      required: true
                    }
                  )
                ] }),
                tenement_type === "行銷追蹤" ? " " : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "主建物:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: formData.main_building,
                      onChange: (e2) => handleChange("main_building", e2.target.value),
                      isError: formData.main_building.length <= 2,
                      errorMessage: "請輸入到小數點後二位",
                      required: true
                    }
                  )
                ] }),
                tenement_type === "行銷追蹤" ? " " : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "附屬建物:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: formData.affiliated_building,
                      onChange: (e2) => handleChange("affiliated_building", e2.target.value),
                      isError: formData.affiliated_building.length <= 2,
                      errorMessage: "請輸入到小數點後二位",
                      required: true
                    }
                  )
                ] }),
                tenement_type === "行銷追蹤" ? " " : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "公設面積:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: formData.public_building,
                      onChange: (e2) => handleChange("public_building", e2.target.value),
                      isError: formData.public_building.length <= 2,
                      errorMessage: "請輸入到小數點後二位",
                      required: true
                    }
                  )
                ] }),
                tenement_type === "行銷追蹤" ? " " : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "未登記面積:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: formData.unregistered_area,
                      onChange: (e2) => handleChange("unregistered_area", e2.target.value),
                      isError: formData.unregistered_area.length <= 2,
                      errorMessage: "請輸入到小數點後二位"
                    }
                  )
                ] }),
                tenement_type === "行銷追蹤" ? " " : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "管理費倍率:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: formData.management_magnification,
                      onChange: (e2) => {
                        handleChange(
                          "management_fee",
                          (parseFloat(e2.target.value) * parseFloat(formData.total_rating)).toString()
                        );
                        handleChange("management_magnification", e2.target.value);
                      },
                      isError: formData.management_fee.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] }),
                tenement_type === "行銷追蹤" ? " " : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "管理費:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: formData.management_fee,
                      onChange: (e2) => handleChange("management_fee", e2.target.value),
                      isError: formData.management_fee.length <= 0,
                      errorMessage: "至少一個字"
                    }
                  )
                ] }),
                swtitchExtraInfo(tenement_type),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "總樓層:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: formData.tenement_floor,
                      onChange: (e2) => handleChange("tenement_floor", e2.target.value),
                      isError: formData.tenement_floor.length <= 0,
                      errorMessage: "至少一個字"
                    }
                  )
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col w-1/2 h-full ", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex flex-col mb-10 ", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 mb-3 text-3xl font-bold whitespace-normal", children: "房屋照片" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    App$1,
                    {
                      fileList: formData.tenement_images,
                      setFileList: (newFilelist) => handleChange("tenement_images", newFilelist)
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 mb-3 text-3xl font-bold whitespace-normal", children: tenement_type === "行銷追蹤" ? "買客資訊" : "屋主資訊" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "姓名:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: formData.tenement_host_name,
                      onChange: (e2) => handleChange("tenement_host_name", e2.target.value),
                      isError: formData.tenement_host_name.length <= 2,
                      errorMessage: "至少兩個字",
                      required: true
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "行動電話:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: formData.tenement_host_telphone,
                      onChange: (e2) => handleChange("tenement_host_telphone", e2.target.value),
                      isError: formData.tenement_host_telphone.length <= 2,
                      errorMessage: "至少兩個字",
                      required: true
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "電話:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: formData.tenement_host_phone,
                      onChange: (e2) => handleChange("tenement_host_phone", e2.target.value),
                      isError: formData.tenement_host_phone.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "Line:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: formData.tenement_host_line,
                      onChange: (e2) => handleChange("tenement_host_line", e2.target.value),
                      isError: formData.tenement_host_line.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "匯款銀行:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: formData.tenement_host_remittance_bank,
                      onChange: (e2) => handleChange(
                        "tenement_host_remittance_bank",
                        e2.target.value
                      ),
                      isError: formData.tenement_host_remittance_bank.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "帳號:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: formData.tenement_host_remittance_account,
                      onChange: (e2) => handleChange(
                        "tenement_host_remittance_account",
                        e2.target.value
                      ),
                      isError: formData.tenement_host_remittance_account.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "通訊地址:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: formData.tenement_host_address,
                      onChange: (e2) => handleChange("tenement_host_address", e2.target.value),
                      isError: formData.tenement_host_address.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "生日:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: formData.tenement_host_birthday,
                      onChange: (e2) => handleChange("tenement_host_birthday", e2.target.value),
                      isError: formData.tenement_host_birthday.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "嗜好:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: formData.tenement_host_hobby,
                      onChange: (e2) => handleChange("tenement_host_hobby", e2.target.value),
                      isError: formData.tenement_host_hobby.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 mt-5 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "備註:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Input$1.TextArea,
                    {
                      className: "col-span-3",
                      rows: 4,
                      value: formData.tenement_host_remark,
                      onChange: (e2) => handleChange("tenement_host_remark", e2.target.value)
                    }
                  )
                ] })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              SwitchTenementType,
              {
                tenement_type,
                sellerData,
                handleChangeSeller,
                renterData,
                handleRenterChange
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col p-5", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex flex-row gap-5 mb-5 ", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-4xl font-bold whitespace-normal", children: "提醒設定" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button$2,
                  {
                    type: "primary",
                    className: "mt-1 bg-blue-600",
                    onClick: handleAddNotice,
                    children: "新增提醒"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-3 ml-5 border-b-2 border-gray-300" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-5", children: notices.map((notice, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                Notice,
                {
                  keya: index2,
                  notice,
                  handleNoticeChange,
                  handleDeleteNotice
                },
                index2
              )) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-end gap-5 m-10 ", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { className: "bg-blue-600 ", type: "primary", htmlType: "submit", children: "儲存" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { type: "default", onClick: () => handleReset(), children: "回復預設" })
            ] })
          ] })
        }
      );
    }
    const TenemmentAdd = () => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(TenementInfo, {});
    };
    const useTenementList = () => {
      const columns = [
        {
          title: "地址",
          dataIndex: "tenement_address",
          key: "tenement_address",
          width: "10%",
          ...getColumnSearchProps("tenement_address")
        },
        {
          title: "面向",
          dataIndex: "tenement_face",
          key: "tenement_face",
          width: "10%",
          filters: [
            {
              text: "海景",
              value: "海景"
            },
            {
              text: "中庭",
              value: "中庭"
            },
            {
              text: "三多路",
              value: "三多路"
            },
            {
              text: "自強路",
              value: "自強路"
            },
            {
              text: "市景風洞",
              value: "市景風洞"
            },
            {
              text: "海景風洞",
              value: "海景風洞"
            },
            {
              text: "其他",
              value: "其他"
            }
          ],
          onFilter: (value, record) => record.tenement_face.includes(value)
        },
        {
          title: "物件狀態",
          dataIndex: "tenement_status",
          key: "tenement_status",
          width: "10%",
          // 未成交、已成交、已退租下架、過戶完成下架
          filters: [
            {
              text: "未成交",
              value: "未成交"
            },
            {
              text: "已成交",
              value: "已成交"
            },
            {
              text: "已退租下架",
              value: "已退租下架"
            },
            {
              text: "過戶完成下架",
              value: "過戶完成下架"
            },
            {
              text: "開發中",
              value: "開發中"
            }
          ],
          onFilter: (value, record) => record.tenement_status.includes(value)
        },
        {
          title: "物件型態",
          dataIndex: "tenement_type",
          key: "tenement_type",
          width: "10%",
          filters: [
            {
              text: "出租",
              value: "出租"
            },
            {
              text: "出售",
              value: "出售"
            },
            {
              text: "開發追蹤",
              value: "開發追蹤"
            },
            {
              text: "行銷追蹤",
              value: "行銷追蹤"
            }
          ],
          onFilter: (value, record) => record.tenement_type.includes(value)
        },
        {
          title: "樓層",
          dataIndex: "management_floor_bottom",
          key: "management_floor_bottom",
          width: "10%",
          sorter: (a, b2) => a.management_floor_bottom - b2.management_floor_bottom
        },
        {
          title: "產品類別",
          dataIndex: "tenement_product_type",
          key: "tenement_product_type",
          width: "10%",
          filters: [
            {
              text: "套房",
              value: "套房"
            },
            {
              text: "辦公室",
              value: "辦公室"
            },
            {
              text: "店面",
              value: "店面"
            },
            {
              text: "其他",
              value: "其他"
            }
          ],
          onFilter: (value, record) => record.tenement_product_type.includes(value)
        },
        {
          title: "管理費",
          dataIndex: "management_fee_bottom",
          key: "management_fee_bottom",
          width: "10%",
          sorter: (a, b2) => a.management_fee_bottom - b2.management_fee_bottom
        }
      ];
      const navigate = useNavigate();
      const switchType = (type) => {
        switch (type) {
          case "出租":
            return "rent";
          case "出售":
            return "sell";
          case "開發追蹤":
            return "develop";
          case "行銷追蹤":
            return "market";
          default:
            return "rent";
        }
      };
      const onRow = (record) => {
        return {
          onClick: () => {
            navigate(
              `/Tenement/${record.tenement_id}/${switchType(
                record.tenement_type
              )}?tenement_type=${record.tenement_type}`
            );
          }
        };
      };
      return {
        columns,
        onRow
      };
    };
    const FilterModule = (props) => {
      const { handlePopout, handleSelect, form, validateMax, children, type } = props;
      const onFinish = (values) => {
        handleSelect(values);
        handlePopout();
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "fixed top-0 bottom-0 left-0 right-0 z-50 flex justify-center bg-black bg-opacity-50",
          onClick: handlePopout,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Form$1,
            {
              form,
              name: "house_information",
              onFinish,
              className: "w-2/3 p-10 my-5 bg-white rounded-md h-5/6 overflow-y-auto ",
              onClick: (e2) => e2.stopPropagation(),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between px-10 mb-10", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-3xl font-bold", children: [
                    type,
                    "篩選"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xl cursor-pointer", onClick: handlePopout, children: "X" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: " flex flex-col px-16 mb-10 h-5/6 ", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Form$1.Item, { name: "tenement_address", label: "地址", className: "w-48 ", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, {}) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Form$1.Item, { name: "tenement_product_type", label: "產品類別", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Checkbox$1.Group, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { value: "套房", children: "套房" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { value: "辦公室", children: "辦公室" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { value: "店面", children: "店面" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { value: "其他", children: "其他" })
                  ] }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Form$1.Item, { name: "tenement_status", label: "物件狀態", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Checkbox$1.Group, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { value: "未成交", children: "未成交" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { value: "已成交", children: "已成交" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { value: "已成交下架", children: "已成交下架" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { value: "過戶完成下架", children: "過戶完成下架" })
                  ] }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Form$1.Item, { name: "tenement_face", label: "面向", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Checkbox$1.Group, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { value: "海景", children: "海景" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { value: "中庭", children: "中庭" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { value: "三多路", children: "三多路" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { value: "自強路", children: "自強路" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { value: "市景風洞", children: "市景風洞" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { value: "海景風洞", children: "海景風洞" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { value: "其他", children: "其他" })
                  ] }) }),
                  children,
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-6", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Form$1.Item,
                      {
                        name: "floor_min",
                        label: "樓層",
                        rules: [{ message: "請輸入樓層 min" }],
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "min" })
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1", children: "~" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Form$1.Item,
                      {
                        name: "floor_max",
                        rules: [
                          { message: "請輸入樓層 max" },
                          { validator: validateMax("floor_min", "floor_max") }
                        ],
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "max" })
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Form$1.Item, { className: " mb-10", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { type: "primary", htmlType: "submit", className: "bg-blue-600", children: "搜尋" }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Form$1.Item, { className: " mb-10" })
                ] })
              ]
            }
          )
        }
      );
    };
    const TenementLists = () => {
      const [Popout, setPopout] = reactExports.useState(false);
      const handlePopout = () => {
        setPopout(!Popout);
      };
      const [breadcrumbItems, setBreadcrumbItems] = reactExports.useState([{ title: "全部房屋", value: "房屋列表" }]);
      const switchTitletoChinese = (title) => {
        switch (title) {
          case "tenement_address":
            return "地址";
          case "tenement_product_type":
            return "產品類型";
          case "tenement_type":
            return "物件類型";
          case "tenement_face":
            return "面向";
          case "tenement_status":
            return "物件狀態";
          case "selling_price_min":
            return "售價 min";
          case "sellling_price_max":
            return "售價 max";
          case "rent_price_min":
            return "租金 min";
          case "rent_price_max":
            return "租金 max";
          case "floor_min":
            return "樓層 min";
          case "floor_max":
            return "樓層 max";
        }
      };
      const { columns, onRow } = useTenementList();
      const [data, setData] = reactExports.useState([
        {
          tenement_address: "54321",
          tenement_face: "a",
          tenement_status: "a",
          tenement_type: "a",
          tenement_product_type: "a",
          management_fee_bottom: 100,
          management_floor_bottom: 7,
          tenement_id: 1
        },
        {
          tenement_id: 2,
          tenement_address: "54322",
          tenement_face: "b",
          tenement_status: "b",
          tenement_type: "b",
          tenement_product_type: "b",
          management_fee_bottom: 120,
          management_floor_bottom: 11
        },
        {
          tenement_id: 3,
          tenement_address: "54323",
          tenement_face: "c",
          tenement_status: "c",
          tenement_type: "c",
          tenement_product_type: "c",
          management_fee_bottom: 150,
          management_floor_bottom: 3
        },
        {
          tenement_id: 4,
          tenement_address: "54323",
          tenement_face: "d",
          tenement_status: "d",
          tenement_type: "d",
          tenement_product_type: "d",
          management_fee_bottom: 150,
          management_floor_bottom: 3
        }
      ]);
      const { isLoading, isError, dataTenement, handleGetTenement } = useGetTenementList();
      reactExports.useEffect(() => {
        handleGetTenement("");
      }, []);
      reactExports.useEffect(() => {
        if (!dataTenement)
          return;
        const data2 = dataTenement.map((item) => {
          return {
            tenement_id: item.tenement_id,
            tenement_address: item.tenement_address,
            tenement_face: item.tenement_face,
            tenement_status: item.tenement_status,
            tenement_type: item.tenement_type,
            tenement_product_type: item.tenement_product_type,
            management_fee_bottom: item.tenement_type === "行銷追蹤" ? 0 : item.management_fee_bottom,
            management_floor_bottom: item.management_floor_bottom,
            key: item.tenement_address
          };
        });
        setData(data2);
      }, [dataTenement]);
      const handleSelect = (data2) => {
        handleGetTenement(data2);
        const filterData = Object.fromEntries(
          Object.entries(data2).filter(([_, v2]) => v2 !== void 0 && v2 !== "")
        );
        const removeFunction = (item) => {
          if (!item)
            return;
          if (item.value.length === 0) {
            return false;
          }
          if (item.value === void 0) {
            return false;
          } else
            return true;
        };
        const filterDataTitles = Object.entries(filterData).map(([k2, v2]) => ({
          title: k2,
          value: v2
        })).filter(removeFunction);
        handleGetTenement(data2);
        const filterDataTitle = filterDataTitles.map((item) => ({
          title: switchTitletoChinese(item.title),
          value: item.value
        }));
        if (filterDataTitle.length === 0) {
          setBreadcrumbItems([{ title: "全部房屋", value: "房屋列表" }]);
          return;
        }
        setBreadcrumbItems(filterDataTitle);
      };
      const handleReset = () => {
        window.location.reload();
      };
      const [form] = Form$1.useForm();
      const validateMax = (minKey, maxKey) => {
        return async (_, value) => {
          const minValue = form.getFieldValue(minKey);
          if (parseInt(value) < parseInt(minValue)) {
            throw new Error(`${maxKey} 不可小於 ${minKey}`);
          }
        };
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center w-4/5 m-10 ", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex items-center mb-10 justify-evenly w-96", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-4xl ", children: "房屋列表" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { type: "primary", onClick: handlePopout, className: "bg-blue-600 ", children: "篩選" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { type: "primary", className: "bg-blue-600 ", onClick: handleReset, children: "重置" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "篩選條件" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Breadcrumb$1, { className: "mb-5", items: breadcrumbItems }),
        isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "loading..." }) : isError ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "error..." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(TableCompoent, { data, columns, onRow }),
        Popout && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          FilterModule,
          {
            handlePopout,
            handleSelect,
            validateMax,
            form,
            type: "房屋",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Form$1.Item, { name: "tenement_type", label: "物件型態", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Checkbox$1.Group, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { value: "出租", children: "出租" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { value: "出售", children: "出售" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { value: "開發追蹤", children: "開發追蹤" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { value: "行銷追蹤", children: "行銷追蹤" })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex gap-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "rent_price_min",
                    label: "租金",
                    rules: [{ message: "請輸入租金 min" }],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "mix" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1", children: "~" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "rent_price_max",
                    rules: [
                      { message: "請輸入租金 max" },
                      { validator: validateMax("rent_price_min", "rent_price_max") }
                    ],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "max" })
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex gap-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "selling_price_min",
                    label: "售價",
                    rules: [{ message: "請輸入售價 min" }],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "min" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1", children: "~" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "selling_price_max",
                    rules: [
                      { message: "請輸入售價 max" },
                      {
                        validator: validateMax(
                          "selling_price_min",
                          "selling_price_max"
                        )
                      }
                    ],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "max" })
                  }
                )
              ] })
            ]
          }
        )
      ] });
    };
    const LoginForm = () => {
      const navigate = useNavigate();
      const { handleLogin } = useLogin();
      const onFinish = (values) => {
        handleLogin(values).then(() => {
          navigate("/Calenderlist");
        }).catch((err) => {
          console.log(err);
          alert("帳號或密碼錯誤");
        });
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Form$1,
        {
          name: "normal_login",
          className: "login-form",
          initialValues: { remember: true },
          onFinish,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Form$1.Item,
              {
                name: "user_email",
                rules: [{ required: true, message: "請輸入您的信箱" }],
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input$1,
                  {
                    prefix: /* @__PURE__ */ jsxRuntimeExports.jsx(UserOutlined$1, { className: "site-form-item-icon" }),
                    type: "email",
                    placeholder: "信箱"
                  }
                )
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Form$1.Item,
              {
                name: "user_password",
                rules: [{ required: true, message: "請輸入您的密碼" }],
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input$1.Password,
                  {
                    prefix: /* @__PURE__ */ jsxRuntimeExports.jsx(LockOutlined$1, { className: "site-form-item-icon" }),
                    type: "user_password",
                    placeholder: "密碼"
                  }
                )
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Form$1.Item, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button$2,
              {
                type: "primary",
                htmlType: "submit",
                className: "bg-blue-600 login-form-button",
                children: "登入"
              }
            ) })
          ]
        }
      );
    };
    const Login = () => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col items-center justify-center h-screen bg-slate-400 ", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex flex-col items-center justify-center gap-10 p-20 shadow-2xl bg-slate-100 rounded-xl", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-4xl font-extrabold", children: "使用者登入" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(LoginForm, {})
      ] }) });
    };
    const CalenderList = () => {
      const { isLoading, isError, handleGetCalender, dataCalender } = usePostCalenderCollection();
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center w-4/5 m-10 ", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inline-flex items-center mb-10 justify-evenly w-96", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inline-flex items-center justify-evenly w-96", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-4xl ", children: "代收付提醒列表" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex p-4 site-calendar-custom-header gap-x-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "w-4 h-4 bg-red-600 rounded-full" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs", children: "代收" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "w-4 h-4 bg-blue-600 rounded-full" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs", children: "收付" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          CalenderTable,
          {
            isLoading,
            isError,
            handleGetCalender,
            dataCalender
          }
        )
      ] });
    };
    const useTenementListRent = () => {
      const columns = [
        {
          title: "地址",
          dataIndex: "tenement_address",
          key: "tenement_address",
          width: "10%",
          ...getColumnSearchProps("tenement_address")
        },
        {
          title: "面向",
          dataIndex: "tenement_face",
          key: "tenement_face",
          width: "10%",
          filters: [
            {
              text: "海景",
              value: "海景"
            },
            {
              text: "中庭",
              value: "中庭"
            },
            {
              text: "三多路",
              value: "三多路"
            },
            {
              text: "自強路",
              value: "自強路"
            },
            {
              text: "市景風洞",
              value: "市景風洞"
            },
            {
              text: "海景風洞",
              value: "海景風洞"
            },
            {
              text: "其他",
              value: "其他"
            }
          ],
          onFilter: (value, record) => record.tenement_face.includes(value)
        },
        {
          title: "產品類別",
          dataIndex: "tenement_product_type",
          key: "tenement_product_type",
          width: "10%",
          filters: [
            {
              text: "套房",
              value: "套房"
            },
            {
              text: "辦公室",
              value: "辦公室"
            },
            {
              text: "店面",
              value: "店面"
            },
            {
              text: "其他",
              value: "其他"
            }
          ],
          onFilter: (value, record) => record.tenement_product_type.includes(value)
        },
        {
          title: "租金",
          dataIndex: "rent",
          key: "rent",
          width: "10%",
          sorter: (a, b2) => (a.rent || 0) - (b2.rent || 0)
        },
        {
          title: "權狀坪數",
          dataIndex: "Total_rating",
          key: "Total_rating",
          width: "10%",
          sorter: (a, b2) => (a.Total_rating || 0) - (b2.Total_rating || 0)
        },
        {
          title: "室內面積",
          dataIndex: "inside_rating",
          key: "inside_rating",
          width: "10%",
          sorter: (a, b2) => (a.inside_rating || 0) - (b2.inside_rating || 0)
        },
        {
          title: "公設面積",
          dataIndex: "public_building",
          key: "public_building",
          width: "10%",
          sorter: (a, b2) => (a.public_building || 0) - (b2.public_building || 0)
        },
        {
          title: "總樓層",
          dataIndex: "tenement_floor",
          key: "tenement_floor",
          width: "10%",
          sorter: (a, b2) => (a.tenement_floor || 0) - (b2.tenement_floor || 0)
        },
        {
          title: "管理費",
          dataIndex: "management_fee_bottom",
          key: "management_fee_bottom",
          width: "10%",
          sorter: (a, b2) => (a.management_fee_bottom || 0) - (b2.management_fee_bottom || 0)
        }
      ];
      const navigate = useNavigate();
      const switchType = (type) => {
        switch (type) {
          case "出租":
            return "rent";
          case "出售":
            return "sell";
          case "開發追蹤":
            return "develop";
          case "行銷追蹤":
            return "market";
          default:
            return "rent";
        }
      };
      const onRow = (record) => {
        return {
          onClick: () => {
            navigate(
              `/Tenement/${record.tenement_id}/${switchType(
                record.tenement_type
              )}?tenement_type=出租`
            );
          }
        };
      };
      return {
        columns,
        onRow
      };
    };
    const TenementListRent = () => {
      const [Popout, setPopout] = reactExports.useState(false);
      const handlePopout = () => {
        setPopout(!Popout);
      };
      const [breadcrumbItems, setBreadcrumbItems] = reactExports.useState([{ title: "全部房屋", value: "房屋列表" }]);
      const switchTitletoChinese = (title) => {
        switch (title) {
          case "tenement_address":
            return "地址";
          case "tenement_product_type":
            return "產品類別";
          case "tenement_face":
            return "面向";
          case "rent_price_min":
            return "租金 min";
          case "rent_price_max":
            return "租金 max";
          case "total_rating_min":
            return "權狀坪數 min";
          case "total_rating_max":
            return "權狀坪數 max";
          case "inside_rating_min":
            return "室內面積 min";
          case "inside_rating_max":
            return "室內面積 max";
          case "public_building_min":
            return "公設面積 min";
          case "public_building_max":
            return "公設面積 max";
          case "management_fee_min":
            return "管理費 min";
          case "management_fee_max":
            return "管理費 max";
          case "tenement_status":
            return "物件狀態";
          case "floor_min":
            return "樓層 min";
          case "floor_max":
            return "樓層 max";
        }
      };
      const { columns, onRow } = useTenementListRent();
      const { isLoading, isError, dataTenement, handleGetTenement } = useGetTenementListRent();
      const [data, setData] = reactExports.useState([
        {
          tenement_id: 1,
          tenement_address: "地址",
          tenement_face: "海景",
          tenement_status: "未成交",
          tenement_type: "出售",
          tenement_product_type: "辦公室",
          management_fee_bottom: 100,
          management_floor_bottom: 7,
          rent: 100,
          Total_rating: 100,
          inside_rating: 100,
          public_building: 100,
          tenement_floor: 100
        },
        {
          tenement_id: 2,
          tenement_address: "地址",
          tenement_face: "中庭",
          tenement_status: "已成交",
          tenement_type: "出租",
          tenement_product_type: "店面",
          management_fee_bottom: 120,
          management_floor_bottom: 11,
          rent: 120,
          Total_rating: 120,
          inside_rating: 120,
          public_building: 120,
          tenement_floor: 120
        },
        {
          tenement_id: 3,
          tenement_address: "地址",
          tenement_face: "三多路",
          tenement_status: "已退租下架",
          tenement_type: "開發追蹤",
          tenement_product_type: "套房",
          management_fee_bottom: 150,
          management_floor_bottom: 3,
          rent: 150,
          Total_rating: 150,
          inside_rating: 150,
          public_building: 150,
          tenement_floor: 150
        },
        {
          tenement_id: 4,
          tenement_address: "地址",
          tenement_face: "三多路",
          tenement_status: "過戶完成下架",
          tenement_type: "行銷追蹤",
          tenement_product_type: "套房",
          management_fee_bottom: 150,
          management_floor_bottom: 3,
          rent: 150,
          Total_rating: 150,
          inside_rating: 150,
          public_building: 150,
          tenement_floor: 150
        }
      ]);
      reactExports.useEffect(() => {
        handleGetTenement("");
      }, []);
      reactExports.useEffect(() => {
        if (!dataTenement)
          return;
        const data2 = dataTenement.map((item) => {
          return {
            tenement_id: item.tenement_id,
            tenement_address: item.tenement_address,
            tenement_face: item.tenement_face,
            tenement_status: item.tenement_status,
            tenement_type: item.tenement_type,
            tenement_product_type: item.tenement_product_type,
            management_fee_bottom: item.management_fee_bottom,
            management_floor_bottom: item.management_floor_bottom,
            rent: item.rent,
            Total_rating: item.Total_rating,
            inside_rating: item.inside_rating,
            public_building: item.public_building,
            tenement_floor: item.tenement_floor,
            key: item.tenement_address
          };
        });
        setData(data2);
      }, [dataTenement]);
      const handleSelect = (data2) => {
        handleGetTenement(data2);
        const filterData = Object.fromEntries(
          Object.entries(data2).filter(
            ([_, v2]) => v2 !== void 0 && v2 !== "" && v2 !== 0
          )
        );
        const removeFunction = (item) => {
          if (!item)
            return;
          if (item.value.length === 0) {
            return false;
          }
          if (item.value === void 0) {
            return false;
          } else
            return true;
        };
        const filterDataTitles = Object.entries(filterData).map(([k2, v2]) => ({
          title: k2,
          value: v2
        })).filter(removeFunction);
        const filterDataTitle = filterDataTitles.map((item) => ({
          title: switchTitletoChinese(item.title),
          value: item.value
        }));
        if (filterDataTitle.length === 0) {
          setBreadcrumbItems([{ title: "全部房屋", value: "房屋列表" }]);
          return;
        }
        setBreadcrumbItems(filterDataTitle);
      };
      const handleReset = () => {
        setBreadcrumbItems([{ title: "全部房屋", value: "房屋列表" }]);
        window.location.reload();
      };
      const [form] = Form$1.useForm();
      const validateMax = (minKey, maxKey) => {
        return async (_, value) => {
          const minValue = form.getFieldValue(minKey);
          if (parseInt(value) < parseInt(minValue)) {
            throw new Error(`${maxKey} 不可小於 ${minKey}`);
          }
        };
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center w-4/5 m-10 ", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex items-center mb-10 justify-evenly w-96", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-4xl ", children: "出租列表" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { type: "primary", onClick: handlePopout, className: "bg-blue-600 ", children: "篩選" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { type: "primary", className: "bg-blue-600 ", onClick: handleReset, children: "重置" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "篩選條件" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Breadcrumb$1, { className: "mb-5", items: breadcrumbItems }),
        isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "loading..." }) : isError ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "error..." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(TableCompoent, { data, columns, onRow }),
        Popout && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          FilterModule,
          {
            handlePopout,
            handleSelect,
            form,
            validateMax,
            type: "出租",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex gap-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "rent_price_min",
                    label: "租金",
                    rules: [{ message: "請輸入租金 min" }],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "mix" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1", children: "~" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "rent_price_max",
                    rules: [
                      { message: "請輸入租金 max" },
                      { validator: validateMax("rent_price_min", "rent_price_max") }
                    ],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "max" })
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex gap-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "total_rating_min",
                    label: "權狀坪數",
                    rules: [{ message: "請輸入樓層 min" }],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "min" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1", children: "~" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "total_rating_max",
                    rules: [
                      { message: "請輸入樓層 max" },
                      {
                        validator: validateMax(
                          "total_rating_min",
                          "total_rating_max"
                        )
                      }
                    ],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "max" })
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex gap-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "inside_rating_min",
                    label: "室內面積",
                    rules: [{ message: "請輸入樓層 min" }],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "min" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1", children: "~" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "inside_rating_max",
                    rules: [
                      { message: "請輸入樓層 max" },
                      {
                        validator: validateMax(
                          "inside_rating_min",
                          "inside_rating_max"
                        )
                      }
                    ],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "max" })
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex gap-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "public_building_min",
                    label: "公設面積",
                    rules: [{ message: "請輸入樓層 min" }],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "min" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1", children: "~" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "public_building_max",
                    rules: [
                      { message: "請輸入樓層 max" },
                      {
                        validator: validateMax(
                          "public_building_min",
                          "public_building_max"
                        )
                      }
                    ],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "max" })
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex gap-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "management_fee_min",
                    label: "管理費",
                    rules: [{ message: "請輸入樓層 min" }],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "min" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1", children: "~" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "management_fee_max",
                    rules: [
                      { message: "請輸入樓層 max" },
                      {
                        validator: validateMax(
                          "management_fee_min",
                          "management_fee_max"
                        )
                      }
                    ],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "max" })
                  }
                )
              ] })
            ]
          }
        )
      ] });
    };
    const useTenementListSell = () => {
      const columns = [
        {
          title: "地址",
          dataIndex: "tenement_address",
          key: "tenement_address",
          width: "10%",
          ...getColumnSearchProps("tenement_address")
        },
        {
          title: "面向",
          dataIndex: "tenement_face",
          key: "tenement_face",
          width: "10%",
          filters: [
            {
              text: "海景",
              value: "海景"
            },
            {
              text: "中庭",
              value: "中庭"
            },
            {
              text: "三多路",
              value: "三多路"
            },
            {
              text: "自強路",
              value: "自強路"
            },
            {
              text: "市景風洞",
              value: "市景風洞"
            },
            {
              text: "海景風洞",
              value: "海景風洞"
            },
            {
              text: "其他",
              value: "其他"
            }
          ],
          onFilter: (value, record) => record.tenement_face.includes(value)
        },
        {
          title: "產品類別",
          dataIndex: "tenement_product_type",
          key: "tenement_product_type",
          width: "10%",
          filters: [
            {
              text: "套房",
              value: "套房"
            },
            {
              text: "辦公室",
              value: "辦公室"
            },
            {
              text: "店面",
              value: "店面"
            },
            {
              text: "其他",
              value: "其他"
            }
          ],
          onFilter: (value, record) => record.tenement_product_type.includes(value)
        },
        {
          title: "售價",
          dataIndex: "selling_price",
          key: "selling_price",
          width: "10%",
          sorter: (a, b2) => (a.selling_price || 0) - (b2.selling_price || 0)
        },
        {
          title: "權狀坪數",
          dataIndex: "Total_rating",
          key: "Total_rating",
          width: "10%",
          sorter: (a, b2) => (a.Total_rating || 0) - (b2.Total_rating || 0)
        },
        {
          title: "室內面積",
          dataIndex: "inside_rating",
          key: "inside_rating",
          width: "10%",
          sorter: (a, b2) => (a.inside_rating || 0) - (b2.inside_rating || 0)
        },
        {
          title: "公設面積",
          dataIndex: "public_building",
          key: "public_building",
          width: "10%",
          sorter: (a, b2) => (a.public_building || 0) - (b2.public_building || 0)
        },
        {
          title: "總樓層",
          dataIndex: "tenement_floor",
          key: "tenement_floor",
          width: "10%",
          sorter: (a, b2) => (a.tenement_floor || 0) - (b2.tenement_floor || 0)
        },
        {
          title: "管理費",
          dataIndex: "management_fee_bottom",
          key: "management_fee_bottom",
          width: "10%",
          sorter: (a, b2) => (a.management_fee_bottom || 0) - (b2.management_fee_bottom || 0)
        }
      ];
      const navigate = useNavigate();
      const switchType = (type) => {
        switch (type) {
          case "出租":
            return "rent";
          case "出售":
            return "sell";
          case "開發追蹤":
            return "develop";
          case "行銷追蹤":
            return "market";
          default:
            return "rent";
        }
      };
      const onRow = (record) => {
        return {
          onClick: () => {
            navigate(
              `/Tenement/${record.tenement_id}/${switchType(
                record.tenement_type
              )}?tenement_type=出售`
            );
          }
        };
      };
      return {
        columns,
        onRow
      };
    };
    const TenementListSell = () => {
      const [Popout, setPopout] = reactExports.useState(false);
      const handlePopout = () => {
        setPopout(!Popout);
      };
      const [breadcrumbItems, setBreadcrumbItems] = reactExports.useState([{ title: "全部房屋", value: "房屋列表" }]);
      const switchTitletoChinese = (title) => {
        switch (title) {
          case "tenement_address":
            return "地址";
          case "tenement_product_type":
            return "產品類別";
          case "tenement_face":
            return "面向";
          case "rent_price_min":
            return "租金 min";
          case "rent_price_max":
            return "租金 max";
          case "total_rating_min":
            return "權狀坪數 min";
          case "total_rating_max":
            return "權狀坪數 max";
          case "inside_rating_min":
            return "室內面積 min";
          case "inside_rating_max":
            return "室內面積 max";
          case "public_building_min":
            return "公設面積 min";
          case "public_building_max":
            return "公設面積 max";
          case "management_fee_min":
            return "管理費 min";
          case "management_fee_max":
            return "管理費 max";
          case "tenement_status":
            return "物件狀態";
          case "floor_min":
            return "樓層 min";
          case "floor_max":
            return "樓層 max";
          case "selling_price_min":
            return "售價 min";
          case "selling_price_max":
            return "售價 max";
        }
      };
      const { columns, onRow } = useTenementListSell();
      const { isLoading, isError, dataTenement, handleGetTenement } = useGetTenementListSell();
      const [data, setData] = reactExports.useState([
        {
          tenement_id: 1,
          tenement_address: "地址",
          tenement_face: "海景",
          tenement_status: "未成交",
          tenement_type: "出售",
          tenement_product_type: "辦公室",
          management_fee_bottom: 100,
          rent: 100,
          Total_rating: 100,
          inside_rating: 100,
          public_building: 100,
          tenement_floor: 100
        },
        {
          tenement_id: 2,
          tenement_address: "地址",
          tenement_face: "中庭",
          tenement_status: "已成交",
          tenement_type: "出租",
          tenement_product_type: "店面",
          management_fee_bottom: 120,
          rent: 120,
          Total_rating: 120,
          inside_rating: 120,
          public_building: 120,
          tenement_floor: 120
        },
        {
          tenement_id: 3,
          tenement_address: "地址",
          tenement_face: "三多路",
          tenement_status: "已退租下架",
          tenement_type: "開發追蹤",
          tenement_product_type: "套房",
          management_fee_bottom: 150,
          rent: 150,
          Total_rating: 150,
          inside_rating: 150,
          public_building: 150,
          tenement_floor: 150
        },
        {
          tenement_id: 4,
          tenement_address: "地址",
          tenement_face: "三多路",
          tenement_status: "過戶完成下架",
          tenement_type: "行銷追蹤",
          tenement_product_type: "套房",
          management_fee_bottom: 150,
          rent: 150,
          Total_rating: 150,
          inside_rating: 150,
          public_building: 150,
          tenement_floor: 150
        }
      ]);
      reactExports.useEffect(() => {
        handleGetTenement("");
      }, []);
      reactExports.useEffect(() => {
        if (!dataTenement)
          return;
        const data2 = dataTenement.map((item) => {
          return {
            tenement_id: item.tenement_id,
            tenement_address: item.tenement_address,
            tenement_face: item.tenement_face,
            tenement_status: item.tenement_status,
            tenement_type: item.tenement_type,
            tenement_product_type: item.tenement_product_type,
            management_fee_bottom: item.management_fee_bottom,
            selling_price: item.selling_price,
            Total_rating: item.Total_rating,
            inside_rating: item.inside_rating,
            public_building: item.public_building,
            tenement_floor: item.tenement_floor,
            key: item.tenement_address
          };
        });
        setData(data2);
      }, [dataTenement]);
      const handleSelect = (data2) => {
        const filterData = Object.fromEntries(
          Object.entries(data2).filter(([_, v2]) => v2 !== void 0 && v2 !== "")
        );
        const removeFunction = (item) => {
          if (!item)
            return;
          if (item.value.length === 0) {
            return false;
          }
          if (item.value === void 0) {
            return false;
          } else
            return true;
        };
        const filterDataTitles = Object.entries(filterData).map(([k2, v2]) => ({
          title: k2,
          value: v2
        })).filter(removeFunction);
        handleGetTenement(data2);
        const filterDataTitle = filterDataTitles.map((item) => ({
          title: switchTitletoChinese(item.title),
          value: item.value
        }));
        if (filterDataTitle.length === 0) {
          setBreadcrumbItems([{ title: "全部房屋", value: "房屋列表" }]);
          return;
        }
        setBreadcrumbItems(filterDataTitle);
      };
      const handleReset = () => {
        window.location.reload();
      };
      const [form] = Form$1.useForm();
      const validateMax = (minKey, maxKey) => {
        return async (_, value) => {
          const minValue = form.getFieldValue(minKey);
          if (parseInt(value) < parseInt(minValue)) {
            throw new Error(`${maxKey} 不可小於 ${minKey}`);
          }
        };
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center w-4/5 m-10 ", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex items-center mb-10 justify-evenly w-96", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-4xl ", children: "出售列表" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { type: "primary", onClick: handlePopout, className: "bg-blue-600 ", children: "篩選" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { type: "primary", className: "bg-blue-600 ", onClick: handleReset, children: "重置" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "篩選條件" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Breadcrumb$1, { className: "mb-5", items: breadcrumbItems }),
        isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "loading..." }) : isError ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "error..." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(TableCompoent, { data, columns, onRow }),
        Popout && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          FilterModule,
          {
            handlePopout,
            handleSelect,
            validateMax,
            form,
            type: "出售",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex gap-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "selling_price_min",
                    label: "售價",
                    rules: [{ message: "請輸入售價 min" }],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "mix" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1", children: "~" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "selling_price_max",
                    rules: [
                      { message: "請輸入售價 max" },
                      {
                        validator: validateMax(
                          "selling_price_min",
                          "selling_price_max"
                        )
                      }
                    ],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "max" })
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex gap-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "total_rating_min",
                    label: "權狀坪數",
                    rules: [{ message: "請輸入樓層 min" }],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "min" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1", children: "~" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "total_rating_max",
                    rules: [
                      { message: "請輸入樓層 max" },
                      {
                        validator: validateMax(
                          "total_rating_min",
                          "total_rating_max"
                        )
                      }
                    ],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "max" })
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex gap-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "inside_rating_min",
                    label: "室內面積",
                    rules: [{ message: "請輸入樓層 min" }],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "min" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1", children: "~" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "inside_rating_max",
                    rules: [
                      { message: "請輸入樓層 max" },
                      {
                        validator: validateMax(
                          "inside_rating_min",
                          "inside_rating_max"
                        )
                      }
                    ],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "max" })
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex gap-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "public_building_min",
                    label: "公設面積",
                    rules: [{ message: "請輸入樓層 min" }],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "min" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1", children: "~" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "public_building_max",
                    rules: [
                      { message: "請輸入樓層 max" },
                      {
                        validator: validateMax(
                          "public_building_min",
                          "public_building_max"
                        )
                      }
                    ],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "max" })
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex gap-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "management_fee_min",
                    label: "管理費",
                    rules: [{ message: "請輸入樓層 min" }],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "min" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1", children: "~" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "management_fee_max",
                    rules: [
                      { message: "請輸入樓層 max" },
                      {
                        validator: validateMax(
                          "management_fee_min",
                          "management_fee_max"
                        )
                      }
                    ],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "max" })
                  }
                )
              ] })
            ]
          }
        )
      ] });
    };
    function useTenementNotice(tenementType, tenementId) {
      const nowdatestring = hooks().format("YYYY-MM-DD");
      const [notices, setNotices] = reactExports.useState([
        {
          id: 1,
          visitDate: nowdatestring,
          record: "紀錄事項1",
          remindDate: nowdatestring,
          remind: "提醒事項1"
        }
      ]);
      const { isLoading, isError, getNotice, dataNotice } = useGetNotice();
      const { handlePutNotice } = usePutNotice();
      const handleSaveNoticeData = () => {
        handlePutNotice(tenementType, notices);
      };
      const handleAddNotice = async () => {
        console.log(tenementId);
        const newNotice = {
          visitDate: nowdatestring,
          record: "",
          remindDate: nowdatestring,
          remind: "",
          collection_id: Number(tenementId)
        };
        const newNoticeData = await handlePostAddNotice(tenementType, [newNotice]);
        if (newNoticeData === void 0)
          return;
        setNotices((prevNotices) => {
          return [...prevNotices, ...newNoticeData];
        });
      };
      reactExports.useEffect(() => {
        getNotice(tenementType, tenementId);
      }, []);
      reactExports.useEffect(() => {
        if (!dataNotice)
          return;
        setNotices(dataNotice);
      }, [dataNotice]);
      const handleNoticeChange = (index2, key, value) => {
        setNotices(
          (prev2) => prev2.map(
            (notice, i) => i === index2 ? { ...notice, [key]: value } : notice
          )
        );
      };
      const { handleDeleteNoticeApi } = useDeleteNotice();
      const handleDeleteNotice = (index2) => {
        handleDeleteNoticeApi(notices[index2].id, tenementType);
        setNotices((prev2) => prev2.filter((_, i) => i !== index2));
      };
      return {
        states: {
          notices,
          isLoading,
          isError
        },
        handlers: {
          handleNoticeChange,
          handleDeleteNotice,
          handleAddNotice,
          handleSaveNoticeData
        }
      };
    }
    function useTenementMarketInfo(tenementId) {
      const [marketInfo, setMarketInfo] = reactExports.useState({
        tenement_id: 1,
        tenement_address: "1234",
        tenement_product_type: "套房",
        tenement_type: "行銷追蹤",
        tenement_face: "海景",
        tenement_images: [],
        tenement_host_name: "John",
        tenement_host_telphone: "0987654321",
        tenement_host_phone: "0987654321",
        tenement_host_line: "line_id",
        tenement_host_remittance_bank: "ABC Bank",
        tenement_host_remittance_account: "1234567890",
        tenement_host_address: "台北市大安區",
        tenement_host_birthday: "1950-09-01",
        tenement_host_hobby: "打球",
        tenement_host_remark: "備註",
        tenement_area_max: "10",
        tenement_area_min: "5",
        burget_rent_max: "20000",
        burget_rent_min: "10000",
        hopefloor_max: "5",
        hopefloor_min: "2",
        market_state: "租房"
      });
      const handleChange = (key, value) => {
        setMarketInfo((prev2) => {
          if (!prev2)
            return prev2;
          return { ...prev2, [key]: value };
        });
      };
      const { handleSaveColumn } = usePostMarketEdit();
      const handleSave = () => {
        if (!tenementId)
          return;
        const marketinfo = {
          ...marketInfo,
          tenement_id: tenementId
        };
        handleSaveColumn(marketinfo);
      };
      const { handleDeleteTenement } = useDeleteTenement();
      const handleDelete = (tenement_type, isRollback = false) => {
        if (!tenementId)
          return;
        !isRollback && handleDeleteTenement(tenementId, tenement_type);
        isRollback && hardDeleteTenement(tenementId, tenement_type);
        alert("刪除成功");
      };
      const { getMarketEdit, dataEdit, isError, isLoading } = useGetMarketEdit();
      reactExports.useEffect(() => {
        getMarketEdit(tenementId);
      }, [tenementId]);
      const query = new URLSearchParams(window.location.search);
      const tenementTypeOnQuery = query.get("tenement_type");
      reactExports.useEffect(() => {
        if (!dataEdit)
          return;
        setMarketInfo({
          tenement_id: Number(dataEdit.tenement_id),
          tenement_address: dataEdit.tenement_address,
          tenement_product_type: dataEdit.tenement_product_type,
          tenement_type: tenementTypeOnQuery ? tenementTypeOnQuery : dataEdit.tenement_type,
          tenement_face: dataEdit.tenement_face,
          tenement_images: dataEdit.tenement_images,
          tenement_host_name: dataEdit.tenement_host_name,
          tenement_host_telphone: dataEdit.tenement_host_telphone,
          tenement_host_phone: dataEdit.tenement_host_phone,
          tenement_host_line: dataEdit.tenement_host_line,
          tenement_host_remittance_bank: dataEdit.tenement_host_remittance_bank,
          tenement_host_remittance_account: dataEdit.tenement_host_remittance_account,
          tenement_host_address: dataEdit.tenement_host_address,
          tenement_host_birthday: dataEdit.tenement_host_birthday,
          tenement_host_hobby: dataEdit.tenement_host_hobby,
          tenement_host_remark: dataEdit.tenement_host_remark,
          tenement_area_max: dataEdit.tenement_area_max,
          tenement_area_min: dataEdit.tenement_area_min,
          burget_rent_max: dataEdit.burget_rent_max,
          burget_rent_min: dataEdit.burget_rent_min,
          hopefloor_max: dataEdit.hopefloor_max,
          hopefloor_min: dataEdit.hopefloor_min,
          market_state: dataEdit.market_state
        });
      }, [dataEdit]);
      return {
        states: {
          marketInfo,
          isLoading,
          isError
        },
        handlers: {
          handleChange,
          handleSave,
          handleDelete
        }
      };
    }
    function useTenementRentInfo(tenementId) {
      const [rentInfo, setRentInfo] = reactExports.useState({
        tenement_id: 1,
        tenement_address: "1234",
        tenement_product_type: "套房",
        tenement_type: "出租",
        tenement_face: "海景",
        tenement_images: [],
        tenement_status: "已成交",
        total_rating: "4",
        main_building: "3",
        affiliated_building: "2",
        public_building: "1",
        unregistered_area: "2",
        management_magnification: "1.5",
        management_fee: "3000",
        rent_price: "20000",
        deposit_price: "40000",
        tenement_floor: "7",
        tenement_host_name: "John Doe",
        tenement_host_telphone: "1234567890",
        tenement_host_phone: "0987654321",
        tenement_host_line: "john_doe",
        tenement_host_remittance_bank: "Bank of America",
        tenement_host_remittance_account: "9876543210",
        tenement_host_address: "123 Main St, City, Country",
        tenement_host_birthday: "1980-01-01",
        tenement_host_hobby: "Reading",
        tenement_host_remark: "No remarks",
        renter_start_date: "2022-01-01",
        renter_end_date: "2023-01-01",
        renter_name: "Jane Doe",
        renter_id_images: [],
        renter_phone: "0987654321",
        renter_jobtitle: "Software Engineer",
        renter_guarantor_name: "John Smith",
        renter_guarantor_phone: "1234567890",
        renter_remark: "No remarks"
      });
      const handleChange = (key, value) => {
        setRentInfo((prev2) => {
          if (!prev2)
            return prev2;
          return { ...prev2, [key]: value };
        });
      };
      const { handleSaveColumn } = usePostRentEdit();
      const handleSave = () => {
        if (!tenementId)
          return;
        const rentinfo = {
          ...rentInfo,
          tenement_id: Number(tenementId)
        };
        handleSaveColumn(rentinfo);
      };
      const { handleDeleteTenement } = useDeleteTenement();
      const handleDelete = (tenement_type, isRollback = false) => {
        if (!tenementId)
          return;
        !isRollback && handleDeleteTenement(tenementId, tenement_type);
        isRollback && hardDeleteTenement(tenementId, tenement_type);
        alert("刪除成功");
      };
      const { getRentEdit, dataEdit, isError, isLoading } = useGetRentEdit();
      reactExports.useEffect(() => {
        getRentEdit(tenementId);
      }, [tenementId]);
      const query = new URLSearchParams(window.location.search);
      const tenementTypeOnQuery = query.get("tenement_type");
      reactExports.useEffect(() => {
        if (!dataEdit)
          return;
        setRentInfo({
          tenement_id: dataEdit.tenement_id,
          tenement_address: dataEdit.tenement_address,
          tenement_product_type: dataEdit.tenement_product_type,
          tenement_type: tenementTypeOnQuery ? tenementTypeOnQuery : dataEdit.tenement_type,
          tenement_face: dataEdit.tenement_face,
          tenement_images: dataEdit.tenement_images,
          tenement_status: dataEdit.tenement_status,
          total_rating: dataEdit.total_rating,
          main_building: dataEdit.main_building,
          affiliated_building: dataEdit.affiliated_building,
          public_building: dataEdit.public_building,
          unregistered_area: dataEdit.unregistered_area,
          management_magnification: dataEdit.management_magnification,
          management_fee: dataEdit.management_fee,
          rent_price: dataEdit.rent_price,
          deposit_price: dataEdit.deposit_price,
          tenement_floor: dataEdit.tenement_floor,
          tenement_host_name: dataEdit.tenement_host_name,
          tenement_host_telphone: dataEdit.tenement_host_telphone,
          tenement_host_phone: dataEdit.tenement_host_phone,
          tenement_host_line: dataEdit.tenement_host_line,
          tenement_host_remittance_bank: dataEdit.tenement_host_remittance_bank,
          tenement_host_remittance_account: dataEdit.tenement_host_remittance_account,
          tenement_host_address: dataEdit.tenement_host_address,
          tenement_host_birthday: dataEdit.tenement_host_birthday,
          tenement_host_hobby: dataEdit.tenement_host_hobby,
          tenement_host_remark: dataEdit.tenement_host_remark,
          renter_start_date: dataEdit.renter_start_date,
          renter_end_date: dataEdit.renter_end_date,
          renter_name: dataEdit.renter_name,
          renter_id_images: dataEdit.renter_id_images,
          renter_phone: dataEdit.renter_phone,
          renter_jobtitle: dataEdit.renter_jobtitle,
          renter_guarantor_name: dataEdit.renter_guarantor_name,
          renter_guarantor_phone: dataEdit.renter_guarantor_phone,
          renter_remark: dataEdit.renter_remark
        });
      }, [dataEdit]);
      return {
        states: {
          rentInfo,
          isLoading,
          isError
        },
        handlers: {
          handleChange,
          handleSave,
          handleDelete
        }
      };
    }
    function useTenementDevelopInfo(tenementId) {
      const [developInfo, setDevelopInfo] = reactExports.useState({
        tenement_id: 1,
        tenement_address: "1234",
        tenement_product_type: "套房",
        tenement_type: "開發追蹤",
        tenement_face: "海景",
        tenement_images: [],
        total_rating: "4.5",
        main_building: "100",
        affiliated_building: "50",
        public_building: "30",
        unregistered_area: "20",
        management_magnification: "1.5",
        management_fee: "3000",
        selling_price: "500000",
        rent_price: "20000",
        deposit_price: "40000",
        tenement_floor: "7",
        tenement_host_name: "John Doe",
        tenement_host_telphone: "1234567890",
        tenement_host_phone: "0987654321",
        tenement_host_line: "john_doe",
        tenement_host_remittance_bank: "Bank of America",
        tenement_host_remittance_account: "9876543210",
        tenement_host_address: "123 Main St, City, Country",
        tenement_host_birthday: "1980-01-01",
        tenement_host_hobby: "Reading",
        tenement_host_remark: "No remarks"
      });
      const handleChange = (key, value) => {
        setDevelopInfo((prev2) => {
          if (!prev2)
            return prev2;
          return { ...prev2, [key]: value };
        });
      };
      const { handleSaveColumn } = usePostDevelopEdit();
      const handleSave = () => {
        if (!tenementId)
          return;
        handleSaveColumn(developInfo);
      };
      const { handleDeleteTenement } = useDeleteTenement();
      const handleDelete = (tenement_type, isRollback = false) => {
        if (!tenementId)
          return;
        !isRollback && handleDeleteTenement(tenementId, tenement_type);
        isRollback && hardDeleteTenement(tenementId, tenement_type);
        alert("刪除成功");
      };
      const { getDevelopEdit, dataEdit, isError, isLoading } = useGetDevelopEdit();
      reactExports.useEffect(() => {
        getDevelopEdit(tenementId);
      }, [tenementId]);
      const query = new URLSearchParams(window.location.search);
      const tenementTypeOnQuery = query.get("tenement_type");
      reactExports.useEffect(() => {
        if (!dataEdit)
          return;
        setDevelopInfo({
          tenement_id: Number(dataEdit.tenement_id),
          tenement_address: dataEdit.tenement_address,
          tenement_product_type: dataEdit.tenement_product_type,
          tenement_type: tenementTypeOnQuery ? tenementTypeOnQuery : dataEdit.tenement_type,
          tenement_face: dataEdit.tenement_face,
          tenement_images: dataEdit.tenement_images,
          total_rating: dataEdit.total_rating,
          main_building: dataEdit.main_building,
          affiliated_building: dataEdit.affiliated_building,
          public_building: dataEdit.public_building,
          unregistered_area: dataEdit.unregistered_area,
          management_magnification: dataEdit.management_magnification,
          management_fee: dataEdit.management_fee,
          selling_price: dataEdit.selling_price,
          rent_price: dataEdit.rent_price,
          deposit_price: dataEdit.deposit_price,
          tenement_floor: dataEdit.tenement_floor,
          tenement_host_name: dataEdit.tenement_host_name,
          tenement_host_telphone: dataEdit.tenement_host_telphone,
          tenement_host_phone: dataEdit.tenement_host_phone,
          tenement_host_line: dataEdit.tenement_host_line,
          tenement_host_remittance_bank: dataEdit.tenement_host_remittance_bank,
          tenement_host_remittance_account: dataEdit.tenement_host_remittance_account,
          tenement_host_address: dataEdit.tenement_host_address,
          tenement_host_birthday: dataEdit.tenement_host_birthday,
          tenement_host_hobby: dataEdit.tenement_host_hobby,
          tenement_host_remark: dataEdit.tenement_host_remark
        });
      }, [dataEdit]);
      return {
        states: {
          developInfo,
          isLoading,
          isError
        },
        handlers: {
          handleChange,
          handleSave,
          handleDelete
        }
      };
    }
    function useTenementSellInfo(tenementId) {
      const [sellInfo, setSellInfo] = reactExports.useState({
        tenement_id: 1,
        tenement_address: "aaaaa",
        tenement_product_type: "套房",
        tenement_type: "出售",
        tenement_face: "海景",
        tenement_images: [],
        tenement_status: "已成交",
        total_rating: "4.5",
        main_building: "100",
        affiliated_building: "50",
        public_building: "30",
        unregistered_area: "20",
        management_magnification: "1.5",
        management_fee: "3000",
        selling_price: "500000",
        tenement_floor: "7",
        tenement_host_name: "John Doe",
        tenement_host_telphone: "1234567890",
        tenement_host_phone: "0987654321",
        tenement_host_line: "john_doe",
        tenement_host_remittance_bank: "Bank of America",
        tenement_host_remittance_account: "9876543210",
        tenement_host_address: "123 Main St, City, Country",
        tenement_host_birthday: "1980-01-01",
        tenement_host_hobby: "Reading",
        tenement_host_remark: "No remarks",
        buyer_order_date: "2022-01-01",
        buyer_handout_date: "2022-02-01",
        buyer_name: "Jane Doe",
        buyer_id_images: [],
        buyer_phone: "0987654321",
        buyer_jobtitle: "Software Engineer",
        buyer_remark: "No remarks"
      });
      const handleChange = (key, value) => {
        setSellInfo((prev2) => {
          if (!prev2)
            return prev2;
          return { ...prev2, [key]: value };
        });
      };
      const { handleSaveColumn } = usePostSellEdit();
      const handleSave = () => {
        if (!tenementId)
          return;
        handleSaveColumn(sellInfo);
        alert("儲存成功");
      };
      const { handleDeleteTenement } = useDeleteTenement();
      const handleDelete = (tenement_type, isRollback = false) => {
        if (!tenementId)
          return;
        !isRollback && handleDeleteTenement(tenementId, tenement_type);
        isRollback && hardDeleteTenement(tenementId, tenement_type);
        alert("刪除成功");
      };
      const { getSellEdit, dataEdit, isError, isLoading } = useGetSellEdit();
      reactExports.useEffect(() => {
        getSellEdit(tenementId);
      }, [tenementId]);
      const query = new URLSearchParams(window.location.search);
      const tenementTypeOnQuery = query.get("tenement_type");
      reactExports.useEffect(() => {
        if (!dataEdit)
          return;
        setSellInfo({
          tenement_id: Number(dataEdit.tenement_id),
          tenement_address: dataEdit.tenement_address,
          tenement_product_type: dataEdit.tenement_product_type,
          tenement_type: tenementTypeOnQuery ? tenementTypeOnQuery : dataEdit.tenement_type,
          tenement_face: dataEdit.tenement_face,
          tenement_images: dataEdit.tenement_images,
          tenement_status: dataEdit.tenement_status,
          total_rating: dataEdit.total_rating,
          main_building: dataEdit.main_building,
          affiliated_building: dataEdit.affiliated_building,
          public_building: dataEdit.public_building,
          unregistered_area: dataEdit.unregistered_area,
          management_magnification: dataEdit.management_magnification,
          management_fee: dataEdit.management_fee,
          selling_price: dataEdit.selling_price,
          tenement_floor: dataEdit.tenement_floor,
          tenement_host_name: dataEdit.tenement_host_name,
          tenement_host_telphone: dataEdit.tenement_host_telphone,
          tenement_host_phone: dataEdit.tenement_host_phone,
          tenement_host_line: dataEdit.tenement_host_line,
          tenement_host_remittance_bank: dataEdit.tenement_host_remittance_bank,
          tenement_host_remittance_account: dataEdit.tenement_host_remittance_account,
          tenement_host_address: dataEdit.tenement_host_address,
          tenement_host_birthday: dataEdit.tenement_host_birthday,
          tenement_host_hobby: dataEdit.tenement_host_hobby,
          tenement_host_remark: dataEdit.tenement_host_remark,
          buyer_order_date: dataEdit.buyer_order_date,
          buyer_handout_date: dataEdit.buyer_handout_date,
          buyer_name: dataEdit.buyer_name,
          buyer_id_images: dataEdit.buyer_id_images,
          buyer_phone: dataEdit.buyer_phone,
          buyer_jobtitle: dataEdit.buyer_jobtitle,
          buyer_remark: dataEdit.buyer_remark
        });
      }, [dataEdit]);
      return {
        states: {
          sellInfo,
          isLoading,
          isError
        },
        handlers: {
          handleChange,
          handleSave,
          handleDelete
        }
      };
    }
    function Market() {
      const { id: tenementId } = useParams();
      const query = new URLSearchParams(window.location.search);
      const isRollback = query.get("rollback");
      const getRentHook = useGetRentEdit();
      const getSellHook = useGetSellEdit();
      const getDevelopHook = useGetDevelopEdit();
      const getMarketHook = useGetMarketEdit();
      const noticeHook = useTenementNotice("market", tenementId);
      const marketHook = useTenementMarketInfo(tenementId);
      const onSave = () => {
        noticeHook.handlers.handleSaveNoticeData();
        marketHook.handlers.handleSave();
        alert("儲存成功");
      };
      const onDelete = () => {
        if (window.confirm("確定要刪除嗎?")) {
          marketHook.handlers.handleDelete("market", isRollback !== null);
        } else
          return;
      };
      const isLoading = marketHook.states.isLoading || noticeHook.states.isLoading;
      const isError = marketHook.states.isError || noticeHook.states.isError;
      const navigate = useNavigate();
      const handletypeChange = async (e2) => {
        const marketData = marketHook.states.marketInfo;
        const urlParams = new URLSearchParams();
        if (marketData.tenement_images.length > 0) {
          urlParams.append(
            "tenement_images",
            JSON.stringify(marketData.tenement_images)
          );
        } else {
          urlParams.append("tenement_images", JSON.stringify([]));
        }
        for (const key in marketData) {
          if (marketData.hasOwnProperty(key) && marketData[key] !== "") {
            if (key === "tenement_type") {
              urlParams.append(key, e2.target.value);
              continue;
            }
            urlParams.append(key, marketData[key]);
          }
        }
        const queryString = urlParams.toString();
        async function switchAndNavigate(type, id2) {
          let data;
          switch (type) {
            case "出租": {
              const newData = await getRentHook.getRentEdit(id2);
              data = newData;
              break;
            }
            case "出售": {
              const newData = await getSellHook.getSellEdit(id2);
              data = newData;
              break;
            }
            case "開發追蹤": {
              const newData = await getDevelopHook.getDevelopEdit(id2);
              data = newData;
              break;
            }
            case "行銷追蹤": {
              const newData = await getMarketHook.getMarketEdit(id2);
              data = newData;
              break;
            }
          }
          if (data) {
            const typeMap = {
              出租: "rent",
              出售: "sell",
              開發追蹤: "develop",
              行銷追蹤: "market"
            };
            navigate(`/tenement/${id2}/${typeMap[type]}?tenement_type=${type}`);
          } else {
            navigate(`/Tenement/Add?${queryString}`);
          }
        }
        if (window.confirm(
          "是否要切換案件型態?(請確實按下儲存，避免切換後部分資料會遺失)"
        )) {
          const id2 = window.location.pathname.split("/")[2];
          await switchAndNavigate(e2.target.value, id2);
        } else {
          return;
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "form",
        {
          className: "flex flex-col items-center w-full h-full ",
          onSubmit: (e2) => {
            e2.preventDefault();
            onSave();
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col w-full h-full max-w-screen-xl pb-12 mt-12 mb-10 bg-white shadow-2xl rounded-xl", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "flex w-12 h-20 mt-10 ml-5",
                onClick: () => navigate("/Tenements"),
                children: "< 返回"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inline-flex flex-col mb-5 ml-8", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-4xl font-bold whitespace-normal", children: [
              isRollback && "復原",
              "行銷追蹤資料"
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-3 ml-5 border-b-2 border-gray-300" }),
            isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "isLoading..." }),
            isError && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "isError..." }),
            !isLoading && !isError && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row ", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col flex-wrap w-1/2 h-full gap-3 overflow-visible pl-7 ", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 whitespace-nowrap ", children: "地址:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: marketHook.states.marketInfo.tenement_address,
                      onChange: (e2) => marketHook.handlers.handleChange(
                        "tenement_address",
                        e2.target.value
                      ),
                      isError: marketHook.states.marketInfo.tenement_address.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 ", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 text-right", children: "產品類別:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Radio$1.Group,
                    {
                      className: "col-span-4",
                      value: marketHook.states.marketInfo.tenement_product_type,
                      onChange: (e2) => marketHook.handlers.handleChange(
                        "tenement_product_type",
                        e2.target.value
                      ),
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "套房", children: "套房" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "店面", children: "店面" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "辦公室", children: "辦公室" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "其他", children: "其他" })
                      ]
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 ", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-right whitespace-nowrap", children: "物件型態:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Radio$1.Group,
                    {
                      value: marketHook.states.marketInfo.tenement_type,
                      onChange: (e2) => {
                        handletypeChange(e2);
                      },
                      className: "col-span-4 ",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "出租", children: "出租" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "出售", children: "出售" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "開發追蹤", children: "開發追蹤" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "行銷追蹤", children: "行銷追蹤" })
                      ]
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 ", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 text-right whitespace-nowrap ", children: "面向:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Radio$1.Group,
                    {
                      className: "col-span-4",
                      value: marketHook.states.marketInfo.tenement_face,
                      onChange: (e2) => marketHook.handlers.handleChange(
                        "tenement_face",
                        e2.target.value
                      ),
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "海景", children: "海景" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "中庭", children: "中庭" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "三多路", children: "三多路" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "自強路", children: "自強路" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "市景風洞", children: "市景風洞" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "海景風洞", children: "海景風洞" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "其他", children: "其他" })
                      ]
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 mb-5 ", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 text-right", children: "預期坪數:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-grid items-center grid-flow-col ", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Input$1,
                        {
                          value: marketHook.states.marketInfo.tenement_area_min,
                          onChange: (e2) => marketHook.handlers.handleChange(
                            "tenement_area_min",
                            e2.target.value
                          ),
                          className: "h-8 col-span-1 mt-3",
                          placeholder: "最小值"
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "pt-3 pl-1 ", children: "~" })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Input$1,
                      {
                        value: marketHook.states.marketInfo.tenement_area_max,
                        onChange: (e2) => marketHook.handlers.handleChange(
                          "tenement_area_max",
                          e2.target.value
                        ),
                        className: "col-span-1 mt-3",
                        placeholder: "最大值"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-10 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-2 pt-1 whitespace-nowrap ", children: "要租要買:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Select$1,
                      {
                        defaultValue: "租房",
                        className: "w-20 col-span-1 ",
                        value: marketHook.states.marketInfo.market_state,
                        onChange: (value) => marketHook.handlers.handleChange("market_state", value),
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Select$1.Option, { value: "租房", children: "租房" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Select$1.Option, { value: "買房", children: "買房" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Select$1.Option, { value: "要租要買", children: "要租要買" })
                        ]
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "col-span-1 pt-5 ", children: [
                      " ",
                      marketHook.states.marketInfo.market_state === "租房" ? "租金預算" : "售價預算(萬)",
                      ":"
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-grid items-center grid-flow-col ", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Input$1,
                        {
                          value: marketHook.states.marketInfo.burget_rent_min,
                          onChange: (e2) => marketHook.handlers.handleChange(
                            "burget_rent_min",
                            e2.target.value
                          ),
                          className: "h-8 col-span-1 mt-3",
                          placeholder: "最小值",
                          required: true
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "pt-3 pl-1 ", children: "~" })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Input$1,
                      {
                        value: marketHook.states.marketInfo.burget_rent_max,
                        onChange: (e2) => marketHook.handlers.handleChange(
                          "burget_rent_max",
                          e2.target.value
                        ),
                        className: "col-span-1 mt-3",
                        placeholder: "最大值",
                        required: true
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "希望的樓層:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-grid items-center grid-flow-col ", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Input$1,
                        {
                          value: marketHook.states.marketInfo.hopefloor_min,
                          onChange: (e2) => marketHook.handlers.handleChange(
                            "hopefloor_min",
                            e2.target.value
                          ),
                          className: "h-8 col-span-1 mt-3",
                          placeholder: "最小值",
                          required: true
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "pt-3 pl-1 ", children: "~" })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Input$1,
                      {
                        value: marketHook.states.marketInfo.hopefloor_max,
                        onChange: (e2) => marketHook.handlers.handleChange(
                          "hopefloor_max",
                          e2.target.value
                        ),
                        className: "col-span-1 mt-3",
                        placeholder: "最大值",
                        required: true
                      }
                    )
                  ] })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col w-1/2 h-full ", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex flex-col mb-10 ", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 mb-3 text-3xl font-bold whitespace-normal", children: "房屋照片" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    App$1,
                    {
                      fileList: marketHook.states.marketInfo.tenement_images,
                      setFileList: (newFilelist) => {
                        marketHook.handlers.handleChange(
                          "tenement_images",
                          newFilelist
                        );
                      }
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 mb-3 text-3xl font-bold whitespace-normal", children: "買客資訊" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "姓名:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: marketHook.states.marketInfo.tenement_host_name,
                      onChange: (e2) => marketHook.handlers.handleChange(
                        "tenement_host_name",
                        e2.target.value
                      ),
                      isError: marketHook.states.marketInfo.tenement_host_name.length <= 2,
                      errorMessage: "至少兩個字",
                      required: true
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "行動電話:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: marketHook.states.marketInfo.tenement_host_telphone,
                      onChange: (e2) => marketHook.handlers.handleChange(
                        "tenement_host_telphone",
                        e2.target.value
                      ),
                      isError: marketHook.states.marketInfo.tenement_host_telphone.length <= 2,
                      errorMessage: "至少兩個字",
                      required: true
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "電話:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: marketHook.states.marketInfo.tenement_host_phone,
                      onChange: (e2) => marketHook.handlers.handleChange(
                        "tenement_host_phone",
                        e2.target.value
                      ),
                      isError: marketHook.states.marketInfo.tenement_host_phone.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "Line:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: marketHook.states.marketInfo.tenement_host_line,
                      onChange: (e2) => marketHook.handlers.handleChange(
                        "tenement_host_line",
                        e2.target.value
                      ),
                      isError: marketHook.states.marketInfo.tenement_host_line.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "匯款銀行:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: marketHook.states.marketInfo.tenement_host_remittance_bank,
                      onChange: (e2) => marketHook.handlers.handleChange(
                        "tenement_host_remittance_bank",
                        e2.target.value
                      ),
                      isError: marketHook.states.marketInfo.tenement_host_remittance_bank.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "帳號:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: marketHook.states.marketInfo.tenement_host_remittance_account,
                      onChange: (e2) => marketHook.handlers.handleChange(
                        "tenement_host_remittance_account",
                        e2.target.value
                      ),
                      isError: marketHook.states.marketInfo.tenement_host_remittance_account.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "通訊地址:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: marketHook.states.marketInfo.tenement_host_address,
                      onChange: (e2) => marketHook.handlers.handleChange(
                        "tenement_host_address",
                        e2.target.value
                      ),
                      isError: marketHook.states.marketInfo.tenement_host_address.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "生日:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: marketHook.states.marketInfo.tenement_host_birthday,
                      onChange: (e2) => marketHook.handlers.handleChange(
                        "tenement_host_birthday",
                        e2.target.value
                      ),
                      isError: marketHook.states.marketInfo.tenement_host_birthday.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "嗜好:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: marketHook.states.marketInfo.tenement_host_hobby,
                      onChange: (e2) => marketHook.handlers.handleChange(
                        "tenement_host_hobby",
                        e2.target.value
                      ),
                      isError: marketHook.states.marketInfo.tenement_host_hobby.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 mt-3 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "備註:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Input$1.TextArea,
                    {
                      className: "col-span-3",
                      rows: 4,
                      value: marketHook.states.marketInfo.tenement_host_remark,
                      onChange: (e2) => marketHook.handlers.handleChange(
                        "tenement_host_remark",
                        e2.target.value
                      )
                    }
                  )
                ] })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col p-5", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex flex-row gap-5 mb-5 ", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-4xl font-bold whitespace-normal", children: "提醒設定" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button$2,
                  {
                    type: "primary",
                    className: "mt-1 bg-blue-600",
                    onClick: noticeHook.handlers.handleAddNotice,
                    children: "新增提醒"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-3 ml-5 border-b-2 border-gray-300" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-5", children: noticeHook.states.notices.map((notice, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                Notice,
                {
                  keya: index2,
                  notice,
                  handleNoticeChange: noticeHook.handlers.handleNoticeChange,
                  handleDeleteNotice: noticeHook.handlers.handleDeleteNotice
                },
                index2
              )) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-end gap-5 m-10 ", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { className: "bg-blue-600 ", type: "primary", htmlType: "submit", children: isRollback ? "復原" : "儲存" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { type: "default", children: "回復預設" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { danger: true, onClick: onDelete, children: isRollback ? "永久刪除" : "刪除" })
            ] })
          ] })
        }
      );
    }
    function Rent$2() {
      const { id: tenementId } = useParams();
      const query = new URLSearchParams(window.location.search);
      const isRollback = query.get("rollback");
      const noticeHook = useTenementNotice("rent", tenementId);
      const rentHook = useTenementRentInfo(tenementId);
      const getRentHook = useGetRentEdit();
      const getSellHook = useGetSellEdit();
      const getDevelopHook = useGetDevelopEdit();
      const getMarketHook = useGetMarketEdit();
      const onSave = () => {
        noticeHook.handlers.handleSaveNoticeData();
        rentHook.handlers.handleSave();
        alert("儲存成功");
      };
      const onDelete = () => {
        if (window.confirm("確定要刪除嗎?")) {
          rentHook.handlers.handleDelete("rent", isRollback !== null);
        }
      };
      const isLoading = rentHook.states.isLoading || noticeHook.states.isLoading;
      const isError = rentHook.states.isError || noticeHook.states.isError;
      const navigate = useNavigate();
      const handletypeChange = async (e2) => {
        const rentData = rentHook.states.rentInfo;
        const urlParams = new URLSearchParams();
        if (rentData.tenement_images.length > 0) {
          urlParams.append(
            "tenement_images",
            JSON.stringify(rentData.tenement_images)
          );
        } else {
          urlParams.append("tenement_images", JSON.stringify([]));
        }
        for (const key in rentData) {
          if (rentData.hasOwnProperty(key) && rentData[key] !== "") {
            if (key === "tenement_type") {
              urlParams.append(key, e2.target.value);
              continue;
            }
            urlParams.append(key, rentData[key]);
          }
        }
        const queryString = urlParams.toString();
        async function switchAndNavigate(type, id2) {
          let data;
          switch (type) {
            case "出租": {
              const newData = await getRentHook.getRentEdit(id2);
              data = newData;
              break;
            }
            case "出售": {
              const newData = await getSellHook.getSellEdit(id2);
              data = newData;
              break;
            }
            case "開發追蹤": {
              const newData = await getDevelopHook.getDevelopEdit(id2);
              data = newData;
              break;
            }
            case "行銷追蹤": {
              const newData = await getMarketHook.getMarketEdit(id2);
              data = newData;
              break;
            }
          }
          if (data) {
            const typeMap = {
              出租: "rent",
              出售: "sell",
              開發追蹤: "develop",
              行銷追蹤: "market"
            };
            navigate(`/tenement/${id2}/${typeMap[type]}?tenement_type=${type}`);
          } else {
            navigate(`/Tenement/Add?${queryString}`);
          }
        }
        if (window.confirm(
          "是否要切換案件型態?(請確實按下儲存，避免切換後部分資料會遺失)"
        )) {
          const id2 = window.location.pathname.split("/")[2];
          await switchAndNavigate(e2.target.value, id2);
        } else {
          return;
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "form",
        {
          className: "flex flex-col items-center w-full h-full ",
          onSubmit: (e2) => {
            e2.preventDefault();
            onSave();
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col w-full h-full max-w-screen-xl pb-12 mt-12 mb-10 bg-white shadow-2xl rounded-xl", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "flex w-12 h-20 mt-10 ml-5",
                onClick: () => navigate("/Tenements"),
                children: "< 返回"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inline-flex flex-col mb-5 ml-8", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-4xl font-bold whitespace-normal", children: [
              isRollback && "復原",
              "出租資料"
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-3 ml-5 border-b-2 border-gray-300" }),
            isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "isLoading..." }),
            isError && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "isError..." }),
            !isLoading && !isError && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row ", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col flex-wrap w-1/2 h-full gap-3 overflow-visible pl-7 ", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 whitespace-nowrap ", children: "地址:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: rentHook.states.rentInfo.tenement_address,
                        onChange: (e2) => rentHook.handlers.handleChange(
                          "tenement_address",
                          e2.target.value
                        ),
                        isError: rentHook.states.rentInfo.tenement_address.length <= 2,
                        errorMessage: "至少兩個字",
                        required: true
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 ", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 text-right", children: "產品類別:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Radio$1.Group,
                      {
                        className: "col-span-4",
                        value: rentHook.states.rentInfo.tenement_product_type,
                        onChange: (e2) => rentHook.handlers.handleChange(
                          "tenement_product_type",
                          e2.target.value
                        ),
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "套房", children: "套房" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "店面", children: "店面" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "辦公室", children: "辦公室" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "其他", children: "其他" })
                        ]
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 ", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-right whitespace-nowrap", children: "物件狀態:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Radio$1.Group,
                      {
                        className: "col-span-4",
                        value: rentHook.states.rentInfo.tenement_status,
                        onChange: (e2) => rentHook.handlers.handleChange(
                          "tenement_status",
                          e2.target.value
                        ),
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "未成交", children: "未成交" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "已成交", children: "已成交" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "已成交下架", children: "已成交下架" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "過戶完成下架", children: "過戶完成下架" })
                        ]
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 ", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-right whitespace-nowrap", children: "物件型態:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Radio$1.Group,
                      {
                        value: rentHook.states.rentInfo.tenement_type,
                        onChange: (e2) => {
                          handletypeChange(e2);
                        },
                        className: "col-span-4 ",
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "出租", children: "出租" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "出售", children: "出售" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "開發追蹤", children: "開發追蹤" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "行銷追蹤", children: "行銷追蹤" })
                        ]
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 ", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 text-right whitespace-nowrap ", children: "面向:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Radio$1.Group,
                      {
                        className: "col-span-4",
                        value: rentHook.states.rentInfo.tenement_face,
                        onChange: (e2) => rentHook.handlers.handleChange(
                          "tenement_face",
                          e2.target.value
                        ),
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "海景", children: "海景" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "中庭", children: "中庭" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "三多路", children: "三多路" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "自強路", children: "自強路" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "市景風洞", children: "市景風洞" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "海景風洞", children: "海景風洞" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "其他", children: "其他" })
                        ]
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "權狀坪數:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: rentHook.states.rentInfo.total_rating,
                        onChange: (e2) => rentHook.handlers.handleChange(
                          "total_rating",
                          e2.target.value
                        ),
                        isError: rentHook.states.rentInfo.total_rating.length <= 2,
                        errorMessage: "至少兩個字",
                        required: true
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 whitespace-nowrap ", children: "主建物:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: rentHook.states.rentInfo.main_building,
                        onChange: (e2) => rentHook.handlers.handleChange(
                          "main_building",
                          e2.target.value
                        ),
                        isError: rentHook.states.rentInfo.main_building.length <= 2,
                        errorMessage: "至少兩個字",
                        required: true
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "附屬建物:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: rentHook.states.rentInfo.affiliated_building,
                        onChange: (e2) => rentHook.handlers.handleChange(
                          "affiliated_building",
                          e2.target.value
                        ),
                        isError: rentHook.states.rentInfo.affiliated_building.length <= 2,
                        errorMessage: "至少兩個字",
                        required: true
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "公設面積:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: rentHook.states.rentInfo.public_building,
                        onChange: (e2) => rentHook.handlers.handleChange(
                          "public_building",
                          e2.target.value
                        ),
                        isError: rentHook.states.rentInfo.public_building.length <= 2,
                        errorMessage: "至少兩個字",
                        required: true
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "未登記面積:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: rentHook.states.rentInfo.unregistered_area,
                        onChange: (e2) => rentHook.handlers.handleChange(
                          "unregistered_area",
                          e2.target.value
                        ),
                        isError: rentHook.states.rentInfo.unregistered_area.length <= 2,
                        errorMessage: "至少兩個字"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "管理費倍率:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: rentHook.states.rentInfo.management_magnification,
                        onChange: (e2) => {
                          rentHook.handlers.handleChange(
                            "management_fee",
                            (parseFloat(e2.target.value) * parseFloat(rentHook.states.rentInfo.total_rating)).toString()
                          );
                          rentHook.handlers.handleChange(
                            "management_magnification",
                            e2.target.value
                          );
                        },
                        isError: rentHook.states.rentInfo.management_fee.length <= 2,
                        errorMessage: "至少兩個字"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "管理費:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: rentHook.states.rentInfo.management_fee,
                        onChange: (e2) => rentHook.handlers.handleChange(
                          "management_fee",
                          e2.target.value
                        ),
                        isError: rentHook.states.rentInfo.management_fee.length <= 2,
                        errorMessage: "至少兩個字"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "租金:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: rentHook.states.rentInfo.rent_price,
                        onChange: (e2) => rentHook.handlers.handleChange(
                          "rent_price",
                          e2.target.value
                        ),
                        isError: rentHook.states.rentInfo.rent_price.length <= 2,
                        errorMessage: "至少兩個字",
                        required: true
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "押金:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: rentHook.states.rentInfo.deposit_price,
                        onChange: (e2) => rentHook.handlers.handleChange(
                          "deposit_price",
                          e2.target.value
                        ),
                        isError: rentHook.states.rentInfo.deposit_price.length <= 2,
                        errorMessage: "至少兩個字"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "總樓層:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: rentHook.states.rentInfo.tenement_floor,
                        onChange: (e2) => rentHook.handlers.handleChange(
                          "tenement_floor",
                          e2.target.value
                        ),
                        isError: rentHook.states.rentInfo.tenement_floor.length <= 2,
                        errorMessage: "至少兩個字"
                      }
                    )
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col w-1/2 h-full ", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex flex-col mb-10 ", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 mb-3 text-3xl font-bold whitespace-normal", children: "房屋照片" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      App$1,
                      {
                        fileList: rentHook.states.rentInfo.tenement_images,
                        setFileList: (fileList) => rentHook.handlers.handleChange(
                          "tenement_images",
                          fileList
                        )
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 mb-3 text-3xl font-bold whitespace-normal", children: "屋主資訊" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "姓名:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: rentHook.states.rentInfo.tenement_host_name,
                        onChange: (e2) => rentHook.handlers.handleChange(
                          "tenement_host_name",
                          e2.target.value
                        ),
                        isError: rentHook.states.rentInfo.tenement_host_name.length <= 2,
                        errorMessage: "至少兩個字",
                        required: true
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "行動電話:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: rentHook.states.rentInfo.tenement_host_telphone,
                        onChange: (e2) => rentHook.handlers.handleChange(
                          "tenement_host_telphone",
                          e2.target.value
                        ),
                        isError: rentHook.states.rentInfo.tenement_host_telphone.length <= 2,
                        errorMessage: "至少兩個字",
                        required: true
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "電話:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: rentHook.states.rentInfo.tenement_host_phone,
                        onChange: (e2) => rentHook.handlers.handleChange(
                          "tenement_host_phone",
                          e2.target.value
                        ),
                        isError: rentHook.states.rentInfo.tenement_host_phone.length <= 2,
                        errorMessage: "至少兩個字"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "Line:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: rentHook.states.rentInfo.tenement_host_line,
                        onChange: (e2) => rentHook.handlers.handleChange(
                          "tenement_host_line",
                          e2.target.value
                        ),
                        isError: rentHook.states.rentInfo.tenement_host_line.length <= 2,
                        errorMessage: "至少兩個字"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "匯款銀行:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: rentHook.states.rentInfo.tenement_host_remittance_bank,
                        onChange: (e2) => rentHook.handlers.handleChange(
                          "tenement_host_remittance_bank",
                          e2.target.value
                        ),
                        isError: rentHook.states.rentInfo.tenement_host_remittance_bank.length <= 2,
                        errorMessage: "至少兩個字"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "帳號:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: rentHook.states.rentInfo.tenement_host_remittance_account,
                        onChange: (e2) => rentHook.handlers.handleChange(
                          "tenement_host_remittance_account",
                          e2.target.value
                        ),
                        isError: rentHook.states.rentInfo.tenement_host_remittance_account.length <= 2,
                        errorMessage: "至少兩個字"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "通訊地址:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: rentHook.states.rentInfo.tenement_host_address,
                        onChange: (e2) => rentHook.handlers.handleChange(
                          "tenement_host_address",
                          e2.target.value
                        ),
                        isError: rentHook.states.rentInfo.tenement_host_address.length <= 2,
                        errorMessage: "至少兩個字"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "生日:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: rentHook.states.rentInfo.tenement_host_birthday,
                        onChange: (e2) => rentHook.handlers.handleChange(
                          "tenement_host_birthday",
                          e2.target.value
                        ),
                        isError: rentHook.states.rentInfo.tenement_host_birthday.length <= 2,
                        errorMessage: "至少兩個字"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "嗜好:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: rentHook.states.rentInfo.tenement_host_hobby,
                        onChange: (e2) => rentHook.handlers.handleChange(
                          "tenement_host_hobby",
                          e2.target.value
                        ),
                        isError: rentHook.states.rentInfo.tenement_host_hobby.length <= 2,
                        errorMessage: "至少兩個字"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 mt-3 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "備註:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Input$1.TextArea,
                      {
                        className: "col-span-3",
                        rows: 4,
                        value: rentHook.states.rentInfo.tenement_host_remark,
                        onChange: (e2) => rentHook.handlers.handleChange(
                          "tenement_host_remark",
                          e2.target.value
                        )
                      }
                    )
                  ] })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col w-full px-5 mt-10", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inline-flex col-span-2 mb-5 ml-10", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-4xl font-bold", children: "租客資訊" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-3 ml-5 border-b-2 border-gray-300" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row w-full ", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col w-1/3 gap-10 mr-3 ", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-1 text-right ", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 ", children: "起租日期:" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        DatePicker$1,
                        {
                          className: "col-span-2",
                          value: dayjs(
                            rentHook.states.rentInfo.renter_start_date,
                            "YYYY-MM-DD"
                          ),
                          onChange: (_, dateString) => rentHook.handlers.handleChange(
                            "renter_start_date",
                            dateString
                          )
                        }
                      )
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-1 text-right ", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 ", children: "退租日期:" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        DatePicker$1,
                        {
                          className: "col-span-2",
                          value: dayjs(
                            rentHook.states.rentInfo.renter_end_date,
                            "YYYY-MM-DD"
                          ),
                          onChange: (_, dateString) => rentHook.handlers.handleChange(
                            "renter_end_date",
                            dateString
                          )
                        }
                      )
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-1 text-right ", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 ", children: "租客姓名:" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Input$1,
                        {
                          className: "col-span-2",
                          value: rentHook.states.rentInfo.renter_name,
                          onChange: (e2) => rentHook.handlers.handleChange(
                            "renter_name",
                            e2.target.value
                          )
                        }
                      )
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-1 text-right ", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 ", children: "電話:" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Input$1,
                        {
                          className: "col-span-2",
                          value: rentHook.states.rentInfo.renter_phone,
                          onChange: (e2) => rentHook.handlers.handleChange(
                            "renter_phone",
                            e2.target.value
                          )
                        }
                      )
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-1 text-right ", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 ", children: "工作職稱:" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Input$1,
                        {
                          className: "col-span-2",
                          value: rentHook.states.rentInfo.renter_jobtitle,
                          onChange: (e2) => rentHook.handlers.handleChange(
                            "renter_jobtitle",
                            e2.target.value
                          )
                        }
                      )
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-1 text-right ", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 ", children: "保證人姓名:" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Input$1,
                        {
                          className: "col-span-2",
                          value: rentHook.states.rentInfo.renter_guarantor_name,
                          onChange: (e2) => rentHook.handlers.handleChange(
                            "renter_guarantor_name",
                            e2.target.value
                          )
                        }
                      )
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-3 gap-1 text-right ", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 ", children: "保證人電話:" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Input$1,
                        {
                          className: "col-span-2",
                          value: rentHook.states.rentInfo.renter_guarantor_phone,
                          onChange: (e2) => rentHook.handlers.handleChange(
                            "renter_guarantor_phone",
                            e2.target.value
                          )
                        }
                      )
                    ] })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col w-1/3 ", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-3 gap-1 ", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-2 ", children: "身分證件翻拍存檔:" }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      App$1,
                      {
                        fileList: rentHook.states.rentInfo.renter_id_images,
                        setFileList: (newFilelist) => {
                          rentHook.handlers.handleChange(
                            "renter_id_images",
                            newFilelist
                          );
                        }
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col w-1/3 ml-5", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-5 gap-1 ", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-5 ", children: "備註:" }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "textarea",
                      {
                        className: "w-full h-40 border border-gray-300",
                        value: rentHook.states.rentInfo.renter_remark,
                        onChange: (e2) => rentHook.handlers.handleChange(
                          "renter_remark",
                          e2.target.value
                        )
                      }
                    )
                  ] })
                ] })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col p-5", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex flex-row gap-5 mb-5 ", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-4xl font-bold whitespace-normal", children: "提醒設定" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button$2,
                  {
                    type: "primary",
                    className: "mt-1 bg-blue-600",
                    onClick: noticeHook.handlers.handleAddNotice,
                    children: "新增提醒"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-3 ml-5 border-b-2 border-gray-300" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-5", children: noticeHook.states.notices.map((notice, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                Notice,
                {
                  keya: index2,
                  notice,
                  handleNoticeChange: noticeHook.handlers.handleNoticeChange,
                  handleDeleteNotice: noticeHook.handlers.handleDeleteNotice
                },
                index2
              )) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-end gap-5 m-10 ", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { className: "bg-blue-600 ", type: "primary", htmlType: "submit", children: isRollback ? "復原" : "儲存" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { type: "default", children: "回復預設" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { danger: true, onClick: onDelete, children: isRollback ? "永久刪除" : "刪除" })
            ] })
          ] })
        }
      );
    }
    dayjs.extend(customParseFormat);
    function Rent$1() {
      const { id: tenementId } = useParams();
      const query = new URLSearchParams(window.location.search);
      const isRollback = query.get("rollback");
      const getRentHook = useGetRentEdit();
      const getSellHook = useGetSellEdit();
      const getDevelopHook = useGetDevelopEdit();
      const getMarketHook = useGetMarketEdit();
      const noticeHook = useTenementNotice("sell", tenementId);
      const sellHook = useTenementSellInfo(tenementId);
      const onSave = () => {
        noticeHook.handlers.handleSaveNoticeData();
        sellHook.handlers.handleSave();
      };
      const onDelete = () => {
        if (window.confirm("確定要刪除嗎?")) {
          sellHook.handlers.handleDelete("sell", isRollback !== null);
        }
      };
      const isLoading = sellHook.states.isLoading || noticeHook.states.isLoading;
      const isError = sellHook.states.isError || noticeHook.states.isError;
      const navigate = useNavigate();
      const handletypeChange = async (e2) => {
        const sellData = sellHook.states.sellInfo;
        const urlParams = new URLSearchParams();
        if (sellData.tenement_images.length > 0) {
          urlParams.append(
            "tenement_images",
            JSON.stringify(sellData.tenement_images)
          );
        } else {
          urlParams.append("tenement_images", JSON.stringify([]));
        }
        for (const key in sellData) {
          if (sellData.hasOwnProperty(key) && sellData[key] !== "") {
            if (key === "tenement_type") {
              urlParams.append(key, e2.target.value);
              continue;
            }
            urlParams.append(key, sellData[key]);
          }
        }
        const queryString = urlParams.toString();
        async function switchAndNavigate(type, id2) {
          let data;
          switch (type) {
            case "出租": {
              const newData = await getRentHook.getRentEdit(id2);
              data = newData;
              break;
            }
            case "出售": {
              const newData = await getSellHook.getSellEdit(id2);
              data = newData;
              break;
            }
            case "開發追蹤": {
              const newData = await getDevelopHook.getDevelopEdit(id2);
              data = newData;
              break;
            }
            case "行銷追蹤": {
              const newData = await getMarketHook.getMarketEdit(id2);
              data = newData;
              break;
            }
          }
          if (data) {
            const typeMap = {
              出租: "rent",
              出售: "sell",
              開發追蹤: "develop",
              行銷追蹤: "market"
            };
            navigate(`/tenement/${id2}/${typeMap[type]}?tenement_type=${type}`);
          } else {
            navigate(`/Tenement/Add?${queryString}`);
          }
        }
        if (window.confirm(
          "是否要切換案件型態?(請確實按下儲存，避免切換後部分資料會遺失)"
        )) {
          const id2 = window.location.pathname.split("/")[2];
          await switchAndNavigate(e2.target.value, id2);
        } else {
          return;
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "form",
        {
          className: "flex flex-col items-center w-full h-full ",
          onSubmit: (e2) => {
            e2.preventDefault();
            onSave();
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col w-full h-full max-w-screen-xl pb-12 mt-12 mb-10 bg-white shadow-2xl rounded-xl", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "flex w-12 h-20 mt-10 ml-5",
                onClick: () => navigate("/Tenements"),
                children: "< 返回"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inline-flex flex-col mb-5 ml-8", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-4xl font-bold whitespace-normal", children: [
              isRollback && "復原",
              "出售資料"
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-3 ml-5 border-b-2 border-gray-300" }),
            isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "isLoading..." }),
            isError && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "isError..." }),
            !isLoading && !isError && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row ", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col flex-wrap w-1/2 h-full gap-3 overflow-visible pl-7 ", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 whitespace-nowrap ", children: "地址:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: sellHook.states.sellInfo.tenement_address,
                        onChange: (e2) => sellHook.handlers.handleChange(
                          "tenement_address",
                          e2.target.value
                        ),
                        isError: sellHook.states.sellInfo.tenement_address.length <= 2,
                        errorMessage: "至少兩個字",
                        required: true
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 ", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 text-right", children: "產品類別:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Radio$1.Group,
                      {
                        className: "col-span-4",
                        value: sellHook.states.sellInfo.tenement_product_type,
                        onChange: (e2) => sellHook.handlers.handleChange(
                          "tenement_product_type",
                          e2.target.value
                        ),
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "套房", children: "套房" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "店面", children: "店面" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "辦公室", children: "辦公室" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "其他", children: "其他" })
                        ]
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 ", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-right whitespace-nowrap", children: "物件狀態:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Radio$1.Group,
                      {
                        className: "col-span-4",
                        value: sellHook.states.sellInfo.tenement_status,
                        onChange: (e2) => sellHook.handlers.handleChange(
                          "tenement_status",
                          e2.target.value
                        ),
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "未成交", children: "未成交" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "已成交", children: "已成交" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "已成交下架", children: "已成交下架" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "過戶完成下架", children: "過戶完成下架" })
                        ]
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 ", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-right whitespace-nowrap", children: "物件型態:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Radio$1.Group,
                      {
                        value: sellHook.states.sellInfo.tenement_type,
                        onChange: (e2) => {
                          handletypeChange(e2);
                        },
                        className: "col-span-4 ",
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "出租", children: "出租" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "出售", children: "出售" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "開發追蹤", children: "開發追蹤" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "行銷追蹤", children: "行銷追蹤" })
                        ]
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 ", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 text-right whitespace-nowrap ", children: "面向:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Radio$1.Group,
                      {
                        className: "col-span-4",
                        value: sellHook.states.sellInfo.tenement_face,
                        onChange: (e2) => sellHook.handlers.handleChange(
                          "tenement_face",
                          e2.target.value
                        ),
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "海景", children: "海景" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "中庭", children: "中庭" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "三多路", children: "三多路" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "自強路", children: "自強路" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "市景風洞", children: "市景風洞" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "海景風洞", children: "海景風洞" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "其他", children: "其他" })
                        ]
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "權狀坪數:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: sellHook.states.sellInfo.total_rating,
                        onChange: (e2) => sellHook.handlers.handleChange(
                          "total_rating",
                          e2.target.value
                        ),
                        isError: sellHook.states.sellInfo.total_rating.length <= 2,
                        errorMessage: "至少兩個字",
                        required: true
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 whitespace-nowrap ", children: "主建物:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: sellHook.states.sellInfo.main_building,
                        onChange: (e2) => sellHook.handlers.handleChange(
                          "main_building",
                          e2.target.value
                        ),
                        isError: sellHook.states.sellInfo.main_building.length <= 2,
                        errorMessage: "至少兩個字",
                        required: true
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "附屬建物:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: sellHook.states.sellInfo.affiliated_building,
                        onChange: (e2) => sellHook.handlers.handleChange(
                          "affiliated_building",
                          e2.target.value
                        ),
                        isError: sellHook.states.sellInfo.affiliated_building.length <= 2,
                        errorMessage: "至少兩個字",
                        required: true
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "公設面積:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: sellHook.states.sellInfo.public_building,
                        onChange: (e2) => sellHook.handlers.handleChange(
                          "public_building",
                          e2.target.value
                        ),
                        isError: sellHook.states.sellInfo.public_building.length <= 2,
                        errorMessage: "至少兩個字",
                        required: true
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "未登記面積:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: sellHook.states.sellInfo.unregistered_area,
                        onChange: (e2) => sellHook.handlers.handleChange(
                          "unregistered_area",
                          e2.target.value
                        ),
                        isError: sellHook.states.sellInfo.unregistered_area.length <= 2,
                        errorMessage: "至少兩個字"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "管理費倍率:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: sellHook.states.sellInfo.management_magnification,
                        onChange: (e2) => {
                          sellHook.handlers.handleChange(
                            "management_fee",
                            (parseFloat(e2.target.value) * parseFloat(sellHook.states.sellInfo.total_rating)).toString()
                          );
                          sellHook.handlers.handleChange(
                            "management_magnification",
                            e2.target.value
                          );
                        },
                        isError: sellHook.states.sellInfo.management_fee.length <= 2,
                        errorMessage: "至少兩個字"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "售價(萬):" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: sellHook.states.sellInfo.selling_price,
                        onChange: (e2) => sellHook.handlers.handleChange(
                          "selling_price",
                          e2.target.value
                        ),
                        isError: sellHook.states.sellInfo.selling_price.length <= 2,
                        errorMessage: "至少兩個字",
                        required: true
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "管理費:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: sellHook.states.sellInfo.management_fee,
                        onChange: (e2) => sellHook.handlers.handleChange(
                          "management_fee",
                          e2.target.value
                        ),
                        isError: sellHook.states.sellInfo.management_fee.length <= 2,
                        errorMessage: "至少兩個字"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "總樓層:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: sellHook.states.sellInfo.tenement_floor,
                        onChange: (e2) => sellHook.handlers.handleChange(
                          "tenement_floor",
                          e2.target.value
                        ),
                        isError: sellHook.states.sellInfo.tenement_floor.length <= 2,
                        errorMessage: "至少兩個字"
                      }
                    )
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col w-1/2 h-full ", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex flex-col mb-10 ", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 mb-3 text-3xl font-bold whitespace-normal", children: "房屋照片" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      App$1,
                      {
                        fileList: sellHook.states.sellInfo.tenement_images,
                        setFileList: (newFilelist) => {
                          sellHook.handlers.handleChange(
                            "tenement_images",
                            newFilelist
                          );
                        }
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 mb-3 text-3xl font-bold whitespace-normal", children: "屋主資訊" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "姓名:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: sellHook.states.sellInfo.tenement_host_name,
                        onChange: (e2) => sellHook.handlers.handleChange(
                          "tenement_host_name",
                          e2.target.value
                        ),
                        isError: sellHook.states.sellInfo.tenement_host_name.length <= 2,
                        errorMessage: "至少兩個字",
                        required: true
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "行動電話:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: sellHook.states.sellInfo.tenement_host_telphone,
                        onChange: (e2) => sellHook.handlers.handleChange(
                          "tenement_host_telphone",
                          e2.target.value
                        ),
                        isError: sellHook.states.sellInfo.tenement_host_telphone.length <= 2,
                        errorMessage: "至少兩個字",
                        required: true
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "電話:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: sellHook.states.sellInfo.tenement_host_phone,
                        onChange: (e2) => sellHook.handlers.handleChange(
                          "tenement_host_phone",
                          e2.target.value
                        ),
                        isError: sellHook.states.sellInfo.tenement_host_phone.length <= 2,
                        errorMessage: "至少兩個字"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "Line:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: sellHook.states.sellInfo.tenement_host_line,
                        onChange: (e2) => sellHook.handlers.handleChange(
                          "tenement_host_line",
                          e2.target.value
                        ),
                        isError: sellHook.states.sellInfo.tenement_host_line.length <= 2,
                        errorMessage: "至少兩個字"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "匯款銀行:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: sellHook.states.sellInfo.tenement_host_remittance_bank,
                        onChange: (e2) => sellHook.handlers.handleChange(
                          "tenement_host_remittance_bank",
                          e2.target.value
                        ),
                        isError: sellHook.states.sellInfo.tenement_host_remittance_bank.length <= 2,
                        errorMessage: "至少兩個字"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "帳號:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: sellHook.states.sellInfo.tenement_host_remittance_account,
                        onChange: (e2) => sellHook.handlers.handleChange(
                          "tenement_host_remittance_account",
                          e2.target.value
                        ),
                        isError: sellHook.states.sellInfo.tenement_host_remittance_account.length <= 2,
                        errorMessage: "至少兩個字"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "通訊地址:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: sellHook.states.sellInfo.tenement_host_address,
                        onChange: (e2) => sellHook.handlers.handleChange(
                          "tenement_host_address",
                          e2.target.value
                        ),
                        isError: sellHook.states.sellInfo.tenement_host_address.length <= 2,
                        errorMessage: "至少兩個字"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "生日:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: sellHook.states.sellInfo.tenement_host_birthday,
                        onChange: (e2) => sellHook.handlers.handleChange(
                          "tenement_host_birthday",
                          e2.target.value
                        ),
                        isError: sellHook.states.sellInfo.tenement_host_birthday.length <= 2,
                        errorMessage: "至少兩個字"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "嗜好:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      InputWithErrorMessage,
                      {
                        value: sellHook.states.sellInfo.tenement_host_hobby,
                        onChange: (e2) => sellHook.handlers.handleChange(
                          "tenement_host_hobby",
                          e2.target.value
                        ),
                        isError: sellHook.states.sellInfo.tenement_host_hobby.length <= 2,
                        errorMessage: "至少兩個字"
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 mt-3 text-right", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "備註:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Input$1.TextArea,
                      {
                        className: "col-span-3",
                        rows: 4,
                        value: sellHook.states.sellInfo.tenement_host_remark,
                        onChange: (e2) => sellHook.handlers.handleChange(
                          "tenement_host_remark",
                          e2.target.value
                        )
                      }
                    )
                  ] })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col w-full px-5 mt-10", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inline-flex col-span-2 mb-5 ml-10", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-4xl font-bold", children: "買客資訊" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-3 ml-5 border-b-2 border-gray-300" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row w-full ", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col w-1/3 gap-5 mr-3 ", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "下定日期:" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        DatePicker$1,
                        {
                          className: "col-span-3",
                          value: dayjs(
                            sellHook.states.sellInfo.buyer_order_date,
                            "YYYY-MM-DD"
                          ),
                          onChange: (_, dateString) => sellHook.handlers.handleChange(
                            "buyer_order_date",
                            dateString
                          )
                        }
                      )
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "交房日期:" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        DatePicker$1,
                        {
                          className: "col-span-3",
                          value: dayjs(
                            sellHook.states.sellInfo.buyer_handout_date,
                            "YYYY-MM-DD"
                          ),
                          onChange: (_, dateString) => sellHook.handlers.handleChange(
                            "buyer_handout_date",
                            dateString
                          )
                        }
                      )
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "姓名:" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        InputWithErrorMessage,
                        {
                          value: sellHook.states.sellInfo.buyer_name,
                          onChange: (e2) => sellHook.handlers.handleChange(
                            "buyer_name",
                            e2.target.value
                          ),
                          isError: sellHook.states.sellInfo.buyer_name.length <= 2,
                          errorMessage: "至少兩個字"
                        }
                      )
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "行動電話:" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        InputWithErrorMessage,
                        {
                          value: sellHook.states.sellInfo.buyer_phone,
                          onChange: (e2) => sellHook.handlers.handleChange(
                            "buyer_phone",
                            e2.target.value
                          ),
                          isError: sellHook.states.sellInfo.buyer_phone.length <= 2,
                          errorMessage: "至少兩個字"
                        }
                      )
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "職稱:" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        InputWithErrorMessage,
                        {
                          value: sellHook.states.sellInfo.buyer_jobtitle,
                          onChange: (e2) => sellHook.handlers.handleChange(
                            "buyer_jobtitle",
                            e2.target.value
                          ),
                          isError: sellHook.states.sellInfo.buyer_jobtitle.length <= 2,
                          errorMessage: "至少兩個字"
                        }
                      )
                    ] })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col w-1/3 ", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-3 gap-1 ", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-2 ", children: "身分證件翻拍存檔:" }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      App$1,
                      {
                        fileList: sellHook.states.sellInfo.buyer_id_images,
                        setFileList: (newFilelist) => {
                          sellHook.handlers.handleChange(
                            "buyer_id_images",
                            newFilelist
                          );
                        }
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col w-1/3 ml-5", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-5 gap-1 ", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-5 ", children: "備註:" }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "textarea",
                      {
                        className: "w-full h-40 border border-gray-300",
                        value: sellHook.states.sellInfo.buyer_remark,
                        onChange: (e2) => sellHook.handlers.handleChange(
                          "buyer_remark",
                          e2.target.value
                        )
                      }
                    )
                  ] })
                ] })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col p-5", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex flex-row gap-5 mb-5 ", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-4xl font-bold whitespace-normal", children: "提醒設定" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button$2,
                  {
                    type: "primary",
                    className: "mt-1 bg-blue-600",
                    onClick: noticeHook.handlers.handleAddNotice,
                    children: "新增提醒"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-3 ml-5 border-b-2 border-gray-300" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-5", children: noticeHook.states.notices.map((notice, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                Notice,
                {
                  keya: index2,
                  notice,
                  handleNoticeChange: noticeHook.handlers.handleNoticeChange,
                  handleDeleteNotice: noticeHook.handlers.handleDeleteNotice
                },
                index2
              )) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-end gap-5 m-10 ", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { className: "bg-blue-600 ", type: "primary", htmlType: "submit", children: isRollback ? "復原" : "儲存" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { type: "default", children: "回復預設" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { danger: true, onClick: onDelete, children: isRollback ? "永久刪除" : "刪除" })
            ] })
          ] })
        }
      );
    }
    dayjs.extend(customParseFormat);
    function Rent() {
      const { id: tenementId } = useParams();
      const query = new URLSearchParams(window.location.search);
      const isRollback = query.get("rollback");
      const noticeHook = useTenementNotice("develop", tenementId);
      const developHook = useTenementDevelopInfo(tenementId);
      const getSellHook = useGetSellEdit();
      const getRentHook = useGetRentEdit();
      const getDevelopHook = useGetDevelopEdit();
      const getMarketHook = useGetMarketEdit();
      const onSave = () => {
        noticeHook.handlers.handleSaveNoticeData();
        developHook.handlers.handleSave();
        alert("儲存成功");
      };
      const onDelete = () => {
        if (window.confirm("確定要刪除嗎?")) {
          developHook.handlers.handleDelete("develop", isRollback !== null);
        }
      };
      const isLoading = developHook.states.isLoading || noticeHook.states.isLoading;
      const isError = developHook.states.isError || noticeHook.states.isError;
      const navigate = useNavigate();
      const handletypeChange = async (e2) => {
        const developData = developHook.states.developInfo;
        const urlParams = new URLSearchParams();
        if (developData.tenement_images.length > 0) {
          urlParams.append(
            "tenement_images",
            JSON.stringify(developData.tenement_images)
          );
        } else {
          urlParams.append("tenement_images", JSON.stringify([]));
        }
        for (const key in developData) {
          if (developData.hasOwnProperty(key) && developData[key] !== "") {
            if (key === "tenement_type") {
              urlParams.append(key, e2.target.value);
              continue;
            }
            urlParams.append(key, developData[key]);
          }
        }
        const queryString = urlParams.toString();
        async function switchAndNavigate(type, id2) {
          let data;
          switch (type) {
            case "出租": {
              const newData = await getRentHook.getRentEdit(id2);
              data = newData;
              break;
            }
            case "出售": {
              const newData = await getSellHook.getSellEdit(id2);
              data = newData;
              break;
            }
            case "開發追蹤": {
              const newData = await getDevelopHook.getDevelopEdit(id2);
              data = newData;
              break;
            }
            case "行銷追蹤": {
              const newData = await getMarketHook.getMarketEdit(id2);
              data = newData;
              break;
            }
          }
          if (data) {
            const typeMap = {
              出租: "rent",
              出售: "sell",
              開發追蹤: "develop",
              行銷追蹤: "market"
            };
            navigate(`/tenement/${id2}/${typeMap[type]}?tenement_type=${type}`);
          } else {
            navigate(`/Tenement/Add?${queryString}`);
          }
        }
        if (window.confirm(
          "是否要切換案件型態?(請確實按下儲存，避免切換後部分資料會遺失)"
        )) {
          const id2 = window.location.pathname.split("/")[2];
          await switchAndNavigate(e2.target.value, id2);
        } else {
          return;
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "form",
        {
          className: "flex flex-col items-center w-full h-full ",
          onSubmit: (e2) => {
            e2.preventDefault();
            onSave();
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col w-full h-full max-w-screen-xl pb-12 mt-12 mb-10 bg-white shadow-2xl rounded-xl", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "flex w-12 h-20 mt-10 ml-5",
                onClick: () => navigate("/Tenements"),
                children: "< 返回"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inline-flex flex-col mb-5 ml-8", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-4xl font-bold whitespace-normal", children: [
              isRollback && "復原",
              "開發追蹤資料"
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-3 ml-5 border-b-2 border-gray-300" }),
            isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "isLoading..." }),
            isError && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "isError..." }),
            !isLoading && !isError && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row ", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col flex-wrap w-1/2 h-full gap-3 overflow-visible pl-7 ", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 whitespace-nowrap ", children: "地址:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: developHook.states.developInfo.tenement_address,
                      onChange: (e2) => developHook.handlers.handleChange(
                        "tenement_address",
                        e2.target.value
                      ),
                      isError: developHook.states.developInfo.tenement_address.length <= 2,
                      errorMessage: "至少兩個字",
                      required: true
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 ", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 text-right", children: "產品類別:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Radio$1.Group,
                    {
                      className: "col-span-4",
                      value: developHook.states.developInfo.tenement_product_type,
                      onChange: (e2) => developHook.handlers.handleChange(
                        "tenement_product_type",
                        e2.target.value
                      ),
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "套房", children: "套房" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "店面", children: "店面" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "辦公室", children: "辦公室" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "其他", children: "其他" })
                      ]
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 ", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-right whitespace-nowrap", children: "物件型態:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Radio$1.Group,
                    {
                      value: developHook.states.developInfo.tenement_type,
                      onChange: (e2) => {
                        handletypeChange(e2);
                      },
                      className: "col-span-4 ",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "出租", children: "出租" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "出售", children: "出售" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "開發追蹤", children: "開發追蹤" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "行銷追蹤", children: "行銷追蹤" })
                      ]
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 ", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 text-right whitespace-nowrap ", children: "面向:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Radio$1.Group,
                    {
                      className: "col-span-4",
                      value: developHook.states.developInfo.tenement_face,
                      onChange: (e2) => developHook.handlers.handleChange(
                        "tenement_face",
                        e2.target.value
                      ),
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "海景", children: "海景" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "中庭", children: "中庭" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "三多路", children: "三多路" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "自強路", children: "自強路" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "市景風洞", children: "市景風洞" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "海景風洞", children: "海景風洞" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Radio$1, { value: "其他", children: "其他" })
                      ]
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "權狀坪數:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: developHook.states.developInfo.total_rating,
                      onChange: (e2) => developHook.handlers.handleChange(
                        "total_rating",
                        e2.target.value
                      ),
                      isError: developHook.states.developInfo.total_rating.length <= 2,
                      errorMessage: "至少兩個字",
                      required: true
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 whitespace-nowrap ", children: "主建物:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: developHook.states.developInfo.main_building,
                      onChange: (e2) => developHook.handlers.handleChange(
                        "main_building",
                        e2.target.value
                      ),
                      isError: developHook.states.developInfo.main_building.length <= 2,
                      errorMessage: "至少兩個字",
                      required: true
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "附屬建物:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: developHook.states.developInfo.affiliated_building,
                      onChange: (e2) => developHook.handlers.handleChange(
                        "affiliated_building",
                        e2.target.value
                      ),
                      isError: developHook.states.developInfo.affiliated_building.length <= 2,
                      errorMessage: "至少兩個字",
                      required: true
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "公設面積:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: developHook.states.developInfo.public_building,
                      onChange: (e2) => developHook.handlers.handleChange(
                        "public_building",
                        e2.target.value
                      ),
                      isError: developHook.states.developInfo.public_building.length <= 2,
                      errorMessage: "至少兩個字",
                      required: true
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "未登記面積:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: developHook.states.developInfo.unregistered_area,
                      onChange: (e2) => developHook.handlers.handleChange(
                        "unregistered_area",
                        e2.target.value
                      ),
                      isError: developHook.states.developInfo.unregistered_area.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "管理費倍率:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: developHook.states.developInfo.management_magnification,
                      onChange: (e2) => {
                        developHook.handlers.handleChange(
                          "management_fee",
                          (parseFloat(e2.target.value) * parseFloat(
                            developHook.states.developInfo.total_rating
                          )).toString()
                        );
                        developHook.handlers.handleChange(
                          "management_magnification",
                          e2.target.value
                        );
                      },
                      isError: developHook.states.developInfo.management_fee.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "管理費:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: developHook.states.developInfo.management_fee,
                      onChange: (e2) => developHook.handlers.handleChange(
                        "management_fee",
                        e2.target.value
                      ),
                      isError: developHook.states.developInfo.management_fee.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "售價(萬):" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: developHook.states.developInfo.selling_price,
                      onChange: (e2) => developHook.handlers.handleChange(
                        "selling_price",
                        e2.target.value
                      ),
                      isError: developHook.states.developInfo.selling_price.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "租金:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: developHook.states.developInfo.rent_price,
                      onChange: (e2) => developHook.handlers.handleChange(
                        "rent_price",
                        e2.target.value
                      ),
                      isError: developHook.states.developInfo.rent_price.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "押金:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: developHook.states.developInfo.deposit_price,
                      onChange: (e2) => developHook.handlers.handleChange(
                        "deposit_price",
                        e2.target.value
                      ),
                      isError: developHook.states.developInfo.deposit_price.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "總樓層:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: developHook.states.developInfo.tenement_floor,
                      onChange: (e2) => developHook.handlers.handleChange(
                        "tenement_floor",
                        e2.target.value
                      ),
                      isError: developHook.states.developInfo.tenement_floor.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col w-1/2 h-full ", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex flex-col mb-10 ", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 mb-3 text-3xl font-bold whitespace-normal", children: "房屋照片" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    App$1,
                    {
                      fileList: developHook.states.developInfo.tenement_images,
                      setFileList: (newFilelist) => {
                        developHook.handlers.handleChange(
                          "tenement_images",
                          newFilelist
                        );
                      }
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 mb-3 text-3xl font-bold whitespace-normal", children: "屋主資訊" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "姓名:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: developHook.states.developInfo.tenement_host_name,
                      onChange: (e2) => developHook.handlers.handleChange(
                        "tenement_host_name",
                        e2.target.value
                      ),
                      isError: developHook.states.developInfo.tenement_host_name.length <= 2,
                      errorMessage: "至少兩個字",
                      required: true
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "行動電話:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: developHook.states.developInfo.tenement_host_telphone,
                      onChange: (e2) => developHook.handlers.handleChange(
                        "tenement_host_telphone",
                        e2.target.value
                      ),
                      isError: developHook.states.developInfo.tenement_host_telphone.length <= 2,
                      errorMessage: "至少兩個字",
                      required: true
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "電話:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: developHook.states.developInfo.tenement_host_phone,
                      onChange: (e2) => developHook.handlers.handleChange(
                        "tenement_host_phone",
                        e2.target.value
                      ),
                      isError: developHook.states.developInfo.tenement_host_phone.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "Line:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: developHook.states.developInfo.tenement_host_line,
                      onChange: (e2) => developHook.handlers.handleChange(
                        "tenement_host_line",
                        e2.target.value
                      ),
                      isError: developHook.states.developInfo.tenement_host_line.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "匯款銀行:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: developHook.states.developInfo.tenement_host_remittance_bank,
                      onChange: (e2) => developHook.handlers.handleChange(
                        "tenement_host_remittance_bank",
                        e2.target.value
                      ),
                      isError: developHook.states.developInfo.tenement_host_remittance_bank.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "帳號:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: developHook.states.developInfo.tenement_host_remittance_account,
                      onChange: (e2) => developHook.handlers.handleChange(
                        "tenement_host_remittance_account",
                        e2.target.value
                      ),
                      isError: developHook.states.developInfo.tenement_host_remittance_account.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "通訊地址:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: developHook.states.developInfo.tenement_host_address,
                      onChange: (e2) => developHook.handlers.handleChange(
                        "tenement_host_address",
                        e2.target.value
                      ),
                      isError: developHook.states.developInfo.tenement_host_address.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "生日:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: developHook.states.developInfo.tenement_host_birthday,
                      onChange: (e2) => developHook.handlers.handleChange(
                        "tenement_host_birthday",
                        e2.target.value
                      ),
                      isError: developHook.states.developInfo.tenement_host_birthday.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "嗜好:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InputWithErrorMessage,
                    {
                      value: developHook.states.developInfo.tenement_host_hobby,
                      onChange: (e2) => developHook.handlers.handleChange(
                        "tenement_host_hobby",
                        e2.target.value
                      ),
                      isError: developHook.states.developInfo.tenement_host_hobby.length <= 2,
                      errorMessage: "至少兩個字"
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-5 gap-1 mt-3 text-right", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "col-span-1 pt-5 ", children: "備註:" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Input$1.TextArea,
                    {
                      className: "col-span-3",
                      rows: 4,
                      value: developHook.states.developInfo.tenement_host_remark,
                      onChange: (e2) => developHook.handlers.handleChange(
                        "tenement_host_remark",
                        e2.target.value
                      )
                    }
                  )
                ] })
              ] })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col p-5", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex flex-row gap-5 mb-5 ", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-4xl font-bold whitespace-normal", children: "提醒設定" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button$2,
                  {
                    type: "primary",
                    className: "mt-1 bg-blue-600",
                    onClick: noticeHook.handlers.handleAddNotice,
                    children: "新增提醒"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mb-3 ml-5 border-b-2 border-gray-300" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-5", children: noticeHook.states.notices.map((notice, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                Notice,
                {
                  keya: index2,
                  notice,
                  handleNoticeChange: noticeHook.handlers.handleNoticeChange,
                  handleDeleteNotice: noticeHook.handlers.handleDeleteNotice
                },
                index2
              )) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-end gap-5 m-10 ", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { className: "bg-blue-600 ", type: "primary", htmlType: "submit", children: isRollback ? "復原" : "儲存" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { type: "default", children: "回復預設" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { danger: true, onClick: onDelete, children: isRollback ? "永久刪除" : "刪除" })
            ] })
          ] })
        }
      );
    }
    const useBackupCollectionList = () => {
      const [data, setData] = reactExports.useState([
        {
          collection_name: "代收1",
          collection_type: "代收",
          tenement_address: "1",
          price: "1000",
          collection_id: 1
        },
        {
          collection_name: "代付1",
          tenement_address: "2",
          collection_type: "代付",
          price: "2000",
          collection_id: 2
        },
        {
          collection_name: "代收2",
          tenement_address: "3",
          collection_type: "代收",
          price: "3000",
          collection_id: 3
        },
        {
          collection_name: "代付2",
          tenement_address: "4",
          collection_type: "代付",
          price: "4000",
          collection_id: 4
        }
      ]);
      const columns = [
        {
          title: "編號",
          dataIndex: "collection_id"
        },
        {
          title: "房屋編號",
          dataIndex: "tenement_address",
          key: "tenement_address",
          width: "30%",
          ...getColumnSearchProps("tenement_address")
        },
        {
          title: "費用名稱",
          dataIndex: "collection_name",
          filters: [
            {
              text: "水電空調費",
              value: "水電空調費"
            },
            {
              text: "管理費",
              value: "管理費"
            },
            {
              text: "其他費用",
              value: "其他費用"
            },
            {
              text: "第四台",
              value: "第四台"
            }
          ],
          onFilter: (value, record) => record.collection_name.includes(value)
        },
        {
          title: "費用類型",
          dataIndex: "collection_type",
          filters: [
            {
              text: "代收",
              value: "代收"
            },
            {
              text: "代付",
              value: "代付"
            }
          ],
          onFilter: (value, record) => record.collection_type.includes(value)
        },
        {
          title: "費用金額",
          dataIndex: "price",
          sorter: (a, b2) => parseInt(a.price) - parseInt(b2.price)
        }
      ];
      const { isLoading, isError, datasa } = useGetRollbackCollectionList();
      reactExports.useEffect(() => {
        if (datasa) {
          const newdataCollection = datasa.map((collection) => {
            return {
              collection_id: collection.collection_id,
              tenement_address: collection.tenement_address,
              collection_name: collection.collection_name,
              collection_type: collection.collection_type,
              price: collection.price,
              key: collection.collection_id
            };
          });
          setData(newdataCollection);
        }
      }, [datasa]);
      const navigate = useNavigate();
      const onRow = (record) => {
        return {
          onClick: () => {
            navigate(`/Collection/${record.collection_id}`);
          }
        };
      };
      return {
        data,
        columns,
        onRow,
        isLoading,
        isError
      };
    };
    const RollBackCollectionList = () => {
      const { data, columns, isError, isLoading } = useBackupCollectionList();
      const navigate = useNavigate();
      const customOnRow = (record) => {
        return {
          onClick: () => {
            navigate(`/Collection/${record.collection_id}?rollback=true`);
          }
        };
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center w-4/5 m-10 ", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inline-flex items-center mb-10 justify-evenly w-96", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-4xl ", children: "復原代收付管理" }) }),
        isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "loading..." }) : isError ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "error..." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(TableCompoent, { data, columns, onRow: customOnRow })
      ] });
    };
    const useRollbackUserList = () => {
      const [data, setData] = reactExports.useState([
        {
          user_id: "1",
          user_name: "翁先生",
          user_email: "user@gmail.com",
          status: "是"
        },
        {
          user_id: "2",
          user_name: "李先生",
          user_email: "user2@gmail.com",
          status: "是"
        },
        {
          user_id: "3",
          user_name: "張先生",
          user_email: "user3@gmail.com",
          status: "是"
        },
        {
          user_id: "4",
          user_name: "陳先生",
          user_email: "user4@gmail.com",
          status: "否"
        }
      ]);
      const columns = [
        {
          title: "編號",
          dataIndex: "user_id"
        },
        {
          title: "使用者名稱",
          dataIndex: "user_name"
        },
        {
          title: "使用者信箱",
          dataIndex: "user_email"
        },
        {
          title: "是否啟用",
          dataIndex: "status",
          filters: [
            {
              text: "是",
              value: "是"
            },
            {
              text: "否",
              value: "否"
            }
          ],
          onFilter: (value, record) => record.status.indexOf(value) === 0
        }
      ];
      const { isLoading, isError, dataUser } = useGetRollbackUserList();
      reactExports.useEffect(() => {
        if (dataUser) {
          const newdatauser = dataUser.map((user) => {
            return {
              user_id: user.user_id,
              user_name: user.user_name,
              user_email: user.user_email,
              status: user.status,
              key: user.user_id
            };
          });
          setData(newdatauser);
        }
      }, [dataUser]);
      const navigate = useNavigate();
      const onRow = (record) => {
        return {
          onClick: () => {
            navigate(`/User/${record.user_id}`);
          }
        };
      };
      return {
        data,
        columns,
        onRow,
        isLoading,
        isError
      };
    };
    const RollbackUserList = () => {
      const { data, columns, isError, isLoading } = useRollbackUserList();
      const navigate = useNavigate();
      const customOnRow = (record) => {
        return {
          onClick: () => {
            navigate(`/User/${record.user_id}?rollback=true`);
          }
        };
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center w-4/5 m-10 ", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inline-flex items-center mb-10 justify-evenly w-96", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-4xl ", children: "復原使用者列表" }) }),
        isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "loading..." }) : isError ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "error..." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(TableCompoent, { data, columns, onRow: customOnRow })
      ] });
    };
    const RollbackTenementLists = () => {
      const [Popout, setPopout] = reactExports.useState(false);
      const handlePopout = () => {
        setPopout(!Popout);
      };
      const [breadcrumbItems, setBreadcrumbItems] = reactExports.useState([{ title: "全部房屋", value: "房屋列表" }]);
      const switchTitletoChinese = (title) => {
        switch (title) {
          case "tenement_address":
            return "地址";
          case "tenement_product_type":
            return "產品類型";
          case "tenement_type":
            return "物件類型";
          case "tenement_face":
            return "面向";
          case "tenement_status":
            return "物件狀態";
          case "selling_price_min":
            return "售價 min";
          case "sellling_price_max":
            return "售價 max";
          case "rent_price_min":
            return "租金 min";
          case "rent_price_max":
            return "租金 max";
          case "floor_min":
            return "樓層 min";
          case "floor_max":
            return "樓層 max";
        }
      };
      const navigate = useNavigate();
      const { columns } = useTenementList();
      const customOnRow = (record) => {
        const switchType = (type) => {
          switch (type) {
            case "出租":
              return "rent";
            case "出售":
              return "sell";
            case "開發追蹤":
              return "develop";
            case "行銷追蹤":
              return "market";
            default:
              return "rent";
          }
        };
        return {
          onClick: () => {
            navigate(
              `/Tenement/${record.tenement_id}/${switchType(
                record.tenement_type
              )}?rollback=true&tenement_type=${record.tenement_type}`
            );
          }
        };
      };
      const [data, setData] = reactExports.useState([
        {
          tenement_address: "54321",
          tenement_face: "a",
          tenement_status: "a",
          tenement_type: "a",
          tenement_product_type: "a",
          management_fee_bottom: 100,
          management_floor_bottom: 7,
          tenement_id: 1
        },
        {
          tenement_id: 2,
          tenement_address: "54322",
          tenement_face: "b",
          tenement_status: "b",
          tenement_type: "b",
          tenement_product_type: "b",
          management_fee_bottom: 120,
          management_floor_bottom: 11
        },
        {
          tenement_id: 3,
          tenement_address: "54323",
          tenement_face: "c",
          tenement_status: "c",
          tenement_type: "c",
          tenement_product_type: "c",
          management_fee_bottom: 150,
          management_floor_bottom: 3
        },
        {
          tenement_id: 4,
          tenement_address: "54323",
          tenement_face: "d",
          tenement_status: "d",
          tenement_type: "d",
          tenement_product_type: "d",
          management_fee_bottom: 150,
          management_floor_bottom: 3
        }
      ]);
      const { isLoading, isError, dataTenement, handleGetTenement } = useGetRollbackTenementList();
      reactExports.useEffect(() => {
        handleGetTenement("");
      }, []);
      reactExports.useEffect(() => {
        if (!dataTenement)
          return;
        const data2 = dataTenement.map((item) => {
          return {
            tenement_id: item.tenement_id,
            tenement_address: item.tenement_address,
            tenement_face: item.tenement_face,
            tenement_status: item.tenement_status,
            tenement_type: item.tenement_type,
            tenement_product_type: item.tenement_product_type,
            management_fee_bottom: item.management_fee_bottom,
            management_floor_bottom: item.management_floor_bottom,
            key: item.tenement_address
          };
        });
        setData(data2);
      }, [dataTenement]);
      const handleSelect = (data2) => {
        handleGetTenement(data2);
        const filterData = Object.fromEntries(
          Object.entries(data2).filter(([_, v2]) => v2 !== void 0 && v2 !== "")
        );
        const removeFunction = (item) => {
          if (!item)
            return;
          if (item.value.length === 0) {
            return false;
          }
          if (item.value === void 0) {
            return false;
          } else
            return true;
        };
        const filterDataTitles = Object.entries(filterData).map(([k2, v2]) => ({
          title: k2,
          value: v2
        })).filter(removeFunction);
        handleGetTenement(data2);
        const filterDataTitle = filterDataTitles.map((item) => ({
          title: switchTitletoChinese(item.title),
          value: item.value
        }));
        if (filterDataTitle.length === 0) {
          setBreadcrumbItems([{ title: "全部房屋", value: "房屋列表" }]);
          return;
        }
        setBreadcrumbItems(filterDataTitle);
      };
      const handleReset = () => {
        window.location.reload();
      };
      const [form] = Form$1.useForm();
      const validateMax = (minKey, maxKey) => {
        return async (_, value) => {
          const minValue = form.getFieldValue(minKey);
          if (parseInt(value) < parseInt(minValue)) {
            throw new Error(`${maxKey} 不可小於 ${minKey}`);
          }
        };
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center w-4/5 m-10 ", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex items-center mb-10 justify-evenly w-96", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-4xl ", children: "復原房屋列表" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { type: "primary", onClick: handlePopout, className: "bg-blue-600 ", children: "篩選" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { type: "primary", className: "bg-blue-600 ", onClick: handleReset, children: "重置" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "篩選條件" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Breadcrumb$1, { className: "mb-5", items: breadcrumbItems }),
        isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "loading..." }) : isError ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "error..." }) : /* @__PURE__ */ jsxRuntimeExports.jsx(TableCompoent, { data, columns, onRow: customOnRow }),
        Popout && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          FilterModule,
          {
            handlePopout,
            handleSelect,
            validateMax,
            form,
            type: "房屋",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Form$1.Item, { name: "tenement_type", label: "物件型態", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Checkbox$1.Group, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { value: "出租", children: "出租" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { value: "出售", children: "出售" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { value: "開發追蹤", children: "開發追蹤" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox$1, { value: "行銷追蹤", children: "行銷追蹤" })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex gap-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "rent_price_min",
                    label: "租金",
                    rules: [{ message: "請輸入租金 min" }],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "mix" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1", children: "~" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "rent_price_max",
                    rules: [
                      { message: "請輸入租金 max" },
                      { validator: validateMax("rent_price_min", "rent_price_max") }
                    ],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "max" })
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex gap-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "selling_price_min",
                    label: "售價",
                    rules: [{ message: "請輸入售價 min" }],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "min" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1", children: "~" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Form$1.Item,
                  {
                    name: "selling_price_max",
                    rules: [
                      { message: "請輸入售價 max" },
                      {
                        validator: validateMax(
                          "selling_price_min",
                          "selling_price_max"
                        )
                      }
                    ],
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input$1, { type: "number", placeholder: "max" })
                  }
                )
              ] })
            ]
          }
        )
      ] });
    };
    const App = () => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full h-full", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/login", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Login, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "/", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Layout, {}), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "collections", element: /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionList$1, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "Collection/:id", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "Collection/Add", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "users", element: /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionList, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "User/:user_id", element: /* @__PURE__ */ jsxRuntimeExports.jsx(UserEdit, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "user", element: /* @__PURE__ */ jsxRuntimeExports.jsx(UserAdd, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "Calenderlist", element: /* @__PURE__ */ jsxRuntimeExports.jsx(CalenderList$1, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Route,
            {
              path: "Calenderlist_collection",
              element: /* @__PURE__ */ jsxRuntimeExports.jsx(CalenderList, {})
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "Tenement/Add", element: /* @__PURE__ */ jsxRuntimeExports.jsx(TenemmentAdd, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "Tenements", element: /* @__PURE__ */ jsxRuntimeExports.jsx(TenementLists, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "Tenements/Rent", element: /* @__PURE__ */ jsxRuntimeExports.jsx(TenementListRent, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "Tenements/Sell", element: /* @__PURE__ */ jsxRuntimeExports.jsx(TenementListSell, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/tenement/:id/market", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Market, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/tenement/:id/rent", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Rent$2, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/tenement/:id/sell", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Rent$1, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/tenement/:id/develop", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Rent, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/rollback/tenements", element: /* @__PURE__ */ jsxRuntimeExports.jsx(RollbackTenementLists, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Route,
            {
              path: "/rollback/collections",
              element: /* @__PURE__ */ jsxRuntimeExports.jsx(RollBackCollectionList, {})
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/rollback/users", element: /* @__PURE__ */ jsxRuntimeExports.jsx(RollbackUserList, {}) })
        ] })
      ] }) });
    };
    var zh_TW$7 = {};
    var interopRequireDefault = { exports: {} };
    (function(module2) {
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : {
          "default": obj
        };
      }
      module2.exports = _interopRequireDefault2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
    })(interopRequireDefault);
    var interopRequireDefaultExports = interopRequireDefault.exports;
    var zh_TW$6 = {};
    Object.defineProperty(zh_TW$6, "__esModule", {
      value: true
    });
    zh_TW$6.default = void 0;
    var locale$3 = {
      // Options
      items_per_page: "條/頁",
      jump_to: "跳至",
      jump_to_confirm: "確定",
      page: "頁",
      // Pagination
      prev_page: "上一頁",
      next_page: "下一頁",
      prev_5: "向前 5 頁",
      next_5: "向後 5 頁",
      prev_3: "向前 3 頁",
      next_3: "向後 3 頁",
      page_size: "頁碼"
    };
    zh_TW$6.default = locale$3;
    var zh_TW$5 = {};
    var zh_TW$4 = {};
    var zh_TW$3 = {};
    Object.defineProperty(zh_TW$3, "__esModule", {
      value: true
    });
    zh_TW$3.default = void 0;
    var locale$2 = {
      locale: "zh_TW",
      today: "今天",
      now: "此刻",
      backToToday: "返回今天",
      ok: "確定",
      timeSelect: "選擇時間",
      dateSelect: "選擇日期",
      weekSelect: "選擇周",
      clear: "清除",
      month: "月",
      year: "年",
      previousMonth: "上個月 (翻頁上鍵)",
      nextMonth: "下個月 (翻頁下鍵)",
      monthSelect: "選擇月份",
      yearSelect: "選擇年份",
      decadeSelect: "選擇年代",
      yearFormat: "YYYY年",
      dayFormat: "D日",
      dateFormat: "YYYY年M月D日",
      dateTimeFormat: "YYYY年M月D日 HH時mm分ss秒",
      previousYear: "上一年 (Control鍵加左方向鍵)",
      nextYear: "下一年 (Control鍵加右方向鍵)",
      previousDecade: "上一年代",
      nextDecade: "下一年代",
      previousCentury: "上一世紀",
      nextCentury: "下一世紀"
    };
    zh_TW$3.default = locale$2;
    var zh_TW$2 = {};
    Object.defineProperty(zh_TW$2, "__esModule", {
      value: true
    });
    zh_TW$2.default = void 0;
    const locale$1 = {
      placeholder: "請選擇時間"
    };
    zh_TW$2.default = locale$1;
    var _interopRequireDefault$2 = interopRequireDefaultExports.default;
    Object.defineProperty(zh_TW$4, "__esModule", {
      value: true
    });
    zh_TW$4.default = void 0;
    var _zh_TW$2 = _interopRequireDefault$2(zh_TW$3);
    var _zh_TW2$1 = _interopRequireDefault$2(zh_TW$2);
    const locale = {
      lang: Object.assign({
        placeholder: "請選擇日期",
        yearPlaceholder: "請選擇年份",
        quarterPlaceholder: "請選擇季度",
        monthPlaceholder: "請選擇月份",
        weekPlaceholder: "請選擇周",
        rangePlaceholder: ["開始日期", "結束日期"],
        rangeYearPlaceholder: ["開始年份", "結束年份"],
        rangeMonthPlaceholder: ["開始月份", "結束月份"],
        rangeQuarterPlaceholder: ["開始季度", "結束季度"],
        rangeWeekPlaceholder: ["開始周", "結束周"]
      }, _zh_TW$2.default),
      timePickerLocale: Object.assign({}, _zh_TW2$1.default)
    };
    locale.lang.ok = "確 定";
    zh_TW$4.default = locale;
    var _interopRequireDefault$1 = interopRequireDefaultExports.default;
    Object.defineProperty(zh_TW$5, "__esModule", {
      value: true
    });
    zh_TW$5.default = void 0;
    var _zh_TW$1 = _interopRequireDefault$1(zh_TW$4);
    zh_TW$5.default = _zh_TW$1.default;
    var _interopRequireDefault = interopRequireDefaultExports.default;
    Object.defineProperty(zh_TW$7, "__esModule", {
      value: true
    });
    zh_TW$7.default = void 0;
    var _zh_TW = _interopRequireDefault(zh_TW$6);
    var _zh_TW2 = _interopRequireDefault(zh_TW$5);
    var _zh_TW3 = _interopRequireDefault(zh_TW$4);
    var _zh_TW4 = _interopRequireDefault(zh_TW$2);
    const typeTemplate = "${label}不是一個有效的${type}";
    const localeValues = {
      locale: "zh-tw",
      Pagination: _zh_TW.default,
      DatePicker: _zh_TW3.default,
      TimePicker: _zh_TW4.default,
      Calendar: _zh_TW2.default,
      global: {
        placeholder: "請選擇"
      },
      Table: {
        filterTitle: "篩選器",
        filterConfirm: "確定",
        filterReset: "重置",
        filterEmptyText: "無篩選項",
        selectAll: "全部選取",
        selectInvert: "反向選取",
        selectNone: "清空所有",
        selectionAll: "全選所有",
        sortTitle: "排序",
        expand: "展開行",
        collapse: "關閉行",
        triggerDesc: "點擊降序",
        triggerAsc: "點擊升序",
        cancelSort: "取消排序"
      },
      Modal: {
        okText: "確定",
        cancelText: "取消",
        justOkText: "知道了"
      },
      Tour: {
        Next: "下一步",
        Previous: "上一步",
        Finish: "結束導覽"
      },
      Popconfirm: {
        okText: "確定",
        cancelText: "取消"
      },
      Transfer: {
        titles: ["", ""],
        searchPlaceholder: "搜尋資料",
        itemUnit: "項目",
        itemsUnit: "項目",
        remove: "删除",
        selectCurrent: "全選當頁",
        removeCurrent: "删除當頁",
        selectAll: "全選所有",
        removeAll: "删除全部",
        selectInvert: "反選當頁"
      },
      Upload: {
        uploading: "正在上傳...",
        removeFile: "刪除檔案",
        uploadError: "上傳失敗",
        previewFile: "檔案預覽",
        downloadFile: "下载文件"
      },
      Empty: {
        description: "無此資料"
      },
      Icon: {
        icon: "圖標"
      },
      Text: {
        edit: "編輯",
        copy: "複製",
        copied: "複製成功",
        expand: "展開"
      },
      PageHeader: {
        back: "返回"
      },
      Form: {
        optional: "（可選）",
        defaultValidateMessages: {
          default: "字段驗證錯誤${label}",
          required: "請輸入${label}",
          enum: "${label}必須是其中一個[${enum}]",
          whitespace: "${label}不能為空字符",
          date: {
            format: "${label}日期格式無效",
            parse: "${label}不能轉換為日期",
            invalid: "${label}是一個無效日期"
          },
          types: {
            string: typeTemplate,
            method: typeTemplate,
            array: typeTemplate,
            object: typeTemplate,
            number: typeTemplate,
            date: typeTemplate,
            boolean: typeTemplate,
            integer: typeTemplate,
            float: typeTemplate,
            regexp: typeTemplate,
            email: typeTemplate,
            url: typeTemplate,
            hex: typeTemplate
          },
          string: {
            len: "${label}須為${len}個字符",
            min: "${label}最少${min}個字符",
            max: "${label}最多${max}個字符",
            range: "${label}須在${min}-${max}字符之間"
          },
          number: {
            len: "${label}必須等於${len}",
            min: "${label}最小值為${min}",
            max: "${label}最大值為${max}",
            range: "${label}須在${min}-${max}之間"
          },
          array: {
            len: "須為${len}個${label}",
            min: "最少${min}個${label}",
            max: "最多${max}個${label}",
            range: "${label}數量須在${min}-${max}之間"
          },
          pattern: {
            mismatch: "${label}與模式不匹配${pattern}"
          }
        }
      },
      Image: {
        preview: "預覽"
      }
    };
    zh_TW$7.default = localeValues;
    var zh_TW = zh_TW$7;
    const zh_TW$1 = /* @__PURE__ */ getDefaultExportFromCjs(zh_TW);
    client.createRoot(document.getElementById("root")).render(
      /* @__PURE__ */ jsxRuntimeExports.jsx(ConfigProvider$1, { locale: zh_TW$1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(BrowserRouter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AuthProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) }) }) })
    );
  }
});
export default require_index_001();
